"use strict";

/*jshint -W121 */
Array.prototype.remove = function(item) {
  var i;
  while ((i = this.indexOf(item)) >= 0) {
    this.splice(i, 1);
  }
  return this;
};

/*jshint -W121 */
Array.prototype.removeMatching = function(fn) {
  var i = 0;
  if (fn instanceof Function) {
    while (i < this.length) {
      if (fn(this[i])) {
        this.splice(i, 1);
      } else {
        i++;
      }
    }
  }
  return this;
};

/*jshint -W121 */
Array.prototype.removeAt = function(index) {
  if (index > -1) {
    this.splice(index, 1);
  }
  return this;
};

/*jshint -W121 */
Array.prototype.insert = function(item, index) {
  if (index > -1) {
    this.splice(index, 0, item);
  }
  return this;
};

/*jshint -W121 */
Array.prototype.flatten = function() {
  return this.reduce(function(flat, toFlatten) {
    return flat.concat(Array.isArray(toFlatten) ? toFlatten.flatten() : toFlatten);
  }, []);
};

/*jshint -W121 */
Array.prototype.add = function(toAdd, index) {
  this.splice(index, 0, toAdd);
};

if (!Array.prototype.find) {
  /*jshint -W121 */
  Array.prototype.find = function(fn) {
    var i = 0,
      len = this.length;
    for (; i < len; i++) {
      if (fn(this[i], i, this)) {
        return this[i];
      }
    }
    return null;
  };
}
if (!Array.prototype.findIndex) {
  /*jshint -W121 */
  Array.prototype.findIndex = function(fn) {
    var i = 0,
      len = this.length;
    for (; i < len; i++) {
      if (fn(this[i])) {
        return i;
      }
    }
    return -1;
  };
}
if (!Array.prototype.contains) {
  /*jshint -W121 */
  Array.prototype.contains = function(element) {
    return this.indexOf(element) >= 0;
  };
}
if (!Array.from) {
  /*jshint -W121 */
  Array.from = function(arr) {
    return Array.prototype.slice.call(arr, 0);
  };
}
;
"use strict";
(function() {
  /**
   *
   * @param {string} name
   */
  Element.prototype.getIntAttribute = function(name) {
    var result = parseInt(this.getAttribute(name), 10);
    return Object.isNaN(result) ? null : result;
  };

  var classedEventRE = /([^.]+)+(\..+)?/;

  /**
   *
   * @param {string} type
   * @param {string=} subFilter
   * @param {Function} callback
   */
  Element.prototype.on = function(type, subFilter, callback) {
    this._registeredEvents = this._registeredEvents || {};
    var supportsPassiveEvents = !window.browserInfo.isIE && !window.browserInfo.isEdge;
    var t = classedEventRE.exec(type || ""),
      event = t && t[1],
      passive = (event === "wheel" || event === "touchstart" || event === "touchmove") && supportsPassiveEvents,
      eventClass = t && t[2];
    if (!!event) {
      var registered = (this._registeredEvents[event] = this._registeredEvents[event] || {
        __default: []
      });
      var cb;
      if (!callback) {
        cb = subFilter;
      } else {
        cb = function(ev) {
          if (!subFilter || this.querySelectorAll(subFilter).contains(ev.target) ||
            this.querySelectorAll(subFilter + " *").contains(ev.target)) {
            callback(ev);
          }
        }.bind(this);
      }
      (registered[eventClass || "__default"] = registered[eventClass || "__default"] || []).push(cb);
      this.addEventListener(event, cb, passive ? {
        passive: true
      } : false);
    }
    return this;
  };

  /**
   *
   * @param {string} type
   */
  Element.prototype.off = function(type) {
    this._registeredEvents = this._registeredEvents || {};
    var t = classedEventRE.exec(type || "") || [],
      event = t[1],
      eventClass = t[2];
    if (!!event) {
      var registered = this._registeredEvents[event];
      if (!!eventClass) {
        if (!!registered && !!registered[eventClass]) {
          while (registered[eventClass].length) {
            this.removeEventListener(event, registered[eventClass].pop());
          }
        }
      } else {
        var keys = Object.keys(registered);
        for (var i = 0; i < keys.length; i++) {
          while (registered[keys[i]].length) {
            this.removeEventListener(event, registered[keys[i]].pop());
          }
        }
      }
    }
    return this;
  };

  /**
   *
   * @param {Function=} callback
   * @param noScrollContainer
   */
  Element.prototype.domFocus = function(callback, noScrollContainer) {
    var activeElement = document.activeElement;
    // We don't want modifier keys to raise focus change and to be recorded
    // if modal system is opened we should not change the focus // TODO have better way to do this
    // if gbc chrome bar filter has focus you should not change it // TODO have better way to do this
    var gbcFilterInputHasFocus = !!activeElement && activeElement.hasClass("gbc_FilterInput");
    if (gbc.systemModalOpened === false && gbcFilterInputHasFocus === false && this !== activeElement) {
      if (noScrollContainer && !this.setActive) {
        // hack to prevent automatic scrolling when focus()
        var scrollTop = noScrollContainer.scrollTop;
        var scrollLeft = noScrollContainer.scrollLeft;

        this.on("focus.NOScrollFocus", function() {
          noScrollContainer.scrollTop = scrollTop;
          noScrollContainer.scrollLeft = scrollLeft;
          this.off("focus.NOScrollFocus");
        }.bind(this));

        this.focus();
      } else if (noScrollContainer) {
        try {
          this.setActive(); // IE: setActive gives the focus but don't scroll into view
        } catch (e) {
          this.focus();
        }
      } else {
        this.focus();
      }
    }
    if (!!callback) {
      window.requestAnimationFrame(callback);
    }
  };

  Element.prototype.hasParentOfType = function(nodeName) {
    var el = this;
    while (el.parentNode !== null) {
      el = el.parentNode;
      if (el.nodeName === nodeName) {
        return true;
      }
    }
    return false;
  };

  Element.prototype.setCursorPosition = function(pos, pos2) {
    if (!pos2 || pos2 === 0) {
      pos2 = pos;
    }
    try {
      if (!this.hasParentOfType("#document-fragment")) {
        this.setSelectionRange(pos, pos2);
      }
    } catch (e) {}
  };

  /**
   *
   * @param {HTMLElement} element
   */
  Element.prototype.replaceWith = function(element) {
    this.parentNode.insertBefore(element, this);
    this.remove();
  };

  if (!('remove' in Element.prototype)) {
    Element.prototype.remove = function() {
      if (this.parentNode) {
        this.parentNode.removeChild(this);
      }
    };
  }

  /**
   *
   * @param {HTMLElement} element
   */
  Element.prototype.prependChild = function(element) {
    var refElement = null;
    if ((window.browserInfo.isIE || window.browserInfo.isEdge) && this instanceof SVGElement) {
      refElement = this.childNodes[0];
    } else {
      refElement = this.children[0];
    }
    this.insertBefore(element, refElement);
  };

  /**
   *
   * @param index
   * @param {HTMLElement} parentNode
   */
  Element.prototype.insertAt = function(index, parentNode) {
    var parentChildren = null;
    if ((window.browserInfo.isIE || window.browserInfo.isEdge) && this instanceof SVGElement) {
      parentChildren = parentNode.childNodes;
    } else {
      parentChildren = parentNode.children;
    }

    if (index === 0) {
      if (parentChildren.length) {
        parentNode.prependChild(this);
      } else {
        parentNode.appendChild(this);
      }
    } else {
      var where = !!index && parentChildren[index];
      if (!!where) {
        if (where !== this) {
          parentNode.insertBefore(this, where);
        }
      } else {
        parentNode.appendChild(this);
      }
    }
  };
  /**
   *
   * @param {HTMLElement} refNode
   */
  Element.prototype.insertAfter = function(refNode) {
    if (refNode && refNode.parentNode) {
      refNode.parentNode.insertBefore(this, refNode.nextSibling);
    }
  };
  /**
   * Remove all children
   */
  Element.prototype.empty = function() {
    while (this.firstChild) {
      this.removeChild(this.firstChild);
    }
  };
  /**
   *
   * @param className
   * @returns {HTMLElement}
   */
  Element.prototype.parent = function(className) {
    // TODO simplify no need to have "found" variable
    var found = false,
      parent = this.parentNode;
    while (!found) {
      if (!parent) {
        found = true;
        break;
      }
      if (parent.nodeType === Node.ELEMENT_NODE && parent.hasClass(className)) {
        found = true;
        break;
      }
      parent = parent.parentNode;
    }
    return parent;
  };

  /**
   * Returns element if it has classname or first parent which has classname
   * @param {string} className
   * @returns {HTMLElement}
   */
  Element.prototype.elementOrParent = function(className) {
    if (this.hasClass(className)) {
      return this;
    } else {
      return this.parent(className);
    }
  };

  /**
   * Returns if current element is the same or is child of a specified element
   * @param {HTMLElement} elem - sepcified element
   * @returns {boolean}
   */
  Element.prototype.isElementOrChildOf = function(elem) {
    var current = this;
    while (!!current) {
      if (current.nodeType === Node.ELEMENT_NODE && current === elem) {
        return true;
      }
      current = current.parentNode;
    }
    return false;
  };

  /**
   *
   * @returns {boolean}
   */
  Element.prototype.isInDOM = function() {
    var found = false,
      parent = this.parentNode;
    while (!found) {
      if (!parent) {
        break;
      }
      if (parent === window.document.body) {
        found = true;
        break;
      }
      parent = parent.parentNode;
    }
    return found;
  };
  /**
   *
   * @param className
   * @returns {HTMLElement}
   */
  Element.prototype.child = function(className) {
    var children = this.children,
      found = null;
    for (var i = 0; i < children.length; i++) {
      if (children[i].hasClass(className)) {
        found = children[i];
        break;
      }
    }
    return found;
  };

  /**
   *
   * @param tagName
   * @returns {HTMLElement}
   */
  Element.prototype.childTag = function(tagName) {
    var children = this.children,
      found = null;
    for (var i = 0; i < children.length; i++) {
      if (children[i].tagName.toLowerCase() === tagName.toLowerCase()) {
        found = children[i];
        break;
      }
    }
    return found;
  };

  /**
   *
   * @param className
   * @returns {Node[]}
   */
  Element.prototype.allchild = function(className) {
    var children = this.children,
      result = [];
    for (var i = 0; i < children.length; i++) {
      if (children[i].hasClass(className)) {
        result.push(children[i]);
      }
    }
    return result;
  };

  /**
   *
   * @param item
   * @returns {Node[]}
   */
  Element.prototype.childrenExcept = function(item) {
    var children = this.children,
      result = [];
    for (var i = 0; i < children.length; i++) {
      if (children[i] !== item) {
        result.push(children[i]);
      }
    }
    return result;
  };

  /**
   *
   * @param {string} cssClass
   * @returns {boolean}
   */
  Element.prototype.hasClass = function(cssClass) {
    if ((window.browserInfo.isIE || window.browserInfo.isEdge) && this instanceof SVGElement) {
      return (this.getAttribute("class") || "").split(" ").indexOf(cssClass) >= 0;
    } else {
      return this.classList.contains(cssClass);
    }
  };

  /**
   *
   * @param {string} cssClass
   * @returns {HTMLElement}
   */
  Element.prototype.addClass = function(cssClass) {
    if ((window.browserInfo.isIE || window.browserInfo.isEdge) && this instanceof SVGElement) {
      var currentClasses = (this.getAttribute("class") || "").split(" "),
        exists = currentClasses.indexOf(cssClass);
      if (exists >= 0) {
        currentClasses.splice(exists, 1);
      }
      currentClasses.push(cssClass);
      this.setAttribute("class", currentClasses.join(" "));
    } else {
      this.classList.add(cssClass);
    }
    return this;
  };

  /**
   *
   * @returns {HTMLElement}
   */
  Element.prototype.addClasses = function() {
    for (var i = 0; i < arguments.length; ++i) {
      this.classList.add(arguments[i]);
    }
    return this;
  };

  /**
   * Switch between classes
   * @param {string} cssClass1 - class added if switcher is true
   * @param {string|boolean} cssClass2 - class added if switcher is false
   * @param {boolean=} switcher
   * @returns {HTMLElement}
   */
  Element.prototype.toggleClass = function(cssClass1, cssClass2, switcher) {
    if (typeof switcher === "undefined") {
      switcher = cssClass2;
      if (window.browserInfo.isIE) {
        if (switcher) {
          this.classList.add(cssClass1);
        } else {
          this.classList.remove(cssClass1);
        }
      } else {
        if (switcher === true || switcher === false) {
          this.classList.toggle(cssClass1, switcher);
        } else {
          this.classList.toggle(cssClass1);
        }
      }
    } else {
      if (switcher) {
        this.classList.remove(cssClass2);
        this.classList.add(cssClass1);
      } else {
        this.classList.remove(cssClass1);
        this.classList.add(cssClass2);
      }
    }
    return this;
  };

  /**
   *
   * @param {string} cssClass
   * @returns {HTMLElement}
   */
  Element.prototype.removeClass = function(cssClass) {
    this.classList.remove(cssClass);
    return this;
  };

  Element.prototype.index = function() {
    var index = 0;
    var i = 0,
      parent = this.parentNode,
      children = parent.childNodes,
      len = children.length;
    for (; i < len; i++) {
      var item = children[i];
      if (item === this) {
        return index;
      }
      if (item.nodeType === Node.ELEMENT_NODE) {
        index++;
      }
    }
    return -1;
  };

  Element.prototype.selectText = function() {
    var range, selection;
    if (document.body.createTextRange) {
      range = document.body.createTextRange();
      range.moveToElementText(this);
      range.select();
    } else if (window.getSelection) {
      selection = window.getSelection();
      range = document.createRange();
      range.selectNodeContents(this);
      selection.removeAllRanges();
      selection.addRange(range);
    }
  };
  Element.prototype.closest = function(className) {
    if (this.hasClass(className)) {
      return this;
    } else {
      return this.parent(className);
    }
  };

  if (!NodeList.prototype.contains) {
    /*jshint -W121 */
    NodeList.prototype.contains = function(element) {
      var i = 0,
        len = this.length;
      for (; i < len; i++) {
        if (this[i] === element) {
          return true;
        }
      }
      return false;
    };
  }

  if (!SVGElement.prototype.getElementsByClassName) {
    SVGElement.prototype.getElementsByClassName = function(cssClass) {
      return this.querySelectorAll(cssClass);
    };
  }

  Element.prototype.emitEvent = function(type) {
    var event = document.createEvent("Event");
    event.initEvent(type, false, true);
    this.dispatchEvent(event);
  };
})();
;
"use strict";
(function() {

  /**
   * Handle double tap events
   * @param {string} context gives a namespace to the event
   * @param {Function=} callback
   */
  Element.prototype.onDoubleTap = function(context, callback) {
    if (window.isTouchDevice()) {
      var lastTap = 0;
      this.on('touchstart.doubleTap_' + context, function(eventstart) {
        this.off('touchend.doubleTap_' + context);
        if (eventstart.touches.length <= 1) {
          this.on('touchend.doubleTap_' + context, function(event) {
            var currentTime = new Date().getTime();
            var tapLength = currentTime - lastTap;
            if (tapLength < 500 && tapLength > 0) {
              // Double Tapped
              callback(event);
              event.preventCancelableDefault();
            }
            lastTap = currentTime;
          });
        }
      });
    }
    return this;
  };

  /**
   * Unregister doubleTap event
   * @param {string} context : namespace of the event to unregister
   */
  Element.prototype.offDoubleTap = function(context) {
    if (window.isTouchDevice()) {
      this.off("touchend.doubleTap_" + context);
    }
  };

  /**
   * Handle swipe events
   * @param {string} context gives a namespace to the event
   * @param {Function} swipeCallback function executed after each successful swipe
   * @param {Object} options
   * @param {Array} options.direction : give direction to listen to: ['left', 'right', 'up', 'down']. By default we will listen to all.
   * @param {number=} options.velocity : minimum velocity (px/ms) that gesture has to obtain to execute callback. Default value is 0.2.
   * @param {number=} options.distance : fraction of swiped distance over element. If swiped distance if higher that provided value
   *      we will always generate a successful swipe even if velocity was very low. Default value is 0.1. (0.1 = 10% of element size as swipe)
   * @param {boolean=} options.debounce : true/false to limit the touchmove call. False by default.
   * @param {Element|Array<Element>} [options.ignore] : if event target of swipe start is one of or a child of one of the given element(s),
   *      we don't consider this move as a swipe
   * @param {Function=} options.startCallback : callback executed on each touchstart/mousedown action. Null by default.
   * @param {Function=} options.moveCallback : callback executed during touchmove/mousemove actions. Take note that this callback will be raised massively and may induce performance issues. Null by default.
   * @param {Function=} options.endCallback : callback executed after each touchend/mouseup action. Null by default.
   */
  Element.prototype.onSwipe = function(context, swipeCallback, options) {
    options = (typeof options === "object") ? options : {};

    // watched swipe directions
    var direction = options.direction ? options.direction : ["left", "right", "up", "down"];
    var watchedDirection = {};
    for (var i = 0; i < direction.length; i++) {
      watchedDirection[direction[i]] = true;
    }
    var _touchStartX = null;
    var _touchStartY = null;
    var _touchStartTime = null;

    var unifyTouchEvent = function(evt) {
      return evt.changedTouches ? evt.changedTouches[0] : evt;
    };

    /** Touch/Mouse Events **/
    // touch/mouse up event callback
    var endSwipe = function(evt) {
      if (!evt.touches || evt.touches.length === 0) { // we don't manage multiples touch

        // on touch/mouse release unbind move/up events
        this.off('mouseup.swipe_' + context);
        this.off('touchend.swipe_' + context);
        this.off('mouseleave.swipe_' + context);
        this.off('touchleave.swipe_' + context);
        if (options.moveCallback) {
          this.off('mousemove.swipe_' + context);
          this.off('touchmove.swipe_' + context);
        }

        var swipedVelocity = 0;
        var swipedFraction = 0;

        if (_touchStartX && _touchStartY && evt) {
          // swipe direction, distance and velocity calculation
          var xUp = unifyTouchEvent(evt).clientX;
          var yUp = unifyTouchEvent(evt).clientY;
          var xDiff = _touchStartX - xUp;
          var yDiff = _touchStartY - yUp;
          var xIndex = Math.sign(xDiff);
          var yIndex = Math.sign(yDiff);

          // Get most significant direction
          var absXMove = Math.abs(xDiff);
          var absYMove = Math.abs(yDiff);
          var isXSwipe = absXMove > absYMove;
          var maxMove = Math.max(absXMove, absYMove);
          if (maxMove > 15) { // exclude micro gestures and clicks from calculation
            var totalDistance = isXSwipe ? this.clientWidth : this.clientHeight;
            swipedFraction = (maxMove / totalDistance).toFixed(2);
          } else if (maxMove > 0) {
            swipedFraction = 0.05;
          }

          var duration = new Date().getTime() - _touchStartTime;
          var velocity = options.velocity ? options.velocity : 0.2;
          var distanceToSwipe = options.distance ? options.distance : 0.1;
          swipedVelocity = maxMove / duration;

          // swipe if minimum velocity of gesture (distance/duration of swipe) or swiped 50% of viewport width
          if (swipedVelocity >= velocity || swipedFraction > distanceToSwipe) {
            swipedFraction = 1 - swipedFraction;
            if (isXSwipe) {
              if (xIndex > 0) {
                /* left swipe */
                if (watchedDirection.left) {
                  swipeCallback("left");
                }
              } else {
                if (watchedDirection.right) {
                  swipeCallback("right");
                }
              }
            } else {
              if (yIndex > 0) {
                if (watchedDirection.up) {
                  swipeCallback("up");
                }
              } else {
                if (watchedDirection.down) {
                  swipeCallback("down");
                }
              }
            }
          }
        }

        if (options.endCallback) {
          options.endCallback(evt, swipedVelocity, swipedFraction);
        }

        // reset values
        _touchStartX = null;
        _touchStartY = null;
        _touchStartTime = null;
      }
    };

    this.offSwipe(context);

    var endHandler = endSwipe;
    // touch/mouse down event callback
    var startSwipe = function(evt) {
      if (options.ignore) {
        if (!Array.isArray(options.ignore)) {
          options.ignore = [options.ignore];
        }
        if (options.ignore.find(function(item) {
            return evt.target && evt.target.isElementOrChildOf(item);
          })) {
          return;
        }
      }
      if (evt.ctrlKey === false && (!evt.touches || evt.touches.length === 1)) {
        // do not swipe if CTRL key pressed and do not add additional bindings if multiple fingers
        if (evt.cancelable) { // prevent text selection
          evt.preventDefault();
        }

        this.on('mouseup.swipe_' + context, endHandler);
        this.on('touchend.swipe_' + context, endHandler);
        this.on('mouseleave.swipe_' + context, endHandler);
        this.on('touchleave.swipe_' + context, endHandler);

        if (options.moveCallback) {
          // touch/mouse move callback
          var moveHandler = function(evt) {
            if (evt.cancelable) { // to avoid browser back native
              evt.preventDefault();
            }
            options.moveCallback(evt, _touchStartX, _touchStartY);
          };
          this.on('mousemove.swipe_' + context, moveHandler);
          this.on('touchmove.swipe_' + context, moveHandler);
        }

        _touchStartX = unifyTouchEvent(evt).clientX;
        _touchStartY = unifyTouchEvent(evt).clientY;
        _touchStartTime = new Date().getTime();
        if (options.startCallback) {
          options.startCallback(evt);
        }
      }
    };

    var startHandler = startSwipe;
    if (options.debounce) {
      startHandler = startSwipe.debounce().bind(this);
      endHandler = endSwipe.debounce().bind(this);
    }
    this.on('mousedown.swipe_' + context, startHandler);
    this.on('touchstart.swipe_' + context, startHandler);
  };

  /**
   * Unregister swipe event
   * @param {string} context : namespace of the event to unregister
   */
  Element.prototype.offSwipe = function(context) {
    this.off('mousemove.swipe_' + context);
    this.off('touchmove.swipe_' + context);
    this.off('mousedown.swipe_' + context);
    this.off('touchstart.swipe_' + context);
    this.off('mouseup.swipe_' + context);
    this.off('touchend.swipe_' + context);
    this.off('mouseleave.swipe_' + context);
    this.off('touchleave.swipe_' + context);
  };

  /**
   * Handle long touch events
   * @param {string} context gives a namespace to the event
   * @param {Function=} callback
   * @param {Object} options
   *    touchDuration : define the duration before triggering the callback
   */
  Element.prototype.onLongTouch = function(context, callback, options) {
    if (window.isTouchDevice()) {
      var touchDuration = (options && options.touchDuration) || 500;
      var preventDefault = (options && options.preventDefault) || true; // TODO Wrong it is always true
      var timer = null;

      this.on('touchstart.longTouch_' + context, function(event) {
        if (preventDefault) {
          event.preventCancelableDefault();
        }
        timer = setTimeout(function() {
          callback(event);
        }.bind(this), touchDuration);
      });

      this.on('touchend.longTouch_' + context, function() {
        if (timer) {
          clearTimeout(timer);
        }
      });
    }
    return this;
  };

  /**
   * Unregister longTouch event
   * @param {string} context : namespace of the event to unregister
   */
  Element.prototype.offLongTouch = function(context) {
    if (window.isTouchDevice()) {
      this.off("touchstart.longTouch_" + context);
      this.off("touchend.longTouch_" + context);
    }
  };

})();
;
"use strict";

/*jshint -W121 */
Event.prototype.preventCancelableDefault = function() {
  if (typeof this.cancelable !== 'boolean' || this.cancelable) {
    // The event can be canceled, so we do so.
    this.preventDefault();
  } else {
    // The event cannot be canceled, so it is not safe
    // to call preventDefault() on it.
    console.warn("Event couldn't be canceled");
    //console.dir(this);
  }
};

// TODO should be gbcPreventDefault
Event.prototype.gbcDontPreventDefault = null;

// When an event is not created by GBC (ex for Webcomponents) some functions must be defined in the event.
/*jshint -W121 */
Event.prototype.normalizeEventForGBC = function(event) {
  if (!event.preventCancelableDefault) {
    event.preventCancelableDefault = Event.prototype.preventCancelableDefault;
  }
};
;
"use strict";

/*
 ** The Math.sign() function returns the sign of a number, indicating whether the number is positive, negative or zero.
 */
if (!Math.sign) {
  Math.sign = function(x) {
    return ((x > 0) - (x < 0)) || +x;
  };
}
;
"use strict";

/*
 ** Function decodeInteger
 **
 ** Decode an integer in Big-Endian binary notation
 ** and store it into a JavaScript native integer.
 **
 ** Truncate the value parameter if longer than 4 bytes.
 **
 ** String value: the integer in BE binary notation
 ** returns int: the integer in JavaScript native integer
 */
Number.decodeInteger = function(value) {
  if (value.length > 4) {
    value = value.substring(0, 4);
  }
  var ret = "";
  for (var i = 0; i < value.length; ++i) {
    var hex = value.charCodeAt(i).toString(16);
    if (hex.length < 2) {
      hex = "0" + hex;
    }
    ret += hex;
  }
  value = parseInt(ret, 16);
  return value;
};

/*
 ** Function encodeInteger
 **
 ** Encode a JavaScript native integer and store it
 ** into an integer in Big-Endian binary notation.
 **
 ** Truncate the value parameter if longer than 4 bytes.
 ** (the VM protocol's header only handles 4 bytes integer)
 **
 ** int value: the integer in JavaScript native integer
 ** returns String: the integer in BE binary notation
 */
Number.encodeInteger = function(value) {
  value = value.toString(16);
  if (value.length > 8) {
    value = value.substring(value.length - 8, value.length);
  } else if (value.length < 8) {
    while (value.length < 8) {
      value = "0" + value;
    }
  }
  var valueArr = value.match(/.{2}/g);
  for (var i = 0; i < valueArr.length; ++i) {
    valueArr[i] = String.fromCharCode(parseInt(valueArr[i], 16));
  }
  value = valueArr.join("");
  return value;
};

Number.isNaN = Number.isNaN || window.isNaN;

/*jshint -W121 */
Number.prototype.pad = function(total) {
  var len = total - this.toString().length,
    result = [];
  for (var i = 0; i < len; i++) {
    result[i] = "0";
  }
  result[i] = this;
  return result.join("");
};

Number.compare = function(a, b) {
  if (a === b) {
    return 0;
  }
  if (a < b) {
    return -1;
  }
  return 1;
};
;
"use strict";

/**
 * swaps key/values
 *
 * @param {Object} obj the source object
 * @returns {Object} a newly created object that represents the swapped object
 */
Object.swap = function(obj) {
  var result = {};
  if (obj) {
    for (var property in obj) {
      if (obj.hasOwnProperty(property)) {
        result[obj[property]] = property;
      }
    }
  }
  return result;
};

Object.isString = function(obj) {
  return typeof obj === "string";
};
Object.isNumber = function(obj) {
  return typeof obj === "number";
};
Object.isFunction = function(obj) {
  return typeof obj === "function";
};
Object.isBoolean = function(obj) {
  return obj === true || obj === false;
};

Object.isNaN = function(i) {
  return window.isNaN(i);
};

if (!Object.values) {
  /**
   * IE11 Polyfill
   * @param obj
   * @returns {Array} Array of values
   */
  Object.values = function(obj) {
    return Object.keys(obj).map(function(e) {
      return obj[e];
    });
  };
}

/*
 Object.merge = function(target, source) {
 var keys = Object.keys(source),
 l = keys.length;
 for (var i = 0; i < l; i++) {
 target[keys[i]] = source[keys[i]];
 }
 return target;
 };
 Object.clone = function(obj) {
 return Object.merge({}, obj);
 };
 Object.map = function(obj, map) {
 var result = {},
 keys = Object.keys(obj),
 l = keys.length;
 for (var i = 0; i < l; i++) {
 result[keys[i]] = map(keys[i], obj[keys[i]]);
 }
 return result;
 };*/
;
"use strict";

// jshint ignore:start
String.prototype.getBytesCount = function() {
  var log = Math.log(256);
  var total = 0;
  for (var i = 0; i < this.length; i++) {
    var charCode = this.charCodeAt(i);
    total += Math.ceil(Math.log(charCode) / log);
  }
  return total;
};

// Replace char at index
String.prototype.replaceAt = function(index, character) {
  return this.substr(0, index) + character + this.substr(index + character.length);
};
if (!String.prototype.startsWith) {
  String.prototype.startsWith = function(search, pos) {
    return this.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
  };
}
if (!String.prototype.endsWith) {
  String.prototype.endsWith = function(search, this_len) {
    if (this_len === undefined || this_len > this.length) {
      this_len = this.length;
    }
    return this.substring(this_len - search.length, this_len) === search;
  };
}

if (!String.prototype.trim) {
  String.prototype.trim = function() {
    return this.replace(/^\s+/, "").replace(/\s+$/, "");
  };
}

String.prototype.capitalize = function() {
  return this.substr(0, 1).toUpperCase() + this.substr(1).toLowerCase();
};

if (!String.prototype.repeat) {
  String.prototype.repeat = function(count) {
    var total = Math.floor(Number(count));
    if (total > 0) {
      return new Array(total + 1).join(this);
    } else {
      return "";
    }
  };
}

var ESC_MAP = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#39;'
};

// escape most problematic html chars from the string
String.prototype.escapeHTML = function() {
  return this.replace(/[&<>'"]/g, function(c) {
    return ESC_MAP[c];
  });
};

// jshint ignore:end
;
"use strict";

/*jshint -W121 */
Function.prototype.debounce = function(threshold, execAsap) {
  var timeout = null;
  var func = this;
  return function(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9) {
    var context = this;
    var delayed = function() {
      if (!execAsap) {
        func.apply(context, [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9]);
      }
      timeout = null;
    };

    if (timeout) {
      clearTimeout(timeout);
    } else if (execAsap) {
      func.apply(context, [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9]);
    }

    timeout = setTimeout(delayed, threshold || 100);
  };
};

Function.prototype.throttle = function(threshold) {
  var func = this;
  var throttling = false;
  var clear = function() {
    throttling = false;
  };
  return function() {
    if (!throttling) {
      func.apply(this, arguments);
      window.setTimeout(clear, threshold);
      throttling = true;
    }
  };
};

Function.noop = function() {};
Function.true = function() {
  return true;
};
Function.false = function() {
  return false;
};
;
"use strict";

/**
 * Return true if mobile browser, false otherwise
 * @returns bool if the browser is mobile
 */
/* jshint ignore:start */
window.isMobile = function() {
  var testExp = new RegExp('Android|iPhone|iPad|iPod|BlackBerry|Windows Phone|Opera Mini|IEMobile|Mobile|webOS', 'i');
  // window.orientation works well but is deprecated. So we use additional check.
  return typeof window.orientation !== "undefined" || testExp.test(navigator.userAgent) === true;
};

window.isPhone = function() {
  if (window.isMobile()) {
    return Math.min(window.screen.width, window.screen.height) < 768;
  }
  return false;
};

window.isTablet = function() {
  if (window.isMobile()) {
    return Math.min(window.screen.width, window.screen.height) >= 768;
  }
  return false;
};

window.isAndroid = function() {
  var testExp = new RegExp('Android', 'i');
  // window.orientation works well but is deprecated. So we use additional check.
  return typeof window.orientation !== "undefined" && testExp.test(navigator.userAgent) === true;
};

window.isIOS = function() {
  var testExp = new RegExp('iPhone|iPad|iPod', 'i');
  // window.orientation works well but is deprecated. So we use additional check.
  return typeof window.orientation !== "undefined" && testExp.test(navigator.userAgent) === true;
};

window.isTouchDevice = function() {
  return "ontouchstart" in document.documentElement || 'ontouchstart' in window ||
    navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
};

/* jshint ignore:end */
window.offset = function(elt) {
  var rect = elt[0].getBoundingClientRect();
  return {
    left: Math.round(rect.left),
    top: Math.round(rect.top),
    centerX: Math.round(rect.left + rect.width / 2),
    centerY: Math.round(rect.top + rect.height / 2)
  };
};

/**
 * Check if capslock is on
 * @param {domEvent} e - event emitted on keydown
 * @return {boolean} true if capsLock is on, false otherwise
 */
window.isCapslock = function(e) {
  if (e.which === 20) {
    // toggle capsLock state when the key is CapsLock
    this._capsLock = !this._capsLock;
  } else if (e && e.getModifierState) {
    // Otherwise get the caps modifier of the key
    this._capsLock = e.getModifierState("CapsLock") || (e.which === 20 && !e.getModifierState("CapsLock"));
  }
  return this._capsLock;
};

/**
 * Test if a string is a valid URL
 *
 * @returns {boolean}
 */
window.isValidURL = function(str) {
  var pattern = new RegExp("((http|https)(:\/\/))?([a-zA-Z0-9]+[.]{1}){2}[a-zA-z0-9]+(\/{1}[a-zA-Z0-9]+)*\/?", "i");
  return pattern.test(str);
};

/**
 * Check if url has a parameter with corresponding value
 * @param {string} url - url to check parameter on
 * @param {string} param - parameter
 * @param {string} value - value of parameter
 * @returns {boolean} true if parameter with corresponding value has been found in url
 */
window.hasParameterValue = function(url, param, value) {
  var queryString = (param + "=" + value).toLowerCase();
  // extract url parameters only
  var start = url.lastIndexOf("?") + 1;
  var end = url.lastIndexOf("#"); // manage optional hash section located at the end of the url
  if (end < start) {
    end = url.length;
  }
  var variables = url.substring(start, end).toLowerCase().split("&"); // get array of parameters
  for (var i = 0; i < variables.length; i++) {
    if (variables[i] === queryString) {
      return true;
    }
  }
  return false;
};

/**
 * Check if url has the parameter set as active (1 value)
 * @param {string?} url - optional. If unset, we look by default for current browser url
 * @param {string} param - parameter name to check
 * @returns {boolean} true if parameter is set and enabled in url
 */
window.isURLParameterEnabled = function(url, param) {
  if (param === undefined) {
    param = url;
    url = window.location.search;
  }
  return window.hasParameterValue(url, param, "1");
};

/**
 * Check if url has the parameter set as inactive (0 value)
 * @param {string?} url - optional. If unset, we look by default for current browser url
 * @param {string} param - parameter name to check
 * @returns {boolean} true if parameter is set and disabled in url
 */
window.isURLParameterDisabled = function(url, param) {
  if (param === undefined) {
    param = url;
    url = window.location.search;
  }
  return window.hasParameterValue(url, param, "0");
};

window.isOrientationImplemented = typeof window.orientation !== "undefined";

(function(window) {
  window.waitMax = function(timeout, trigger, event, fallback) {
    var time = 0;
    var itv = window.setInterval(function() {
      if (trigger()) {
        window.clearInterval(itv);
        event();
      } else {
        time += 50;
        if (time > timeout) {
          window.clearInterval(itv);
          (fallback || event)();
        }
      }
    }, 50);
  };
})(window);
(function() {
  window.browserInfo = {
    isFirefox: false,
    isEdge: false,
    isIE: false,
    isChrome: false,
    isOpera: false,
    isSafari: false,
    isAndroid: false,
    isIOS: false
  };

  var sUsrAg = window.navigator.userAgent;

  if (sUsrAg.indexOf("Edge") > -1) {
    window.browserInfo.isEdge = true;
  } else if (sUsrAg.indexOf("Chrome") > -1) {
    window.browserInfo.isChrome = true;
  } else if (sUsrAg.indexOf("Safari") > -1) {
    window.browserInfo.isSafari = true;
  } else if (sUsrAg.indexOf("Opera") > -1) {
    window.browserInfo.isOpera = true;
  } else if (sUsrAg.indexOf("Firefox") > -1) {
    window.browserInfo.isFirefox = true;
  } else if (sUsrAg.indexOf("MSIE") > -1 || sUsrAg.indexOf("Trident") > -1) {
    window.browserInfo.isIE = true;
  }
  if (window.isAndroid()) {
    window.browserInfo.isAndroid = true;
  }
  if (window.isIOS()) {
    window.browserInfo.isIOS = true;
  }
})();

// Compute ScrollBar size
(function() {
  var div = document.createElement('div');
  div.style.width = "50px";
  div.style.height = "50px";
  div.style.overflowY = "scroll";
  div.style.position = "absolute";
  div.style.top = "-200px";
  div.style.left = "-200px";
  div.innerHTML = '<div style="height:100px;width:100%"></div>';

  document.body.appendChild(div);
  var w1 = div.offsetWidth;
  var w2 = div.children[0].offsetWidth;
  document.body.removeChild(div);

  window.scrollBarSize = w1 - w2;
})();

/**
 * Convert image to base64
 * @param {String} src
 * @param {Function} callback
 * @param {String} outputFormat - image/png, image/jpeg
 */
window.toDataURL = function(src, callback, outputFormat) {
  var img = new Image();
  img.crossOrigin = 'Anonymous';
  img.onload = function() {
    var canvas = document.createElement('CANVAS');
    var ctx = canvas.getContext('2d');
    var dataURL;
    // Resize the canvas to the original image dimensions
    canvas.height = this.naturalHeight;
    canvas.width = this.naturalWidth;
    ctx.drawImage(this, 0, 0);
    dataURL = canvas.toDataURL(outputFormat);
    callback(dataURL);
    canvas = null;
  };
  img.src = src;
  // Make sure the load event fires for cached images too
  if (img.complete || img.complete === undefined) {
    // Flush cache
    img.src = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==";
    // Try again
    img.src = src;
  }
};
;
"use strict";

/**
 * Display a message as a critical error in an old console style
 * @param {string} message the message to display
 */
window.critical = function(message) {
  this.message = message;
  this._decorated = window.location.search.toLowerCase().indexOf("debugmode=1") >= 0;
  this._prepareStyle();
  document.body.innerHTML = "<div id='critical-overlay'></div><div id='term'>\n" + this._prepareMessage() +
    "</div>";
};
/**
 * shortcut method
 * @param {string} message the message to display
 * @return {Window.critical}the critical instance
 */
window.critical.display = function(message) {
  return new window.critical(message);
};

window.critical.prototype = {

  /**
   * prepare css style of critical error
   * @private
   */
  _prepareStyle: function() {
    var link = document.createElement("style");
    if (this._decorated) {
      link.innerHTML =
        "* {margin: 0;padding: 0;outline: none;font-family:monospace;}" +
        "html,body{width:100%;height:100%;margin:0;padding:0;border:0;background:#000;color:lime;}" +
        "body{box-shadow: 0 0 1px 3px rgba(10, 10, 10, .7);overflow: hidden;user-select: none;}" +
        "body:before{width: 100%;height: 100%;position: absolute;" +
        "background-color: #000;background: linear-gradient(#fff 50%, #000 50%);background-size: 100% 4px;background-repeat: repeat-y;" +
        "opacity: .14;box-shadow: inset 0 0 10px 10px rgba(0, 0, 0, .8);z-index: 12;animation: pulse 5s linear infinite;content: '';}" +
        "body:after{content:'';width: 100%;height: 100%;background-color: #00ff77;background: radial-gradient(ellipse at center, rgba(0,0,0,1) 0%,rgba(0,0,0,0.62) 45%,rgba(0,9,4,0.6) 47%,rgba(0,255,119,1) 100%);opacity: .1;z-index: 11;}" +
        "#term{text-align:center;position: absolute;top: 0px;left: 0px;bottom: -1px;right: -10px;overflow: hidden;z-index: 1;font-size:1.4em;padding:2em;white-space:pre;background: radial-gradient(ellipse at center, rgba(0,255,119,0.45) 0%,rgba(255,255,255,0) 100%);transform-origin: 50% 50%;transform: perspective(200px) rotateX(.1deg) skewX(1deg) scale(1.02);opacity: .9;}" +
        "#critical-overlay {width: 100%;height: 100%;position: absolute;left: 0;top: 0;margin-left: 0;margin-top: 0;z-index: 100;}" +
        "#critical-overlay:before {content: '';position: absolute;top: 0;left: 0;width: 100%;height: 50px;background: #fff;background: linear-gradient(to bottom, rgba(255,0,0,0) 0%,rgba(255,250,250,1) 50%,rgba(255,255,255,0.98) 51%,rgba(255,0,0,0) 100%);opacity: .02;animation: vline 1.25s linear infinite;}" +
        "@keyframes pulse {0% {transform: scale(1.001);opacity: .14;}8% {transform: scale(1.000);opacity: .13;}" +
        "15% {transform: scale(1.004);opacity: .14;}30% {transform: scale(1.002);opacity: .11;}" +
        "100% {transform: scale(1.000);opacity: .14;}}" +
        "@keyframes vline {0% {top: 0px;}100% {top: 100%;}}";
    } else {
      link.innerHTML =
        "* {margin: 0;padding: 0;outline: none;font-family:monospace;}" +
        "html,body{width:100%;height:100%;margin:0;padding:0;border:0;text-align:center;}" +
        "#term{white-space:pre;}";
    }
    document.head.appendChild(link);
  },

  /**
   *  console style full line template
   */
  _line: "#".repeat(80) + "\n",

  /**
   *  console style empty line template
   */
  _empty: "#" + " ".repeat(78) + "#\n",

  /**
   * get a console styled formatted text
   * @param {string} text text to display in line
   * @param {number} size size of alignment text
   * @return {string} the console styled text
   * @private
   */
  _prepareLine: function(text, size) {
    var before = Math.floor((78 - size) / 2),
      after = 78 - text.length - before;
    return "#" + " ".repeat(before) + text + " ".repeat(after) + "#\n";
  },
  /**
   * get a full text message in a console style
   * @return {string} the text to display
   * @private
   */
  _prepareMessage: function() {
    var msg = this.message.match(/.{1,76}/g),
      size = Math.max.apply(null, msg.map(function(item) {
        return item.length;
      })),
      text = "\n",
      i = 0,
      before = Math.max(Math.floor((19 - msg.length) / 2), 1),
      after = Math.max(19 - msg.length - before, 1);
    text += this._line;
    for (; i < before; i++) {
      text += this._empty;
    }
    text += this._prepareLine("Genero Browser Client", 21);
    text += this._prepareLine("---------------------", 21);
    text += this._empty;
    for (i = 0; i < msg.length; i++) {
      text += this._prepareLine(msg[i], size);
    }

    for (i = 0; i < after; i++) {
      text += this._empty;
    }
    text += this._prepareLine("See browser's console for details.", 33);
    text += this._empty;
    text += this._line;
    return text;
  }
};
;
"use strict";

(function(context) {
  var nativeJsface = context.jsface;
  var noop = function() {};

  /**
   * @typedef {Function} ClassFunctor
   * @param {Object.<string, function|*>} $super
   */

  /**
   * ### __jsface override__
   * adds some new features:
   *
   * * introduce $super keyword
   * * ability to declare mixins in class definition
   *
   * See {@link augmentedFace.Class} to create classes
   * @namespace window.augmentedFace
   */
  context.augmentedFace = /** @lends window.augmentedFace */ {
    /**
     * Creates a class
     * @example
     * // Simple class, no inheritance
     * var MyClass = augmentedFace.Class({
     *   myMethod : function(){
     *     this.myMember = 1;
     *   }
     * });
     * @example
     * // Simple class, inherits from MyClass, overrides myMethod
     * augmentedFace.Class(MyClass, {
     *   myMethod : function(){
     *     this.myMember = 2;
     *   }
     * });
     * @example
     * // Simple class, inherits from MyClass, calls superclass' myMethod
     * augmentedFace.Class(MyClass, function($super){
     *   return {
     *     myMethod : function(){
     *       this.myMember = 2;
     *     }
     *   };
     * });
     * @method Class
     * @param {ClassFunctor|Object|number} [params]
     * if *params* is omitted, the defined class will not have a superclass
     * @param {ClassFunctor|Object|number} api
     * if *api* is omitted, the *params* parameter will be used as api description
     * The *api* parameter can be:
     * * an object, describing the different members of the class
     * * a function, that will return an object as above desciption, but with the ability to inject *$super* accessor
     * @param {?boolean=} _checkMembers internal flag
     * @returns {Function} the constructed class
     */
    Class: function(params, api, _checkMembers) {
      var parent = 0,
        inheritance = [],
        ascendance = [];
      if (!api) {
        api = params;
        params = 0;
      }
      switch (typeof params) {
        case "function":
          parent = params;
          break;
        case "object":
          parent = params.base || 0;
          break;
        default:
          break;
      }

      var $super = {
        constructor: parent || noop
      };

      if (parent) {
        var memberKeys = Object.keys(parent.prototype);
        for (var k = 0; k < memberKeys.length; k++) {
          var methodName = memberKeys[k];
          var method = parent.prototype[methodName];
          if (typeof method === "function") {
            $super[methodName] = method;
          } else if (methodName === "__name") {
            $super.__name = method;
          } else if (methodName === "__ascendance") {
            ascendance = method.slice();
          } else if (methodName === "__inheritance") {
            inheritance = method.slice();
            inheritance.push($super.__name);
          }
        }
      }

      api = (typeof api === "function" ? api($super) : api) || {};
      if (!api.__name && ascendance.indexOf("WidgetBase") >= 0) {
        throw api;
      }
      if (!api.__virtual) {
        ascendance.push(api.__name);
      }
      if (ascendance.indexOf("WidgetBase") >= 0) {
        this._widgetSpecificApi(api, ascendance);
      }
      api.__inheritance = inheritance;
      api.isInstanceOf = function(type) {
        return type &&
          type.prototype &&
          type.prototype.__name === this.__name ||
          this.__inheritance.indexOf(type.prototype.__name) >= 0;
      };
      if (!api.hasOwnProperty("constructor")) {
        api.constructor =
          function(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9) {
            $super.constructor.call(this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
          };
      }
      if (_checkMembers !== false) {
        this._checkMembers(api);
      }

      return nativeJsface.Class(parent, api);
    },
    _widgetSpecificApi: function(api, ascendance) {
      if (api.__ignoreInheritance) {
        api.__ascendance = ["WidgetBase"];
        if (!api.__virtual) {
          api.__ascendance.push(api.__name);
        }
      } else {
        api.__ascendance = ascendance;
      }
      api.__ascendanceClasses = ascendance.map(function(item) {
        return "gbc_" + item;
      }).join(" ");
    },
    _checkMembers: function(api) {
      Object.keys(api).forEach(function(mk) {
        switch (mk) {
          case "__inheritance":
          case "__ascendance":
          case "usedStyleAttributes":
          case "__dataContentPlaceholderSelector":
          case "watchedAttributes":
          case "$static":
            return;
          default:
            break;
        }
        switch (typeof api[mk]) {
          case "function":
          case "string":
          case "number":
          case "boolean":
            return;
          case "object":
            if (api[mk] === null) {
              return;
            }
            break;
          default:
            break;
        }
        console.warn("class definition issue, member seems shared", api.__name, mk, typeof api[mk]);
      });
    },

    /**
     * Creates a single instance of a class
     * @method Singleton
     * @param {ClassFunctor|Object|number} [params]
     * if *params* is omitted, the defined class will not have a superclass
     * @param {ClassFunctor|Object|number} api
     * if *api* is omitted, the *params* parameter will be used as api description
     * The *api* parameter can be:
     *
     * * an object, describing the different members of the class
     * * a function, that will return an object as above desciption, but with the ability to inject *$super* accessor
     * @returns {*} the constructed instance
     */
    Singleton: function(params, api) {
      var SingletonClass = this.Class(params, api, false);
      SingletonClass.prototype.__unique = true;
      return new SingletonClass();
    },

    /**
     * Creates a static class. Should not be instantiated
     * @method StaticClass
     * @param {ClassFunctor|Object|number} [params]
     * if *params* is omitted, the defined class will not have a superclass
     * @param {ClassFunctor|Object|number} api
     * if *api* is omitted, the *params* parameter will be used as api description
     * The *api* parameter can be:
     * * an object, describing the different members of the class
     * * a function, that will return an object as above desciption, but with the ability to inject *$super* accessor
     * @returns {*} the constructed class
     */
    StaticClass: function(params, api) {
      if (!api) {
        api = params;
        params = 0;
      }
      if (api) {
        if (typeof api === "function") {
          var originalApi = api;
          api = function($super) {
            var result = originalApi($super);
            if (result) {
              result.$singleton = true;
            }
            return result;
          };
        } else {
          api.$singleton = true;
        }
      }
      return this.Class(params, api, false);
    }
  };
})(window);
;
"use strict";

(function(w) {
  var modules = [];
  var resolvedModules = 0;
  var loadedModules = {};
  var injection = [];
  var loadModule = function(module) {
    module.exec.apply(w, injection);
  };
  var resolve = function() {
    var moduleIndex = 0;
    for (;;) {
      if (moduleIndex >= modules.length) {
        break;
      }
      var module = modules[moduleIndex];
      if (module) {
        var dependencyIndex = 0;
        for (;;) {
          if (!module.after || dependencyIndex >= module.after.length) {
            break;
          }
          var dependency = module.after[dependencyIndex];
          if (dependency && loadedModules[dependency]) {
            module.after[dependencyIndex] = null;
            module.dependencyResolved++;
          }
          dependencyIndex++;

        }
        if (module.after.length === module.dependencyResolved) {
          loadedModules[module.id] = true;
          loadModule(module);
          modules[moduleIndex] = null;
          resolvedModules++;
        } else {
          moduleIndex++;
        }
      } else {
        moduleIndex++;
      }
    }
  };
  var error = function() {
    var text = "Modulum.js: Cyclic dependency detected.\n";
    for (var i = 0, j = 0; i < modules.length; i++) {
      if (modules[i]) {
        text += modules[i].id + " depends on [" + modules[i].after.join(", ") + "]\n";
        j++;
        if (j > 10) {
          text += "[...]";
          break;
        }
      }
    }
    window.critical.display(text);
  };
  var checkLoadedDependencies = function(module) {
    var result = true;
    var deps = module.after,
      i = 0,
      len = deps.length;
    for (; i < len; i++) {
      if (deps[i] && !loadedModules[deps[i]]) {
        result = false;
        break;
      } else {
        deps[i] = null;
        module.dependencyResolved++;
      }
    }
    return result;
  };

  /**
   * @typedef {Function} ModulumExec
   * @param {gbc} arg1
   * @param {classes} arg2
   */

  /**
   *
   * @param {string} module module name
   * @param {string[]|ModulumExec} dependencies module dependencies
   * @param {?ModulumExec=} exec module content
   */
  w.modulum = function(module, dependencies, exec) {
    if (!exec) {
      exec = dependencies;
      dependencies = null;
    }
    var mod = {
      id: module,
      after: dependencies,
      exec: exec,
      dependencyResolved: 0
    };
    if (!mod.after || checkLoadedDependencies(mod)) {
      loadedModules[mod.id] = true;
      loadModule(mod);
      modules.push(null);
      resolvedModules++;
    } else {
      modules.push(mod);
    }
  };

  /**
   *
   * @param {gbc} arg1 gbc context
   * @param {classes} arg2 classes context
   */
  w.modulum.inject = function(arg1, arg2) {
    injection = [arg1, arg2];
  };
  w.modulum.assemble = function() {
    var loaded = resolvedModules;
    while (loaded < modules.length) {
      resolve();
      if (loaded === resolvedModules) {
        error();
        throw new Error("cyclic dependencies");
      }
      loaded = resolvedModules;
    }
  };
})(window);
;
"use strict";

// Fourjs : few modifications about group matching and host restrictions loose

/// matches :
/// 1 - protocol
/// 2 - username
/// 3 - password
/// 4 - host
/// 5 - port
/// 6 - path
/// 7 - query string
/// 8 - hash

//window.re_weburl = new RegExp(
window.RegExpUrl = new RegExp(
  "^" +
  // leading spaces
  "\\s*" +
  // protocol identifier
  "(?:(https?|ftp|app|file)://)" +
  // user:pass authentication
  "(?:(\\S+)(?::(\\S*))?@)?" +

  "([^:/]+)" +

  //  "(" +

  // Fourjs : we don't filter ip

  // IP address exclusion
  // private & local networks
  ///"(?!(?:10|127)(?:\\.\\d{1,3}){3})" +
  ///"(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})" +
  ///"(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})" +

  // IP address dotted notation octets
  // excludes loopback network 0.0.0.0
  // excludes reserved space >= 224.0.0.0
  // excludes network & broacast addresses
  // (first & last IP address of each class)
  //  "(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])" +
  //  "(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}" +
  //  "(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))" +
  //  "|" +
  // host name
  //  "(?:(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)" +
  // domain name
  //  "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*" +

  // Fourjs : we authorize localhost and one token host names
  // TLD identifier
  //  "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))*" +

  //  ")" +
  // port number
  "(?::(\\d{2,5}))?" +
  // resource path
  "(/[^\\?\\#]*)?" +

  // query string
  "(?:\\?([^\\#]+)?)?" +
  // hash
  "(?:\\#(\\S*))?" +

  // trailing spaces
  "\\s*" +
  "$", "i"
);
;
"use strict";

(function(context) {
  var _internal = {
    debug: false,
    styleSheetNamePrefix: "dyncss__",
    _buffered: false,

    createDOM: function(id, contents) {
      if (contents) {
        var cssContent = "<!--\n" + contents + "\n-->",
          styleSheetName = this.styleSheetNamePrefix + id;

        var sheet = document.createElement("style");
        sheet.addClass(styleSheetName);
        this.setCssContents(sheet, cssContent);
        return sheet;
      }
      return null;
    },
    appendDOM: function(sheet) {
      document.head.appendChild(sheet);
    },
    setCssContents: function(styleSheet, cssContent) {
      if (styleSheet) {
        if (styleSheet.styleSheet) {
          styleSheet.styleSheet.cssText = cssContent;
        } else {
          styleSheet.appendChild(document.createTextNode(cssContent));
        }
      }
    },
    contentFromRules: function(styles, builder) {
      if (styles) {
        var localStyles = JSON.parse(styles);
        if (localStyles) {
          var _builder = builder || [];
          var keys = Object.keys(localStyles);
          for (var ruleIndex = 0; ruleIndex < keys.length; ruleIndex++) {
            var rule = keys[ruleIndex],
              ruleStyles = localStyles[rule];
            var items = Object.keys(ruleStyles);
            if (items.length) {
              var added = 0;
              _builder.push(rule, "{");
              for (var i = 0; i < items.length; i++) {
                var item = items[i];
                if (ruleStyles[item] || ruleStyles[item] === 0 || ruleStyles[item] === false || ruleStyles[item] === "") {
                  added++;
                  _builder.push(item, ":", ruleStyles[item], ";");
                }
              }
              if (added) {
                _builder.push("}");
              } else {
                _builder.length = _builder.length - 2;
              }
            }
          }
          if (!builder && _builder.length) {
            return _builder.join(this.debug ? "\n" : "");
          }
        }
      }
      return null;
    },
    contentFromRuleSet: function(ruleSet) {
      var builder = [];
      if (!!ruleSet) {
        ruleSet.forEach(function(rule) {
          this.contentFromRules(rule, builder);
        }, this);
      }
      return builder.length ? builder.join(this.debug ? "\n" : "") : null;
    }
  };

  var DynStyleSheet = context.augmentedFace.Class({
    __name: "styler",
    /**
     * @type Map
     */
    _sections: null,
    _id: null,
    _isStandalone: false,

    /**
     * @type HTMLElement
     */
    _dom: null,
    _oldRaw: null,
    _rawContent: null,
    _dirty: false,
    _toDestroy: false,

    constructor: function(id) {
      this._sections = new Map();
      this._id = id;
      this._isStandalone = Boolean(id);
    },
    destroy: function() {
      if (this._sections) {
        this._sections.clear();
        this._sections = null;
      }
      this._id = null;
      if (this._dom) {
        this._dom.remove();
      }
      this._dom = null;
      this._oldRaw = null;
      this._rawContent = null;
    },
    render: function() {
      if (this._dirty) {
        var old = this._dom;
        this._oldRaw = this._rawContent;
        this._rawContent = this._getContents();
        if (this._oldRaw !== this._rawContent) {
          this._dom = _internal.createDOM(this._id || "default", this._rawContent);

          if (old) {
            old.remove();
          }
          if (this._dom) {
            _internal.appendDOM(this._dom);
          }
        }
        this._dirty = false;
      }
    },
    _getContents: function() {
      return _internal.contentFromRuleSet(this._sections);
    },

    clear: function() {
      if (this._sections) {
        this._sections.clear();
      } else {
        this._sections = new Map();
      }
      this._dirty = true;
    },

    setContents: function(id, rules) {
      var current = this._sections.get(id),
        newrules = JSON.stringify(rules);
      if (current !== newrules) {
        if (newrules === "{}") {
          this._sections.delete(id);
          if (this._sections.size === 0) { // empty style object. flag it to destroy it later during flush
            this._toDestroy = true;
          }
        } else {
          this._sections.set(id, newrules);
          this._toDestroy = false;
        }
        this._dirty = true;
      }
    }
  });

  /**
   * styler
   * ===============
   *
   * provides methods to work with styles
   * @namespace styler
   */
  context.styler = /** @lends styler */ {
    /**
     * @type Map
     */
    _cachedStyles: new Map(),

    appendStyleSheet: function(styles, id, standalone, sheetId) {
      var lid = sheetId || sheetId === 0 ? sheetId : id;
      var cacheKey = standalone ? lid : "__default";
      var cached = this._cachedStyles.get(cacheKey);
      if (!cached) {
        cached = new DynStyleSheet(standalone ? lid : null);
        this._cachedStyles.set(cacheKey, cached);
      }
      cached.setContents(id, styles);
      if (!_internal._buffered) {
        cached.render();
      }
    },

    isBuffering: function() {
      return Boolean(_internal._buffered);
    },

    bufferize: function() {
      _internal._buffered = true;
    },
    flush: function() {
      this._cachedStyles.forEach(function(style, key) {
        if (style) {
          if (style._toDestroy) {
            this._destroyStyleSheet(style, key);
          } else {
            style.render();
          }
        }
      }, this);
      _internal._buffered = false;
    },
    removeStyleSheet: function(key) {
      var style = this._cachedStyles.get(key);
      if (style) {
        this._destroyStyleSheet(style, key);
      }
    },
    _destroyStyleSheet: function(stylesheet, key) {
      stylesheet._toDestroy = false;
      stylesheet.clear();
      stylesheet.render();
      stylesheet.destroy();
      stylesheet = null;
      this._cachedStyles.delete(key);
    }
  };
})(window);
;
"use strict";

(function(window) {
  var empty = [];
  var noop = function() {};
  var defaultChildrenSelector = function(item) {
    return item && item.children || empty;
  };

  /**
   * @class
   * @param {Object} data data
   */
  var Throu = function(data) {
    this._data = data;
    this._childrenSelector = defaultChildrenSelector;
    this._passes = [];
    this._beforePass = noop;
    this._afterPass = noop;
  };
  Throu.prototype = {
    setChildrenSelector: function(selector) {
      this._childrenSelector = selector;
    },
    unique: function(unique) {
      this._passes.push({
        pass: unique,
        unique: true
      });
    },
    pass: function(pass, childrenFirst, childrenSelector) {
      this._passes.push({
        pass: pass,
        childrenFirst: childrenFirst,
        childrenSelector: childrenSelector
      });
    },
    passIf: function(condition, pass, childrenFirst, childrenSelector) {
      this._passes.push({
        condition: condition,
        pass: pass,
        childrenFirst: childrenFirst,
        childrenSelector: childrenSelector
      });
    },
    beforePass: function(cb) {
      this._beforePass = cb;
    },
    afterPass: function(cb) {
      this._afterPass = cb;
    },
    run: function() {
      for (var p = 0; p < this._passes.length; p++) {
        var pass = this._passes[p];
        this._beforePass(p);
        if (!pass.condition || pass.condition()) {
          if (pass.unique) {
            pass.pass();
          } else {
            if (!pass.childrenFirst) {
              this._runPass(pass.pass, this._data, null, pass.childrenSelector);
            } else {
              this._runPassReverse(pass.pass, this._data, null, pass.childrenSelector);
            }
          }
        }
        this._afterPass(p);
      }
    },
    destroy: function() {
      this._data = null;
      this._passes.length = 0;
      this._childrenSelector = null;
    },
    _runPass: function(pass, item, parent, childrenSelector) {
      pass(item, parent);
      var children = (childrenSelector || this._childrenSelector)(item) || [];
      for (var i = 0; i < children.length; i++) {
        this._runPass(pass, children[i], item);
      }
    },
    _runPassReverse: function(pass, item, parent, childrenSelector) {
      var children = (childrenSelector || this._childrenSelector)(item) || [];
      for (var i = 0; i < children.length; i++) {
        this._runPassReverse(pass, children[i], item);
      }
      pass(item, parent);
    }
  };

  /**
   * @class
   * @param {Object} data data
   */
  var ThrouFlat = function(data) {
    this._data = data;
    this._childrenSelector = defaultChildrenSelector;
    this._flattened = [];
    this._passes = [];
    this._beforePass = noop;
    this._afterPass = noop;
    this._refreshFlattened();
  };
  ThrouFlat.prototype = {
    setChildrenSelector: function(selector) {
      this._childrenSelector = selector;
      this._refreshFlattened();
    },
    _runFlatten: function(parent, flat) {
      var children = this._childrenSelector(parent);
      for (var i = 0; i < children.length; i++) {
        flat.push({
          item: children[i],
          parent: parent
        });
        this._runFlatten(children[i], flat);
      }
    },
    _refreshFlattened: function() {
      this._flattened.length = 0;
      this._flattened.push({
        item: this._data,
        parent: null
      });
      this._runFlatten(this._data, this._flattened);
    },
    pass: function(pass, childrenFirst) {
      this._passes.push({
        pass: pass,
        childrenFirst: childrenFirst
      });
    },
    beforePass: function(cb) {
      this._beforePass = cb;
    },
    afterPass: function(cb) {
      this._afterPass = cb;
    },
    run: function() {
      for (var p = 0; p < this._passes.length; p++) {
        var pass = this._passes[p];
        this._beforePass(p);
        var l = this._flattened.length;
        for (var i = 0; i < l; i++) {
          var item = this._flattened[!pass.childrenFirst ? i : (l - i - 1)];
          pass.pass(item.item, item.parent);
        }
        this._afterPass(p);
      }
    },
    destroy: function() {
      this._data = null;
      this._flattened.length = 0;
      this._passes.length = 0;
      this._childrenSelector = null;
    }
  };

  window.Throu = Throu;
  window.ThrouFlat = ThrouFlat;
})(window);
;
"use strict";

/*
 see tools/doc/internaldoc/UR/implement.md for documentation
 bootstrapper for gbc environment
 will let embedding platforms do their job
 */

(function(context) {
  var readyCallbacks = [],
    /**
     *
     * @param event
     * @param src
     * @param data
     */
    doReadyCallbacks = function(event, src, data) {
      if (!context.gbcWrapper._readyData) {
        context.gbcWrapper._readyData = data;
      }
      context.gbcWrapper.ready = true;
      var i = 0,
        len = readyCallbacks.length;
      for (; i < len; i++) {
        readyCallbacks[i]();
      }
      readyCallbacks = [];
    };
  /**
   * @namespace window.gbcWrapper
   */
  context.gbcWrapper = {
    events: {
      /**
       * Event ready
       * Fired once when platform declares its low level bindings are ready
       */
      READY: "ready",
      /**
       * Event close
       * Fired when platform's close button is clicked
       */
      CLOSE: "close",
      /**
       * Event end
       * Fired when an application ends
       */
      END: "end",
      /**
       * Event receive
       * Fired when data are received
       */
      RECEIVE: "receive",
      /**
       * Event nativeAction
       * Fired when native sends an action to be managed by UR (e.g. pushNotification, cordovaCallback
       */
      NATIVEACTION: "nativeAction",
      /**
       * Event debugNode
       * Fired when debugNode is selected in the debugger
       */
      DEBUGNODE: "debugNode",
      /**
       * Event query
       * Fired when native platforms needs to query the universal renderer
       * answer will be sent via queryResult
       */
      QUERY: "query"
    },
    /**
     * true when all platform bindings are ready to use
     */
    ready: false,

    /**
     * @typedef {Object} ReadyData
     * @property {Object<string, *>} [headers]
     * @property {string} [meta]
     * @property {boolean} [debugMode]
     * @property {boolean} [isLogReplay]
     * @property {Number} [logLevel]
     * @property {string} nativeResourcePrefix
     * @property {Object<string, string|Array<string>>} [forcedURfrontcalls]
     */

    /**
     * application start data
     * @type {?ReadyData}
     */
    _readyData: null,

    /**
     * @typedef {Object<string, string|Array<string>>} ForcedURFrontCalls
     */

    /**
     * list of frontcalls per module forced to be called at browser side
     * @type {Object<string, string|Array<string>>}
     */
    _forcedURfrontcalls: {
      "webcomponent": "*",
      "qa": ["startqa", "getattribute"]
    },

    /**
     * platform type
     * can be "browser" or "native"
     */
    platformType: context.gbcWrapperInfo.platformType || "browser",
    /**
     * platform name
     * can be "browser", "GDC", "GMA", "GMI"
     */
    platformName: context.gbcWrapperInfo.platformName || "browser",
    /**
     * protocol type
     * can be "ua" or "direct"
     */
    protocolType: context.gbcWrapperInfo.protocolType || "ua",

    /**
     * inform the platform that Universal Renderer is fully initialized and wait for data
     * param {Object<string, *>} options additional information for the protocol
     */
    URReady: function(attr) {},

    /**
     * send data through the platform
     * @param {string} data stringified aui order
     * @param {Object<string, *>} options additional information for the protocol
     *   e.g. in no user activity actions, options will be set to {userActivity: "no"}
     */
    send: function(data, options) {},

    /**
     * inform the platform about a childstart
     */
    childStart: function() {},

    /**
     * send interrupt signal through the platform
     */
    interrupt: function() {},

    /**
     * send close signal through the platform
     */
    close: function() {},

    /**.
     * @callback frontcallCallback
     * @param {{status:number, result:string, errorMessage:string}} result
     */

    /**
     * call the platform's frontcall
     * @param {number} nodeId
     * @param {frontcallCallback} callback
     */
    frontcall: function(nodeId, callback) {},

    /**
     * Send answer of query event to native platform
     * @param {*} data the an object depending on the query
     */
    queryResult: function(data) {},

    /**
     * Show the native aui debugger
     * @param {Number} data the node id or -1
     */
    showDebugger: function(data) {},

    /**
     * Call a named native function
     * @param {{name:string, args:Array}} data native call info
     *
     * Possible call data are:
     *
     * > `{name:"windowTitle",args: [<document.title>]}`
     * > will update the document title to the native
     *
     * > `{name:"error",args: [<error message>]}`
     * > will send error messages to the native
     *
     * > `{name:"noBackAction"}`
     * > will inform the native there is no back resolved action (after a 'nativeAction' 'back')
     *
     */
    nativeCall: function(data) {},

    /**
     * Inform the native platform that a the log was processed
     * Fired in UR log player mode when a log order is fully processed
     */
    logProcessed: function() {},

    /**
     * fires event in gbcWrapper
     * @param {string} eventType the event type
     * @param {*} [data] any data to fire with
     * DO NOT IMPLEMENT
     */
    emit: function(eventType, data) {},

    /**
     * gbcWrapper initializer
     * GBC internal
     * DO NOT IMPLEMENT
     * @private
     */
    __init: function() {
      console.log(
        "GBC", context.gbc.version + "-" + context.gbc.build,
        "- Platform:", context.gbcWrapper.platformName,
        "- Protocol:", context.gbcWrapper.protocolType);
      context.gbcWrapper.on = function(eventType, eventHandler) {
        if (eventType === context.gbcWrapper.events.READY) {
          if (eventHandler instanceof Function) {
            if (this.ready) {
              eventHandler();
            } else {
              if (this._eventListener) {
                this._eventListener.when(eventType, eventHandler, true);
              } else {
                readyCallbacks.push(eventHandler);
              }
            }
            return;
          } else {
            throw new Error("gbcWrapper: onReady callback is not a function");
          }
        }
        if (this._eventListener) {
          this._eventListener.when(eventType, eventHandler);
        }
      };
      if (context.gbcWrapper.protocolType === "direct") {
        context.__gbcDefer = function(start) {
          start();
        };
      }
    },

    /**
     * gbcWrapper prepare wrapper before real start
     * GBC internal
     * DO NOT IMPLEMENT
     * @private
     */
    __prepare: function() {
      var listener = context.gbcWrapper._eventListener =
        new context.gbc.classes.EventListener();
      context.gbcWrapper.emit = function(eventType, data) {
        this._eventListener.emit(eventType, data);
      };
      listener.when(context.gbcWrapper.events.READY, doReadyCallbacks);
      if (context.gbcWrapper.isBrowser()) {
        this.emit(context.gbcWrapper.events.READY);
      }
    },
    /**
     * gbcWrapper ending wrapper initialization after GBC ready
     * GBC internal
     * DO NOT IMPLEMENT
     * @private
     */
    __gbcReady: function() {
      if (context.gbcWrapper.protocolType === "direct") {
        context.gbcWrapper.on(context.gbcWrapper.events.QUERY, function(event, src, data) {
          context.gbc.NativeService.onQuery(data);
        });
        context.gbcWrapper.on(context.gbcWrapper.events.NATIVEACTION, function(event, src, data) {
          context.gbc.NativeService.onNativeAction(data);
        });
        context.gbcWrapper.on(context.gbcWrapper.events.CLOSE, function() {
          context.gbc.NativeService.onNativeAction({
            name: "close"
          });
        });
        context.gbcWrapper.on(context.gbcWrapper.events.READY, function() {
          if (context.gbcWrapper._readyData.nativeResourcePrefix) {
            context.gbcWrapper.nativeResourcePrefix =
              context.gbcWrapper._readyData.nativeResourcePrefix.replace(/\/$/, "") + "/__dvm__/";
          } else {
            throw new Error("gbcWrapper: onReady data did not contain a valid 'nativeResourcePrefix'");
          }
          if (context.gbcWrapper._readyData.debugMode) {
            context.gbc.DebugService.activate();
          }
          if (context.gbcWrapper._readyData.language) {
            context.gbc.I18NService.setLng(context.gbcWrapper._readyData.language);
          }
          context.gbc.LogService.changeLevel(
            ["none", "error", "warn", "log", "all"][context.gbcWrapper._readyData.logLevel || 0] || "none"
          );
          if (context.gbcWrapper._readyData.forcedURfrontcalls) {
            context.gbcWrapper._forcedURfrontcalls = context.gbcWrapper._readyData.forcedURfrontcalls;
          }
          // 
          if (context.gbcWrapper._readyData.isLogReplay) {
            var app = context.gbc.LogPlayerService.getApplication(0, 0);
            context.gbcWrapper.on(context.gbcWrapper.events.RECEIVE, function(event, src, data) {
              app.dvm.manageAuiOrders(data, function() {
                if (app.ending || app.ended) {
                  context.gbcWrapper.logProcessed();
                } else {
                  app.layout.afterLayoutComplete(function() {
                    context.gbcWrapper.logProcessed();
                  }, true);
                }
              });
            });
            context.gbcWrapper.URReady({
              UCName: "GBC",
              UCVersion: gbc.version,
              mobileUI: gbc.ThemeService.getValue("aui-mobileUI-default") ? 1 : 0
            });
          } else {
            context.gbc.SessionService.startDirect(context.gbcWrapper, context.gbcWrapper._readyData.headers);
          }
        });
      }
    },

    /**
     * returns whether or not gbc runs in native mode
     * GBC internal
     * DO NOT IMPLEMENT
     * @return {boolean} true if gbc runs in native mode
     */
    isNative: function() {
      return this.platformType === "native";
    },

    /**
     * returns whether or not gbc runs in browser mode
     * GBC internal
     * DO NOT IMPLEMENT
     * @return {boolean} true if gbc runs in browser mode
     */
    isBrowser: function() {
      return this.platformType === "browser";
    },

    /**
     * transforms a resource path
     * GBC internal
     * DO NOT IMPLEMENT
     * @param {string} path raw path
     * @param {string} [nativePrefix] native prefix if any
     * @param {string} [browserPrefix] browser prefix if any
     * @return {string} the transformed resource path
     */
    wrapResourcePath: function(path, nativePrefix, browserPrefix) {
      // if path has a scheme, don't change it
      if (!path || /^(http[s]?|[s]?ftp|data|file|font)/i.test(path)) {
        return path;
      }
      var startPath = this.isNative() ?
        this.nativeResourcePrefix + (nativePrefix ? nativePrefix + "/" : "") :
        (browserPrefix ? browserPrefix + "/" : "");
      // Prevent Windows path like C:\foo\too.ttf
      return startPath + (this.isNative() ? encodeURIComponent(path).replace("%2F", "/") : path);
    },

    /**
     * in native mode, will check if function call is forced to be done by UR
     * GBC internal
     * DO NOT IMPLEMENT
     * @param {string} moduleName the function call module
     * @param {string} functionName the function call name
     * @return {boolean} whtether or not function call is forced to by done by UR
     * @private
     */
    isFrontcallURForced: function(moduleName, functionName) {
      return Boolean(this._forcedURfrontcalls[moduleName]) &&
        ((this._forcedURfrontcalls[moduleName] === "*") ||
          (this._forcedURfrontcalls[moduleName].indexOf(functionName) >= 0));
    }
  };

})(window);
;
"use strict";

(function(contextWin) {
  // try to store js errors for forensics
  contextWin.__jsErrors = contextWin.__jsErrors || [];

  /**
   * @namespace classes
   * @alias classes
   */
  var classes = {};

  /**
   * Genero Browser Client main entry point service
   * @namespace gbc
   * @gbcService
   */
  var gbc = contextWin.augmentedFace.Singleton( /** @lends gbc.prototype */ {
    __name: "gbc",
    oo: contextWin.augmentedFace,

    version: "1.00.55.c" || "none",
    build: "202002270927" || "none",
    tag: "1.00.55.c" || "dev-snapshot",
    dirtyFlag: "" || "",
    prodMode: "cdev",
    systemAppId: -1,
    qaMode: false,
    unitTestMode: false,
    canShowExitWarning: true,
    bootstrapInfo: contextWin.__gbcBootstrap || {},
    moment: contextWin.moment,
    styler: contextWin.styler,
    StateMachine: contextWin.StateMachine,
    classes: classes,
    constants: {
      theme: {}
    },
    errorCount: 0,
    jsErrorCount: 0,
    systemModalOpened: false, // true if a modal system (about, settings, etc...) is currently opened

    /**
     * prepare GBC system environment
     * @memberOf gbc
     */
    preStart: function() {
      document.body.toggleClass("is-mobile-device", contextWin.isMobile());
      document.body.toggleClass("is-not-mobile-device", !contextWin.isMobile());
      document.body.toggleClass("is-touch-device", contextWin.isTouchDevice());
      document.body.toggleClass("is-not-touch-device", !contextWin.isTouchDevice());
      document.body.toggleClass("is-firefox", contextWin.browserInfo.isFirefox);
      document.body.toggleClass("is-edge", contextWin.browserInfo.isEdge);
      document.body.toggleClass("is-ie", contextWin.browserInfo.isIE);
      document.body.toggleClass("is-chrome", contextWin.browserInfo.isChrome);
      document.body.toggleClass("is-opera", contextWin.browserInfo.isOpera);
      document.body.toggleClass("is-safari", contextWin.browserInfo.isSafari);
      document.body.toggleClass("is-ios", contextWin.browserInfo.isIOS);
      document.body.toggleClass("is-android", contextWin.browserInfo.isAndroid);
      if (contextWin.gbc.bootstrapInfo.serverVersion) {
        contextWin.gbc.bootstrapInfo.serverVersion = contextWin.gbc.bootstrapInfo.serverVersion.replace(" - Build ", "-");
      }
      contextWin.gbc.bootstrapInfo.subAppInfo = parseInt(contextWin.gbc.bootstrapInfo.subAppInfo, 10) || 0;
      // Event activation changed
      contextWin.gbc.DebugService.whenActivationChanged(function(event, src, active) {
        contextWin.gbc.LogService.enableProviders(active);
      });
      contextWin.gbc.LogService.registerLogProvider(
        new classes.KeyboardPrefixedConsoleLogProvider("[KEYBOARD ]", "background: #AA6; color: #FFF"), "keyboard", "Keyboard");
      contextWin.gbc.LogService.registerLogProvider(
        new classes.MousePrefixedConsoleLogProvider("[MOUSE    ]", "background: #A66; color: #FFF"), "mouse", "Mouse");
      contextWin.gbc.LogService.registerLogProvider(
        new classes.UiPrefixedConsoleLogProvider("[UI       ]", "background: #015d51; color: #FFF"), "ui", "UI");
      contextWin.gbc.LogService.registerLogProvider(
        new classes.PrefixedConsoleLogProvider("[TYPEAHEAD]", "background: #6A6; color: #FFF"), "typeahead", "TypeAhead");
      contextWin.gbc.LogService.registerLogProvider(
        new classes.PrefixedConsoleLogProvider("[FOCUS    ]", "background: #A6A; color: #FFF"), "focus", "Focus");
      contextWin.gbc.LogService.registerLogProvider(
        new classes.PrefixedConsoleLogProvider("[gICAPI   ]", "background: #6AA; color: #FFF"), "gICAPI", "gICAPI");
      contextWin.gbc.LogService.registerLogProvider(
        new classes.NetworkPrefixedConsoleLogProvider("[NETWORK  ]", "background: #66A; color: #FFF"), "networkProtocol",
        "Network");
      contextWin.gbc.LogService.registerLogProvider(new classes.BufferedConsoleLogProvider(), null, "Default");

      // need to enable or disable debug mode explicitly
      // because DebugService can be also be activated by GAS parameters
      if (window.isURLParameterEnabled(contextWin.location.search, "debugmode")) {
        contextWin.gbc.DebugService.activate();
      } else if (window.isURLParameterDisabled(contextWin.location.search, "debugmode")) {
        contextWin.gbc.DebugService.disable();
      }

      contextWin.gbc.bootstrapInfo.gbcPath = "resources";

      if (window.isURLParameterEnabled(contextWin.location.search, "qainfo")) {
        contextWin.gbc.qaMode = true;

        // helper querystrings for QA
        if (window.isURLParameterEnabled(contextWin.location.search, "contextmenu")) {
          gbc.ThemeService.setValue("theme-disable-context-menu", false);
        }
        if (window.isURLParameterEnabled(contextWin.location.search, "mobileui")) {
          gbc.ThemeService.setValue("aui-mobileUI-default", true);
        }
      }

      // inhibit default browser behaviors
      document.body.addEventListener('keydown', function(event) {
        var contentEditable = !!event.target.getAttribute("contenteditable") && event.target.getAttribute("contenteditable") !==
          "false";
        var isInputable = event.target.tagName === "TEXTAREA" || event.target.tagName === "INPUT" || (event.target.tagName ===
          "DIV" && contentEditable);

        if (event.ctrlKey) {
          if (event.which === 80 /* p */ || event.which === 83 /* s */ ) {
            event.preventCancelableDefault();
          }
          if (event.which === 65 /* a */ && !isInputable) {
            event.preventCancelableDefault();
          }
        }

        if (event.which === 8 /* backspace */ && (!isInputable || event.target.readOnly)) {
          event.preventCancelableDefault(); // inhibit previous page on backspace
        }

        // fallback to manage accelerators is focused unfortunately ended on body
        gbc.InitService.onKeyFallback(event);
      });

      if (contextWin.gbc.qaMode) {
        contextWin.gbc.classes.DebugHelper.activateDebugHelpers();
      }

      /**
       * Disable default IE behavior when pressing F1 key (which launch a apage toward microsoft website)
       * ref: https://agile.strasbourg.4js.com/jira/browse/ENGGCS-3879
       */
      if ('onhelp' in window) {
        // To avoid IE to popup the help dialog on F1, we override associated 'onhelp' event
        window.onhelp = function() {
          return false;
        };
      }
    },

    /**
     * start the GBC system (home page or application if bootstrapped)
     */
    start: function() {
      if (contextWin.gbc.__gbcStarted) {
        return;
      }
      contextWin.gbc.__gbcStarted = true;
      gbc.HostService.preStart();
      document.body.addClass("flexible_host_stretch_row");
      if (gbc.DebugService.isMonitorWindow()) {
        return;
      }
      contextWin.gbc.HostService.start();
    },
    /**
     * GBC system entry point
     */
    run: function(callback) {
      modulum.assemble();
      var queryStringTheme = contextWin.location.search.match(/^(?:.*[?&])?theme=([^&$]+)(?:&.*)?$/);
      gbc.ThemeService.initTheme(queryStringTheme && queryStringTheme[1], function() {
        gbc.InitService.initServices();
        gbc.preStart();
        var start = function() {
          gbc.start();
        };
        if (Object.isFunction(contextWin.__gbcDefer)) {
          contextWin.__gbcDefer(start);
        } else {
          contextWin.requestAnimationFrame(start);
        }
        if (callback instanceof Function) {
          callback();
        }
      });
    },
    /**
     * display before ending warning if needed when quitting the web page
     * @return {string}
     */
    showExitWarning: function() {
      if (gbc.ThemeService.getValue("theme-disable-ending-popup") !== true &&
        !contextWin.__desactivateEndingPopup &&
        !window.isURLParameterEnabled(contextWin.location.search, "noquitpopup") &&
        !contextWin.gbc.DebugService.isActive() && gbc.SessionService.getCurrent() && gbc.SessionService
        .getCurrent().getCurrentApplication()) {
        return "The Genero application is still running.\n" +
          "If you leave now, some data may be lost.\n" +
          "Please use the application user interface to exit the application before navigating away from this page.";
      }
    },
    /**
     * emulated window.alert
     * @param {string} text
     * @param {string} header
     * @param {Function?} closeCallback
     * @ignore
     */
    alert: function(text, header, closeCallback) {
      var modal = contextWin.gbc.classes.WidgetFactory.createWidget('Modal', {
        appHash: gbc.systemAppId
      });
      modal._gbcSystemModal();
      modal.setHeader(header);

      var contents = document.createElement("div");
      contents.setAttribute("style", "white-space: pre;");
      contents.textContent = text;

      modal.setContent(contents);
      document.body.appendChild(modal.getElement());
      modal.onClose(function() {
        modal.destroy();
        modal = null;
        contents = null;
        if (closeCallback) {
          closeCallback();
        }
      }.bind(this));

      modal.show();
    }
  });

  var rawError = function() {
    var args = Array.prototype.join.call(arguments, " ");
    contextWin.__jsErrors.push(args);
    console.error(args);
  };

  var stackCallback = function(stackframes) {
    rawError("ERROR - Stacktrace");
    var stringifiedStack = "    at " + stackframes.map(function(sf) {
      return sf.toString();
    }).join('\n    at ');
    rawError(stringifiedStack);
  };

  var stackErrorCallback = function(err) {
    rawError(err);
  };

  /**
   * log and stacktrace errors of the GBC system
   * @param errorText
   * @param error
   * @ignore
   */
  gbc.error = function(errorText, error) {
    var text = Object.isString(errorText) && errorText || error && error.toString && error.toString(),
      err = error || (errorText && errorText.stack);
    rawError(text);
    gbc.__wrapper.nativeCall({
      name: "error",
      args: [text]
    });
    if (contextWin.StackTrace && err && typeof(err) !== "string") {
      contextWin.StackTrace.fromError(err).then(stackCallback).catch(stackErrorCallback);
    }
  };
  /**
   *
   * @param msg
   * @param file
   * @param line
   * @param col
   * @param error
   * @ignore
   */
  contextWin.onerror = function(msg, file, line, col, error) {
    gbc.error(msg, error);
    if (window.isURLParameterEnabled(contextWin.location.search, "debugmode")) {
      window.critical.display(msg);
    }
  };

  /**
   * js stacktrace emulation
   * @ignore
   */
  gbc.stack = function() {
    if (contextWin.StackTrace) {
      contextWin.StackTrace.generateArtificially().then(stackCallback).catch(stackErrorCallback);
    }
  };

  contextWin.addEventListener("unload", function() {
    var i = 0,
      sessions = gbc.SessionService && gbc.SessionService.getSessions(),
      len = sessions && sessions.length;
    if (len) {
      for (; i < len; i++) {
        if (sessions[i]) {
          sessions[i].closeSession(true);
        }
      }
    }
    gbc.InitService.emit(gbc.constants.widgetEvents.onUnload);
  });

  /**
   * @ignore
   * @return {*|string}
   */
  contextWin.onbeforeunload = function() {
    //emit hook
    gbc.InitService.emit(gbc.constants.widgetEvents.onBeforeUnload);
    gbc.LogService.ui.log("window onBeforeUnload called");

    if (gbc.canShowExitWarning) {
      // Deprecated since chrome 51 : https://www.chromestatus.com/feature/5349061406228480
      return gbc.showExitWarning();
    }
  };

  /**
   * @ignore
   * @return {*|string}
   */
  contextWin.onblur = function() {
    //emit hook
    gbc.InitService.emit(gbc.constants.widgetEvents.onBlur);
  };

  contextWin.modulum.inject(gbc, gbc.classes);
  contextWin.addEventListener('unload', function() {
    gbc.DebugService.destroy();
    gbc.InitService.destroy();
    document.body.innerHTML = "";
  });

  /**
   * testing purpose only
   * @param callback
   * @ignore
   * @private
   */
  gbc.__isIdleTest = function(callback) {
    contextWin.setTimeout(function() {
      try {
        var session = contextWin.gbc && contextWin.gbc.SessionService && contextWin.gbc.SessionService.getCurrent();
        callback({
          session: !!session,
          idle: !session || !session.getCurrentApplication() || session.isCurrentIdle(),
          jsErrors: window.__jsErrors
        });
      } catch (e) {
        var result = {
          ___TEST_EXCEPTION: true
        };
        result.message = e.toString();
        result.stack = e.stack && e.stack.toString();
        callback(result);
      }
    }, contextWin.browserInfo && (contextWin.browserInfo.isIE || contextWin.browserInfo.isFirefox) ? 10 : 1);
  };

  if (window.isURLParameterEnabled(contextWin.location.search, "unittestmode")) {
    gbc.unitTestMode = true;
  }
  gbc.__wrapper = contextWin.gbcWrapper;

  contextWin.gbc = gbc;

  contextWin.gbcWrapper.__init();
})(window);
;
"use strict";

/**
 * @readonly
 * @enum {string};
 */
gbc.constants.accessoryType = {
  checkmark: "checkmark",
  detailButton: "detailButton",
  disclosureIndicator: "disclosureIndicator"
};

/**
 * @readonly
 * @enum {string};
 */
gbc.constants.selectionMode = {
  none: "",
  set: "set",
  unset: "unset",
  exset: "exset"
};

/**
 * @readonly
 * @enum {string};
 */
gbc.constants.textJustify = {
  left: "left",
  center: "center",
  right: "right"
};

/**
 * @readonly
 * @enum {string};
 */
gbc.constants.fontSize = {
  xxSmall: "xx-small",
  xSmall: "x-small",
  small: "small",
  medium: "medium",
  large: "large",
  xLarge: "x-large",
  xxLarge: "xx-large"
};

/**
 * Action visibility
 * @readonly
 * @enum {number};
 */
gbc.constants.visibility = {
  visible: 0,
  hiddenByProgram: 1,
  hiddenByUser: 2
};

/**
 * Font pitch
 * @readonly
 * @enum {string};
 */
gbc.constants.fontPitch = {
  default: "default",
  fixed: "fixed",
  variable: "variable"
};

/**
 * Table column sort type
 * @readonly
 * @enum {string};
 */
gbc.constants.sortType = {
  none: "",
  ascending: "asc",
  descending: "desc"
};

/**
 * VM runtime status
 * @readonly
 * @enum {string};
 */
gbc.constants.runtimeStatus = {
  interactive: "interactive",
  processing: "processing",
  childstart: "childstart"
};

/**
 * Widget spacing policy
 * @readonly
 * @enum {string};
 */
gbc.constants.spacing = {
  compact: "compact",
  normal: "normal"
};

/**
 * Stretching orientation
 * @readonly
 * @enum {string};
 */
gbc.constants.stretch = {
  none: "none",
  x: "x",
  y: "y",
  both: "both"
};

/**
 * Scrollbars to display
 * @readonly
 * @enum {string};
 */
gbc.constants.scrollBars = {
  none: "none",
  vertical: "vertical",
  horizontal: "horizontal",
  both: "both"
};

/**
 * Widget size policy
 * @readonly
 * @enum {string};
 */
gbc.constants.sizePolicy = {
  initial: "initial",
  fixed: "fixed",
  dynamic: "dynamic"
};

/**
 * Action visibility policy
 * @readonly
 * @enum {string};
 */
gbc.constants.viewType = {
  showNever: "no",
  showAlways: "yes",
  showIfNoExplicitView: "auto"
};

/**
 * Form display mode
 * @readonly
 * @enum {string};
 */
gbc.constants.uiMode = {
  default: "default",
  traditional: "traditional"
};

/**
 * Dialog type
 * @readonly
 * @enum {string};
 */
gbc.constants.dialogType = {
  display: "Display",
  input: "Input",
  construct: "Construct",
  displayArray: "DisplayArray",
  inputArray: "InputArray"
};

/**
 * Text case shift
 * @readonly
 * @enum {string};
 */
gbc.constants.shift = {
  none: "none",
  up: "up",
  down: "down"
};

/**
 * Current drag and drop operation to do
 * @readonly
 * @enum {string};
 */
gbc.constants.dndOperation = {
  none: "none",
  copy: "copy",
  move: "move"
};

/**
 * Widget orientation
 * @readonly
 * @enum {string};
 */
gbc.constants.orientation = {
  vertical: "vertical",
  horizontal: "horizontal"
};

/**
 * Table's aggregate type
 * @readonly
 * @enum {string};
 */
gbc.constants.aggregateType = {
  sum: "sum",
  average: "avg",
  minimum: "min",
  maximum: "max",
  count: "count",
  program: "program"
};

/**
 * Current drag and drop visual feedback
 * @readonly
 * @enum {string};
 */
gbc.constants.dndFeedback = {
  insert: "insert",
  insertAfter: "insert_after",
  select: "select"
};

/**
 * Tab key field order
 * @readonly
 * @enum {number};
 */
gbc.constants.fieldOrder = {
  unconstrained: 0,
  constrained: 1,
  form: 2
};

/**
 * @readonly
 * @enum {string};
 */
gbc.constants.precisionType = {
  year: "year",
  month: "month",
  day: "day",
  hour: "hour",
  minute: "minute",
  second: "second",
  fraction: "fraction"
};

/**
 * @readonly
 * @enum {string};
 */
gbc.constants.keyboardHint = {
  default: "default",
  number: "number",
  phone: "phone",
  email: "email"
};

/**
 * @readonly
 * @enum {string};
 */
gbc.constants.windowType = {
  normal: "",
  left: "left",
  right: "right",
  navigator: "navigator",
  popup: "popup"
};

/**
 * @typedef = {number}; IntBoolean : 0,1
 */

/**
 * @typedef = {string}; Direction : 'nw'|'n'|'ne'|'e'|'se'|'s'|'sw'|'w'
 */

/**
 * @typedef = {string}; Color : 'black'|'red'|'green'|'yellow'|'blue'|'magenta'|'cyan'|'white'
 */
;
"use strict";

gbc.constants.debugInfo = {};
;
"use strict";

/**
 * @ignore
 */
gbc.constants.debugInfo.attributeCategory = {
  "acceleratorKey1": "General",
  "acceleratorKey3": "General",
  "acceleratorName": "General",
  "acceleratorName2": "General",
  "acceleratorName3": "General",
  "acceleratorName4": "General",
  "accessoryType": "General",
  "action": "General",
  "actionActive": "General",
  "actionIdRef": "General",
  "active": "General",
  "aggregateText": "General",
  "aggregateType": "General",
  "aggregateValue": "General",
  "anchor": "General",
  "autoNext": "General",
  "autoScale": "General",
  "blink": "TTY",
  "bold": "TTY",
  "border": "General",
  "bufferSize": "General",
  "build": "General",
  "buttonTextHidden": "General",
  "century": "General",
  "className": "General",
  "clickedCanvasItemId": "General",
  "cloneColumns": "General",
  "cloneCount": "General",
  "colName": "General",
  "color": "TTY",
  "colorCondition": "TTY",
  "columnCount": "General",
  "comment": "General",
  "commentLine": "General",
  "commentLineHidden": "General",
  "componentType": "General",
  "compress": "General",
  "config": "General",
  "container": "General",
  "contextMenu": "General",
  "count": "General",
  "currentColumn": "General",
  "currentParentRow": "General",
  "currentRow": "General",
  "currentWindow": "General",
  "cursor": "General",
  "cursor2": "General",
  "dataType": "General",
  "dbCentury": "General",
  "dbDate": "General",
  "decimalSeparator": "General",
  "defaultValue": "General",
  "defaultView": "General",
  "delimiters": "General",
  "detailAction": "General",
  "dialogEventItem": "General",
  "dialogEventType": "General",
  "dialogType": "General",
  "diameter": "General",
  "dim": "TTY",
  "dirty": "General",
  "disabled": "General",
  "disclosureIndicator": "General",
  "dndAccepted": "General",
  "dndBuffer": "General",
  "dndCanCopy": "General",
  "dndCanMove": "General",
  "dndFeedback": "General",
  "dndIdRef": "General",
  "dndMimeTypes": "General",
  "dndOperation": "General",
  "dndRequiredMimeType": "General",
  "doubleClick": "General",
  "endX": "General",
  "endY": "General",
  "errorLine": "General",
  "exec": "General",
  "expanded": "General",
  "expandedColumn": "General",
  "extentDegrees": "General",
  "fieldId": "General",
  "fieldIdRef": "General",
  "fieldOrder": "General",
  "fieldSelection": "General",
  "fileName": "General",
  "fillColor": "General",
  "filter": "General",
  "focus": "General",
  "focusOnField": "General",
  "fontPitch": "General",
  "formLine": "General",
  "format": "General",
  "gridChildrenInParent": "Layout",
  "gridHeight": "Layout",
  "gridWidth": "Layout",
  "hasChildren": "General",
  "height": "Layout",
  "helpNum": "General",
  "hidden": "Layout",
  "href": "General",
  "idColumn": "General",
  "idRef": "General",
  "image": "General",
  "imageCollapsed": "General",
  "imageColumn": "General",
  "imageExpanded": "General",
  "imageLeaf": "General",
  "include": "General",
  "initializer": "General",
  "inputWrap": "General",
  "isHotKey": "General",
  "isNodeColumn": "General",
  "isNull": "General",
  "isPassword": "TTY",
  "isSystem": "General",
  "isTimer": "General",
  "isTree": "General",
  "justify": "General",
  "keyboardHint": "General",
  "maxLength": "General",
  "menuLine": "General",
  "messageLine": "General",
  "minHeight": "Layout",
  "minWidth": "Layout",
  "moduleName": "General",
  "multiRowSelection": "General",
  "name": "General",
  "noEntry": "General",
  "noFilter": "General",
  "nodeIdRef": "General",
  "notEditable": "General",
  "notNull": "General",
  "numAlign": "General",
  "offset": "General",
  "orientation": "General",
  "pageSize": "General",
  "paramCount": "General",
  "parent": "General",
  "parentIdColumn": "General",
  "picture": "General",
  "placeholder": "General",
  "posX": "Layout",
  "posY": "Layout",
  "procId": "General",
  "procIdParent": "General",
  "procIdWaiting": "General",
  "program": "General",
  "promptLine": "General",
  "queryEditable": "General",
  "required": "General",
  "returnCount": "General",
  "reverse": "TTY",
  "row": "General",
  "rowBound": "General",
  "runtimeStatus": "General",
  "sample": "General",
  "screenRecord": "General",
  "scroll": "General",
  "scrollBars": "General",
  "selected": "General",
  "selection": "General",
  "shift": "General",
  "size": "General",
  "sizePolicy": "Layout",
  "sortColumn": "General",
  "sortType": "General",
  "spacing": "General",
  "splitter": "General",
  "sqlDbName": "General",
  "sqlTabName": "General",
  "sqlType": "General",
  "startDegrees": "General",
  "startX": "General",
  "startY": "General",
  "step": "General",
  "stepX": "General",
  "stepY": "General",
  "stretch": "Layout",
  "style": "General",
  "tabIndex": "General",
  "tabIndexRt": "General",
  "tabName": "General",
  "tag": "General",
  "targetType": "General",
  "text": "General",
  "thousandsSeparator": "General",
  "timeout": "General",
  "touched": "General",
  "ttyAttr": "General",
  "type": "General",
  "uiMode": "General",
  "underline": "TTY",
  "unhidable": "General",
  "unhidableColumns": "General",
  "unmovable": "General",
  "unmovableColumns": "General",
  "unsizable": "General",
  "unsizableColumns": "General",
  "unsortable": "General",
  "unsortableColumns": "General",
  "validate": "General",
  "value": "General",
  "valueChecked": "General",
  "valueMax": "General",
  "valueMin": "General",
  "valueUnchecked": "General",
  "varType": "General",
  "verify": "General",
  "version": "General",
  "visibleId": "General",
  "waiting": "General",
  "wantFixedPageSize": "General",
  "wantReturns": "General",
  "wantTabs": "General",
  "width": "Layout",
  "windowStyle": "General",
  "windowType": "General",
  "xyList": "General"
};
;
"use strict";
/**
 * @ignore
 */
gbc.constants.debugInfo.attributeInfo = {
  acceleratorKey1: {
    desc: "Accelerator Key related to mouse left button.",
    type: "string"
  },
  acceleratorKey3: {
    desc: "Accelerator Key related to mouse right button.",
    type: "string"
  },
  acceleratorName2: {
    desc: "The second accelerator key.",
    type: "string"
  },
  acceleratorName3: {
    desc: "The third accelerator key.",
    type: "string"
  },
  acceleratorName4: {
    desc: "The fourth accelerator key.",
    type: "string"
  },
  acceleratorName: {
    desc: "The accelerator key.",
    type: "string"
  },
  action: {
    desc: "The name of the action the Node is linked with",
    type: "string"
  },
  actionActive: {
    desc: "This action-view node is active, a Action can be invoked.",
    type: "number"
  },
  active: {
    desc: "This interactive node is active, a FormField can be edited, a Action can be invoked.",
    type: "IntBoolean"
  },
  aggregateText: {
    desc: "The aggregate caption. The default is 'Summary'.",
    type: "string"
  },
  aggregateType: {
    desc: "Displays an aggregate value.  final='1'",
    type: "AggregateType"
  },
  aggregateValue: {
    desc: "The aggregate value set by program.",
    type: "string"
  },
  anchor: {
    desc: "The direction of the CanvasText.",
    type: "Direction"
  },
  autoNext: {
    desc: "Leave the field automatically if the input buffer has been filled.",
    type: "IntBoolean"
  },
  autoScale: {
    desc: "",
    type: "IntBoolean"
  },
  blink: {
    desc: "The text of the field is blinking. Required for compatibility.",
    type: "IntBoolean"
  },
  bold: {
    desc: "The text of the field is bold.",
    type: "IntBoolean"
  },
  border: {
    desc: "The Window has a border-frame.",
    type: "IntBoolean"
  },
  bufferSize: {
    desc: "The number of rows needed by the front end to display the current array. Must be greater or equal as pageSize.",
    type: "number"
  },
  build: {
    desc: "DVM Only - The version and build of fglform used to compile the form.  volatile='1'",
    type: "string"
  },
  buttonTextHidden: {
    desc: "Defines if the text is displayed on toolBarItem.",
    type: "IntBoolean"
  },
  century: {
    desc: "The century attribute specifies how to expand abbreviated one- and two- digit year specifications in a DATE and DATETIME field.  Symbol Algorithm for Expanding Abbreviated Years.&lt;br/&gt;C or c Use the past, future, or current year closest to the current date.&lt;br/&gt;F or f Use the nearest year in the future to expand the entered value.&lt;br/&gt;P or p Use the nearest year in the past to expand the entered value.&lt;br/&gt;R or r Prefix the entered value with the first two digits of the current year.",
    type: "string"
  },
  className: {
    desc: "The class attribute as specified in the per file.",
    type: "string"
  },
  clickedCanvasItemId: {
    desc: "The id of the last clicked canvas item - for internal use only.  volatile='1' final='1'",
    type: "number"
  },
  cloneColumns: {
    desc: "Static elements cloned in matrix - number of columns",
    type: "number"
  },
  cloneCount: {
    desc: "Static elements cloned in matrix",
    type: "number"
  },
  colName: {
    desc: "The identifier to lookup this Node in the 4gl program.  The identifier to lookup this Edit in the 4gl program.  Convention Rule: all nodes having a colName attribute can be used within the 4gl program as replacement of the 'old' formfield.  Those statements are ScreenInteraction statements expecting the name of a formfield.  final='1'",
    type: "string"
  },
  color: {
    desc: "A color name, typical for text foreground.",
    type: "Color"
  },
  colorCondition: {
    desc: "DVM Only - an internal value corresponding to COLOR WHERE attribute.  volatile='1'",
    type: "string"
  },
  columnCount: {
    desc: "The number of columns of the current Matrix.",
    type: "number"
  },
  comment: {
    desc: "Item specific help-text.",
    type: "string"
  },
  commentLine: {
    desc: "DVM Only -",
    type: "number"
  },
  commentLineHidden: {
    desc: "DVM Only -",
    type: "number"
  },
  componentType: {
    desc: "",
    type: "string"
  },
  compress: {
    desc: "DVM Only - Remove fill characters after input has been done. Required for compatibility.",
    type: "IntBoolean"
  },
  config: {
    desc: "The config attribute as specified in the .per file.",
    type: "string"
  },
  container: {
    desc: "Defines the name of the parent MDI",
    type: "string"
  },
  contextMenu: {
    desc: "Indicates that the action must be displayed in the context menu.  no: never shown,  yes: always shown,  auto: is shown if there is no explicit view (toolbar, topmenu, button in form..)",
    type: "Trilean"
  },
  count: {
    desc: "The count number of the Message.",
    type: "number"
  },
  currentColumn: {
    desc: "The id of the active column in a Table. The id of the first columns is 0.",
    type: "number"
  },
  currentParentRow: {
    desc: "Parent row of current row.",
    type: "number"
  },
  currentRow: {
    desc: "The index of the current row.",
    type: "number"
  },
  currentWindow: {
    desc: "The id of the active Window",
    type: "number"
  },
  cursor2: {
    desc: "The secondary position of the editor cursor, used for text selection.",
    type: "number"
  },
  cursor: {
    desc: "The current position of the editor cursor. The left most position is 0.",
    type: "number"
  },
  dataType: {
    desc: "Describes a data type in string format (ex:'DECIMAL(4.2)').",
    type: "string"
  },
  dbCentury: {
    desc: "The century to apply client specific date conversions.",
    type: "string"
  },
  dbDate: {
    desc: "The date format to apply client specific date conversions.",
    type: "string"
  },
  decimalSeparator: {
    desc: "Defines the decimal separator for numbers (used for numeric keypad).",
    type: "string"
  },
  defaultValue: {
    desc: "DVM Only - The initial value when making an INPUT.  The value the initialize the target-variable when making an INPUT WITHOUT DEFAULTS.  volatile='1'",
    type: "string"
  },
  defaultView: {
    desc: "Indicates in ringmenu/fkey/action button must be displayed.  no: never shown,  yes: always shown,  auto: button is shown if there is no explicit view (toolbar, topmenu..)",
    type: "Trilean"
  },
  delimiters: {
    desc: "DVM Only - The delimiter-characters as defined in the per-file.",
    type: "string"
  },
  dialogEventItem: {
    desc: "Holds the id of the form item linked to the event (screen-record).",
    type: "number"
  },
  dialogEventType: {
    desc: "Contains the name of the dialog trigger. BeforeField, AfterRow,...",
    type: "string"
  },
  dialogType: {
    desc: "The type name of the controlling dialog.",
    type: "DialogType"
  },
  diameter: {
    desc: "The diameter of the Canvas Item.",
    type: "number"
  },
  dim: {
    desc: "",
    type: "IntBoolean"
  },
  dirty: {
    desc: "DVM Only - The Edit has been used by subdialog.  volatile='1'",
    type: "IntBoolean"
  },
  disabled: {
    desc: "Indicates that the element does not allow any user interaction.",
    type: "IntBoolean"
  },
  dndAccepted: {
    desc: "This Drag can be dropped.",
    type: "IntBoolean"
  },
  dndBuffer: {
    desc: "",
    type: "string"
  },
  dndCanCopy: {
    desc: "",
    type: "IntBoolean"
  },
  dndCanMove: {
    desc: "",
    type: "IntBoolean"
  },
  dndFeedback: {
    desc: "",
    type: "DndFeedback"
  },
  dndIdRef: {
    desc: "",
    type: "number"
  },
  dndMimeTypes: {
    desc: "fgl:in, gdc:out",
    type: "string"
  },
  dndOperation: {
    desc: "",
    type: "DndOperation"
  },
  dndRequiredMimeType: {
    desc: "The required mime type. fgl:out, gdc:in",
    type: "string"
  },
  doubleClick: {
    desc: "Defines the action to be sent by client on a double-click",
    type: "string"
  },
  endX: {
    desc: "The X pos of the ending point of the Canvas Item.",
    type: "number"
  },
  endY: {
    desc: "The Y pos of the ending point of the Canvas Item.",
    type: "number"
  },
  errorLine: {
    desc: "Required for compatibility.",
    type: "number"
  },
  exec: {
    desc: "DVM Only - The command to be executed from the 4gl runtime. Specifies a parameter for a RUN command invoked from fglrun when selecting the command.  The invocation of the command is controlled by the fgl runtime.  volatile='1'",
    type: "string"
  },
  expanded: {
    desc: "Child rows visible?",
    type: "IntBoolean"
  },
  expandedColumn: {
    desc: "The name of the column holding the expanded state of a tree node  volatile='1' final='1'",
    type: "string"
  },
  extentDegrees: {
    desc: "The ending angle for the Canvas Arc.",
    type: "number"
  },
  fieldId: {
    desc: "DVM Only - The unique id of this Edit within the Form. The attribute will be used by fglrun to lookup the Edit.  The fieldId attribute is used to lookup a FormField qualified by a record-name.  final='1'",
    type: "number"
  },
  fieldIdRef: {
    desc: "DVM Only - The fieldId attribute of the FormField or Matrix this Link is referencing.",
    type: "number"
  },
  fieldOrder: {
    desc: "DVM Only - Controls the cursor tabbing in INPUT or CONSTRUCT statements.",
    type: "IntBoolean"
  },
  fieldSelection: {
    desc: "Indicates if the field must be selected, even if focus has not changed.",
    type: "number"
  },
  fileName: {
    desc: "DVM Only - This attribute is for debugging only: fileName is the absolute file name of the resource file.",
    type: "string"
  },
  fillColor: {
    desc: "The color used to fill the Canvas Item.",
    type: "string"
  },
  focus: {
    desc: "The id of the node having the focus.",
    type: "number"
  },
  fontPitch: {
    desc: "The character width of the font. Required for compatibility.",
    type: "FontPitch"
  },
  formLine: {
    desc: "The top-offset when displaying a FORM. Required for compatibility.",
    type: "number"
  },
  format: {
    desc: "A mask to format the output. Only used for NUMERIC and DATE values.",
    type: "string"
  },
  gridChildrenInParent: {
    desc: "The children items are aligned into the parent grid and not into the current container. This can be used to have an alignment between several Groups.",
    type: "IntBoolean"
  },
  gridHeight: {
    desc: "The height in grid-cells.",
    type: "number"
  },
  gridWidth: {
    desc: "The width in grid-cells.",
    type: "number"
  },
  hasChildren: {
    desc: "Is Node.",
    type: "IntBoolean"
  },
  height: {
    desc: "The visible height of an object in character cells. For some objects like windows, tables and images, it can be followed by an optional unit (co,ln,pt,px). Default unit is character cells.",
    type: "string"
  },
  helpNum: {
    desc: "DVM Only - The HELP number value of a MENU-Command clause.",
    type: "number"
  },
  hidden: {
    desc: "Visibility (0=visible,1=hidden by program,2=hidden by user). Runtime handles hidden fields as inactive.",
    type: "number"
  },
  idColumn: {
    desc: "The name of the column holding the tree item id  volatile='1' final='1'",
    type: "string"
  },
  image: {
    desc: "Is the case sensitive name of the file of the icon which should be displayed.",
    type: "string"
  },
  imageCollapsed: {
    desc: "The default image for a collapsed node.  volatile='1' final='1'",
    type: "string"
  },
  imageColumn: {
    desc: "The name of the column holding the image attribute of this TableColumn  volatile='1' final='1'",
    type: "string"
  },
  imageExpanded: {
    desc: "The default image for a expanded node.  volatile='1' final='1'",
    type: "string"
  },
  imageLeaf: {
    desc: "The default image for a leaf.  volatile='1' final='1'",
    type: "string"
  },
  include: {
    desc: "A list of values or ranges.  Will be used to constrain special values when making an input.  &lt;danger&gt;The attribute should be replaced by an Element because of the sub-grammar.&lt;/danger&gt; The list separator is a &lt;code&gt;|&lt;/code&gt;. The separator for the start and end value is &lt;code&gt;:&lt;/code&gt;. The escape character is a backslash.",
    type: "string"
  },
  initializer: {
    desc: "DVM Only - The name of a 4gl function to initialize the item list of this combo box.  volatile='1' final='1'",
    type: "string"
  },
  inputWrap: {
    desc: "DVM Only - Leaving the last field of a INPUT will set the focus to the first field.  Secifies if an INPUT or CONSTRUCT will be termined when leaving the last field if will be continued on the first field (the input cursor wraps). GUI-client implementors can ignore this attribute - the tabbing is controlled by the vm yet.",
    type: "IntBoolean"
  },
  isHotKey: {
    desc: "DVM Only - This has been declared by a COMMAND KEY (key-name).",
    type: "number"
  },
  isNodeColumn: {
    desc: "The name of the column holding the isNode attribute a tree node  volatile='1' final='1'",
    type: "string"
  },
  isNull: {
    desc: "Indicates if the element is NULL.",
    type: "number"
  },
  isPassword: {
    desc: "This is a field with password input.",
    type: "IntBoolean"
  },
  isSystem: {
    desc: "Defines if the element is system or user (used by FunctionCall).",
    type: "IntBoolean"
  },
  isTree: {
    desc: "This table is decorated as tree.  volatile='1' final='1'",
    type: "IntBoolean"
  },
  justify: {
    desc: "Text justification form the element.",
    type: "TextJustify"
  },
  maxLength: {
    desc: "What's the maximum number if characters a user can enter (0 is unlimited).",
    type: "number"
  },
  menuLine: {
    desc: "Required for compatibility.",
    type: "number"
  },
  messageLine: {
    desc: "Required for compatibility.",
    type: "number"
  },
  minHeight: {
    desc: "minimum height for the form measured in characters.",
    type: "number"
  },
  minWidth: {
    desc: "minimum width for the form measured in characters.",
    type: "number"
  },
  moduleName: {
    desc: "Defines the name of a module.",
    type: "string"
  },
  multiRowSelection: {
    desc: "Table allows multirow selection.",
    type: "IntBoolean"
  },
  name: {
    desc: "The name of this Node. Convenience rule: all Node-objects should have a name attribute with a unique value in the list of siblings. This simplifies the identification of the Node.",
    type: "string"
  },
  noEntry: {
    desc: "Do not enable INPUT from this field. If this flag is set the field will be ignored for making input.",
    type: "IntBoolean"
  },
  nodeIdRef: {
    desc: "The id of a node in the AUI tree.",
    type: "number"
  },
  notEditable: {
    desc: "Use the NOTEDITABLE attribute to deny text modification",
    type: "IntBoolean"
  },
  notNull: {
    desc: "On leave an INPUT the target-variable will be checked to be NOT NULL.",
    type: "IntBoolean"
  },
  numAlign: {
    desc: "Indicates if a field contains a numeric value, for text justification.",
    type: "IntBoolean"
  },
  offset: {
    desc: "The index of the first visible row.",
    type: "number"
  },
  orientation: {
    desc: "Defines the orientation of an element.",
    type: "Orientation"
  },
  pageSize: {
    desc: "The number of usable rows in the visible Array. Is lower than bufferSize.",
    type: "number"
  },
  paramCount: {
    desc: "Defines a number of parameters.",
    type: "number"
  },
  parent: {
    desc: "The id attribute of the parent Menu.",
    type: "number"
  },
  parentIdColumn: {
    desc: "The name of the column holding the tree item parent id  volatile='1' final='1'",
    type: "string"
  },
  picture: {
    desc: "A mask defining which character-classes are allowed on fix input positions. Only used for INPUT.",
    type: "string"
  },
  posX: {
    desc: "The X position of the Node in its container. The leftmost position is 0.",
    type: "number"
  },
  posY: {
    desc: "The Y position of the Node in its container. The topmost position is 0.",
    type: "number"
  },
  procId: {
    desc: "The process identifier of a program (hostname:pid).",
    type: "string"
  },
  procIdParent: {
    desc: "The process identifier of the parent program (hostname:pid).",
    type: "string"
  },
  procIdWaiting: {
    desc: "The process identifier of the waiting parent program (hostname:pid).",
    type: "string"
  },
  program: {
    desc: "The name of a program that will be called to edit TEXT or BYTE values.",
    type: "string"
  },
  promptLine: {
    desc: "Required for compatibility.",
    type: "number"
  },
  queryEditable: {
    desc: "Indicates if the field (combobox) is editable during CONSTRUCT.",
    type: "IntBoolean"
  },
  required: {
    desc: "The user must enter something but can also leave the field empty.",
    type: "IntBoolean"
  },
  returnCount: {
    desc: "Defines a number of returned values.",
    type: "number"
  },
  reverse: {
    desc: "Make reverse colors - if You can.",
    type: "IntBoolean"
  },
  row: {
    desc: "(Tree) Row",
    type: "number"
  },
  runtimeStatus: {
    desc: "Tell the client the status of the runtime, interactive: the runtime waits for a user interaction, processing: the runtime is busy,childstart: the runtime is starting a child application process.",
    type: "RuntimeStatus"
  },
  sample: {
    desc: "A sample of a typical value.",
    type: "string"
  },
  screenRecord: {
    desc: "The name of the attached screen record in INPUT|DISPLAY ARRAY.",
    type: "string"
  },
  scroll: {
    desc: "Required for compatibility.",
    type: "IntBoolean"
  },
  scrollBars: {
    desc: "Defines scrolling and word wrapping.",
    type: "ScrollBars"
  },
  selected: {
    desc: "Object selection indicator (0 = not selected, 1 = selected).",
    type: "IntBoolean"
  },
  selection: {
    desc: "The id attribute of the current MenuAction-child.",
    type: "string"
  },
  shift: {
    desc: "The shift attribute controls up or down shifting if this field is in input mode.",
    type: "Shift"
  },
  size: {
    desc: "The size of the array.",
    type: "number"
  },
  sizePolicy: {
    desc: "how elements grow if content is displayed to them.",
    type: "SizePolicy"
  },
  sortColumn: {
    desc: "The index of the Column, data is ordered by.",
    type: "number"
  },
  sortType: {
    desc: "(none|asc|desc)",
    type: "string"
  },
  spacing: {
    desc: "Defines the spacing between two visible siblings.",
    type: "Spacing"
  },
  splitter: {
    desc: "Children will be separated by a splitter.",
    type: "IntBoolean"
  },
  sqlDbName: {
    desc: "The name of the database used to compile this form.  volatile='1' final='1'",
    type: "string"
  },
  sqlTabName: {
    desc: "The name of the SQL Table this Edit is related to. For debugging only.  volatile='1' final='1'",
    type: "string"
  },
  sqlType: {
    desc: "A SQL-type-name. Will be used for CONSTRUCT.  volatile='1' final='1'",
    type: "string"
  },
  startDegrees: {
    desc: "The starting angle for the Canvas Arc.",
    type: "number"
  },
  startX: {
    desc: "The X pos of the starting point of the Canvas Item.",
    type: "number"
  },
  startY: {
    desc: "The Y pos of the starting point of the Canvas Item.",
    type: "number"
  },
  step: {
    desc: "The step between two marks.",
    type: "number"
  },
  stepX: {
    desc: "The space between two cells (horizontal).",
    type: "number"
  },
  stepY: {
    desc: "The space between two cells (vertical).",
    type: "number"
  },
  stretch: {
    desc: "One of { none x y both } - Indicates if the Image can be streched.",
    type: "Stretch"
  },
  style: {
    desc: "The given style of the Node.This is used to centralize attributes in the node.stylename style.",
    type: "string"
  },
  tabIndex: {
    desc: "Sets the order of fields in a form.",
    type: "number"
  },
  tabIndexRt: {
    desc: "The tab index of the field in the current dialog.",
    type: "number"
  },
  tabName: {
    desc: "DVM Only - An identifier to lookup children of this node in the rogram.",
    type: "string"
  },
  tag: {
    desc: "User specific text. Can be added to any node.",
    type: "string"
  },
  targetType: {
    desc: "Type of the target variable associated to this screen field.",
    type: "string"
  },
  text: {
    desc: "Text associated to this Control. he text is typically visible for the user.",
    type: "string"
  },
  thousandsSeparator: {
    desc: "Defines the thousands separator for numbers (used for numeric keypad).",
    type: "string"
  },
  timeout: {
    desc: "After timeout seconds beeing idle this action must be invoked",
    type: "number"
  },
  touched: {
    desc: "DVM Only - The Edit has been touched in the current dialog.  volatile='1'",
    type: "IntBoolean"
  },
  ttyAttr: {
    desc: "TTY attributes (COLOR, REVERSE, UNDERLINE, BOLD) as seen from fglcomp.  volatile='1' final='1'",
    type: "string"
  },
  type: {
    desc: "",
    type: "string"
  },
  uiMode: {
    desc: "Render as close as possible like the text user interface.",
    type: "UIMode"
  },
  underline: {
    desc: "Indicates if the current text is underlined. Required for compatibility.",
    type: "IntBoolean"
  },
  unhidable: {
    desc: "Not hidable.",
    type: "IntBoolean"
  },
  unhidableColumns: {
    desc: "Table columns cannot be hidden.",
    type: "IntBoolean"
  },
  unmovable: {
    desc: "Can't be move. Have sense if at least two columns are unmovable: then the order for these columns is fixed.",
    type: "IntBoolean"
  },
  unmovableColumns: {
    desc: "All columns of this list-view have a fixed position. This attribute disables user to set the order of columns at runtime.",
    type: "IntBoolean"
  },
  unsizable: {
    desc: "Not resizable.",
    type: "IntBoolean"
  },
  unsizableColumns: {
    desc: "Table columns are not resizable.",
    type: "IntBoolean"
  },
  unsortable: {
    desc: "Not sortable.",
    type: "IntBoolean"
  },
  unsortableColumns: {
    desc: "Table columns cannot be used for sort.",
    type: "IntBoolean"
  },
  validate: {
    desc: "volatile='1' final='1'",
    type: "number"
  },
  value: {
    desc: "The current value.",
    type: "string"
  },
  valueChecked: {
    desc: "The value the checkbox holds when checked. The default value is 1.",
    type: "string"
  },
  valueMax: {
    desc: "The upper limit of a range of allowed values.",
    type: "number"
  },
  valueMin: {
    desc: "The lower limit of a range of allowed values.",
    type: "number"
  },
  valueUnchecked: {
    desc: "The value the checkbox holds when unchecked. The default value is 0",
    type: "string"
  },
  verify: {
    desc: "DVM Only - the value must be entered twice by the user.",
    type: "IntBoolean"
  },
  version: {
    desc: "The version of an element (used for example in form version).",
    type: "string"
  },
  visibleId: {
    desc: "Ensure the item with the given id to be visible.",
    type: "number"
  },
  waiting: {
    desc: "DVM Only - The command started in a start menu will be started WITH waitingor not depending on waiting value, defaults to 0, not waiting  volatile='1'",
    type: "number"
  },
  wantFixedPageSize: {
    desc: "The pageSize can't be set interactively. This attribute disables users to resize the listView at runtime.",
    type: "IntBoolean"
  },
  wantReturns: {
    desc: "Indicates that this textEdit will consume return-characters. Return characters will not be used to leave the input.",
    type: "IntBoolean"
  },
  wantTabs: {
    desc: "Indicates that this textEdit will consume tab-characters. Tab characters will not be used to leave this field.",
    type: "IntBoolean"
  },
  width: {
    desc: "The visible width of an object in character cells. For some objects like windows, tables and images, it can be followed by an optional unit (co,ln,pt,px). Default unit is character cells.",
    type: "string"
  },
  windowStyle: {
    desc: "Defines the parent window style of a form.",
    type: "string"
  },
  xyList: {
    desc: "A space separated list of coordinates describing the CanvasPolygon.",
    type: "string"
  }
};
;
"use strict";

gbc.constants.debugInfo.auiTreeNodeInfo = {
  "Action": {
    "collapsed": false,
    "color": "#78DBE2"
  },
  "ActionDefault": {
    "collapsed": false,
    "color": "#87A96B"
  },
  "ActionDefaultList": {
    "collapsed": true,
    "color": "#FFA474"
  },
  "Aggregate": {
    "collapsed": false,
    "color": "#FAE7B5"
  },
  "Button": {
    "collapsed": false,
    "color": "#9F8170"
  },
  "ButtonEdit": {
    "collapsed": false,
    "color": "#FD7C6E"
  },
  "Canvas": {
    "collapsed": false,
    "color": "#ACE5EE"
  },
  "CanvasArc": {
    "collapsed": false,
    "color": "#A2A2D0"
  },
  "CanvasCircle": {
    "collapsed": false
  },
  "CanvasLine": {
    "collapsed": false
  },
  "CanvasOval": {
    "collapsed": false
  },
  "CanvasPolygon": {
    "collapsed": false,
    "color": "#DE5D83"
  },
  "CanvasRectangle": {
    "collapsed": false,
    "color": "#B0B7C6"
  },
  "CanvasText": {
    "collapsed": false,
    "color": "#B4674D"
  },
  "CheckBox": {
    "collapsed": false,
    "color": "#FF7F49"
  },
  "ComboBox": {
    "collapsed": false,
    "color": "#1F75FE"
  },
  "Completer": {
    "collapsed": false,
    "color": "#1F75FE"
  },
  "Config": {
    "collapsed": false,
    "color": "#EA7E5D"
  },
  "DateEdit": {
    "collapsed": false,
    "color": "#CB4154"
  },
  "DateTimeEdit": {
    "collapsed": false,
    "color": "#56004C"
  },
  "DefaultActions": {
    "collapsed": false,
    "color": "#1CD3A2"
  },
  "Dialog": {
    "collapsed": false,
    "color": "#1DACD6"
  },
  "DialogEvent": {
    "collapsed": false,
    "color": "#BC5D58"
  },
  "DialogInfo": {
    "collapsed": false,
    "color": "#DD9475"
  },
  "DragDropInfo": {
    "collapsed": false,
    "color": "#9ACEEB"
  },
  "Edit": {
    "collapsed": false,
    "color": "#FDDB6D"
  },
  "FieldInfo": {
    "collapsed": false,
    "color": "#2B6CC4"
  },
  "Folder": {
    "collapsed": false,
    "color": "#6E5160"
  },
  "Form": {
    "collapsed": false,
    "color": "#CEFF1D"
  },
  "FormField": {
    "collapsed": false,
    "color": "#71BC78"
  },
  "FunctionCall": {
    "collapsed": false,
    "color": "#C364C5"
  },
  "FunctionCallParameter": {
    "collapsed": false,
    "color": "#CC6666"
  },
  "Grid": {
    "collapsed": false,
    "color": "#FCD975"
  },
  "Group": {
    "collapsed": false,
    "color": "#A8E4A0"
  },
  "GroupTitle": {
    "collapsed": false,
    "color": "#A8E4A0"
  },
  "HBox": {
    "collapsed": false,
    "color": "#1164B4"
  },
  "HLine": {
    "collapsed": false,
    "color": "#F0E891"
  },
  "IdleAction": {
    "collapsed": false,
    "color": "#FF1DCE"
  },
  "Image": {
    "collapsed": false,
    "color": "#CA3767"
  },
  "ImageFonts": {
    "collapsed": false,
    "color": "#CA3767"
  },
  "ImageFont": {
    "collapsed": false,
    "color": "#CA3767"
  },
  "Item": {
    "collapsed": false,
    "color": "#3BB08F"
  },
  "Label": {
    "collapsed": false,
    "color": "#DADA22"
  },
  "Link": {
    "collapsed": false,
    "color": "#FFBD88"
  },
  "Matrix": {
    "collapsed": false,
    "color": "#F664AF"
  },
  "Menu": {
    "collapsed": false,
    "color": "#AAF0D1"
  },
  "MenuAction": {
    "collapsed": false,
    "color": "#CD4A4C"
  },
  "Message": {
    "collapsed": false,
    "color": "#EDD19C"
  },
  "Page": {
    "collapsed": false,
    "color": "#FF8243"
  },
  "PhantomColumn": {
    "collapsed": false,
    "color": "#C8385A"
  },
  "PhantomEdit": {
    "collapsed": false,
    "color": "#EF98AA"
  },
  "PhantomFormField": {
    "collapsed": false,
    "color": "#1A4876"
  },
  "PhantomMatrix": {
    "collapsed": false,
    "color": "#30BA8F"
  },
  "ProgressBar": {
    "collapsed": false,
    "color": "#C54B8C"
  },
  "Property": {
    "collapsed": false,
    "color": "#1974D2"
  },
  "PropertyArray": {
    "collapsed": false,
    "color": "#FFA343"
  },
  "PropertyDict": {
    "collapsed": false,
    "color": "#BAB86C"
  },
  "RadioGroup": {
    "collapsed": false,
    "color": "#FF7538"
  },
  "RecordView": {
    "collapsed": false,
    "color": "#FF2B2B"
  },
  "Rectangle": {
    "collapsed": false,
    "color": "#F8D568"
  },
  "RowInfo": {
    "collapsed": false,
    "color": "#1CA9C9"
  },
  "RowInfoList": {
    "collapsed": false,
    "color": "#FFCFAB"
  },
  "Screen": {
    "collapsed": false,
    "color": "#FDDDE6"
  },
  "ScrollArea": {
    "collapsed": false,
    "color": "#EFDECD"
  },
  "ScrollGrid": {
    "collapsed": false,
    "color": "#A5694F"
  },
  "Slider": {
    "collapsed": false,
    "color": "#8A795D"
  },
  "SpacerItem": {
    "collapsed": false,
    "color": "#45CEA2"
  },
  "SpinEdit": {
    "collapsed": false,
    "color": "#FB7EFD"
  },
  "Stack": {
    "collapsed": false,
    "color": "#80DAEB"
  },
  "StartMenu": {
    "collapsed": false,
    "color": "#80DAEB"
  },
  "StartMenuCommand": {
    "collapsed": false,
    "color": "#ECEABE"
  },
  "StartMenuGroup": {
    "collapsed": false,
    "color": "#FFCF48"
  },
  "StartMenuSeparator": {
    "collapsed": false,
    "color": "#FD5E53"
  },
  "Style": {
    "collapsed": false,
    "color": "#FAA76C"
  },
  "StyleAttribute": {
    "collapsed": false,
    "color": "#18A7B5"
  },
  "StyleList": {
    "collapsed": true,
    "color": "#EBC7DF"
  },
  "Table": {
    "collapsed": false,
    "color": "#FC89AC"
  },
  "TableAction": {
    "collapsed": false,
    "color": "#FC8900"
  },
  "TableActions": {
    "collapsed": false,
    "color": "#FC00AC"
  },
  "TableColumn": {
    "collapsed": false,
    "color": "#DBD7D2"
  },
  "TextEdit": {
    "collapsed": false,
    "color": "#17806D"
  },
  "TimeEdit": {
    "collapsed": false,
    "color": "#DEAA88"
  },
  "ToolBar": {
    "collapsed": false,
    "color": "#77DDE7"
  },
  "ToolBarItem": {
    "collapsed": false,
    "color": "#FFFF66"
  },
  "ToolBarSeparator": {
    "collapsed": false,
    "color": "#926EAE"
  },
  "TopMenu": {
    "collapsed": false,
    "color": "#324AB2"
  },
  "TopMenuCommand": {
    "collapsed": false,
    "color": "#F75394"
  },
  "TopMenuGroup": {
    "collapsed": false,
    "color": "#FFA089"
  },
  "TopMenuSeparator": {
    "collapsed": false,
    "color": "#8F509D"
  },
  "TreeInfo": {
    "collapsed": false,
    "color": "#A2ADD0"
  },
  "TreeItem": {
    "collapsed": false,
    "color": "#FF43A4"
  },
  "UserInterface": {
    "collapsed": false,
    "color": "#FC6C85"
  },
  "VBox": {
    "collapsed": false,
    "color": "#CDA4DE"
  },
  "Value": {
    "collapsed": false,
    "color": "#FCE883"
  },
  "ValueList": {
    "collapsed": true,
    "color": "#C5E384"
  },
  "WebComponent": {
    "collapsed": false,
    "color": "#FFAE42"
  },
  "Window": {
    "collapsed": false,
    "color": "#CD9575"
  }
};
;
"use strict";

gbc.constants.attributeDefaultValuesByNodeType = {
  ScrollGrid: {
    wantFixedPageSize: 1
  },
  Slider: {
    orientation: "horizontal"
  },
  WebComponent: {
    stretch: "both"
  }
};
/**
 * AUI attributes default values.
 *
 * @instance attributeDefaultValues
 */
gbc.constants.attributeDefaultValues = {
  acceleratorKey1: "",
  acceleratorKey3: "",
  acceleratorName2: "",
  acceleratorName3: "",
  acceleratorName4: "",
  acceleratorName: "",
  action: "",
  actionActive: 0,
  active: 0,
  aggregateText: "",
  aggregateType: "sum",
  aggregateValue: "",
  anchor: "",
  autoNext: 0,
  autoScale: 0,
  blink: 0,
  bold: 0,
  border: 0,
  bufferSize: 0,
  build: "",
  buttonTextHidden: 0,
  century: "",
  className: "",
  clickedCanvasItemId: 0,
  cloneColumns: 0,
  cloneCount: 0,
  colName: "",
  color: "",
  colorCondition: "",
  columnCount: 1,
  comment: "",
  commentLine: 0,
  commentLineHidden: 0,
  componentType: "",
  compress: 0,
  config: "",
  container: "",
  contextMenu: "yes",
  count: 0,
  currentColumn: 0,
  currentParentRow: 0,
  currentRow: 0,
  currentWindow: 0,
  cursor2: 0,
  cursor: 0,
  dataType: "",
  dbCentury: "",
  dbDate: "",
  decimalSeparator: "",
  defaultValue: "",
  defaultView: "auto",
  delimiters: "",
  dialogEventItem: 0,
  dialogEventType: "",
  dialogType: "Display",
  diameter: 0,
  dim: 0,
  dirty: 0,
  disabled: 0,
  dndAccepted: 0,
  dndBuffer: "",
  dndCanCopy: 0,
  dndCanMove: 0,
  dndFeedback: "insert",
  dndIdRef: 0,
  dndMimeTypes: "",
  dndOperation: "move",
  dndParentIdRef: 0,
  dndRequiredMimeType: "",
  doubleClick: "",
  endX: 0,
  endY: 0,
  errorLine: 0,
  exec: "",
  expanded: 0,
  expandedColumn: "",
  extentDegrees: 0,
  fieldId: "",
  fieldIdRef: 0,
  fieldOrder: 0,
  fieldSelection: 0,
  fileName: "",
  fillColor: "",
  filter: "",
  focus: 0,
  focusOnField: 0,
  fontPitch: "default",
  formLine: 0,
  format: "",
  gridChildrenInParent: 0,
  gridHeight: null,
  gridWidth: null,
  hasChildren: 0,
  height: "",
  helpNum: 0,
  hidden: 0,
  idColumn: "",
  image: "",
  imageCollapsed: "",
  imageColumn: "",
  imageExpanded: "",
  imageLeaf: "",
  include: "",
  initializer: "",
  inputWrap: 0,
  isHotKey: 0,
  isNodeColumn: "",
  isNull: 0,
  isPassword: 0,
  isSystem: 0,
  isTimer: 0,
  isTree: 0,
  justify: "left",
  maxLength: 0,
  menuLine: 0,
  messageLine: 0,
  minHeight: 0,
  minWidth: 0,
  moduleName: "",
  multiRowSelection: 0,
  name: "",
  noEntry: 0,
  noFilter: 0,
  nodeIdRef: 0,
  notNull: 0,
  numAlign: 0,
  offset: 0,
  orientation: "vertical",
  pageSize: 0,
  paramCount: 0,
  parent: 0,
  parentIdColumn: "",
  picture: "",
  placeholder: "",
  posX: 0,
  posY: 0,
  procId: "",
  procIdParent: "",
  procIdWaiting: "",
  program: "",
  promptLine: 0,
  queryEditable: 0,
  required: 0,
  returnCount: 0,
  reverse: 0,
  row: 0,
  runtimeStatus: "interactive",
  sample: "",
  screenRecord: "",
  scroll: 0,
  scrollBars: "vertical",
  selected: 0,
  selection: "",
  shift: "none",
  size: 0,
  sizePolicy: "initial",
  sortColumn: -1,
  sortType: "",
  spacing: "normal",
  splitter: 0,
  sqlDbName: "",
  sqlTabName: "",
  sqlType: "",
  startDegrees: 0,
  startX: 0,
  startY: 0,
  step: 1,
  stepX: 0,
  stepY: 1,
  stretch: "none",
  style: "",
  tabIndex: 0,
  tabIndexRt: 0,
  tabName: "",
  tag: "",
  targetType: "",
  text: "",
  thousandsSeparator: "",
  timeout: 0,
  touched: 0,
  ttyAttr: "",
  type: "",
  uiMode: "default",
  underline: 0,
  unhidable: 0,
  unhidableColumns: 0,
  unmovable: 0,
  unmovableColumns: 0,
  unsizable: 0,
  unsizableColumns: 0,
  unsortable: 0,
  unsortableColumns: 0,
  validate: 0,
  value: "",
  valueChecked: "1",
  valueMax: null,
  valueMin: null,
  valueUnchecked: "0",
  verify: 0,
  version: "",
  visibleId: -1,
  waiting: 0,
  wantFixedPageSize: 0,
  wantReturns: 0,
  wantTabs: 0,
  width: "",
  windowStyle: "",
  xyList: ""
};
;
"use strict";

/**
 * @readonly
 * @enum {string};
 */
gbc.constants.baseEvents = {
  applicationAdded: "g_applicationAdded",
  applicationRemoved: "g_applicationRemoved",
  childrenNodeCreated: "g_childrenNodeCreated",
  controllerCreated: "g_controllerCreated",
  displayEnd: "g_displayEnd",
  idleChanged: "g_idleChanged",
  nodeCreated: "g_nodeCreated",
  nodeDestroyed: "g_nodeDestroyed",
  ordersManaged: "g_ordersManaged"
};
;
"use strict";
/**
 * @namespace gbc.constants.network
 */
gbc.constants.network = {
  /**
   * The different headers used by the protocol
   */
  headers: {
    error: "X-FourJs-Error",
    prompt: "X-FourJs-Prompt",
    session: "X-FourJs-Id",
    server: "X-FourJs-Server",
    serverFeatures: "X-FourJs-Server-Features",
    application: "X-FourJs-AppId",
    timeout: "X-FourJs-Timeout",
    webComponent: "X-FourJs-WebComponent",
    newTask: "X-FourJs-NewTask",
    vmReady: "X-FourJs-VmReady",
    closed: "X-FourJs-Closed",
    endUrl: "X-FourJs-End-Url",
    sessionClosed: "X-FourJs-Session-Closed",
    devmode: "X-FourJs-Development",
    contentType: "Content-Type"
  },

  /**
   * Enum RequestType
   * The type of request used in the VM protocol's header
   */
  requestType: {
    AUI: 1,
    Ping: 2,
    Interrupt: 3,
    Close: 4,
    FT: 5
  },
  /**
   * The needed stater response headers
   */
  startHeaders: {
    session: {
      error: "Missing Session ID"
    },
    timeout: {
      error: "Missing Timeout"
    },
    webComponent: {
      prop: "webComponent",
      error: "Missing WebComponent Path"
    }
  },
  sentHeaders: {
    "X-FourJs-Client": "GBC/" + encodeURIComponent(gbc.version) + "-" + gbc.build,
    "X-FourJs-Client-Features": "prompt"
  }
};

/**
 * Array RequestTypeStrings
 * Associate a string to each RequestType. For logging purpose.
 */
gbc.constants.network.requestTypeStrings = Object.swap(gbc.constants.network.requestType);
;
"use strict";

gbc.constants.nodeAttributes = {
  "Action": [
    "acceleratorName", "acceleratorName2", "acceleratorName3", "acceleratorName4", "active", "comment", "contextMenu",
    "defaultView", "helpNum", "hidden", "idRef", "image", "name", "tabIndexRt", "tag", "text", "validate"
  ],
  "ActionDefault": [
    "acceleratorName", "acceleratorName2", "acceleratorName3", "acceleratorName4", "comment", "contextMenu", "defaultView",
    "idRef", "image", "name", "tag", "text", "validate"
  ],
  "ActionDefaultList": [
    "fileName", "idRef", "name", "tag"
  ],
  "Aggregate": [
    "aggregateText", "aggregateType", "blink", "bold", "color", "colorCondition", "comment", "dim", "fieldIdRef",
    "fontPitch",
    "format", "gridHeight", "gridWidth", "height", "hidden", "idRef", "isPassword", "justify", "name", "posX", "posY", "reverse",
    "sample", "sizePolicy", "style", "tag", "text", "ttyAttr", "underline", "width"
  ],
  "Button": [
    "acceleratorName", "actionActive", "actionIdRef", "cloneColumns", "cloneCount", "comment", "disclosureIndicator",
    "fontPitch", "gridHeight", "gridWidth", "height", "hidden", "idRef", "image", "name", "posX", "posY", "sample", "sizePolicy",
    "stepX",
    "stepY", "style", "tabIndex", "tabIndexRt", "tag", "text", "width"
  ],
  "ButtonEdit": [
    "action", "actionActive", "actionIdRef", "autoNext", "blink", "bold", "century", "color", "colorCondition", "comment",
    "dim", "fontPitch", "format", "gridHeight", "gridWidth", "height", "hidden", "idRef", "image", "isPassword", "justify",
    "keyboardHint", "maxLength", "name", "notEditable", "picture", "placeholder", "posX", "posY", "program", "reverse", "sample",
    "scroll", "shift",
    "sizePolicy", "style", "tag", "text", "ttyAttr", "underline", "verify", "width"
  ],
  "Canvas": [
    "comment", "fontPitch", "gridHeight", "gridWidth", "height", "hidden", "idRef", "name", "posX", "posY", "sample",
    "style",
    "tag", "text", "width"
  ],
  "CanvasArc": [
    "acceleratorKey1", "acceleratorKey3", "comment", "diameter", "extentDegrees", "fillColor", "idRef", "name",
    "startDegrees",
    "startX", "startY", "tag"
  ],
  "CanvasCircle": [
    "acceleratorKey1", "acceleratorKey3", "comment", "diameter", "fillColor", "idRef", "name", "startX", "startY", "tag"
  ],
  "CanvasLine": [
    "acceleratorKey1", "acceleratorKey3", "comment", "diameter", "endX", "endY", "fillColor", "idRef", "name", "startX",
    "startY", "tag", "width"
  ],
  "CanvasOval": [
    "acceleratorKey1", "acceleratorKey3", "comment", "endX", "endY", "fillColor", "idRef", "name", "startX", "startY", "tag"
  ],
  "CanvasPolygon": [
    "acceleratorKey1", "acceleratorKey3", "comment", "fillColor", "idRef", "name", "startX", "startY", "tag", "xyList"
  ],
  "CanvasRectangle": [
    "acceleratorKey1", "acceleratorKey3", "comment", "endX", "endY", "fillColor", "idRef", "name", "startX", "startY", "tag"
  ],
  "CanvasText": [
    "acceleratorKey1", "acceleratorKey3", "anchor", "comment", "fillColor", "idRef", "name", "startX", "startY", "tag",
    "text"
  ],
  "CheckBox": [
    "blink", "bold", "color", "colorCondition", "comment", "dim", "fontPitch", "gridHeight", "gridWidth", "height", "hidden",
    "idRef", "isPassword", "justify", "name", "posX", "posY", "reverse", "sample", "sizePolicy", "style", "tag", "text", "ttyAttr",
    "underline", "valueChecked", "valueUnchecked", "width"
  ],
  "ComboBox": [
    "blink", "bold", "color", "colorCondition", "comment", "dim", "fontPitch", "gridHeight", "gridWidth", "height", "hidden",
    "idRef", "initializer", "isPassword", "justify", "name", "placeholder", "posX", "posY", "queryEditable", "reverse", "sample",
    "scroll", "shift",
    "sizePolicy", "style", "tag", "text", "ttyAttr", "underline", "width"
  ],
  "Completer": [
    "filterMode", "name", "size", "tag"
  ],
  "Config": [
    "idRef", "name", "tag"
  ],
  "DateEdit": [
    "autoNext", "blink", "bold", "century", "color", "colorCondition", "comment", "dim", "fontPitch", "format", "gridHeight",
    "gridWidth", "height", "hidden", "idRef", "isPassword", "justify", "keyboardHint", "maxLength", "name", "picture", "posX", "posY",
    "program", "reverse", "sample", "scroll", "shift", "sizePolicy", "style", "tag", "text", "ttyAttr", "underline", "verify",
    "width"
  ],
  "DateTimeEdit": [
    "autoNext", "blink", "bold", "century", "color", "colorCondition", "comment", "dim", "fontPitch", "format", "gridHeight",
    "gridWidth", "height", "hidden", "idRef", "isPassword", "justify", "keyboardHint", "maxLength", "name", "picture", "posX", "posY",
    "program", "reverse", "sample", "scroll", "shift", "sizePolicy", "style", "tag", "text", "ttyAttr", "underline", "verify",
    "width"
  ],
  "DefaultActions": [
    "idRef", "name", "tag"
  ],
  "Dialog": [
    "active", "idRef", "name", "tag"
  ],
  "DialogEvent": [
    "dialogEventItem", "dialogEventType", "idRef", "name", "tag"
  ],
  "DialogInfo": [
    "dialogType", "idRef", "name", "tag"
  ],
  "DragDropInfo": [
    "dndAccepted", "dndBuffer", "dndCanCopy", "dndCanMove", "dndFeedback", "dndIdRef", "dndMimeTypes", "dndOperation",
    "dndRequiredMimeType", "idRef", "name", "tag"
  ],
  "Edit": [
    "autoNext", "blink", "bold", "century", "color", "colorCondition", "comment", "dim", "fontPitch", "format", "gridHeight",
    "gridWidth", "height", "hidden", "idRef", "isPassword", "justify", "keyboardHint", "maxLength", "name", "picture", "placeholder",
    "posX", "posY",
    "program", "reverse", "sample", "scroll", "shift", "sizePolicy", "style", "tag", "text", "ttyAttr", "underline", "verify",
    "width"
  ],
  "XEdit": [
    "autoNext", "blink", "bold", "century", "color", "colorCondition", "comment", "dim", "fontPitch", "format", "gridHeight",
    "gridWidth", "height", "hidden", "idRef", "isPassword", "justify", "keyboardHint", "maxLength", "name", "picture", "placeholder",
    "posX", "posY",
    "program", "reverse", "sample", "scroll", "shift", "sizePolicy", "style", "tag", "text", "ttyAttr", "underline", "verify",
    "width"
  ],
  "FieldInfo": [
    "idRef", "name", "nodeIdRef", "tag", "targetType"
  ],
  "Folder": [
    "comment", "fontPitch", "gridHeight", "gridWidth", "height", "hidden", "idRef", "name", "posX", "posY", "sample",
    "style",
    "tag", "text", "width"
  ],
  "Form": [
    "blink", "bold", "build", "color", "delimiters", "dim", "formLine", "height", "hidden", "idRef", "image", "isPassword",
    "minHeight", "minWidth", "name", "reverse", "spacing", "sqlDbName", "style", "tag", "text", "ttyAttr", "underline", "version",
    "visibleId", "width", "windowStyle"
  ],
  "FormField": [
    "active", "colName", "cursor", "cursor2", "defaultValue", "dialogType", "dirty", "fieldId", "hidden", "idRef", "include",
    "name", "noEntry", "notNull", "numAlign", "required", "screenRecord", "sqlTabName", "sqlType", "tabIndex", "tabIndexRt", "tag",
    "text", "touched", "unhidable", "unmovable", "unsizable", "unsortable", "value", "varType"
  ],
  "FunctionCall": [
    "idRef", "isSystem", "moduleName", "name", "paramCount", "returnCount", "tag"
  ],
  "FunctionCallParameter": [
    "dataType", "idRef", "isNull", "name", "tag", "value"
  ],
  "Grid": [
    "comment", "fontPitch", "gridHeight", "gridWidth", "height", "hidden", "idRef", "name", "posX", "posY", "sample",
    "style",
    "tag", "text", "width"
  ],
  "Group": [
    "comment", "fontPitch", "gridChildrenInParent", "gridHeight", "gridWidth", "height", "hidden", "idRef", "name", "posX",
    "posY", "sample", "style", "tag", "text", "width"
  ],
  "GroupTitle": [],
  "HBox": [
    "comment", "fontPitch", "gridHeight", "gridWidth", "height", "hidden", "idRef", "name", "posX", "posY", "sample",
    "splitter", "style", "tag", "text", "width"
  ],
  "HLine": [
    "comment", "fontPitch", "gridHeight", "gridWidth", "height", "hidden", "idRef", "name", "posX", "posY", "sample",
    "style",
    "tag", "text", "width"
  ],
  "IdleAction": [
    "hidden", "idRef", "name", "tag", "timeout", "isTimer"
  ],
  "Image": [
    "action", "actionActive", "actionIdRef", "autoScale", "blink", "bold", "cloneColumns", "cloneCount", "color",
    "colorCondition", "comment", "dim", "fontPitch", "gridHeight", "gridWidth", "height", "hidden", "idRef", "image", "isPassword",
    "justify", "name", "posX", "posY", "reverse", "sample", "sizePolicy", "stepX", "stepY", "stretch", "style", "tag", "text",
    "ttyAttr",
    "underline", "width"
  ],
  "ImageFonts": [],
  "ImageFont": [
    "name", "href"
  ],
  "Item": [
    "idRef", "name", "tag", "text"
  ],
  "Label": [
    "blink", "bold", "cloneColumns", "cloneCount", "color", "colorCondition", "comment", "dim", "fontPitch", "format",
    "gridHeight", "gridWidth", "height", "hidden", "idRef", "isPassword", "justify", "name", "posX", "posY", "reverse", "sample",
    "sizePolicy", "stepX", "stepY", "style", "tag", "text", "ttyAttr", "underline", "width"
  ],
  "Link": [
    "colName", "fieldIdRef", "idRef", "name", "tag"
  ],
  "Matrix": [
    "active", "bufferSize", "colName", "columnCount", "currentRow", "cursor", "cursor2", "defaultValue", "dialogType",
    "dirty",
    "fieldId", "hidden", "idRef", "include", "name", "noEntry", "notNull", "numAlign", "offset", "pageSize", "required",
    "screenRecord",
    "size", "sqlTabName", "sqlType", "stepX", "stepY", "tabIndex", "tabIndexRt", "tag", "text", "touched", "unhidable", "unmovable",
    "unsizable", "unsortable", "varType"
  ],
  "Menu": [
    "active", "comment", "hidden", "idRef", "image", "name", "parent", "posY", "selection", "style", "tag", "text"
  ],
  "MenuAction": [
    "acceleratorName", "acceleratorName2", "acceleratorName3", "acceleratorName4", "active", "comment", "contextMenu",
    "defaultView", "disclosureIndicator", "helpNum", "hidden", "idRef", "image", "isHotKey", "name", "tabIndexRt", "tag", "text",
    "validate"
  ],
  "Message": [
    "blink", "bold", "color", "count", "dim", "gridHeight", "gridWidth", "height", "idRef", "isPassword", "name", "posX",
    "posY", "reverse", "style", "tag", "text", "ttyAttr", "type", "underline", "width"
  ],
  "Page": [
    "action", "actionActive", "actionIdRef", "comment", "hidden", "idRef", "image", "name", "style", "tag", "text"
  ],
  "PhantomColumn": [
    "active", "aggregateText", "aggregateType", "aggregateValue", "colName", "cursor", "cursor2", "defaultValue",
    "dialogType",
    "dirty", "fieldId", "hidden", "idRef", "imageColumn", "include", "name", "noEntry", "notNull", "numAlign", "required",
    "sqlTabName",
    "sqlType", "tabIndex", "tabIndexRt", "tag", "text", "touched", "unhidable", "unmovable", "unsizable", "unsortable", "varType"
  ],
  "PhantomEdit": [
    "autoNext", "blink", "bold", "century", "color", "colorCondition", "comment", "dim", "fontPitch", "format", "gridHeight",
    "gridWidth", "height", "hidden", "idRef", "isPassword", "justify", "keyboardHint", "maxLength", "name", "picture", "posX", "posY",
    "program", "reverse", "sample", "scroll", "shift", "sizePolicy", "style", "tag", "text", "ttyAttr", "underline", "verify",
    "width"
  ],
  "PhantomFormField": [
    "active", "colName", "cursor", "cursor2", "defaultValue", "dialogType", "dirty", "fieldId", "hidden", "idRef", "include",
    "name", "noEntry", "notNull", "numAlign", "required", "screenRecord", "sqlTabName", "sqlType", "tabIndex", "tabIndexRt", "tag",
    "text", "touched", "unhidable", "unmovable", "unsizable", "unsortable", "value", "varType"
  ],
  "PhantomMatrix": [
    "active", "bufferSize", "colName", "columnCount", "currentRow", "cursor", "cursor2", "defaultValue", "dialogType",
    "dirty",
    "fieldId", "hidden", "idRef", "include", "name", "noEntry", "notNull", "numAlign", "offset", "pageSize", "required",
    "screenRecord",
    "size", "sqlTabName", "sqlType", "stepX", "stepY", "tabIndex", "tabIndexRt", "tag", "text", "touched", "unhidable", "unmovable",
    "unsizable", "unsortable", "varType"
  ],
  "ProgressBar": [
    "blink", "bold", "color", "colorCondition", "comment", "dim", "fontPitch", "gridHeight", "gridWidth", "height", "hidden",
    "idRef", "isPassword", "justify", "name", "posX", "posY", "reverse", "sample", "sizePolicy", "style", "tag", "text", "ttyAttr",
    "underline", "valueMax", "valueMin", "width"
  ],
  "Property": [
    "idRef", "name", "value"
  ],
  "PropertyArray": [
    "idRef", "name"
  ],
  "PropertyDict": [
    "idRef", "name"
  ],
  "RadioGroup": [
    "blink", "bold", "color", "colorCondition", "comment", "dim", "fontPitch", "gridHeight", "gridWidth", "height", "hidden",
    "idRef", "isPassword", "justify", "name", "orientation", "posX", "posY", "reverse", "sample", "sizePolicy", "style", "tag",
    "text",
    "ttyAttr", "underline", "width"
  ],
  "RecordView": [
    "idRef", "name", "tabName", "tag"
  ],
  "Rectangle": [
    "color", "comment", "fontPitch", "gridHeight", "gridWidth", "height", "hidden", "idRef", "name", "posX", "posY",
    "sample",
    "style", "tag", "text", "width"
  ],
  "RipGraphic": [
    "comment", "fontPitch", "gridHeight", "gridWidth", "height", "hidden", "name", "posX", "posY", "sample", "style", "tag", "text",
    "type", "width"
  ],
  "RowInfo": [
    "idRef", "selected"
  ],
  "RowInfoList": [
    "idRef", "name", "tag"
  ],
  "Screen": [
    "comment", "fontPitch", "gridHeight", "gridWidth", "height", "hidden", "idRef", "name", "posX", "posY", "sample",
    "style",
    "tag", "text", "width"
  ],
  "ScrollArea": [
    "active", "bufferSize", "currentRow", "gridHeight", "gridWidth", "name", "offset", "pageSize", "posX", "posY", "size",
    "tag"
  ],
  "ScrollGrid": [
    "active", "bufferSize", "comment", "currentRow", "doubleClick", "filter", "noFilter", "fontPitch", "gridChildrenInParent",
    "gridHeight",
    "gridWidth", "height", "hidden", "idRef", "name", "offset", "pageSize", "posX", "posY", "sample", "size", "style", "tag", "text",
    "width", "wantFixedPageSize"
  ],
  "Slider": [
    "blink", "bold", "color", "colorCondition", "comment", "dim", "fontPitch", "gridHeight", "gridWidth", "height", "hidden",
    "idRef", "isPassword", "justify", "name", "orientation", "posX", "posY", "reverse", "sample", "sizePolicy", "step", "style",
    "tag",
    "text", "ttyAttr", "underline", "valueMax", "valueMin", "width"
  ],
  "SpacerItem": [
    "idRef", "name", "tag"
  ],
  "SpinEdit": [
    "autoNext", "blink", "bold", "century", "color", "colorCondition", "comment", "dim", "fontPitch", "format", "gridHeight",
    "gridWidth", "height", "hidden", "idRef", "isPassword", "justify", "keyboardHint", "maxLength", "name", "picture", "posX", "posY",
    "program", "reverse", "sample", "scroll", "shift", "sizePolicy", "step", "style", "tag", "text", "ttyAttr", "underline",
    "valueMax",
    "valueMin", "verify", "width"
  ],
  "Stack": [
    "posX", "posY", "width", "height", "gridWidth", "gridHeight", "hidden", "fontPitch", "sample",
    "style", "text", "comment", "name", "tag"
  ],
  "StartMenu": [
    "fileName", "idRef", "name", "tag", "text"
  ],
  "StartMenuCommand": [
    "comment", "disabled", "exec", "hidden", "idRef", "image", "name", "tag", "text", "waiting"
  ],
  "StartMenuGroup": [
    "disabled", "hidden", "idRef", "image", "name", "tag", "text"
  ],
  "StartMenuSeparator": [
    "idRef", "name", "tag"
  ],
  "Style": [
    "idRef", "name", "tag"
  ],
  "StyleAttribute": [
    "idRef", "name", "tag", "value"
  ],
  "StyleList": [
    "fileName", "idRef", "name", "tag"
  ],
  "Table": [
    "actionActive", "actionIdRef", "active", "aggregateText", "bufferSize", "comment", "currentColumn", "currentRow",
    "dialogType", "doubleClick", "expandedColumn", "filter", "noFilter", "focusOnField", "fontPitch", "gridHeight", "gridWidth",
    "height", "hidden",
    "idColumn", "idRef", "imageCollapsed", "imageExpanded", "imageLeaf", "isNodeColumn", "isTree", "multiRowSelection", "name",
    "offset",
    "pageSize",
    "parentIdColumn", "posX", "posY", "sample", "size", "sortColumn", "sortType", "style", "tabName", "tag", "text",
    "unhidableColumns",
    "unmovableColumns", "unsizableColumns", "unsortableColumns", "wantFixedPageSize", "width"
  ],
  "TableAction": [
    "actionIdRef", "active", "hidden", "idRef", "image", "name", "rowBound", "text"
  ],
  "TableActions": [
    "active", "accessoryType", "detailAction", "idRef"
  ],
  "TableColumn": [
    "active", "aggregateText", "aggregateType", "aggregateValue", "colName", "cursor", "cursor2", "defaultValue",
    "dialogType",
    "dirty", "fieldId", "hidden", "idRef", "imageColumn", "include", "name", "noEntry", "notNull", "numAlign", "required",
    "sqlTabName",
    "sqlType", "tabIndex", "tabIndexRt", "tag", "text", "touched", "unhidable", "unmovable", "unsizable", "unsortable", "varType"
  ],
  "TextEdit": [
    "autoNext", "blink", "bold", "century", "color", "colorCondition", "comment", "compress", "dim", "fontPitch", "format",
    "gridHeight", "gridWidth", "height", "hidden", "idRef", "isPassword", "justify", "keyboardHint", "maxLength", "name", "notEditable",
    "picture",
    "posX", "posY", "program", "reverse", "sample", "scroll", "scrollBars", "shift", "sizePolicy", "stretch", "style", "tag", "text",
    "ttyAttr", "underline", "verify", "wantReturns", "wantTabs", "width"
  ],
  "TimeEdit": [
    "autoNext", "blink", "bold", "century", "color", "colorCondition", "comment", "dim", "fontPitch", "format", "gridHeight",
    "gridWidth", "height", "hidden", "idRef", "isPassword", "justify", "keyboardHint", "maxLength", "name", "picture", "posX", "posY",
    "program", "reverse", "sample", "scroll", "shift", "sizePolicy", "style", "tag", "text", "ttyAttr", "underline", "verify",
    "width"
  ],
  "ToolBar": [
    "buttonTextHidden", "fileName", "idRef", "name", "style", "tag"
  ],
  "ToolBarItem": [
    "actionActive", "actionIdRef", "comment", "hidden", "idRef", "image", "name", "style", "tag", "text"
  ],
  "ToolBarSeparator": [
    "hidden", "idRef", "name", "style", "tag"
  ],
  "TopMenu": [
    "fileName", "idRef", "name", "style", "tag"
  ],
  "TopMenuCommand": [
    "acceleratorName", "actionActive", "actionIdRef", "comment", "hidden", "idRef", "image", "name", "style", "tag", "text"
  ],
  "TopMenuGroup": [
    "comment", "hidden", "idRef", "image", "name", "style", "tag", "text"
  ],
  "TopMenuSeparator": [
    "hidden", "idRef", "name", "style", "tag"
  ],
  "TreeInfo": [
    "currentParentRow", "hasChildren", "idRef"
  ],
  "TreeItem": [
    "expanded", "hasChildren", "idRef", "row"
  ],
  "UserInterface": [
    "clickedCanvasItemId", "commentLine", "commentLineHidden", "container", "currentWindow", "dbCentury", "dbDate",
    "decimalSeparator", "errorLine", "fieldOrder", "fieldSelection", "focus", "formLine", "height", "idRef", "image", "inputWrap",
    "menuLine", "messageLine", "name", "procId", "procIdParent", "procIdWaiting", "promptLine", "runtimeStatus", "tag", "text",
    "thousandsSeparator", "type", "uiMode", "width"
  ],
  "VBox": [
    "comment", "fontPitch", "gridHeight", "gridWidth", "height", "hidden", "idRef", "name", "posX", "posY", "sample",
    "splitter", "style", "tag", "text", "width"
  ],
  "Value": [
    "blink", "bold", "color", "dim", "idRef", "image", "isPassword", "name", "reverse", "tag", "ttyAttr", "underline",
    "value"
  ],
  "ValueList": [
    "idRef", "name", "tag"
  ],
  "WebComponent": [
    "blink", "bold", "color", "colorCondition", "comment", "componentType", "dim", "fontPitch", "gridHeight", "gridWidth",
    "height", "hidden", "idRef", "isPassword", "justify", "name", "posX", "posY", "reverse", "sample", "scrollBars", "sizePolicy",
    "stretch", "style", "tag", "text", "ttyAttr", "underline", "width"
  ],
  "Window": [
    "blink", "bold", "border", "color", "commentLine", "commentLineHidden", "dim", "errorLine", "formLine", "gridHeight",
    "gridWidth", "height", "idRef", "image", "isPassword", "menuLine", "messageLine", "name", "parent", "posX", "posY", "promptLine",
    "reverse", "style", "tag", "text", "ttyAttr", "underline", "width", "windowType"
  ]
};
;
"use strict";

gbc.constants.style = {
  /**
   * The mapping between 4st value and HEX value
   */
  colorMap: {
    green: "#008000",
    darkOlive: "#505000",
    lightTeal: "#33cccc",
    lightOrange: "#ffcc00",
    lightMagenta: "#ffc0ff",
    darkTeal: "#005050",
    lightRed: "#ff8080",
    darkYellow: "#aaaa00",
    lightYellow: "#ffffe0",
    window: "Window",
    windowText: "WindowText",
    buttonFace: "ButtonFace",
    buttonText: "ButtonText",
    highLight: "Highlight",
    highLightText: "HighlightText",
    infoBackground: "InfoBackground",
    infoText: "InfoText",
    grayText: "GrayText",
    appWorkSpace: "AppWorkspace",
    background: "Background",
    systemalternatebackground: "#eeeeee"
  },

  /**
   * The mapping between 4st fontWeight value and CSS
   */
  fontWeightMap: {
    light: "100",
    normal: "400",
    "demi-bold": "600",
    bold: "700",
    black: "900"
  }
};
;
"use strict";

modulum('Event',
  function(context, cls) {
    /**
     * Creates an Event object given a type
     * A property bag used in eventing system
     * @class Event
     * @memberOf classes
     * @publicdoc Base
     */
    cls.Event = context.oo.Class( /** @lends classes.Event.prototype */ {
      __name: "Event",
      cancel: false,
      type: null,
      /**
       * @constructs
       * @param {string} type the event type : actionEvent, configureEvent, keyEvent, functionCallEvent, dragDropEvent, or rowSelectionEvent
       */
      constructor: function(type) {
        this.type = type;
      }
    });
  });
;
"use strict";

/**
 * @typedef {Function} Hook
 * @param {classes.Event} event event object
 * @param {Object} src event emitter
 * @param {...any} additional data
 */
/**
 * @typedef {Function} HandleRegistration
 */

modulum('EventListener', ['Event'],
  function(context, cls) {
    //// debug list unregistered listeners
    //  window.reged = {};
    /**
     * A base class to support eventing
     * @class EventListener
     * @memberOf classes
     * @publicdoc Base
     */
    cls.EventListener = context.oo.Class(function() {
      return /** @lends classes.EventListener.prototype */ {
        /**
         * Literal class name.
         * @type {string}
         * @protected
         */
        __name: "EventListener",

        /**
         * Registered events
         * @type {Map.<string, Array<number>>}
         * @protected
         */
        _events: null,

        /**
         * Handlers for asynchroneous calls
         * @type Array<*>
         * @protected
         */
        _asyncHandlers: null,

        /**
         * Indicates if object has been destroyed
         * @type {boolean}
         * @protected
         */
        _destroyed: false,

        /**
         * @constructs
         */
        constructor: function() {
          this._events = new Map();
          this._asyncHandlers = [];
        },

        /**
         * Destroy the object and free memory
         */
        destroy: function() {
          if (!this._destroyed && this._events) {
            this._destroyed = true;
            this._events.clear();
            this._events = null;
            this._clearAllAsyncCalls();
            this._asyncHandlers = null;
          } else {
            context.LogService.warn("Trying to destroy a destroyed Object " + this.__name);
          }
        },

        /**
         * Returns if the node is destroyed
         * @return {boolean} true if node is destroyed
         * @publicdoc
         */
        isDestroyed: function() {
          return this._destroyed;
        },

        /**
         * Emit an event
         * @param {string} type event type to emit
         * @param {...any} arguments - arguments (excluding type) will be set in event.data
         * @publicdoc
         */
        emit: function(type, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9) {
          if (this._events) {
            var handlers = this._events.get(type);
            if (handlers && handlers.length) {
              var event = new cls.Event(type);
              event.data = [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9];
              var list = handlers.slice(),
                len = list.length;
              for (var i = 0; i < len; i++) {
                var handler = list[i];
                if (!!handler && !event.cancel) {
                  handler.call(this, event, this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
                }
              }
            }
          }
        },

        /**
         * Registers a handler for this event type
         * @param {string} type - event type (e.g. "attribute changed")
         * @param {Hook} handler - handler to trigger when the event type is emitted
         * @param {boolean=} once - if true, will only fire once
         * @returns {HandleRegistration} a registration handle (for unbind purpose)
         * @publicdoc
         */
        when: function(type, handler, once) {
          if (this._destroyed) {
            context.LogService.warn("EventListener - Trying to register an event from a destroyed Object: " + type);
            return Function.noop;
          }
          var handlers = this._events.get(type);
          if (!handlers) {
            handlers = [];
            this._events.set(type, handlers);
          }
          var hdlr = handler;
          if (once) {
            hdlr = function(event, src, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) {
              this._off(type, hdlr);
              handler.call(this, event, src, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
            }.bind(this);
          }
          handlers.push(hdlr);
          return this._off.bind(this, type, hdlr);
        },

        /**
         * Checks if an event handler has been registered for the given type
         * @param {string} type - event type
         * @return {boolean} true if an event handler has been registered for the given type, false otherwise
         */
        hasEventListeners: function(type) {
          if (this._events) {
            var handlers = this._events.get(type);
            return !!handlers && handlers.length;
          }
          return false;
        },

        /**
         * Removes an event
         * @param {string} type event type to remove
         * @param {number} handler - event handler id
         * @private
         */
        _off: function(type, handler) {
          //// debug list unregistered listeners
          // if (window.reged[type] && window.reged[type][this.__name]) {
          //   window.reged[type][this.__name]--;
          //   if (!window.reged[type][this.__name]) {
          //     delete window.reged[type][this.__name];
          //   }
          //   if (!Object.keys(window.reged[type]).length) {
          //     delete window.reged[type];
          //
          //   }
          // } else {
          //   console.warn("could not _off event", type, this.__name);
          // }
          if (!this._destroyed) {
            var handlers = this._events.get(type);
            if (handlers) {
              var pos = handlers.indexOf(handler);
              if (pos === -1) {
                gbc.error("We are trying to destroy the wrong event listener ! Please check " + this.__name + " " + type +
                  " event listener bindings and definitions in the project and customizations");
              } else {
                handlers.splice(pos, 1);
                if (handlers.length === 0) {
                  this._events.delete(type);
                }
              }
            } else {
              gbc.error(this.__name + " " + type +
                " event listener has already been destroyed previously. We shouldn't try to remove it again. Please check references and calls of this event listener."
              );
            }
          }
        },

        /**
         * Create a handler of timeout
         * @param {function} callback - function to execute after given time
         * @param {number} time - time in ms before execution
         * @return {number} - handler
         * @protected
         */
        _registerTimeout: function(callback, time) {
          var timeout = {
            type: "timeout"
          };
          this._asyncHandlers.push(timeout);
          var id = window.setTimeout(function() {
            this._asyncHandlers.remove(timeout);
            callback();
          }.bind(this), time);
          timeout.id = id;
          return id;
        },

        /**
         * Create a handler for requestAnimationFrame
         * @param {function} callback - function to execute after the animation frame
         * @return {number} - handler
         * @protected
         */
        _registerAnimationFrame: function(callback) {
          var requestAnimationFrame = {
            type: "requestAnimationFrame"
          };
          this._asyncHandlers.push(requestAnimationFrame);
          var id = window.requestAnimationFrame(function() {
            this._asyncHandlers.remove(requestAnimationFrame);
            callback();
          }.bind(this));
          requestAnimationFrame.id = id;

          return id;
        },

        _clearTimeout: function(id) {
          if (this._asyncHandlers) {
            this._asyncHandlers.removeMatching(function(handler) {
              return handler.type === "timeout" && handler.id === id;
            });
          }
          window.clearTimeout(id);
        },

        _clearAnimationFrame: function(id) {
          if (this._asyncHandlers) {
            this._asyncHandlers.removeMatching(function(handler) {
              return handler.type === "requestAnimationFrame" && handler.id === id;
            });
          }
          window.cancelAnimationFrame(id);
        },

        /**
         * Clear all asynchroneous calls
         * @private
         */
        _clearAllAsyncCalls: function() {
          if (this._asyncHandlers && this._asyncHandlers.length > 0) {
            this._asyncHandlers.forEach(function(handler) {
              if (handler.type === "timeout") {
                window.clearTimeout(handler.id);
              }
              if (handler.type === "requestAnimationFrame") {
                window.cancelAnimationFrame(handler.id);
              }
            });
            this._asyncHandlers = [];
          }
        },
      };
    });
  });
;
"use strict";

modulum('DebugAuiController',
  function(context, cls) {

    /**
     * @class DebugAuiController
     * @memberOf classes
     */
    cls.DebugAuiController = context.oo.Class(function() {
      return /** @lends classes.DebugAuiController.prototype */ {
        __name: "DebugAuiController",
        $static: {
          defaultTreeViewItemTemplate: {
            color: "#000000",
            collapsed: false
          },
          highlightAui: 'highlightAui'
        },
        /** @type {classes.MonitorDebugTreeWidget} */
        _treeWidget: null,
        _nodeWidget: null,
        _layoutWidget: null,
        /** @type classes.NodeBase */
        _lastRootNode: null,
        auiSerial: null,
        _currentSelectedNode: null,

        /**
         * Initializer of the controller
         */
        constructor: function() {
          this._treeWidget = cls.WidgetFactory.createWidget("MonitorDebugTree", {
            appHash: gbc.systemAppId
          });
        },

        /**
         * Destroy the controller properly
         */
        destroy: function() {
          if (this._layoutWidget) {
            this._layoutWidget.destroy();
          }
          if (this._nodeWidget) {
            this._nodeWidget.destroy();
          }
          this._treeWidget.destroy();
          this._treeWidget = null;
        },

        /**
         * Get the Debug widget
         * @return {classes.MonitorDebugTreeWidget|null}
         */
        getWidget: function() {
          return this._treeWidget;
        },

        /**
         * Create the node info widget
         * @param {number} id of the node
         * @return {*|HTMLElement}
         */
        _createNodeInfo: function(id) {
          this._nodeWidget = cls.WidgetFactory.createWidget("MonitorDebugNodeInfo", {
            appHash: gbc.systemAppId
          });
          this._displayProperties(this._nodeWidget.getPropertiesContainer(), id);
          return this._nodeWidget.getElement();
        },

        /**
         * Create the layout info widget
         * @param id
         * @return {*|HTMLElement}
         * @private
         */
        _createLayoutInfo: function(id) {
          this._layoutWidget = cls.WidgetFactory.createWidget("MonitorDebugLayoutInfo", {
            appHash: gbc.systemAppId
          });
          this._displayLayout(this._layoutWidget, id);
          return this._layoutWidget.getElement();
        },

        /**
         * Create the sub tree item of a given node
         * @param node
         * @return {*|classes.WidgetBase}
         * @private
         */
        _createSub: function(node) {
          var widget = cls.WidgetFactory.createWidget("MonitorDebugTreeItem", {
            appHash: gbc.systemAppId
          });
          var label = node._tag;
          if (node.attribute("name")) {
            label += " (" + node.attribute("name") + ")";
          } else if (node.attribute("value")) {
            var value = node.attribute("value");
            label += " (" + (value.length > 16 ? value.substr(0, 16) + "\u2026" : value) + ")";
          }
          widget.setLabel(label);
          widget.setIdRef(node._id);
          widget.setIconColor((context.constants.debugInfo.auiTreeNodeInfo[node._tag] || cls.DebugAuiController
              .defaultTreeViewItemTemplate)
            .color);
          widget.setCollapsed((context.constants.debugInfo.auiTreeNodeInfo[node._tag] || cls.DebugAuiController
              .defaultTreeViewItemTemplate)
            .collapsed);
          widget.when(gbc.constants.widgetEvents.click, this.showNode.bind(this, node));
          return widget;
        },

        /**
         * Show the node in the tree and in the app
         * @param node
         * @param forceHighlight
         */
        showNode: function(node, forceHighlight) {
          forceHighlight = typeof forceHighlight !== "undefined" ? forceHighlight : false;
          this._currentSelectedNode = node;
          if (forceHighlight) {
            var event = document.createEvent('CustomEvent');
            event.initEvent(cls.DebugAuiController.highlightAui, true, false);
            event.auiNodeId = node._id;
            window.dispatchEvent(event);
          }
          this._treeWidget.setSelectedItem(node._id);
          this._treeWidget.setNodeDebugContent(this._createNodeInfo(node._id));
          this._treeWidget.setLayoutInfoContent(this._createLayoutInfo(node._id));
        },

        /**
         * Update the AUI debugger
         * @param {classes.NodeBase} node - node
         */
        refreshDebugAui: function(node) {
          context.styler.bufferize();
          if (node && node.getApplication()) {
            this.auiSerial = node.getApplication().getNode(0).auiSerial;
            this._lastRootNode = node;
            this._treeWidget.setVMFocusedWidget(node.attribute("focus"));

            var subs = function(w, children) {
              for (var i = 0; i < children.length; i++) {
                var widget = this._createSub(children[i]);
                w.addChildWidget(widget);
                subs(widget, children[i].getChildren());
              }
            }.bind(this);
            var rootWidget = this._createSub(node);
            subs(rootWidget, node.getChildren());

            this._treeWidget.empty();
            this._treeWidget.addChildWidget(rootWidget);
            context.styler.flush();
            if (this._currentSelectedNode) {
              this.showNode(this._currentSelectedNode, false);
            }
          } else {
            this._treeWidget.empty();
            if (this._nodeWidget) {
              this._nodeWidget.destroy();
            }
            if (this._layoutWidget) {
              this._layoutWidget.destroy();
            }
          }
        },

        /**
         * Display the layout informations of the widget
         * @param {classes.MonitorDebugLayoutInfoWidget} widget - widget concerned
         * @param {number} refId - IdRef of the linked node
         */
        _displayLayout: function(widget, refId) {
          var app = this._lastRootNode.getApplication();
          var omNode = app.getNode(refId);
          if (omNode) {
            var w = omNode.getController() && omNode.getController().getWidget();
            var layoutInfo = w && w.getLayoutInformation();
            if (layoutInfo) {
              widget.setLayoutEngineName(w.getLayoutEngine() && w.getLayoutEngine().__name);
              widget.setPosX(layoutInfo ? layoutInfo.getGridX() : "???");
              widget.setPosY(layoutInfo ? layoutInfo.getGridY() : "???");
              widget.setGridWidth(layoutInfo ? layoutInfo.getGridWidth() : "???");
              widget.setGridHeight(layoutInfo ? layoutInfo.getGridHeight() : "???");
              widget.setWidth(layoutInfo ? layoutInfo.getPreferred().getWidth() : "???");
              widget.setHeight(layoutInfo ? layoutInfo.getPreferred().getHeight() : "???");
              widget.setMeasuredHasSize(layoutInfo ? layoutInfo.getMeasured().hasSize() : "???");
              widget.setMeasuredWidth(layoutInfo ? layoutInfo.getMeasured().getWidth() : "???");
              widget.setMeasuredHeight(layoutInfo ? layoutInfo.getMeasured().getHeight() : "???");
              widget.setMinimalHasSize(layoutInfo ? layoutInfo.getMinimal().hasSize() : "???");
              widget.setMinimalWidth(layoutInfo ? layoutInfo.getMinimal().getWidth() : "???");
              widget.setMinimalHeight(layoutInfo ? layoutInfo.getMinimal().getHeight() : "???");
              widget.setMaximalHasSize(layoutInfo ? layoutInfo.getMaximal().hasSize() : "???");
              widget.setMaximalWidth(layoutInfo ? layoutInfo.getMaximal().getWidth() : "???");
              widget.setMaximalHeight(layoutInfo ? layoutInfo.getMaximal().getHeight() : "???");
              widget.setAvailableHasSize(layoutInfo ? layoutInfo.getAvailable().hasSize() : "???");
              widget.setAvailableWidth(layoutInfo ? layoutInfo.getAvailable().getWidth() : "???");
              widget.setAvailableHeight(layoutInfo ? layoutInfo.getAvailable().getHeight() : "???");
              widget.setAllocatedHasSize(layoutInfo ? layoutInfo.getAllocated().hasSize() : "???");
              widget.setAllocatedWidth(layoutInfo ? layoutInfo.getAllocated().getWidth() : "???");
              widget.setAllocatedHeight(layoutInfo ? layoutInfo.getAllocated().getHeight() : "???");
              widget.setPreferredHasSize(layoutInfo ? layoutInfo.getPreferred().hasSize() : "???");
              widget.setPreferredWidth(layoutInfo ? layoutInfo.getPreferred().getWidth() : "???");
              widget.setPreferredHeight(layoutInfo ? layoutInfo.getPreferred().getHeight() : "???");
              widget.setDecoratingHasSize(layoutInfo ? layoutInfo.getDecorating().hasSize() : "???");
              widget.setDecoratingWidth(layoutInfo ? layoutInfo.getDecorating().getWidth() : "???");
              widget.setDecoratingHeight(layoutInfo ? layoutInfo.getDecorating().getHeight() : "???");
              widget.setDecoratingoffsetHasSize(layoutInfo ? layoutInfo.getDecoratingOffset().hasSize() : "???");
              widget.setDecoratingoffsetWidth(layoutInfo ? layoutInfo.getDecoratingOffset().getWidth() : "???");
              widget.setDecoratingoffsetHeight(layoutInfo ? layoutInfo.getDecoratingOffset().getHeight() : "???");
              widget.setStretchX(layoutInfo ? layoutInfo.getStretched().getX(true) : "???");
              widget.setStretchY(layoutInfo ? layoutInfo.getStretched().getY(true) : "???");
              widget.setChildrenStretchX(layoutInfo ? layoutInfo.isChildrenXStretched() : "???");
              widget.setChildrenStretchY(layoutInfo ? layoutInfo.isChildrenYStretched() : "???");
              widget.setInvalidatedMeasure(layoutInfo ? w._layoutEngine._invalidatedMeasure : "???");
              widget.setInvalidatedAllocatedSpace(layoutInfo ? w._layoutEngine._invalidatedAllocatedSpace : "???");
            } else {
              widget.setNoLayout();
            }
          }
        },

        /**
         * Display the properties of the node
         * @param propertyContainer
         * @param refId
         * @private
         */
        _displayProperties: function(propertyContainer, refId) {
          var app = this._lastRootNode.getApplication();
          var omNode = app && app.getNode(refId);
          if (omNode) {
            var values = {};
            var categories = {};
            context.constants.nodeAttributes[omNode._tag].forEach(function(property) {
              values[property] = null;
              var cat = categories[context.constants.debugInfo.attributeCategory[property]] || [];
              cat.push(property);
              categories[context.constants.debugInfo.attributeCategory[property]] = cat.sort();
            });
            Object.keys(omNode._attributes).forEach(function(key) {
              values[key] = omNode._attributes[key];
            });

            var cats = document.createDocumentFragment();

            Object.keys(categories).sort().forEach(function(category) {
              var hidden = !!gbc.DebugService.auiview['.cat_' + category];
              var cat = document.createElement("tr"),
                catText = document.createElement("td");
              cat.setAttribute("onclick", "gbc.DebugService.catClicked('" + category + "');");
              catText.setAttribute("colspan", "5");
              catText.addClass("category");
              catText.textContent = category;
              cat.appendChild(catText);
              cats.appendChild(cat);

              var pties = categories[category],
                len = pties.length,
                i = 0;
              for (; i < len; i++) {
                var property = pties[i],
                  defaultValue = cls.NodeHelper.getAttributeDefaultValue(omNode.tag, property);
                var pty = document.createElement("tr"),
                  info = document.createElement("td");
                pty.addClasses("property", "cat_" + category);
                if (!!omNode._attributesSetByVM[property]) {
                  pty.addClass("changed");
                }
                if (hidden) {
                  pty.addClass("hidden");
                }
                info.textContent = "&nbsp;";
                pty.appendChild(info);
                info = document.createElement("td");
                info.textContent = property;
                pty.appendChild(info);
                info = document.createElement("td");
                info.textContent = (values[property] === null) ? defaultValue : values[property];
                pty.appendChild(info);
                info = document.createElement("td");
                info.textContent = property === "value" ? values[property] : ("" + values[property]).replace(new RegExp("\\s",
                  "g"), "_");
                pty.appendChild(info);
                info = document.createElement("td");
                info.textContent = defaultValue;
                pty.appendChild(info);

                cats.appendChild(pty);
              }
            });

            propertyContainer.empty();
            propertyContainer.appendChild(cats);
          }
        }
      };
    });
  });
;
"use strict";

modulum('DebugService', ['InitService'],
  function(context, cls) {

    /**
     * Debug Service
     * @namespace gbc.DebugService
     * @gbcService
     */
    context.DebugService = context.oo.StaticClass(function() {
      return /** @lends gbc.DebugService */ {
        __name: "DebugService",
        /** @type Window */
        _monitorWindow: null,
        /**
         * @type classes.MonitorWidget
         */
        _widget: null,
        /**
         * @type classes.DebugAuiController
         */
        _debugAuiController: null,
        auiview: null,
        _isDebugWindow: false,
        /**
         * @type classes.EventListener
         */
        _eventListener: null,

        _debugUis: null,
        _active: false,
        _disabled: false,

        _highlightElement: null,
        _highlightTimer: null,
        _nodeToShow: null,
        _persistantDebugGrid: false,

        _orderManagedEvent: null,

        _canCounterServer: false,
        /**
         * Check if the current page is a debug monitor
         * @return {boolean} - true if it's the debug monitor, false otherwise
         * @private
         */
        _isMonitor: function() {
          return !!context.UrlService.currentUrl().getQueryStringObject().monitor;
        },

        /**
         * Init service method. should be called only once.
         */
        init: function() {
          this._debugUis = [];
          this._eventListener = new cls.EventListener();
          if (this._isMonitor()) {
            this.auiview = {};
            this._isDebugWindow = true;
            this._widget = cls.WidgetFactory.createWidget("Monitor", {
              appHash: gbc.systemAppId
            });
            document.body.appendChild(this._widget.getElement());
            this._debugAuiController = new cls.DebugAuiController();
            this._widget.addChildWidget(this._debugAuiController.getWidget());

            window.setTimeout(function() {
              var session = window.opener && window.opener.gbc && window.opener.gbc.SessionService.getCurrent();
              var app = session && session.getCurrentApplication();
              if (app) {
                this._debugAuiController.refreshDebugAui(app.getNode(0));
                window.opener.gbc.DebugService.attach(window);

                // Refresh debug window at each order
                this._onAppOrdersManaged(app, function() {
                  this._debugAuiController.refreshDebugAui(app.getNode(0));
                }.bind(this));
              }
            }.bind(this), 100);
          } else {
            if (context.__wrapper.isNative()) {
              context.__wrapper.on(context.__wrapper.events.DEBUGNODE, function(event, src, nodeId) {
                this.onHighlightAuiNode({
                  auiNodeId: nodeId
                });
              }.bind(this));
            }
          }
          this.whenActivationChanged(function(event, src, active) {
            if (active) {
              document.body.addClass("gbc_DebugMode");
              if (window.isURLParameterEnabled(window.location.search, "debugcounter")) {
                this.tryCounterServer();
              }
            }
          }.bind(this));
        },

        /**
         * Handler called once application has switched
         */
        onApplicationSwitch: function() {
          if (this._monitorWindow) {
            var debugAuiController = this._monitorWindow.gbc.DebugService._debugAuiController;
            var app = gbc.SessionService.getCurrent().getCurrentApplication();

            // Refresh debug window at each order
            this._onAppOrdersManaged(app, function() {
              debugAuiController.refreshDebugAui(app.getNode(0));
            }.bind(this));

            debugAuiController.refreshDebugAui(app.getNode(0));
            this.attach(this._monitorWindow);
          }
          this.hideHighlightAui();

        },

        /**
         * @return {boolean}
         */
        isMonitorWindow: function() {
          return this._isDebugWindow;
        },

        /**
         * Destroy the service
         */
        destroy: function() {
          if (this._highlightTimer) {
            window.clearTimeout(this._highlightTimer);
            this._highlightTimer = null;
          }
          if (this._monitorWindow) {
            this._monitorWindow.close();
          }
          if (this._orderManagedEvent) {
            this._orderManagedEvent(); //unbind events
          }
        },

        /**
         * Show the Debug window with the AUI tree
         * @param {Number} [auiId] the aimed node id
         */
        show: function(auiId) {
          if (!this._monitorWindow) {
            if (context.__wrapper.isNative()) {
              context.__wrapper.showDebugger(Object.isNumber(auiId) ? auiId : -1);
            } else {
              var url = context.UrlService.currentUrl();
              window.open(url.removeQueryString("app").addQueryString("monitor", true).toString());
            }
          } else {
            var uiNode = context.SessionService.getCurrent().getCurrentApplication().getNode(0);
            var debugAuiController = this._monitorWindow.gbc.DebugService._debugAuiController;
            if (uiNode.auiSerial !== debugAuiController.auiSerial) {
              debugAuiController.refreshDebugAui(uiNode);
            }
            this._monitorWindow.focus();
          }
        },

        /**
         *
         * @param monitorWindow
         */
        attach: function(monitorWindow) {
          if (this._monitorWindow !== monitorWindow) {
            this._monitorWindow = monitorWindow;
            this._monitorWindow.document.title = "GBC Debug tools";
            this._monitorWindow.onunload = function() {
              this._monitorWindow = null;
            }.bind(this);
            //Persistant Debug Grid
            this._monitorWindow.document.querySelector("#debugGrid").on("change.persistantDebugGrid", function(event) {
              gbc.DebugService.setPersistantDebugGrid(event.target.checked);
            }.bind(this));
            if (this._nodeToShow !== null) {
              this._monitorWindow.gbc.DebugService._debugAuiController.showNode(this._nodeToShow);
              this._nodeToShow = null;
            } else {
              this._monitorWindow.gbc.DebugService._debugAuiController.showNode(window.gbcNode(0));
            }
            this._monitorWindow.addEventListener(context.classes.DebugAuiController.highlightAui, this.onHighlightAuiNode.bind(this));
          }
        },

        /**
         * Enable/disable the persistant Debug grid
         * @param status {boolean} - true to enable, false otherwise
         */
        setPersistantDebugGrid: function(status) {
          this._persistantDebugGrid = status;
          if (!status) {
            document.body.removeChild(this._highlightElement);
            this._highlightTimer = null;
            this._highlightElement = null;
          }
        },

        /**
         *
         * @param widget
         */
        registerDebugUi: function(widget) {
          if (this._debugUis.indexOf(widget) < 0) {
            this._debugUis.push(widget);
          }
          widget.activate(this._active);
        },

        /**
         *
         * @param widget
         */
        unregisterDebugUi: function(widget) {
          if (this._debugUis.indexOf(widget) >= 0) {
            this._debugUis.remove(widget);
          }
        },

        /**
         *
         * @param hook
         * @return {*|HandleRegistration}
         */
        whenActivationChanged: function(hook) {
          return this._eventListener.when("debugActivationChanged", hook);
        },

        /**
         * This override the disabled mode
         */
        enable: function() {
          this._disabled = false;
        },

        /**
         *
         */
        disable: function() {
          this._disabled = true;
        },

        /**
         * Activate the Debug service
         * @param {?Boolean} force - true to override the url parameters
         */
        activate: function(force) {
          if (force) {
            this.enable();
          }
          if (!this._active && !this._disabled) {
            this._active = true;
            for (var i = 0; i < this._debugUis.length; i++) {
              this._debugUis[i].activate(this._active);
            }
            context.classes.DebugHelper.activateDebugHelpers();
            this._registerDebugContextMenu();
            document.body.addClass("gbc_DebugMode");
            this._eventListener.emit("debugActivationChanged", true);
          }
        },

        /**
         *
         * @private
         */
        _registerDebugContextMenu: function() {
          if (!this._isMonitor() && !this.__debugContextMenuRegistered) {
            this.__debugContextMenuRegistered = true;
            window.addEventListener('contextmenu', function(event) {
              if (window.navigator.platform.indexOf('Mac') === 0 ? event.metaKey : event.ctrlKey) {
                var auiNode = window.gbcNode(event.target);
                if (auiNode) {
                  this.show(auiNode.getId());
                  if (this._monitorWindow) {
                    var uiNode = auiNode.getApplication().getNode(0);
                    var debugAuiController = this._monitorWindow.gbc.DebugService._debugAuiController;
                    if (uiNode.auiSerial !== debugAuiController.auiSerial) {
                      debugAuiController.refreshDebugAui(uiNode);
                    }
                    this._monitorWindow.gbc.DebugService._debugAuiController.showNode(auiNode);
                  } else {
                    this._nodeToShow = auiNode;
                  }
                  event.preventCancelableDefault();
                }
              }
            }.bind(this));
          }
        },

        /**
         * Handler called once received orders from the VM
         * @param app - vm application
         * @param callback - hook called once orders are received
         * @private
         */
        _onAppOrdersManaged: function(app, callback) {
          if (this._orderManagedEvent) {
            this._orderManagedEvent();
          }
          this._orderManagedEvent = app.dvm.onOrdersManaged(function() {
            callback();
          }.bind(this));
        },

        /**
         *
         * @return {boolean}
         */
        isActive: function() {
          return this._active;
        },

        /**
         * Hide the highlight layer
         */
        hideHighlightAui: function() {
          if (this._highlightElement) {
            this._highlightElement.addClass("hidden");
          }
        },

        /**
         * Handler called when an element is clicked in AUI tree
         * @param event
         */
        onHighlightAuiNode: function(event) {
          var currentApp = gbc.SessionService.getCurrent().getCurrentApplication();
          if (currentApp) {

            var node = currentApp.getNode(event.auiNodeId);
            if (node.getTag() === 'TreeItem') {
              var table = node;
              while (table.getTag() !== 'Table') {
                table = table.getParentNode();
              }
              var valueIndex = node.attribute('row');
              if (valueIndex === -1) {
                return;
              }
              node = table.getFirstChild('TableColumn').getFirstChild('ValueList').getChildren()[valueIndex];
            }
            var widget = null;
            while (!widget) {
              var ctrl = node.getController();
              if (ctrl) {
                widget = ctrl.getWidget();
              }
              node = node.getParentNode();
            }

            if (this._highlightElement) {
              window.clearTimeout(this._highlightTimer);
              document.body.removeChild(this._highlightElement);
              this._highlightElement = null;
            }

            if (widget._layoutEngine) {
              if (widget._layoutEngine instanceof cls.GridLayoutEngine) {
                this._highlightElement = this.createGridHighlightElement(widget);
              } else if (widget._layoutEngine instanceof cls.DBoxLayoutEngine) {
                this._highlightElement = this.createDBoxHighlightElement(widget);
              }
            }
            if (!this._highlightElement) {
              this._highlightElement = this.createDefaultHighlightElement(widget);
            }

            document.body.appendChild(this._highlightElement);
            if (!this._persistantDebugGrid) {
              this._highlightTimer = window.setTimeout(function() {
                document.body.removeChild(this._highlightElement);
                this._highlightTimer = null;
                this._highlightElement = null;
              }.bind(this), 2000);
            }
          }
        },

        /**
         * Will create an element used to highlight a widget
         * @param widget
         * @return {HTMLElement}
         */
        createDefaultHighlightElement: function(widget) {
          var widgetRect = widget.getElement().getBoundingClientRect();
          var element = document.createElement("div");
          element.style.position = 'fixed';
          element.style.backgroundColor = "rgba(255,0,0,0.5)";
          element.style.border = "1px solid red";
          element.style.zIndex = 999999;
          element.style.top = widgetRect.top + "px";
          element.style.left = widgetRect.left + "px";
          element.style.width = widgetRect.width + "px";
          element.style.height = widgetRect.height + "px";

          document.body.off("keydown.debugLayer");
          document.body.off("keyup.debugLayer");
          document.body.on("keydown.debugLayer", function(event) {
            if (event.shiftKey) {
              element.style.zIndex = -5000;
            }
          });
          document.body.on("keyup.debugLayer", function(event) {
            element.style.zIndex = 999999;
          });
          return element;
        },

        /**
         * Will create an element used to highlight a grid widget
         * @param widget
         * @return {HTMLElement}
         */
        createGridHighlightElement: function(widget) {
          var widgetRect = widget.getElement().getBoundingClientRect();
          var element = this.createDefaultHighlightElement(widget);
          element.style.backgroundColor = "";

          var decorating = {
            offsetLeft: widget.getLayoutInformation().getDecoratingOffset().getWidth(true),
            offsetTop: widget.getLayoutInformation().getDecoratingOffset().getHeight(true),
            width: widget.getLayoutInformation().getDecorating().getWidth(true),
            height: widget.getLayoutInformation().getDecorating().getHeight(true)
          };
          var dimensionElementsList = [
            widget._layoutEngine._xspace.dimensionManager.dimensionElements,
            widget._layoutEngine._yspace.dimensionManager.dimensionElements
          ];
          for (var i = 0; i < dimensionElementsList.length; ++i) {
            var dimensionElements = dimensionElementsList[i];
            var total = 0;
            for (var j = 0; j < dimensionElements.length; ++j) {
              var bandSize = dimensionElements[j].getSize(true, true);
              var band = document.createElement("div");
              band.style.position = 'absolute';
              band.style.backgroundColor = j % 2 ? "rgba(255,100,0,0.3)" : "rgba(255,0,0,0.3)";
              if (i === 0) {
                band.style.top = 0 + decorating.offsetTop + "px";
                band.style.left = total + decorating.offsetLeft + "px";
                band.style.width = bandSize + "px";
                band.style.height = widgetRect.height - decorating.height + "px";
              } else {
                band.style.top = total + decorating.offsetTop + "px";
                band.style.left = 0 + decorating.offsetLeft + "px";
                band.style.width = widgetRect.width - decorating.width + "px";
                band.style.height = bandSize + "px";
              }
              total += bandSize;
              element.appendChild(band);
            }
          }

          var children = widget.getChildren();
          for (i = 0; i < children.length; ++i) {
            var childWidgetRect = children[i].getElement().getBoundingClientRect();
            var childRectElement = document.createElement("div");
            childRectElement.style.position = 'fixed';
            childRectElement.style.border = "1px solid red";
            childRectElement.style.top = childWidgetRect.top + "px";
            childRectElement.style.left = childWidgetRect.left + "px";
            childRectElement.style.width = childWidgetRect.width + "px";
            childRectElement.style.height = childWidgetRect.height + "px";
            element.appendChild(childRectElement);
          }
          return element;
        },

        /**
         * Will create an element used to highlight a DBox widget
         * @param widget
         * @return {HTMLElement}
         */
        createDBoxHighlightElement: function(widget) {
          var widgetRect = widget.getElement().getBoundingClientRect();
          var element = this.createDefaultHighlightElement(widget);

          element.style.backgroundColor = "";

          var children = widget.getChildren();
          var total = 0;
          for (var i = 0; i < children.length; ++i) {
            var bandSize = widget._layoutEngine._getAllocatedSize(children[i]);
            var band = document.createElement("div");
            band.style.position = 'absolute';
            band.style.backgroundColor = i % 2 ? "rgba(255,100,0,0.5)" : "rgba(255,0,0,0.5)";
            if (widget._layoutEngine instanceof cls.HBoxLayoutEngine) {
              band.style.top = 0;
              band.style.left = total + "px";
              band.style.width = bandSize + "px";
              band.style.height = widgetRect.height + "px";
            } else {
              band.style.top = total + "px";
              band.style.left = 0;
              band.style.width = widgetRect.width + "px";
              band.style.height = bandSize + "px";
            }
            total += bandSize;
            element.appendChild(band);
          }

          return element;
        },

        /**
         *
         * @param catName
         * @param noToggle
         */
        catClicked: function(catName, noToggle) {
          if (!noToggle) {
            this.auiview['.cat_' + catName] = !this.auiview['.cat_' + catName];
          }
          var elements = document.body.getElementsByClassName('cat_' + catName),
            i = 0,
            len = elements.length;
          for (; i < len; i++) {
            elements[i].toggleClass("hidden", !!this.auiview['.cat_' + catName]);
          }
        },

        tryCounterServer: function() {
          try {
            fetch("http://localhost:9999/")
              .then(function() {
                this._canCounterServer = true;
              }.bind(this))
              .catch(function() {
                this._canCounterServer = false;
              }.bind(this));

          } catch (e) {
            this._canCounterServer = false;
          }
        },

        count: function(name) {
          if (this._canCounterServer) {
            try {
              fetch("http://localhost:9999/var/increment/" + name).catch();
            } catch (e) {
              //
            }
          }
        }
      };
    });
    context.InitService.register(context.DebugService);
  });
;
"use strict";

modulum('DndService', ['InitService'],
  function(context, cls) {

    /**
     * @namespace gbc.DndService
     */
    context.DndService = context.oo.StaticClass( /** @lends gbc.DndService */ {
      __name: "DndService",

      tableStartDragNode: null,
      tableCurrentDragNode: null,
      valueStartDragNode: null,
      dragDropInfoNode: null,
      dragOverValueNode: null,
      firstDragEnterSent: false,
      dragOverTreeItemNode: null,
      dndAccepted: false,

      init: function() {},

      /**
       * DragStart handler
       * @param tableNode
       * @param valueNode
       * @param evt
       */
      onDragStart: function(tableNode, valueNode, evt) {

        this.firstDragEnterSent = false;
        this.tableStartDragNode = tableNode;
        this.valueStartDragNode = valueNode;

        var events = [];

        // Send currentRow to VM
        var localStartDragRowIndex = valueNode.getParentNode().getChildren().indexOf(valueNode);
        var startDragRowIndex = tableNode.attribute("offset") + localStartDragRowIndex;
        events.push(new cls.VMConfigureEvent(tableNode.getId(), {
          currentRow: startDragRowIndex
        }));

        // Send row selection extension if mrs is enabled
        if (tableNode.attribute("multiRowSelection") === 1) {
          var startDragRowIndexIsSelected = (tableNode.getChildren("RowInfoList")[0].getChildren()[localStartDragRowIndex].attribute(
            "selected") === 1);
          if (startDragRowIndexIsSelected === false) {
            events.push(new cls.VMRowSelectionEvent(tableNode.getId(), {
              startIndex: startDragRowIndex,
              endIndex: startDragRowIndex,
              selectionMode: "set"
            }));
          }
        }

        // Send dragStart event to VM
        events.push(new cls.VMDragDropEvent(this.tableStartDragNode.getId(), {
          dndEventType: "dragStart"
        }));
        this.tableStartDragNode.getApplication().typeahead.event(events, this.tableStartDragNode);
      },

      /**
       * DragLeave handler
       * @param tableNode
       * @param valueNode
       * @param evt
       */
      onDragLeave: function(tableNode, valueNode, evt) {
        // no need all is done in onDragOver function
      },

      /**
       * DragEnter handler
       * @param tableNode
       * @param valueNode
       * @param evt
       */
      onDragEnter: function(tableNode, valueNode, evt) {
        // no need all is done in onDragOver function
      },

      /**
       * DragOver handler
       * @param tableNode
       * @param valueNode
       * @param evt
       */
      onDragOver: function(tableNode, valueNode, evt) {

        if (!this.dragDropInfoNode) {
          return;
        }

        this._showHideDropIndicator(this.dragOverValueNode, false);

        if (this.dragDropInfoNode.attribute("dndAccepted") === 1 && this.firstDragEnterSent) {
          evt.preventCancelableDefault();
        }

        var valueListNode = valueNode.getParentNode();
        var tableColumnNode = valueListNode.getParentNode();
        var indexValue = valueListNode.getChildren().indexOf(valueNode);
        var isTreeView = tableColumnNode.getParentNode().getController().getWidget().isTreeView();
        var treeItemParentNode = null;
        if (isTreeView) {
          var mousePositionTop = evt.offsetY;

          treeItemParentNode = tableNode.getChildren("TreeInfo")[0].findNodeWithAttribute('TreeItem', 'row', indexValue);
          if (!!treeItemParentNode && mousePositionTop < 6) { // if mouse position is between two tree items
            treeItemParentNode = treeItemParentNode.getAncestor("TreeItem");
          }
        }

        this._showHideDropIndicator(valueNode, true, treeItemParentNode);

        if (this.dragOverValueNode !== valueNode || this.dragOverTreeItemNode !== treeItemParentNode) {

          var event = null;
          if (this.tableCurrentDragNode !== tableNode) {

            if (this.tableCurrentDragNode !== null) {
              // Send dragLeave event to VM
              event = new cls.VMDragDropEvent(this.tableCurrentDragNode.getId(), {
                dndEventType: "dragLeave"
              });
              this.tableStartDragNode.getApplication().typeahead.event(event, this.tableStartDragNode);
            }

            this.tableCurrentDragNode = tableNode;

            event = new cls.VMDragDropEvent(tableNode.getId(), {
              dndEventType: "dragEnter",
              dndMimeTypes: this.dragDropInfoNode.attribute("dndMimeTypes"),
              dndOperation: "move"
            });
            tableNode.getApplication().typeahead.event(event, tableNode);
            this.firstDragEnterSent = true;
          } else {

            this.dragOverValueNode = valueNode;
            this.dragOverTreeItemNode = treeItemParentNode;

            if (this.firstDragEnterSent === false) {
              return; // don't send drag over if drag enter has not been sent before
            }

            if (valueNode === this.valueStartDragNode) {
              return; // don't send drag over event to the node which start the drag
            }

            var tableSize = tableNode.attribute("size");
            if (indexValue >= tableSize && this.dragDropInfoNode.attribute("dndFeedback") === "select") {
              return; // don't send drag over event to a node > tableSize if feedback is select
            }

            var dndOperation = this.dragDropInfoNode.attribute("dndOperation");
            dndOperation = dndOperation === "" ? "move" : dndOperation;

            if (isTreeView === false) {
              event = new cls.VMDragDropEvent(valueNode.getId(), {
                dndEventType: "dragOver",
                dndOperation: dndOperation
              });
            } else {
              event = new cls.VMDragDropEvent(valueNode.getId(), {
                dndEventType: "dragOver",
                dndOperation: dndOperation,
                dndParentIdRef: !!treeItemParentNode ? treeItemParentNode.getId() : -1
              });
            }
            this.tableStartDragNode.getApplication().typeahead.event(event, valueNode);
          }
        }

      },

      /**
       * DragEnd handler
       */
      onDragEnd: function() {
        var dndOperation = "";
        if (this.dragDropInfoNode) {
          dndOperation = this.dragDropInfoNode.attribute("dndOperation");
        }
        dndOperation = dndOperation === "" ? "move" : dndOperation;

        // Send dragFinished event to VM
        var event = new cls.VMDragDropEvent(this.tableStartDragNode.getId(), {
          dndEventType: "dragFinished",
          dndOperation: dndOperation
        });
        this.tableStartDragNode.getApplication().typeahead.event(event, this.tableStartDragNode);

        this._showHideDropIndicator(this.dragOverValueNode, false);

        this.tableCurrentDragNode = null;
        this.tableStartDragNode = null;
        this.valueStartDragNode = null;
        this.dragOverValueNode = null;
        this.firstDragEnterSent = false;
        this.dragOverTreeItemNode = null;
      },

      /**
       * Drop handler
       * @param valueNode
       */
      onDrop: function(valueNode) {

        if (!this.dragDropInfoNode) {
          return;
        }

        this._showHideDropIndicator(valueNode, false);

        // Send drop event to VM
        var event = new cls.VMDragDropEvent(valueNode.getId(), {
          dndEventType: "drop",
          dndBuffer: this.dragDropInfoNode.attribute("dndBuffer")

        });
        valueNode.getApplication().typeahead.event(event, valueNode);
      },

      /**
       * Show or hide drop indicator
       * @param {classes.NodeBase} valueNode valueNode to find the row
       * @param {boolean} show if true show indicator, else hide it
       * @param {classes.NodeBase} [overTreeItem] draw over treeitem indicator
       * @private
       */
      _showHideDropIndicator: function(valueNode, show, overTreeItem) {
        if (!valueNode) {
          return;
        }

        var valueListNode = valueNode.getParentNode();
        var tableNode = valueListNode.getParentNode().getParentNode();
        var indexInValueList = valueListNode.getChildren().indexOf(valueNode);
        var parentTreeValueRow = -1;
        if (!!overTreeItem) {
          parentTreeValueRow = overTreeItem.attribute("row");
        }

        // Draw line to visualize where the drop will be done
        var columns = tableNode.getChildren("TableColumn");
        for (var i = 0; i < columns.length; i++) {
          var c = columns[i];
          var valueList = c.getChildren()[1];
          if (!!valueList) {
            var w = valueList.getChildren()[indexInValueList].getController().getWidget();
            if (!!w) {
              var element = w.getParentWidget().getElement();

              element
                .removeClass("dropIndicatorInsert")
                .removeClass("dropIndicatorSelect")
                .removeClass("dropIndicatorInsertAfter");

              if (show && this.dndAccepted && this.firstDragEnterSent) {
                var dndFeedback = this.dragDropInfoNode.attribute("dndFeedback");
                if (!!overTreeItem && indexInValueList === parentTreeValueRow) {
                  element.addClass("dropIndicatorSelect");
                } else if (dndFeedback === "insert") {
                  element.addClass("dropIndicatorInsert");
                } else if (dndFeedback === "select") {
                  element.addClass("dropIndicatorSelect");
                } else if (dndFeedback === "insert_after") {
                  element.addClass("dropIndicatorInsertAfter");
                }
              }
            }
          }
        }
      }

    });
    context.InitService.register(context.DndService);
  });
;
"use strict";

modulum('FrontCallService.modules.localStorage', ['FrontCallService'],
  function(context, cls) {

    /**
     * Local storage module to store variables into browser's local storage
     * @instance localStorage
     * @memberOf gbc.FrontCallService.modules
     */
    context.FrontCallService.modules.localStorage = /** @lends gbc.FrontCallService.modules.localStorage */ {

      /**
       * Set an item in browser's local storage
       * @param {string} key of the item
       * @param {*} value of the item
       * @returns {Array} empty
       */
      setItem: function(key, value) {
        if (!key) {
          this.parametersError();
          return [];
        }
        try {
          var content = context.LocalSettingsService.read('userLocalStorage');
          if (!content) {
            content = {};
          }
          content[key] = value;
          context.LocalSettingsService.write('userLocalStorage', content);
        } catch (ex) {
          this.runtimeError('Could not setItem in localStorage. Maximum size may be reached.');
        }
        return [];
      },

      /**
       * Get an item from browser's local storage
       * @param {string} key identifier of the item to get
       * @returns {*}
       */
      getItem: function(key) {
        if (!key) {
          this.parametersError();
          return [];
        }
        var content = context.LocalSettingsService.read('userLocalStorage');
        return (content && content[key]) ? [content[key]] : [];
      },

      /**
       * Remove an item in browser's local storage
       * @param {string} key identifier of the item to remove
       * @returns {Array} empty
       */
      removeItem: function(key) {
        if (!key) {
          this.parametersError();
          return [];
        }
        try {
          var content = context.LocalSettingsService.read('userLocalStorage');
          delete content[key];
          context.LocalSettingsService.write('userLocalStorage', content);
        } catch (ex) {
          this.runtimeError('Could not removeItem in localStorage. Maximum size may be reached.');
        }
        return [];
      },

      /**
       * Get all the items keys in browser's local storage
       * @returns {string[]}
       */
      keys: function() {
        var content = context.LocalSettingsService.read('userLocalStorage');
        return content ? [JSON.stringify(Object.keys(content))] : [];
      },

      /**
       * Empty the browser's local storage
       * @returns {Array} empty
       */
      clear: function() {
        try {
          context.LocalSettingsService.write('userLocalStorage', {});
        } catch (ex) {
          this.runtimeError('Could not clear in localStorage. Maximum size may be reached.');
        }
        return [];
      }
    };
  }
);
;
"use strict";

modulum('FrontCallService.modules.mobile', ['FrontCallService'],
  function(context, cls) {

    /**
     * Mobile module to store variables into browser's sessions
     * @instance mobile
     * @memberOf gbc.FrontCallService.modules
     */
    context.FrontCallService.modules.mobile = /** @lends gbc.FrontCallService.modules.mobile */ {

      /**
       * Get Browser's Geolocation
       * @returns {string[]}
       */
      getGeolocation: function() {
        // See : http://dev.w3.org/geo/api/spec-source.html
        var statusOK = "ok";
        var statusKO = "nok";

        if (navigator.geolocation) {
          navigator.geolocation.getCurrentPosition(
            function(position) {
              this.setReturnValues([statusOK, position.coords.latitude, position.coords.longitude]);
            }.bind(this),
            function(error) {
              switch (error.code) {
                case error.PERMISSION_DENIED:
                  this.setReturnValues([statusKO, 'PERMISSION_DENIED']);
                  return;
                case error.POSITION_UNAVAILABLE:
                  this.setReturnValues([statusKO, 'POSITION_UNAVAILABLE']);
                  return;
                case error.TIMEOUT:
                  this.setReturnValues([statusKO, 'TIMEOUT']);
                  return;
                default:
                  this.setReturnValues([statusKO, 'UNKNOWN_ERROR']);
                  return;
              }
            }.bind(this)
          );
        } else {
          return [statusKO, 'GEOLOC_UNAVAILABLE'];
        }
      }
    };
  }
);
;
"use strict";

modulum('FrontCallService.modules.qa', ['FrontCallService'],
  function(context, cls) {
    context.FrontCallService.modules.qa = {

      startqa: function() {
        gbc.qaMode = true;
        return [''];
      },
      getattribute: function(id, name) {
        var element = document.querySelector('[data-aui-id="' + JSON.parse(id).id + '"]');

        if (element) {
          switch (name) {
            case "width":
              return [element.getBoundingClientRect().width];
            case "height":
              return [element.getBoundingClientRect().height];
            case "text":
              var textHolder = element.querySelector(".gbc-label-text-container") ||
                element.querySelector(".gbc_dataContentPlaceholder") || element;
              return [(textHolder.value || textHolder.textContent).trim()];
            case "image":
              var img = element.querySelector("img");
              var cssBg = window.getComputedStyle(element).backgroundImage;
              var urlRegex = /url\("(.*)"\)/.exec(cssBg);
              var url = (urlRegex && urlRegex.length >= 1) ? urlRegex[1] : "";
              return [(img && img.attributes.src.value) ? img.attributes.src.value : url];
            default:
              console.log("getAttribute not supported property:", name);
          }
        }
        console.log("getAttribute", id, name);

        return [''];
      }
    };
  }
);
;
"use strict";

modulum('FrontCallService.modules.session', ['FrontCallService'],
  function(context, cls) {
    /**
     * Session module to store variables into browser's sessions
     * @instance session
     * @memberOf gbc.FrontCallService.modules
     */
    context.FrontCallService.modules.session = /** @lends gbc.FrontCallService.modules.session */ {
      _name: 'session_gwcJS',

      /**
       * Set a variable into browser's sessions
       * @param {string} key identifier of the variable to store
       * @param {*} value of the variable to store
       * @returns {Array}
       */
      setvar: function(key, value) {
        if (!key) {
          this.parametersError();
          return [];
        }
        var sessionObj = context.LocalSettingsService.read(context.FrontCallService.modules.session._name) || {};
        sessionObj[key] = value;
        try {
          context.LocalSettingsService.write(context.FrontCallService.modules.session._name, sessionObj);
        } catch (ex) {
          this.runtimeError('Could not write in localStorage. Maximum size may be reached.');
        }
        return [];
      },

      /**
       * Get a variable from browser's sessions
       * @param {string} key identifier of the item to get
       * @returns {*}
       */
      getvar: function(key) {
        if (!key) {
          this.parametersError();
          return [];
        }
        var sessionObj = context.LocalSettingsService.read(context.FrontCallService.modules.session._name) || {};
        var value = sessionObj[key];
        if (value) {
          return [value];
        } else {
          return [];
        }
      },
    };
  }
);
;
'use strict';

modulum('FrontCallService.modules.standard', ['FrontCallService'],
  function(context, cls) {
    context.TemplateService.registerRawTemplate('FrontCallStandardPlaySound', '<audio></audio>');

    /**
     * Standard module of Frontcall Service
     * @instance standard
     * @memberOf gbc.FrontCallService.modules
     */
    context.FrontCallService.modules.standard = /** @lends gbc.FrontCallService.modules.standard */ {

      /**
       * Adds to the content of the clipboard
       * @unsupported
       * @param text to add to the clipboard
       * @returns {?boolean[]}
       */
      cbAdd: function(text) {
        if (text === undefined) {
          this.parametersError();
          return undefined;
        }
        return [false];
      },

      /**
       * Clears the content of the clipboard.
       * @unsupported
       * @returns {boolean[]}
       */
      cbClear: function() {
        return [false];
      },

      /**
       * Gets the content of the clipboard.
       * @unsupported
       * @returns {string[]}
       */
      cbGet: function() {
        return [''];
      },

      /**
       * Pastes the content of the clipboard to the current field.
       * @unsupported
       * @returns {boolean[]}
       */
      cbPaste: function() {
        return [false];
      },

      /**
       * Set the content of the clipboard.
       * @unsupported
       * @param text
       * @returns {?boolean[]}
       */
      cbSet: function(text) {
        if (text === undefined) {
          this.parametersError();
          return undefined;
        }

        var focusedNode = this.getAnchorNode().getApplication().getFocusedVMNode();
        var focusElem = null;
        if (focusedNode && focusedNode.getController() && focusedNode.getController().getWidget()) {
          focusElem = focusedNode.getController().getWidget().getElement();
        }

        cls.ClipboardHelper.copyTo(text, focusElem, function(success) {
          this.setReturnValues([success]);
        }.bind(this));
      },

      /**
       * Executes a command on the front-end platform, with or without waiting.
       * @unsupported
       * @param command
       * @param wait
       * @returns {boolean[]}
       */
      execute: function(command, wait) {
        return [false];
      },

      /**
       * Queries general front-end properties.
       * @param {string} kind of module to call
       * @param data
       * @returns {*}
       */
      feinfo: function(kind, data) {
        if (kind === undefined) {
          this.parametersError();
          return;
        }
        if (kind.toLowerCase) {
          switch (kind.toLowerCase()) {
            case 'browsername':
              if (window.browserInfo.isFirefox) {
                return ['Firefox'];
              } else if (window.browserInfo.isChrome) {
                return ['Chrome'];
              } else if (window.browserInfo.isIE) {
                return ['Internet Explorer'];
              } else if (window.browserInfo.isEdge) {
                return ['Edge'];
              } else if (window.browserInfo.isOpera) {
                return ['Opera'];
              } else if (window.browserInfo.isSafari) {
                return ['Safari'];
              }
              return ['Unknown'];
              // The code identifying the type of front-end component.
            case 'fename':
              return ['GBC'];
              // Returns "1" if the front-end runs in Active X mode (GDC specific). Unsupported in GBC
            case 'isactivex':
              return [false];
              // Number of screens available on the front-end platform. Always return 1 in GBC
            case 'numscreens':
              return [1];
              // The operating system type where the front-end is running.
            case 'ostype':
              if (navigator.appVersion.indexOf('Win') !== -1) {
                return ['WINDOWS'];
              } else if (navigator.appVersion.indexOf('Android') !== -1) {
                return ['ANDROID'];
              } else if (navigator.appVersion.indexOf('iPhone') !== -1 || navigator.appVersion.indexOf('iPad') !== -1) {
                return ['IOS'];
              } else if (navigator.appVersion.indexOf('Linux') !== -1) {
                return ['LINUX'];
              } else if (navigator.appVersion.indexOf('Mac') !== -1) {
                return ['OSX'];
              }
              return ['Unknown OS Type'];
              // The version of the operating system. Always unknow in GBC.
            case 'osversion':
              return ['Unknown'];
              // Unsupportedin GBC, deprecated in 3.10
            case 'outputmap':
              return [''];
              // Returns the screen pixel density of the front-end platform
            case 'ppi':
              return [window.devicePixelRatio * 96];
              // Returns the screen resolution of the front-end platform
            case 'screenresolution':
              return [(window.devicePixelRatio * screen.width) + 'x' + (window.devicePixelRatio * screen
                .height)]; // taking pixel ratio into account
              // Returns the build platform target code name
            case 'target':
              return ['web'];
              // Returns the current size of the front-end view-port.
            case 'windowsize':
              return [window.document.body.clientWidth + 'x' + window.document.body.clientHeight];
              // Returns the language and territory of the locale
            case 'userpreferredlang':
              return [gbc.StoredSettingsService.getLanguage()];
          }
        }
        return [''];
      },

      /**
       * Retrieves a file from the front-end context to the virtual machine context.
       * @param filename
       * @param url
       */
      fgl_getfile: function(filename, url) { // jshint ignore:line
        if (!filename || !url) {
          this.parametersError();
          return;
        }
        var app = this.getAnchorNode().getApplication();
        app.filetransfer.getFile({
            fileTransferUrl: url,
            filename: filename
          }, function() {
            this.setReturnValues([]);
          }.bind(this),
          function(msg) {
            this.runtimeError(msg);
          }.bind(this));
      },

      /**
       * Transfers a file from the virtual machine context to the front end context.
       * @param url
       * @param filename
       * @returns {?Array}
       */
      fgl_putfile: function(url, filename) { // jshint ignore:line
        if (!url || !filename) {
          this.parametersError();
          return undefined;
        }
        var cdUrl = url + (url.indexOf("?") >= 0 ? "&" : "?") + "ContentDisposition=attachment";
        var node = this.getAnchorNode && this.getAnchorNode(),
          app = node && node.getApplication(),
          session = app && app.getSession();
        if (session && session.hasServerFeature("ft-lock-file")) {
          cls.UANetwork.ftLockFile(app, function() {
            window.open(cdUrl, filename);
            this.setReturnValues([]);
          }.bind(this), null, {
            customUrl: cdUrl
          });
        } else {
          window.open(cdUrl, filename);
          return [];
        }
      },

      /**
       * Returns an environment variable set in the user session on the front end platform.
       * @unsupported
       * @param name
       * @returns {string[]}
       */
      getEnv: function(name) {
        if (name === undefined) {
          this.parametersError();
          return undefined;
        }
        return [''];
      },

      /**
       * Returns the local window manager identifier of the window
       * @unsupported
       * @param auiWindowId
       * @returns {string[]}
       */
      getWindowId: function(auiWindowId) {
        if (auiWindowId === undefined) {
          this.parametersError();
          return undefined;
        }
        return [''];
      },

      /**
       * Prints a screen shot of the current window
       * @unsupported
       * @param adaptScreenToPageSize
       * @returns {boolean[]}
       */
      hardCopy: function(adaptScreenToPageSize) {
        window.print();
        return [true];
      },

      /**
       * Opens an URL with the default URL handler of the front-end.
       * @param {string} url to open
       * @param {string=} mode how to open, if 'replace', will open it in the app window
       * @returns {string[]}
       */
      launchURL: function(url, mode) {
        if (url === undefined) {
          this.parametersError();
          return [''];
        }

        var replace = (mode === 'replace');

        if (!url.indexOf('mailto:') || !url.indexOf('news:') || !url.indexOf('file:')) {
          var frame = document.createElement('iframe');
          frame.style.display = 'none';
          document.body.appendChild(frame);
          try {
            frame.src = url;
          } catch (ex) {}
        } else {
          if (replace) {
            gbc.canShowExitWarning = false;
            window.location = url;
          } else { // 'popup'
            var win = window.open('about:blank');
            if (win) {
              win.document.write('<html><body><a href="' + url +
                '" target="_self">' + i18next.t("gwc.app.noload") + '</a></body></html>');
              win.document.close();
              win.location = url;
            }
          }
        }
        return [];
      },

      /**
       * Unloads a DLL or shared library front call module.
       * @unsupported
       * @param name
       * @returns {*}
       */
      mdClose: function(name) {
        if (name === undefined) {
          this.parametersError();
          return;
        }
        return [-2];
      },

      /**
       * Displays a file dialog window to get a directory path on the local file system.
       * @unsupported
       * @param path
       * @param caption
       * @returns {string[]}
       */
      openDir: function(path, caption) {
        if (path === undefined || caption === undefined) {
          this.parametersError();
          return undefined;
        }
        return [''];
      },

      /**
       * Displays a file dialog window to let the user select a single file path on the local file system.
       * @param path
       * @param fileTypeName
       * @param wildcards
       * @param caption
       */
      openFile: function(path, fileTypeName, wildcards, caption) {
        var app = this.getAnchorNode().getApplication();
        app.filetransfer.openFile({
            path: path,
            fileTypeName: fileTypeName,
            wildcards: wildcards,
            caption: caption
          }, function(filename) {
            this.setReturnValues([filename]);
          }.bind(this),
          function(msg) {
            this.runtimeError(msg);
          }.bind(this));
      },

      /**
       * Displays a file dialog window to let the user select a list of file paths on the local file system.
       * @param path
       * @param fileTypeName
       * @param wildcards
       * @param caption
       */
      openFiles: function(path, fileTypeName, wildcards, caption) {
        var app = this.getAnchorNode().getApplication();
        app.filetransfer.openFiles({
            path: path,
            fileTypeName: fileTypeName,
            wildcards: wildcards,
            caption: caption
          }, function(filenames) {
            this.setReturnValues([JSON.stringify(filenames)]);
          }.bind(this),
          function(msg) {
            this.runtimeError(msg);
          }.bind(this));
      },

      /**
       * Plays the sound file passed as parameter on the front-end platform.
       * @param {string} soundFile source (local or distant)
       * @returns {Array}
       */
      playSound: function(soundFile) {
        if (soundFile === undefined) {
          this.parametersError();
          return undefined;
        }
        var audio = context.TemplateService.renderDOM('FrontCallStandardPlaySound');
        audio.setAttribute('src', soundFile);
        audio.play();
        return [];
      },

      /**
       * Displays a file dialog window to get a path to save a file on the local file system.
       * @unsupported
       * @param path
       * @param name
       * @param filetype
       * @param caption
       * @returns {string[]}
       */
      saveFile: function(path, name, filetype, caption) {
        if (path === undefined || name === undefined || filetype === undefined || caption === undefined) {
          this.parametersError();
          return undefined;
        }
        return [''];
      },

      /**
       * Override the font used for report generation for the current application.
       * @unsupported
       * @param font
       * @returns {boolean[]}
       */
      setReportFont: function(font) {
        if (font === undefined) {
          this.parametersError();
          return undefined;
        }
        return [false];
      },

      /**
       * Override the printer configuration used for report generation for the current application.
       * @unsupported
       * @param printer
       * @returns {boolean[]}
       */
      setReportPrinter: function(printer) {
        if (printer === undefined) {
          this.parametersError();
          return undefined;
        }
        return [false];
      },

      /**
       * Defines the base path where web components are located.
       * @deprecated
       * @param path
       * @returns {Array}
       */
      setWebComponentPath: function(path) {
        if (path === undefined) {
          this.parametersError();
          return undefined;
        }
        this.getAnchorNode().getApplication().info().webComponentUsrPath = path;
        return [];
      },

      /**
       * Opens a file on the front-end platform with the program associated to the file extension.
       * @unsupported
       * @param document
       * @param action
       * @returns {boolean[]}
       */
      shellExec: function(document, action) {
        if (document === undefined) {
          this.parametersError();
          return undefined;
        }
        return [false];
      }
    };
  }
);
;
"use strict";

modulum('FrontCallService.modules.theme', ['FrontCallService'],
  function(context, cls) {

    /**
     * Themes module to manage (activate, list and get) front-end themes
     * @instance theme
     * @memberOf gbc.FrontCallService.modules
     */
    context.FrontCallService.modules.theme = /** @lends gbc.FrontCallService.modules.theme */ {
      /**
       * Load and activate a given theme by name
       * @param {string} name theme name
       * @returns {Array}
       */
      setTheme: function(name) {
        if (name === undefined) {
          this.parametersError();
          return undefined;
        }
        context.ThemeService.loadTheme(name, function() {
          this.setReturnValues([]);
        }.bind(this), true);
      },

      /**
       * Get the current theme name
       * @return {string} the current theme name
       */
      getCurrentTheme: function() {
        var currentTheme = context.ThemeService.getCurrentTheme();
        return [currentTheme];
      },

      /**
       * List all available themes
       * @return {Array} list of all available themes. One theme is an object composed of attributes 'name', 'title' and 'conditions'
       */
      listThemes: function() {
        var allThemes = context.ThemeService.getAvailableThemes();
        return [allThemes];
      }
    };
  }
);
;
"use strict";

modulum('FrontCallService.modules.webcomponent', ['FrontCallService'],
  function(context, cls) {
    /**
     * Service to handle Webcomponent's FrontCalls
     * @instance webcomponent
     * @memberOf gbc.FrontCallService.modules
     */
    context.FrontCallService.modules.webcomponent = /** @lends gbc.FrontCallService.modules.webcomponent */ {

      /**
       * Call a method inside the webcomponent
       */
      call: function() {
        if (arguments.length > 1) {
          var webComponentTarget = arguments[0];
          var functionName = arguments[1];

          var parameters = new Array(arguments.length - 2);
          for (var i = 2; i < arguments.length; ++i) {
            parameters[i - 2] = arguments[i];
          }

          // Once we've managed Orders
          var orderManagedHandle = this.getAnchorNode().getApplication().dvm.onOrdersManaged(function() {
            orderManagedHandle();
            var app = this.getAnchorNode().getApplication();

            //search for the target Node
            var currentWindow = app.getNode(app.uiNode().attribute('currentWindow'));
            var forms = currentWindow.getChildren('Form');
            var currentForm;
            for (i = forms.length - 1; i >= 0; --i) {
              var form = forms[i];
              if (!form.attribute('hidden')) {
                currentForm = form;
                break;
              }
            }
            var targetNode = currentForm.findNodeWithAttribute('FormField', 'name', webComponentTarget);

            var widget = targetNode.getController().getWidget();

            var process = function(widget, functionName, parameters) {
              var ret = '';
              try {
                var fct = widget._iframeElement.contentWindow[functionName];
                if (typeof(fct) === 'function') {
                  ret = fct.apply(null, parameters);
                } else {
                  this.runtimeError('No function [' + functionName + '] defined in this webcomponent.');
                }
              } catch (e) {
                this.runtimeError(e.message);
              }
              this.setReturnValues([ret]);
            }.bind(this);

            // If the webcomponent is ready
            if (widget._isReady) {
              process(widget, functionName, parameters);
            } else {
              // Otherwise, we wait that it becomes ready
              var readyHandle = widget.when(context.constants.widgetEvents.ready, function() {
                readyHandle();
                process(widget, functionName, parameters);
              }.bind(this));
            }
          }.bind(this));
        } else {
          this.runtimeError('No webcomponent or function name provided');
        }
      },

      /**
       * Get the frontcall Api version
       * @returns {string[]}
       */
      frontCallAPIVersion: function() {
        return [cls.WebComponentWidget.gICAPIVersion];
      },

      /**
       * Get the window title of the webcomponent
       * @param webComponentTarget
       * @returns {string[]}
       */
      getTitle: function(webComponentTarget) {
        if (webComponentTarget) {
          var targetNode = this.getAnchorNode().getApplication().model.getNodeByAttribute('name', webComponentTarget);
          var domElement = targetNode.getController().getWidget()._iframeElement;
          try {
            return [domElement.contentWindow.document.title];
          } catch (e) {
            this.runtimeError(e.message);
          }
        } else {
          this.runtimeError('No webcomponent name provided');
        }
      }
    };
  }
);
;
"use strict";

modulum('FrontCallService', ['InitService'],
  function(context, cls) {

    /**
     * @namespace gbc.FrontCallService
     */
    context.FrontCallService = context.oo.StaticClass( /** @lends gbc.FrontCallService */ {
      __name: "FrontCallService",

      /**
       * list of available front call modules
       * @type {Object}
       * */
      modules: {},
      /**
       * currently running front call
       * @type {classes.NodeBase}
       * */
      _functionCallNode: null,

      /** @type {boolean} */
      _functionCallProcessing: false,

      /**
       * Initialize the service
       */
      init: function() {
        var lowerCasedModules = {};
        var moduleNames = Object.keys(this.modules);
        for (var i = 0; i < moduleNames.length; ++i) {
          var moduleName = moduleNames[i];
          var module = this.modules[moduleName];
          var functionNames = Object.keys(module);
          var lowerCasedModule = {};
          lowerCasedModules[moduleName.toLowerCase()] = lowerCasedModule;
          for (var j = 0; j < functionNames.length; ++j) {
            var functionName = functionNames[j];
            lowerCasedModule[functionName.toLowerCase()] = module[functionName];
          }
        }
        this.modules = lowerCasedModules;
      },

      /**
       * Check if the module exist
       * @param {string} module - name of the frontcall module (i.e: standard, mobile ...)
       * @return {boolean}
       */
      hasModule: function(module) {
        return !!this.modules[module.toLowerCase()];
      },

      /**
       * Check if module has a frontcall
       * @param {string} module - name of the frontcall module (i.e: standard, mobile ...)
       * @param {string} name - name of the function (i.e: feinfo, openDir, playSound...)
       * @return {boolean} - true if frontcall exist in the module
       */
      hasFrontCall: function(module, name) {
        var moduleItem = this.modules[module.toLowerCase()];
        if (!!moduleItem) {
          return !!moduleItem[name.toLowerCase()];
        } else {
          return false;
        }
      },

      /**
       * Check if a functionCall is processing
       * @return {boolean} true if processing, false otherwise
       */
      functionCallIsProcessing: function() {
        return this._functionCallProcessing;
      },

      /**
       * Tell the service that a FrontCall is processing or not
       * @param {boolean} processing - true if processing
       */
      setFunctionCallProcessing: function(processing) {
        this._functionCallProcessing = processing;
      }

    });
    context.InitService.register(context.FrontCallService);
  });
;
"use strict";

modulum('BookmarkService', ['InitService', 'LocalSettingsService'],
  function(context, cls) {

    /**
     * Service to keep bookmark of favorite apps
     * @class gbc.BookmarkService
     */
    context.BookmarkService = context.oo.StaticClass( /** @lends gbc.BookmarkService */ {
      __name: 'BookmarkService',

      /**
       * Name of the event
       */
      _refreshedEvent: 'refreshed',

      /**
       * Position of the last bookmark
       * @type {number}
       */
      _lastBookmarks: -1,

      /**
       * List of all bookmarks
       * @type {Array}
       */
      _bookmarks: [],

      /**
       * Event Listener shortcut
       */
      _eventListener: new cls.EventListener(),

      /**
       * Init function
       */
      init: function() {
        this._refresh(true);
      },

      /**
       * Write the bookmark
       * @param {boolean} emit flag to trig the refresh event at the end of function
       */
      update: function(emit) {
        context.LocalSettingsService.write('lastBookmarks', new Date().getTime());
        context.LocalSettingsService.write('bookmarks', this._bookmarks);
        if (emit) {
          this._eventListener.emit(this._refreshedEvent);
        }
      },

      /**
       * Get all bookmarked apps
       * @returns {Array}
       */
      getBookmarks: function() {
        return this._bookmarks;
      },

      /**
       * Get a bookmark in localstorage defined by his name
       * @param   {string} name The displayed name in the list
       * @returns {Object} The matching bookmark
       */
      getBookmark: function(name) {
        return this._bookmarks.find(function(n) {
          return n.name === name || n.url === name;
        });
      },

      /**
       * Replace a bookmark
       * @param name
       * @param url
       */
      switchBookmark: function(name, url) {
        if (this.getBookmark(name)) {
          this._removeBookmark(name, true);
        } else {
          this._addBookmark(name, url, true);
        }
      },

      /**
       * Add a bookmark to the localstorage
       * @param   {string}  name Name to be displayed
       * @param   {string}  url  Link to the bookmark content
       * @returns {boolean} true if succesfully added, false otherwise
       */
      addBookmark: function(name, url) {
        return this._addBookmark(name, url, true);
      },

      /**
       * Search localStorage and remove a bookmark
       * @param   {string}   name Name to be removed
       */
      removeBookmark: function(name) {
        this._removeBookmark(name, true);
      },

      /**
       * Handler once the bookmarks are refreshed
       * @param hook callback
       * @returns {*|HandleRegistration}
       */
      onRefreshed: function(hook) {
        return this._eventListener.when(this._refreshedEvent, hook);
      },

      /**
       * Update bookmarks
       * @param {boolean} emit flag to trig the refresh event at the end of function
       * @private
       */
      _refresh: function(emit) {
        var lastBookmarks = context.LocalSettingsService.read('lastBookmarks') || 0;
        if (lastBookmarks > this._lastBookmarks) {
          this._bookmarks = (context.LocalSettingsService.read('bookmarks') || []).remove(null);
        }
        if (emit) {
          this._eventListener.emit(this._refreshedEvent);
        }
      },

      /**
       * Add a bookmark to the localstorage
       * @param   {string}  name Name to be displayed
       * @param   {string}  url  Link to the bookmark content
       * @param   {boolean}  emit if emits the change
       * @returns {boolean} true if succesfully added, false otherwise
       * @private
       */
      _addBookmark: function(name, url, emit) {
        this._refresh();
        if (this.getBookmark(name)) {
          this.removeBookmark(name);
        }
        var mark = {
          'name': name,
          'description': '',
          'url': url,
          'date': Date.now()
        };

        this._bookmarks.unshift(mark);
        this.update(emit);
      },

      /**
       * Search localStorage and remove a bookmark
       * @param {string} name - Name to be removed
       * @param {boolean} emit
       */
      _removeBookmark: function(name, emit) {
        this._refresh();
        var toRemove = this.getBookmark(name);
        this._bookmarks.remove(toRemove);
        this.update(emit);
        return toRemove;
      }
    });
    context.InitService.register(context.BookmarkService);
  });
;
"use strict";

modulum('HistoryService', ['InitService', 'LocalSettingsService'],
  function(context, cls) {

    /**
     * @class gbc.HistoryService
     */
    gbc.HistoryService = context.oo.StaticClass( /** @lends gbc.HistoryService */ {
      __name: 'HistoryService',

      /**
       * Name of the event
       */
      _refreshedEvent: 'refreshed',

      /**
       * Namespace for this part of local storage to avoid inconsistency
       */
      _localSettingsName: 'history_gwcJS',

      /**
       * List of all history entry
       * @type {Array}
       */
      _history: [],

      /**
       * Event Listener shortcut
       */
      _eventListener: new cls.EventListener(),

      /**
       * Init function
       */
      init: function() {
        this.refresh();
      },

      refresh: function() {
        this._history = (context.LocalSettingsService.read(this._localSettingsName) || []).remove(null);
        this._eventListener.emit(this._refreshedEvent);
      },

      /**
       * Get History stored
       * @returns {Array} History marks list
       */
      getHistory: function(name) {
        if (name) {
          return this._history.find(function(n) {
            return n.name === name || n.url === name;
          });
        } else {
          return this._history;
        }
      },

      /**
       * Add something to the history stack
       * @param   {classes.VMApplication} application The name to be displayed
       * @param   {string} url  The link to go with this history mark
       * @param flag
       */
      addHistory: function(application, url, flag) {
        if (typeof(flag) === 'undefined') {
          flag = '';
        }

        this._history.removeMatching(function(n) {
          return n.name === application.info().appId || n.url === name;
        });

        this._history.unshift({
          'name': application.info().appId,
          'description': '',
          'url': url,
          'date': Date.now(),
          'flag': flag,
          'session': application.info().session
        });
        this._history = this._history.slice(0, 10); // take top 10
        context.LocalSettingsService.write(this._localSettingsName, this._history);
        this.refresh();
      },

      /**
       * Remove a given history entry
       * @param   {string} name The name of the entry to remove
       */
      removeHistory: function(name) {
        this._history.removeMatching(function(n) {
          return n.name === ('' + name) || n.url === name;
        });
        context.LocalSettingsService.write(this._localSettingsName, this._history);
        this.refresh();
      },

      /**
       * Remove all the History stored
       */
      clearHistory: function() {
        context.LocalSettingsService.write(this._localSettingsName, []);
        this.refresh();
      },
      onRefreshed: function(hook) {
        return this._eventListener.when(this._refreshedEvent, hook);
      }
    });
    context.InitService.register(context.HistoryService);
  });
;
"use strict";

modulum('HostService', ['InitService', 'DebugService', 'EventListener'],
  function(context, cls) {

    /**
     * @namespace gbc.HostService
     */
    context.HostService = context.oo.StaticClass( /** @lends gbc.HostService */ {
      __name: "HostService",

      currentWindowChanged: "currentWindowChanged",

      /** @type classes.MainContainerWidget */
      _widget: null,
      /** @type classes.LogPlayerWidget */
      _logPlayer: null,
      /** @type String */
      _defaultTitle: "",
      /** @type classes.ApplicationHostWidget */
      _applicationHostWidget: null,
      /** @type classes.WindowWidget */
      _currentWindow: null,
      /** @type classes.EventListener */
      _eventListener: null,
      /** @type HTMLElement */
      _dropDownContainer: null,

      init: function() {
        this._eventListener = new cls.EventListener();

        var existingOnError = window.onerror;
        window.onerror = function(msg, file, line, col, error) {
          if (existingOnError) {
            existingOnError(msg, file, line, col, error);
          }
          context.HostService._eventListener.emit('error', error, msg, file, line, col);
          return false;
        };

        // Device orientation handler
        window.addEventListener("orientationchange", function() {
          if (window.isMobile) {
            this._eventListener.emit("orientationChange.Host");
          }
        }.bind(this));
        // Window Resize handler
        window.addEventListener("resize", function() {
          this._eventListener.emit("resize.Host");
        }.bind(this));
      },

      isLogPlayerRequested: function() {
        return window.isURLParameterEnabled("logplayer");
      },

      preStart: function() {
        if (!context.DebugService.isMonitorWindow()) {
          this._widget = cls.WidgetFactory.createWidget("MainContainer", {
            appHash: gbc.systemAppId
          });
          if (this.isLogPlayerRequested()) {
            this._logPlayer = cls.WidgetFactory.createWidget("LogPlayer", {
              appHash: gbc.systemAppId
            });
            this._logPlayer.addChildWidget(this._widget);
          }
          window.requestAnimationFrame(function() {
            var w = this._logPlayer ? this._logPlayer : this._widget;
            document.body.appendChild(w.getElement());
            if (this.isLogPlayerRequested()) {
              this.setSidebarAvailable(true);
            }
          }.bind(this));
          this._defaultTitle = document.title;
          this._applicationHostWidget = cls.WidgetFactory.createWidget("ApplicationHost", {
            appHash: gbc.systemAppId
          });
          this._widget.addChildWidget(this._applicationHostWidget);

          // create drop down container
          if (!this._dropDownContainer) {
            // TODO rename gbc_DropDownContainerWidget to gbc_DropDownContainer (this is not a widget)
            this._dropDownContainer = document.createElement("div");
            this._dropDownContainer.addClasses("gbc_DropDownContainerWidget", "hidden");
            document.body.appendChild(this._dropDownContainer);
          }
        }
      },
      getWidget: function() {
        return this._widget;
      },

      /**
       *
       * @returns {classes.ApplicationHostWidget}
       */
      getApplicationHostWidget: function() {
        return this._applicationHostWidget;
      },

      getLogPlayer: function() {
        return this._logPlayer;
      },

      /**
       *
       * @param {boolean} enable
       */
      setSidebarAvailable: function(enable) {
        this._applicationHostWidget.enableSidebar(enable);
      },

      setSidebarContent: function(widget) {
        this._applicationHostWidget.setSidebarContent(widget);
      },
      start: function() {
        var params = context.UrlService.currentUrl().getQueryStringObject();
        if (!!params.app || context.bootstrapInfo.appName) {
          context.SessionService.start(params.app || context.bootstrapInfo.appName);
        } else {
          this.displayNoSession();
        }
      },
      displaySession: function() {
        this._applicationHostWidget.getLauncher().setHidden(true);
      },
      displayNoSession: function() {
        this._applicationHostWidget.getLauncher().setHidden(false);
      },
      whenError: function(cb) {
        this._eventListener.when('error', cb);
      },
      getCurrentWindow: function() {
        return this._currentWindow;
      },
      setCurrentWindow: function(win) {
        this._currentWindow = win;
      },

      /**
       * get info about the current available closebutton if any
       * @return {*}
       * @private
       */
      _getCurrentWindowCloseButtonInfo: function() {
        var result = null,
          windowWidget = this.getCurrentWindow();
        if (windowWidget) {
          var uiWidget = windowWidget.getUserInterfaceWidget && windowWidget.getUserInterfaceWidget(),
            app = uiWidget && uiWidget.getParentWidget();
          if (app && app._tabbedPage) {
            var tabbedHostInfo = this._closeButtonsInfo && this._closeButtonsInfo._tabbedHost;
            if (tabbedHostInfo) {
              result = this.getCloseButtonInfo(tabbedHostInfo.widget);
            }
          } else {
            result = this.getCloseButtonInfo(windowWidget);
          }
        }
        return result;
      },

      /**
       * do a click if possible on the current available closebutton if any
       */
      tryCloseButtonClick: function() {
        var closeInfo = this._getCurrentWindowCloseButtonInfo();
        if (closeInfo && closeInfo.closeWidget) {
          closeInfo.closeWidget.manageMouseClick();
        }
      },
      /**
       *
       * @param {Hook} hook
       * @return {HandleRegistration}
       */
      onCurrentWindowChange: function(hook) {
        return this._eventListener.when(this.currentWindowChanged, hook);
      },

      /**
       * - Manage switch of window in the DOM depending of whether they are modal or not and having WebComponent or not.
       * - Display/hide topmenu & toolbars of active/inactive windows.
       * - Set window title
       * @param {classes.WindowWidget} win
       */
      setDisplayedWindow: function(win) {
        if (!win) {
          return;
        }

        // determine if switch of application occured using _currentWindow static variable
        var switchingApplication = (!this._currentWindow && !!win) ||
          (!!win && !!this._currentWindow && win.getUserInterfaceWidget() !== this._currentWindow.getUserInterfaceWidget());
        var session = context.SessionService.getCurrent(),
          app = session && session.getCurrentApplication();

        var sameApplication = app && app.getUI().getWidget() === (win.getUserInterfaceWidget() && win.getUserInterfaceWidget()
          .getParentWidget());

        // If new window is a modal, we don't remove/insert it in DOM. Modal is fully managed by WindowTypeVMBehavior
        if (this._currentWindow) {
          this._currentWindow.freeze();
        }
        if (!!win) {
          // determine if in current application a switch of window occured
          // if only a switch of application occured without change of window in current app, we do nothing (application management done by SessionWidget did all the job)
          var currentUI = win.getUserInterfaceWidget();
          var previousWindow = currentUI._activeWindow;

          if (switchingApplication || !win.isModal) { // if app window changed and new active window isn't a modal, we add it to DOM

            context.DebugService.onApplicationSwitch();

            // WebComponent Management
            if ((previousWindow && previousWindow.hasChildWebComponent()) || (win && win.hasChildWebComponent())) {
              // if window to remove has a webcomponent, just send it far away out of view, without removing it
              if (previousWindow && previousWindow.hasChildWebComponent()) {
                previousWindow.addClass("gbc_out_of_view");
                if (win && !win.hasChildWebComponent() && currentUI && currentUI.getContainerElement()) {
                  currentUI.getContainerElement().appendChild(win.getElement());
                }
              } else {
                if (previousWindow) {
                  previousWindow.getElement().remove();
                }
              }
              // if window to be displayed has a webcomponent, just put it back in the view
              if (win && win.hasChildWebComponent()) {
                win.removeClass("gbc_out_of_view");
                if (!win.getElement().parentNode) {
                  currentUI.getContainerElement().appendChild(win.getElement());
                }
              }
              // if neither previous and new window has WebComponent
            } else if (currentUI) {
              if (currentUI.getContainerElement()) {
                // if previous window wasn't a modal neither, we can safely remove it from DOM
                if (previousWindow && !previousWindow.isModal) {
                  previousWindow.getElement().remove();
                }
                if (win && !win.hasChildWebComponent() && (!win.getElement().parentElement ||
                    (win.getElement().parentElement.lastChild !== win.getElement()))) {
                  currentUI.getContainerElement().appendChild(win.getElement());
                }
              }
              currentUI.activate(); // send activate signal to inform elements that window is append to DOM
            }
          } else if (switchingApplication || win.isModal) {
            var childrenWin = currentUI.getChildren();
            var nonModalPrevWin = null;
            var winIndex = childrenWin.indexOf(win);
            var parentId = win.getParentWindowId();

            // Get the previous non modal window to display it
            for (winIndex; winIndex >= 0; winIndex--) {
              nonModalPrevWin = childrenWin[winIndex - 1];
              if (nonModalPrevWin && !nonModalPrevWin.isModal && nonModalPrevWin._auiTag === parentId) {
                break;
              }
            }
            if (nonModalPrevWin &&
              (nonModalPrevWin.hasChildWebComponent && !nonModalPrevWin.hasChildWebComponent())) {
              if (nonModalPrevWin !== previousWindow && !currentUI.getContainerElement().contains(nonModalPrevWin.getElement())) {
                currentUI.getContainerElement().appendChild(nonModalPrevWin.getElement());
              }
              nonModalPrevWin._forceVisible = true;
            }
          }

          // hide topmenu/toolbar of previous windows if none previous and new window are modal. In that case, topmenu/toolbar container is shared
          if (previousWindow && !previousWindow.isModal && win && !win.isModal) {
            if (previousWindow._activeTopMenuWidget) {
              previousWindow._activeTopMenuWidget.setHidden(true);
            }
            if (previousWindow._toolBarWidget) {
              previousWindow._toolBarWidget.setHidden(true);
            }
          }
          // display topmenu/toolbar of new current window
          if (win) {
            if (win._activeTopMenuWidget) {
              win._activeTopMenuWidget.setHidden(false);
            }
            if (win._toolBarWidget) {
              win._toolBarWidget.setHidden(false);
            }
          }

          this._currentWindow = win;
          currentUI._activeWindow = win;

          if (this._currentWindow) {
            this._currentWindow.unfreeze();
          }

          // if we switched of application we need to invalidate allocated space
          if (previousWindow && win && switchingApplication) {
            win.getUserInterfaceWidget().getLayoutEngine().invalidateAllocatedSpace();
          }
          // set current window title (icon + text) as application host menu title
          if (sameApplication && !switchingApplication && app && app.getUI().getWidget()._tabbedPage) {
            if (!win.isModal) {
              app.getUI().getWidget()._tabbedPage.setText(win ? (win.getText() || win.getUserInterfaceWidget().getText()) : "");
              app.getUI().getWidget()._tabbedPage.setImage(win ? (win.getImage() || win.getUserInterfaceWidget().getImage()) : "");
            }
          }
          if (!app || (!app.getUI().getWidget()._tabbedPage && !win.isModal)) {
            this.setCurrentTitle(win ? (win.getText() || win.getUserInterfaceWidget().getText()) : "");
            this.setCurrentIcon(win ? (win.getImage() || win.getUserInterfaceWidget().getImage()) : "");
          }

          this._eventListener.emit(this.currentWindowChanged, win);
        }
        // need to refresh current application layout for potential background dynamic VM update
        app = session && session.getCurrentApplication();
        if (app) {
          if (app.dvm) {
            app.dvm.updateProcessingStatus();
          }
          app.layout.when(context.constants.widgetEvents.afterLayoutFocusRestored, function() {
            app.focus.restoreVMFocus(true);
          }.bind(this), true);
          app.layout.refreshLayout();
        }
      },

      /**
       * Define the current app title to display
       * @param {string} title - text to display in top bar
       */
      setCurrentTitle: function(title) {
        if (gbc.ThemeService.getValue("theme-legacy-topbar")) {
          this._applicationHostWidget.getMenu().setText(title);
        }
        var app = gbc.SessionService.getCurrent() && gbc.SessionService.getCurrent().getCurrentApplication();
        var uiWidget = app && app.model.getNode(0) && app.model.getNode(0).getWidget();
        if (uiWidget && uiWidget.getChromeBarWidget()) {
          uiWidget.getChromeBarWidget().setTitle(title);
        }
        document.title = title ? title : this._defaultTitle;
        context.__wrapper.nativeCall({
          name: "windowTitle",
          args: [document.title]
        });
      },

      /**
       * Define the current icon for this app
       * @param {string} img - the icon url for current app
       * @param {string} appIcon - the global icon url
       */
      setCurrentIcon: function(img, appIcon) {
        if (gbc.ThemeService.getValue("theme-legacy-topbar")) {
          this._applicationHostWidget.getMenu().setIcon(img, appIcon);
        }
        var app = gbc.SessionService.getCurrent() && gbc.SessionService.getCurrent().getCurrentApplication();
        var uiWidget = app && app.model.getNode(0) && app.model.getNode(0).getWidget();
        if (uiWidget && uiWidget.getChromeBarWidget()) {
          uiWidget.getChromeBarWidget().setIcon(img, appIcon);
        }
      },
      unsetDisplayedWindow: function(win) {
        if (win && this._currentWindow === win) {
          this._currentWindow.disableActions();
        }
      },

      _closeButtonsInfo: {},

      /**
       *
       * @param {classes.WindowWidget} windowWidget
       */
      getCloseButtonInfo: function(windowWidget) {
        return windowWidget && this._closeButtonsInfo[windowWidget._appHash] &&
          this._closeButtonsInfo[windowWidget._appHash][windowWidget.getUniqueIdentifier()];
      },
      setTabbedHost: function(windowWidget) {
        this._closeButtonsInfo._tabbedHost = {
          widget: windowWidget,
          appHash: windowWidget._appHash,
          windowId: windowWidget.getUniqueIdentifier()
        };
      },
      /**
       *
       * @param {classes.WindowWidget} windowWidget
       * @param {Object} opts
       */
      registerClosableWindow: function(windowWidget, opts) {
        var legacyMenu = context.HostService.getApplicationHostWidget().getMenu();
        if (windowWidget && this._closeButtonsInfo[windowWidget._appHash] &&
          this._closeButtonsInfo[windowWidget._appHash][windowWidget.getUniqueIdentifier()]) {
          this.unregisterClosableWindow(windowWidget, true);
        }
        var perAppInfo = this._closeButtonsInfo[windowWidget._appHash] = this._closeButtonsInfo[windowWidget._appHash] || {};
        var closeInfo = perAppInfo[windowWidget.getUniqueIdentifier()] = perAppInfo[windowWidget.getUniqueIdentifier()] || {};

        // Tabbed host with different window (hosted window)
        if (this._closeButtonsInfo._tabbedHost && this._closeButtonsInfo._tabbedHost.appHash !== windowWidget._appHash) {
          if (opts && opts.chromeBar) {
            //closeInfo.closeWidget = opts.chromeBar.getGbcMenuItem("close");
            opts.chromeBar.setHidden(true);
          } //else {
          closeInfo.closeWidget = cls.WidgetFactory.createWidget("TabbedApplicationClose", {
            appHash: gbc.systemAppId
          });
          closeInfo.closeClickHandler = closeInfo.closeWidget.onClick(windowWidget._emitClose.bind(windowWidget));
          //}

          var session = context.SessionService.getCurrent(),
            application = session && session.getApplicationByHash(windowWidget._appHash),
            applicationWidget = application && application.getUI() && application.getUI().getWidget(),
            actionsElement = applicationWidget && applicationWidget._tabbedPage && applicationWidget._tabbedPage.getTitleWidget()
            .getActionsContainerElement();
          this.setClosableWindowActionProcessing(windowWidget, application.isProcessing());
          if (actionsElement) {
            actionsElement.appendChild(closeInfo.closeWidget.getElement());
          }

          // Tabbed host with a window (host window)
        } else if (this._closeButtonsInfo._tabbedHost && this._closeButtonsInfo._tabbedHost.appHash === windowWidget._appHash) {
          //  if chromebar
          if (opts && opts.chromeBar) {
            closeInfo.closeWidget = opts.chromeBar.getGbcMenuItem("close");
            closeInfo.closeWidget.setLinkedWindow(windowWidget);
          } else if (legacyMenu) {
            closeInfo.closeWidget = cls.WidgetFactory.createWidget("TabbedApplicationHostWindowCloseMenu", {
              appHash: gbc.systemAppId
            });
            closeInfo.closeClickHandler = closeInfo.closeWidget.onClick(windowWidget._emitClose.bind(windowWidget));
            legacyMenu.addChildWidget(closeInfo.closeWidget);
          }
        } else {
          // default case
          //  if chromebar
          if (opts && opts.chromeBar) {
            closeInfo.closeWidget = opts.chromeBar.getGbcMenuItem("close");
            closeInfo.closeWidget.setLinkedWindow(windowWidget);
          } else if (legacyMenu) {
            closeInfo.closeWidget = cls.WidgetFactory.createWidget("ApplicationHostWindowCloseMenu", {
              appHash: gbc.systemAppId
            });
            legacyMenu.addChildWidget(closeInfo.closeWidget);
            closeInfo.closeClickHandler = closeInfo.closeWidget.onClick(windowWidget._emitClose.bind(windowWidget));
          }

          if (legacyMenu && gbc.ThemeService.getValue("theme-legacy-topbar")) {
            legacyMenu.setCloseWidget(closeInfo.closeWidget);
          }
        }

      },
      unregisterClosableWindow: function(windowWidget, noHostDelete) {
        var closeInfo = this.getCloseButtonInfo(windowWidget);
        if (closeInfo.closeWidget.isInstanceOf(cls.ChromeBarItemCloseWidget)) {
          closeInfo.closeWidget.setLinkedWindow(null);
          if (!noHostDelete && this._closeButtonsInfo._tabbedHost && this._closeButtonsInfo._tabbedHost.windowId === windowWidget
            .getUniqueIdentifier()) {
            delete this._closeButtonsInfo._tabbedHost;
          }
        } else {
          if (closeInfo && closeInfo.closeWidget && !closeInfo.closeWidget.isDestroyed()) {
            closeInfo.closeWidget.getElement().remove();
            if (closeInfo.closeClickHandler) {
              closeInfo.closeClickHandler();
              closeInfo.closeClickHandler = null;
            }
            closeInfo.closeWidget.destroy();
            closeInfo.closeWidget = null;
            delete this._closeButtonsInfo[windowWidget._appHash][windowWidget.getUniqueIdentifier()];
            if (!Object.keys(this._closeButtonsInfo[windowWidget._appHash]).length) {
              delete this._closeButtonsInfo[windowWidget._appHash];
            }
            if (!noHostDelete && this._closeButtonsInfo._tabbedHost && this._closeButtonsInfo._tabbedHost.windowId === windowWidget
              .getUniqueIdentifier()) {
              delete this._closeButtonsInfo._tabbedHost;
            }
          }
        }
      },
      setClosableWindowActionActive: function(windowWidget, active) {
        var closeInfo = this.getCloseButtonInfo(windowWidget);
        if (closeInfo && closeInfo.closeWidget) {
          closeInfo.closeWidget.setActive(active, windowWidget);
        }
      },
      setClosableWindowActionHidden: function(windowWidget, hidden) {
        var closeInfo = this.getCloseButtonInfo(windowWidget);
        if (closeInfo && closeInfo.closeWidget) {
          closeInfo.closeWidget.setHidden(hidden, windowWidget);
        }
      },
      setClosableWindowActionProcessing: function(windowWidget, processing) {
        var closeInfo = this.getCloseButtonInfo(windowWidget);
        if (closeInfo && closeInfo.closeWidget && closeInfo.closeWidget._setProcessingStyle) {
          closeInfo.closeWidget._setProcessingStyle(processing);
        }
      },

      /**
       * Handler when the screen orientation changed
       * @param {function} callback - method to call once screen orientation changes
       * @note mobile only
       */
      onOrientationChange: function(callback) {
        return this._eventListener.when("orientationChange.Host", callback.bind(this));
      },

      /**
       * Handler when the screen size changed
       * @param {function} callback - method to call once screen size changes
       */
      onScreenResize: function(callback) {
        return this._eventListener.when("resize.Host", callback.bind(this));
      }

    });
    context.InitService.register(context.HostService);
  });
;
"use strict";

modulum('LocalSettingsService', ['InitService'],
  function(context, cls) {

    /**
     * @class gbc.LocalSettingsService
     */
    context.LocalSettingsService = context.oo.StaticClass( /** @lends gbc.LocalSettingsService */ {
      __name: "LocalSettingsService",
      _eventListener: null,
      _quotaExceededError: false,

      init: function() {
        this._eventListener = new cls.EventListener();
        if (!localStorage) {
          console.error("localStorage is not enabled, you might experience some errors");
        }
      },

      read: function(id) {
        if (localStorage) {
          return JSON.parse(localStorage.getItem(id));
        } else {
          return false;
        }
      },

      write: function(id, contents) {
        try {
          localStorage.setItem(id, JSON.stringify(contents));
        } catch (e) {
          if (e.name === "QuotaExceededError") {
            console.error(e);
            this._quotaExceededError = true;
            this._eventListener.emit("QuotaExceededError");
          }
        }
      },
      remove: function(id) {
        localStorage.removeItem(id);
      },
      keys: function() {
        return Object.keys(localStorage);
      },
      clear: function() {
        localStorage.clear();
      }
    });
    context.InitService.register(context.LocalSettingsService);
  });
;
"use strict";

modulum('StoredSettingsService', ['InitService', 'LocalSettingsService'],
  function(context, cls) {

    /**
     * Stored Settings Service to handle clientside specific configurations
     * @class gbc.StoredSettingsService
     */
    gbc.StoredSettingsService = context.oo.Singleton( /** @lends gbc.StoredSettingsService */ {
      __name: "StoredSettingsService",

      /**
       * NameSpace for Stored Settings to avoid conflict
       */
      _storedSettingsName: "storedSettings_gwcJS",

      /**
       * Copy of browser stored settings
       * @type {Object}
       */
      _storedSettings: null,

      /**
       * Flag to define if stored settings are enabled or not
       * @type {boolean}
       */
      _storedSettingsEnable: true,

      /**
       * Keep track of disabled tables in an array
       * @type: {Array}
       */
      _disabledTables: [],

      /**
       * Keep track of disabled tables
       */
      _disabledWindows: [],

      _eventListener: new cls.EventListener(),

      /**
       * Should be called once
       */
      init: function() {
        this._storedSettings = context.LocalSettingsService.read(this._storedSettingsName);
        if (!this._storedSettings) {
          try {
            context.LocalSettingsService.write(this._storedSettingsName, {});
          } catch (e) {
            this._storedSettingsEnable = false;
          }
        }
        context.InitService.when(gbc.constants.widgetEvents.onBeforeUnload, function() {
          this.sync();
        }.bind(this));

      },

      /**
       * Access to a local copy of stored data or browser's one if local copy is empty
       * @returns {Object}
       */
      read: function() {
        return this._storedSettings || context.LocalSettingsService.read(this._storedSettingsName);
      },

      /**
       * Write the local copy of stored data
       * @param object
       */
      write: function(object) {
        this._storedSettings = object;
      },

      /**
       * Synchronize the temporary stored settings to the browser'storage
       * @note Keep in mind that calling this many times will lower performances
       */
      sync: function() {
        context.LocalSettingsService.write(this._storedSettingsName, this._storedSettings);
      },

      /**
       * Write the stored Settings in Local Storage of the browser
       * /!\ you should not call this function directly, it will break the stored settings
       * @param {object|string} newSettings
       * @param {boolean} deep
       * @private
       */
      _update: function(newSettings, deep) {
        deep = typeof(deep) === "undefined" ? true : deep;
        // Pass in the objects to merge as arguments.
        // For a deep extend, set the first argument to `true`.
        var extend = function() {
          // Variables
          var extended = {};
          var deep = false;
          var i = 0;
          var length = arguments.length;

          // Check if a deep merge
          if (Object.prototype.toString.call(arguments[0]) === '[object Boolean]') {
            deep = arguments[0];
            i++;
          }

          // Merge the object into the extended object
          var merge = function(obj) {
            for (var prop in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, prop)) {
                // If deep merge and property is an object, merge properties
                if (deep && Object.prototype.toString.call(obj[prop]) === '[object Object]') {
                  extended[prop] = extend(true, extended[prop], obj[prop]);
                } else {
                  extended[prop] = obj[prop];
                }
              }
            }
          };

          // Loop through each object and conduct a merge
          for (; i < length; i++) {
            var obj = arguments[i];
            merge(obj);
          }
          return extended;
        };

        var oldSettings = this.read();
        var finalSettings = extend(deep, oldSettings, newSettings);
        this.write(finalSettings);
      },

      /**
       * Will create an object according to the accessor key given
       * @param key {string} accessor to the setting
       * @param leafvalue
       * @returns {{}}
       * @private
       */
      _buildTree: function(key, leafvalue) {
        var obj = {};
        var splittedKey = key.split('.');
        var splicedKey = key.split('.');
        var lenght = splittedKey.length;
        var newKey = '';

        //Create branch
        if (lenght > 1) {
          for (var i = 0; lenght > 0; i++) {
            if (!obj.hasOwnProperty(splittedKey[i])) {
              newKey = splicedKey.splice(i + 1).join('.');
              if (newKey.length > 0) {
                obj[splittedKey[i]] = this._buildTree(newKey, leafvalue);
              } else {
                break;
              }
            } else {
              break;
            }
          }
        } else { //create Leaf
          obj[key] = leafvalue || false;
        }
        return obj;
      },

      /**
       * Helper to get a cookie by name
       * @param name {string}
       * @returns {*}
       * @private
       */
      _getCookie: function(name) {
        var match = document.cookie.match(new RegExp(name + '=([^;]+)'));
        if (match) {
          return match[1];
        }
      },

      /**
       * Check if table/window has been disabled by 4ST style
       * @param key {string} accessor to stored ressource
       * @returns {boolean}
       * @private
       */
      _isForcedDefault: function(key) {
        //Check if form disabled
        var formName = key.replace('gwc.forms.', '').split('.')[0];
        //Check if table disabled
        var tableName = key.replace('gwc.forms.' + formName + '.tables.', '').split('.')[0];

        return (this._disabledWindows.indexOf(formName) >= 0 || this._disabledTables.indexOf(tableName) >= 0);
      },

      /**
       * Choose to use or not Stored Settings
       * @param {boolean} state is Enable?
       */
      enable: function(state) {
        this._storedSettingsEnable = state;
        this._update({
          'storedSettingDisabled': !state
        }, false);
      },

      /**
       * Check if StoredSettings are enabled or not
       * @returns {boolean}
       */
      areEnabled: function() {
        var allStored = this.read(this._storedSettingsName);
        if (allStored === null) {
          return false;
        }
        /* jshint ignore:start */
        if (allStored.hasOwnProperty('storedSettingDisabled')) {
          this._storedSettingsEnable = !allStored.storedSettingDisabled;
        }
        /* jshint ignore:end */
        return this._storedSettingsEnable;
      },

      /**
       * Disable stored Settings of a given window
       * @param winName
       * @param disable
       */
      disableWindowStoredSettings: function(winName, disable) {
        if (!disable) {
          var index = this._disabledWindows.indexOf(winName);
          if (index >= 0) {
            this._disabledWindows.splice(index, 1);
          }
        } else {
          this._disabledWindows.push(winName);
        }
      },

      /**
       * Disable stored Settings of a given table
       * @param tableName
       * @param disable
       */
      disableTableStoredSettings: function(tableName, disable) {
        if (!disable) {
          var index = this._disabledTables.indexOf(tableName);
          if (index >= 0) {
            this._disabledTables.splice(index, 1);
          }
        } else {
          this._disabledTables.push(tableName);
        }
      },

      /**
       * Reset and erase all stored settings
       */
      reset: function() {
        this.write({});
        this._eventListener.emit('storedSettingsReset');
      },

      /**
       * Reset and erase a specific stored settings
       * @param key {?string} key to remove from stored settings
       */
      removeSettings: function(key) {
        this.setSettings(key, {}, true); //true to replace
      },

      /**
       * Reset and erase form stored settings
       * @param formName {string} name of the form to remove from stored settings
       */
      resetForm: function(formName) {
        var formkey = 'gwc.forms.' + formName;
        this.setSettings(formkey, {}, true); //true to replace
      },

      /**
       * Reset and erase form stored settings
       * @param {string} tableName - name of the form to remove from stored settings
       */
      resetTable: function(tableName) {
        var formkey = 'gwc.tables.' + tableName;
        this.setSettings(formkey, {}, true); //true to replace
      },

      /**
       * Get a stored setting by its key accessor (i.e: gwc.app.something)
       * @param {string} key
       * @returns {*}
       */
      getSettings: function(key) {
        var settings = this.read(this._storedSettingsName);
        var keys = key.split('.');
        if (this.areEnabled() && !this._isForcedDefault(key)) {
          for (var i = 0; i < keys.length; i++) {
            if (settings.hasOwnProperty(keys[i])) {
              settings = settings[keys[i]];
            } else {
              settings = null;
              break;
            }
          }
          return typeof(settings) === 'undefined' ? null : settings;
        } else {
          return null;
        }

      },

      /**
       * Store a setting, create the accessor path if non existing
       * @param key {string} accessor to the setting
       * @param settings {*}
       * @param replace {boolean=}
       * @returns {boolean} true if success / false otherwise
       */
      setSettings: function(key, settings, replace) {
        if (this.areEnabled() && !this._isForcedDefault(key)) {
          replace = typeof(replace) === 'undefined' ? false : replace;

          //get Settings first
          var existingSetting = this.getSettings(key);

          //If existing : update values
          if (!existingSetting) {
            var tree = this._buildTree(key);
            this._update(tree);
          }

          existingSetting = settings;
          var allStored = this._goDown(key, existingSetting);
          this._update(allStored, !replace);
          return true;
        } else {
          return false;
        }
      },

      /**
       * Used to be recursive
       * @param key
       * @param settings
       * @returns {*|{}}
       * @private
       */
      _goDown: function(key, settings) {
        return this._buildTree(key, settings);
      },

      //Sidebar related functions
      /**
       * Store the sidebar status: visible / hiiden
       * @param visible {bool}
       */
      setSideBarVisible: function(visible) {
        this.setSettings('gwc.app.sidebar.visible', visible);
      },

      /**
       * Check if sideBar is visible
       * @returns {bool}
       */
      isSideBarVisible: function() {
        return this.getSettings('gwc.app.sidebar.visible');
      },

      /**
       * Store the sidebar width
       * @param width {number}
       */
      setSideBarwidth: function(width) {
        this.setSettings('gwc.app.sidebar.width', width);
      },

      /**
       * Get the sidebar width
       * @returns {number}
       */
      getSideBarwidth: function() {
        return this.getSettings('gwc.app.sidebar.width');
      },

      //Language related functions
      /**
       * Manually set the language of the interface
       * @param locale {string} should be something like "en-US" or "fr-FR"
       */
      setLanguage: function(locale) {
        this.setSettings('gwc.app.locale', locale);
        gbc.I18NService.setLng(locale);
      },

      /**
       * Get the language set
       * @returns {string} locale
       */
      getLanguage: function() {
        var locale = this.getSettings('gwc.app.locale');
        if (!locale) {
          locale = this._getCookie('lang');
        }
        return locale;
      },

      //Log level related functions
      /**
       * store the log level
       * @param loglevel {string}
       */
      setLoglevel: function(loglevel) {
        this.setSettings('gwc.app.loglevel', loglevel);
      },

      /**
       * Get the log level
       * @returns {string} loglevel
       */
      getLoglevel: function() {
        return this.getSettings('gwc.app.loglevel') || 'none';
      },

      //Log types related functions
      /**
       * store the log types
       * @param logtypes {string}
       */
      setLogtypes: function(logtypes) {
        this.setSettings('gwc.app.logtypes', JSON.stringify(logtypes));
      },

      /**
       * Get the log types
       * @returns {string} logtypes
       */
      getLogtypes: function() {
        return JSON.parse(this.getSettings('gwc.app.logtypes') || "null");
      },

      //Splitter related functions
      /**
       * Define a splitter according to parameters
       * @param formName
       * @param identifier
       * @param splitInfo
       */
      setSplitter: function(formName, identifier, splitInfo) {
        var selector = 'gwc.forms.' + formName + '.layoutContainer.' + identifier;
        this.setSettings(selector, splitInfo);
      },

      /**
       * Get Splitter info
       * @param formName
       * @param identifier
       * @returns {*}
       */
      getSplitter: function(formName, identifier) {
        var selector = 'gwc.forms.' + formName + '.layoutContainer.' + identifier;
        return this.getSettings(selector);
      },

      //Collapsible group related functions
      /**
       * Define a group collapsed state according to parameters
       * @param {string} formName
       * @param {string} identifier
       * @param {boolean} collapsedInfo
       */
      setGroupCollapsedState: function(formName, identifier, collapsedInfo) {
        var selector = 'gwc.forms.' + formName + '.groupCollapsed.' + identifier;
        this.setSettings(selector, collapsedInfo);
      },

      /**
       * Get group collapsed state
       * @param {string} formName
       * @param {string} identifier
       * @returns {boolean}
       */
      getGroupCollapsedState: function(formName, identifier) {
        var selector = 'gwc.forms.' + formName + '.groupCollapsed.' + identifier;
        return this.getSettings(selector);
      },

      /**
       * Handling a callback on reset storedSettings
       * @param hook
       * @returns {*|HandleRegistration}
       */
      whenReset: function(hook) {
        return this._eventListener.when('storedSettingsReset', hook);
      }
    });
    context.InitService.register(context.StoredSettingsService);
  });
;
"use strict";

modulum('I18NService', ['InitService'],
  function(context, cls) {

    /**
     * Localization Service to translate the app
     * @namespace gbc.I18NService
     * @gbcService
     * @publicdoc
     */
    context.I18NService = context.oo.StaticClass( /** @lends gbc.I18NService */ {
      __name: 'I18NService',
      _init: false,

      /**
       * Language to use if not defined by user or browser
       * @type {string}
       */
      _fallBackLng: 'en-US',

      /**
       * Event listener object
       * @type {*}
       */
      _eventListener: new cls.EventListener(), //used to listen when i18next is ready

      /**
       * Event name once I18N is ready
       */
      _i18nReady: 'i18nReady',

      /**
       * Flag to determine if service is ready or not
       * @type {boolean}
       */
      isReady: false,

      /**
       * Init service method. should be called only once.
       */
      init: function() {
        window.i18next
          .use(window.i18nextBrowserLanguageDetector)
          .init({
            fallbackLng: this._getNormalizedLanguage(),
            resources: window.gbcLocales,
            detection: {
              lookupQuerystring: 'setLng',
              lookupCookie: 'lang',
              caches: ['cookie']
            }
          }, this._onReady.bind(this));
      },

      /**
       * Set the language of the app
       * @param locale {string} language code to set (e.g en_US, fr_FR ...)
       * @publicdoc
       */
      setLng: function(locale) {
        window.i18next.changeLanguage(this._getNormalizedLanguage(locale)[0]);
      },

      /**
       * Translate a widget with i18n data
       * @param {classes.WidgetBase} widget Widget to translate
       * @publicdoc
       */
      translate: function(widget) {
        if (this.isReady) {
          widget.translate();
        } else {
          return this._eventListener.when(this._i18nReady, widget.translate.bind(widget));
        }
        return null;
      },

      /**
       * Get all available translations with locales id
       * @returns {Array} - array of locales id
       * @publicdoc
       */
      getAllLng: function() {
        return Object.keys(window.gbcLocales).map(function(key) {
          if (key !== 'undefined') {
            return {
              'locale': key,
              'language': window.i18next.exists('gwc.lngName', {
                lng: key,
                fallbackLng: 'undef'
              }) ? window.i18next.t('gwc.lngName', {
                lng: key
              }) : key
            };
          }
        });
      },

      /**
       * Ready Handler
       * @private
       */
      _onReady: function() {
        this._checkLanguageCompatibility();
        var storedLng = gbc.StoredSettingsService.getLanguage();
        var cookieLng = gbc.StoredSettingsService._getCookie('lang');
        var language = cookieLng || storedLng || this._fallBackLng;
        document.querySelector("html").setAttribute("lang", language.substring(0, 2));
        // Emit I18n ready
        this._eventListener.emit(this._i18nReady);
        this.isReady = true;
      },

      /**
       * Try to find the closest language as defined by browser
       * @private
       */
      _checkLanguageCompatibility: function() {
        var storedLng = gbc.StoredSettingsService.getLanguage();
        var cookieLng = gbc.StoredSettingsService._getCookie('lang');
        var language = cookieLng || storedLng || this._fallBackLng;

        if (language && !window.gbcLocales[language]) {
          var allLngKeys = Object.keys(window.gbcLocales);
          for (var i = 0; i < allLngKeys.length; i++) {
            if (language.startsWith(allLngKeys[i].substring(0, 2))) {
              this.setLng(allLngKeys[i]);
              gbc.StoredSettingsService.setSettings('gwc.app.locale', allLngKeys[i]);
              break;
            }
          }
        }
      },

      /**
       * Helper to get the browser current language
       * @returns {string} - locale id
       * @public
       */
      getBrowserLanguage: function() {
        return navigator.language || navigator.userLanguage;
      },

      /**
       * Get the normalized locale according to the parameter
       * Will do its best to identify an existing locale
       * @param {string} [locale] - initial str to test, if undef, will take browser language, or fallback one: en-US
       * @return {Array} list of usable locales as fallback (i.e: ["fr-FR","en-US"]) this list allways contain at least one item
       * @private
       */
      _getNormalizedLanguage: function(locale) {
        locale = typeof locale === "undefined" ? false : locale;
        var fallback = locale || this.getBrowserLanguage() || this._fallBackLng;
        var availableLC = Object.keys(window.gbcLocales);
        var fallbackLanguageList = [];
        var localeRegex = /^([a-z]{2})[-_]?([A-Z0-9]*)/;
        var r = null;
        var fallbackR = localeRegex.exec(fallback); // try to match fallback on standardized locale format

        if (fallbackR) {
          for (var i = 0; i < availableLC.length; i++) {
            r = localeRegex.exec(availableLC[i]);
            // Check perfect match (i.e 'es-ES'), then taking care of lang without region (i.e 'es-419', 'es_AR' will take only 'es' into account)
            if (availableLC[i].indexOf(fallback) === 0 || r[1] === fallbackR[1]) {
              if (availableLC[i] === locale) { // add it at begining of the array if the locale match
                fallbackLanguageList.unshift(availableLC[i]);
              } else { // add it at the end of the array
                fallbackLanguageList.push(availableLC[i]);
              }

            }
          }
        }
        // Use en-US as default if nothing found
        if (fallbackLanguageList.indexOf(this._fallBackLng) === -1) {
          fallbackLanguageList.push(this._fallBackLng);
        }
        return fallbackLanguageList;
      },

    });
    context.InitService.register(context.I18NService);
  });
;
"use strict";

modulum('InitService',
  function(context, cls) {

    /**
     * @class gbc.InitService
     */
    context.InitService = context.oo.StaticClass( /** @lends gbc.InitService */ {
      __name: "InitService",
      _builtinActionDefaultsKeys: ['enter', 'esc', 'f3', 'ctrl+f3', 'f4', 'f1', 'alt+f4', 'ctrl+f', 'ctrl+g', 'tab', 'shift+tab',
        'down', 'up', 'home', 'end', 'pageup', 'pagedown', 'ctrl+tab', 'ctrl+shift+tab'
      ],

      _services: [],

      _eventListener: new cls.EventListener(),

      create: function(auiData, app) {
        app = app || context.MockService.fakeApplication();
        var treeModificationTrack = new cls.TreeModificationTracker();
        var node = gbc.classes.NodeFactory.createRecursive(null, auiData, app, treeModificationTrack);
        node.createController();
        return node;
      },
      register: function(service) {
        this._services.push(service);
      },
      /**
       * Fallback method bound on body to manage accelerators when focused unfortunately moved to body
       * @param {domEvent} event - body keydown event
       * @private
       */
      onKeyFallback: function(event) {
        if (document.activeElement.tagName === "BODY") {

          var currentApp = context.SessionService.getCurrent() && context.SessionService.getCurrent().getCurrentApplication();
          if (currentApp && currentApp.keyboard) {

            // 1. Refocus UserInterface widget
            var appWidget = currentApp.getUI().getWidget();
            if (appWidget) {
              var uiWidget = appWidget._uiWidget;
              if (uiWidget) {
                uiWidget.setFocus();
              }
            }
            // 2. Using KeyboardApplicationService logic, we process the key
            currentApp.keyboard._onKeyDown(event);
          }
        }
      },
      _sendEvent: function(sequence) {
        var currentApp = context.SessionService.getCurrent().getCurrentApplication();
        var currentFocusedNode = currentApp.getFocusedVMNode();
        //send current node value
        currentFocusedNode.getController().getWidget().emit(context.constants.widgetEvents.change);
        if (currentApp) {
          context.SessionService.getCurrent().getCurrentApplication().typeahead.event(new cls.VMKeyEvent(sequence));
        }
      },
      initServices: function() {
        document.addEventListener("visibilitychange", function() {
          this.emit(context.constants.widgetEvents.visibilityChange);
        }.bind(this));
        for (var i = 0; i < this._services.length; i++) {
          this._services[i].init();
        }
      },
      /**
       * unique identifiers increments storage
       */
      _uniqueId: {
        asString: 0,
        asNumber: 0
      },

      destroy: function() {
        if (context.SessionService.getCurrent()) {
          var currentApp = context.SessionService.getCurrent().getCurrentApplication();
          if (currentApp) {
            currentApp.close();
          }
        }
      },

      /**
       * Get a unique identifier (an auto increment number)
       * @return {number}
       */
      uniqueId: function() {
        return ++this._uniqueId.asNumber;
      },

      /**
       * Get a unique identifier as string (based on an auto increment number)
       * @return {string} a unique identifier as string
       */
      uniqueIdAsString: function() {
        return "" + (++this._uniqueId.asString);
      },

      emit: function(eventName) {
        this._eventListener.emit(eventName);
      },
      when: function(eventName, hook) {
        return this._eventListener.when(eventName, hook);
      }

    });
  });
;
"use strict";

modulum('LayoutInvalidationService',
  function(context, cls) {

    /**
     * Layout Invalidation Service to manage layout invalidations
     * @namespace gbc.LayoutInvalidationService
     * @gbcService
     */
    context.LayoutInvalidationService = context.oo.StaticClass( /** @lends gbc.LayoutInvalidationService */ {
      __name: "LayoutInvalidationService",

      /**
       * next invalidation timestamp
       * @type {number}
       */
      _nextInvalidation: 2,

      /**
       * get next layout timestamp
       * @return {number} the next layout timestamp
       */
      nextInvalidation: function() {
        return this._nextInvalidation++;
      },

      getInitialInvalidation: function() {
        return Number.POSITIVE_INFINITY;
      }
    });
  });
;
"use strict";

modulum('BufferedConsoleLogProvider', ['LogProviderBase', 'ConsoleLogProvider'],
  function(context, cls) {

    /**
     * @class BufferedConsoleLogProvider
     * @memberOf classes
     * @extends classes.LogProviderBase
     */
    cls.BufferedConsoleLogProvider = context.oo.Class(cls.LogProviderBase, function($super) {
      return /** @lends classes.BufferedConsoleLogProvider.prototype */ {
        __name: "BufferedConsoleLogProvider",
        throttle: 100,
        buffer: null,
        console: null,
        currentLevel: "none",
        constructor: function() {
          $super.constructor.call(this);
          this.buffer = [];
          this.console = new cls.ConsoleLogProvider();
        },
        flush: function(force) {
          if (this.buffer.length) {
            if (force || this.buffer.length >= this.throttle) {
              this.console.getLogger()[this.currentLevel](this.buffer.join("\n"));
              this.buffer.length = 0;
            }
          }
        },
        getLogger: function() {
          var result = {};
          var levels = context.LogService.levels;
          for (var l = 0; l < levels.length; l++) {
            var item = levels[l];
            result[item] = this._loggerMethod.bind(this, item);
          }
          return result;
        },
        _loggerMethod: function(level, arg) {
          if (level !== "all") {
            this.flush(this.currentLevel !== level);
            this.currentLevel = level;
            this.buffer.push(arg);
          }
        }
      };
    });
  });
;
"use strict";

modulum('ConsoleLogProvider', ['LogProviderBase'],
  function(context, cls) {

    /**
     * @class ConsoleLogProvider
     * @memberOf classes
     * @extends classes.LogProviderBase
     */
    cls.ConsoleLogProvider = context.oo.Class(cls.LogProviderBase, /** @lends classes.ConsoleLogProvider.prototype */ {
      __name: "ConsoleLogProvider",
      getLogger: function() {
        return window.console;
      }
    });
  });
;
"use strict";

modulum('KeyboardPrefixedConsoleLogProvider', ['LogProviderBase'],
  function(context, cls) {

    /**
     * Console log provider to handle all keyboard logs
     * @class KeyboardPrefixedConsoleLogProvider
     * @memberOf classes
     * @extends classes.LogProviderBase
     */
    cls.KeyboardPrefixedConsoleLogProvider = context.oo.Class(cls.LogProviderBase, /** @lends classes.PrefixedConsoleLogProvider.prototype */ {
      __name: "KeyboardPrefixedConsoleLogProvider",
      _logger: null,

      /**
       * @inheritDoc
       */
      constructor: function(prefix, prefixStyle) {
        var _prefix = (prefixStyle ? "%c" : "") + prefix;
        this._logger = {
          debug: function() {
            var args = Array.prototype.slice.apply(arguments);
            if (prefixStyle) {
              args.unshift(prefixStyle);
            }
            args.unshift(_prefix);
            console.debug.apply(console, args);
          },
          log: function() {
            var args = Array.prototype.slice.apply(arguments);
            if (prefixStyle) {
              args.unshift(prefixStyle);
            }
            args.unshift(_prefix);
            console.log.apply(console, args);
          },
          info: function() {
            var args = Array.prototype.slice.apply(arguments);
            if (prefixStyle) {
              args.unshift(prefixStyle);
            }
            args.unshift(_prefix);
            console.info.apply(console, args);
          },
          warn: function() {
            var args = Array.prototype.slice.apply(arguments);
            if (prefixStyle) {
              args.unshift(prefixStyle);
            }
            args.unshift(_prefix);
            console.warn.apply(console, args);
          },
          error: function() {
            var args = Array.prototype.slice.apply(arguments);
            if (prefixStyle) {
              args.unshift(prefixStyle);
            }
            args.unshift(_prefix);
            console.error.apply(console, args);
          },
          record: function() {
            var t = new Date().getTime();
            var args = Array.prototype.slice.call(arguments);
            var bufferedKey = args[1];
            var eventKey = args[2];

            var keyMatch = args[0].match(/(Delayed|onKeyDown|processKey).*: (.*)/);

            var entry = {
              provider: prefix.replace(/\s/g, ''), // Change [KEYBOARD   ] to [KEYBOARD]
              t: t,
              type: keyMatch ? keyMatch[1] : "unknown",
              bufferedKey: bufferedKey,
              eventKey: eventKey
            };
            context.LogService.record(entry);
          }
        };
      },

      /**
       * @inheritDoc
       */
      getLogger: function() {
        return this._logger;
      }
    });
  });
;
"use strict";

modulum('LoggerBase', ['LogService'],
  function(context, cls) {
    var abstractLoggerMethods = {};
    for (var levelId = 1; levelId < context.LogService.levels.length; levelId++) {
      abstractLoggerMethods[context.LogService.levels[levelId]] = Function.noop;
    }
    cls.AbstractLogger = context.oo.Class(abstractLoggerMethods);

    /**
     * @class LoggerBase
     * @memberOf classes
     */
    cls.LoggerBase = context.oo.Class(abstractLoggerMethods);
  });
;
"use strict";

modulum('LogProviderBase',
  function(context, cls) {

    /**
     * @class LogProviderBase
     * @memberOf classes
     */
    cls.LogProviderBase = context.oo.Class( /** @lends classes.LogProviderBase.prototype */ {
      __name: "LogProviderBase",

      /** @type {boolean} */
      _enabled: false,

      /**
       * Get the logger with all necessary methods
       * @return {Object|null}
       */
      getLogger: function() {
        throw "LogProvider is abstract. Implement it to log.";
      },

      /**
       * Activate this logProvider
       * @param {Boolean} enable - true to enable, false otherwise
       */
      enable: function(enable) {
        this._enabled = enable;
      },

      /**
       * Check if this logProvider is enabled
       * @return {boolean} true if enabled, false otherwise
       */
      isEnabled: function() {
        return this._enabled;
      }
    });
  });
;
"use strict";

modulum('LogService', ['InitService', 'ConsoleLogProvider', 'StoredSettingsService'],
  function(context, cls) {

    /**
     * @class gbc.LogService
     */
    context.LogService = context.oo.StaticClass( /** @lends gbc.LogService */ {
      __name: "LogService",
      /**
       * @type {string}
       */
      _currentLevel: "none",
      /**
       * @type {string[]}
       */
      levels: ["all", "debug", "log", "info", "warn", "error"],
      /**
       * @type {Object<string, classes.LogProviderBase>}
       */
      _providers: {
        _default: new cls.ConsoleLogProvider()
      },
      /**
       * @type {Array<string>}
       */
      _activeLoggers: null,
      /**
       * @type {Object<string, string>}
       */
      _labels: {},

      /** @type {Boolean} **/
      _enableRecording: false,
      /** @type {Object} **/
      _recordingsHeaders: null,
      /** @type {Array<Object>} **/
      _recordings: null,
      /** @type {Object} **/
      _recordingsImages: null,

      /**
       * initialize service
       */
      init: function() {
        this._currentLevel = context.StoredSettingsService.getLoglevel();
        this._activeLoggers = context.StoredSettingsService.getLogtypes();
        this.changeLevel(this._currentLevel, true);

        var qs = context.UrlService.currentUrl().getQueryStringObject();
        this.enableRecording(!!qs.recordGbcLog); // QueryString  ?recordGbcLog=1  will enable this
        gbc.DebugService.whenActivationChanged(function() {
          if (gbc.LogService.isRecordingEnabled()) {
            gbc.LogService._recordingsHeaders.gbcInfos.debugMode = gbc.DebugService.isActive();
          }
        });
      },

      /**
       *
       * @param {string} level
       * @return {number}
       * @private
       */
      _intLevel: function(level) {
        return this.levels.indexOf(level);
      },

      /**
       *
       * @return {string}
       */
      getCurrentLevel: function() {
        return this._currentLevel;
      },

      /**
       * @param {string} newLevel
       * @param {boolean} force
       */
      changeLevel: function(newLevel, force) {
        var intlevel = this._intLevel(this._currentLevel);
        var intnewlevel = this._intLevel(newLevel);
        if (force || (intnewlevel !== intlevel)) {
          this._currentLevel = newLevel;
          var p = Object.keys(this._providers);
          for (var i = 0; i < p.length; i++) {
            this._prepareLogger(p[i], this._isActive(p[i] || "_default") ? intnewlevel : -1);
          }
        }
      },

      /**
       * @param {classes.LogProviderBase} provider
       * @param {string|Array<string>} type
       * @param {string} [label]
       */
      registerLogProvider: function(provider, type, label) {
        var types = (Array.isArray(type) ? type : [type]);
        for (var i = 0; i < types.length; i++) {
          if (label) {
            this._labels[types[i] || "_default"] = label;
          }
          this._providers[types[i] || "_default"] = provider;
          this._prepareLogger(types[i] || "_default", this._isActive(types[i] || "_default") ? this._intLevel(this._currentLevel) :
            -1);
        }
      },

      /**
       *
       * @param {string} type
       * @param {number} intnewlevel
       * @private
       */
      _prepareLogger: function(type, intnewlevel) {
        var target = this;
        if (type !== "_default") {
          this[type] = {};
          target = this[type];
        }
        for (var i = 1; i < this.levels.length; i++) {
          var levelName = this.levels[i];
          if (intnewlevel < 0 || intnewlevel > i) {
            target[levelName] = this._getLogMethod(type, "record");
          } else {
            target[levelName] = this._getLogMethod(type, levelName);
          }
        }
      },

      /**
       *
       * @param {string} type
       * @return {boolean}
       * @private
       */
      _isActive: function(type) {
        return !this._activeLoggers || this._activeLoggers.indexOf(type) >= 0;
      },

      /**
       *
       * @param {string} logType
       * @param {string} level
       * @return {Function}
       * @private
       */
      _getLogMethod: function(logType, level) {
        var provider = this._providers[logType] || this._providers._default;
        var recordEnabled = this.isRecordingEnabled();
        return function() {
          if (provider.isEnabled()) {
            if (level !== "record") {
              provider.getLogger()[level].apply(provider.getLogger(), arguments);
              // If Record is enabled, use record method of the logger
              if (recordEnabled && provider.getLogger().record) {
                provider.getLogger().record.apply(provider.getLogger(), arguments);
              }
            } else {
              if (recordEnabled && provider.getLogger().record) {
                provider.getLogger().record.apply(provider.getLogger(), arguments);
              }
            }
          }
          // Not enabled: record anyway if enabled
          else if (recordEnabled && provider.getLogger().record) {
            provider.getLogger().record.apply(provider.getLogger(), arguments);
          }
        };
      },
      debug: function() {
        console.debug.apply(console, arguments);
      },
      log: function() {
        console.log.apply(console, arguments);
      },
      info: function() {
        console.info.apply(console, arguments);
      },
      warn: function() {
        console.warn.apply(console, arguments);
      },
      error: function() {
        console.error.apply(console, arguments);
      },

      /**
       * @return {Array<{name:string, label:string}>}
       */
      getTypes: function() {
        return Object.keys(this._providers).map(function(k) {
          return {
            name: k,
            label: this._labels[k] || k
          };
        }.bind(this));
      },

      /**
       * @return {Array<string>}
       */
      getActiveLogTypes: function() {
        return this._activeLoggers;
      },

      /**
       * @param {string} type
       */
      toggleType: function(type) {
        if (!this._activeLoggers) {
          this._activeLoggers = Object.keys(this._providers);
        }
        if (this._activeLoggers.indexOf(type) >= 0) {
          this._activeLoggers.remove(type);
        } else {
          this._activeLoggers.push(type);
        }
        this._prepareLogger(type || "_default", this._isActive(type || "_default") ? this._intLevel(this._currentLevel) : -1);
      },

      /**
       * Activate the providers
       * @param {Boolean} enable - true to enable the providers, false otherwise
       */
      enableProviders: function(enable) {
        var providers = Object.keys(this._providers);
        for (var i = 0; i < providers.length; i++) {
          this._providers[providers[i]].enable(enable);
        }
      },

      /**
       * Activate recording of GBClog
       * @param {boolean} enabled - true to enable the recording
       */
      enableRecording: function(enabled) {
        if (enabled) {
          this._recordings = [];
          this._enableRecording = enabled;

          // Ensure last recorded log has been saved
          var memoryLogs = gbc.LocalSettingsService.read("logPlayer");
          if (memoryLogs) {
            var useMemoryLog = window.confirm(i18next.t('gwc.logPlayer.unsavedConfirm'));
            if (useMemoryLog) {
              this._recordingsHeaders = memoryLogs.headers;
              this._recordings = memoryLogs.log;
              this.download("recovered_" + memoryLogs.filename);
            }
            gbc.LocalSettingsService.write("logPlayer", null);
          }
          var winRect = window.document.body.getBoundingClientRect();
          // Save useful informations
          this._recordingsHeaders = {
            logType: "gbcLog",
            runDate: new Date(),
            gbcInfos: {
              version: gbc.version,
              build: gbc.build,
              platformName: window.gbcWrapper.platformName,
              protocolType: window.gbcWrapper.protocolType,
              activeTheme: gbc.ThemeService.getCurrentTheme(),
              availableThemes: gbc.ThemeService.getAvailableThemes(),
              isSideBarVisible: gbc.StoredSettingsService.isSideBarVisible(),
              sideBarSize: gbc.StoredSettingsService.getSideBarwidth() || parseInt(gbc.ThemeService.getValue(
                "theme-sidebar-default-width"), 10),
              debugMode: gbc.DebugService.isActive()
            },
            browserInfos: {
              userAgent: window.navigator.userAgent,
              os: navigator.platform,
              activeLanguage: navigator.language,
              availableLanguages: navigator.languages,
              dimension: {
                width: parseInt(winRect.width, 10),
                height: parseInt(winRect.height, 10),
              },
              url: window.location.href
            },
            themeVariables: gbc.ThemeService._currentVariables,
            storedSettings: gbc.StoredSettingsService._storedSettings,
            logs: []
          };
          // end of headers
          this._recordingsImages = {}; // init image list

          gbc.InitService.when(gbc.constants.widgetEvents.onBeforeUnload, function() {
            var session = gbc.SessionService.getCurrent();
            var filename = session.getAppId() + "-" + session.getSessionId().substr(0, 8) + ".gbclog";
            // If there is an un-saved log, store it into the memory before leaving
            if (this._recordingsHeaders.logType) {
              gbc.LocalSettingsService.write("logPlayer", {
                headers: this._recordingsHeaders,
                log: this._recordings,
                filename: filename
              });
            }
          }.bind(this));
        }
      },

      /**
       * Check if recording is enabled on this session
       * @return {boolean} true if enabled, false otherwise
       */
      isRecordingEnabled: function() {
        return this._enableRecording;
      },

      /**
       * Add an entry to the record
       * @param {Object} entry
       */
      record: function(entry) {
        if (!entry.appId) {
          var session = gbc.SessionService.getCurrent();
          var app = session && session.getCurrentApplication();
          if (app) {
            entry.appId = app.applicationHash;
          }
        }
        this._recordings.push(entry);
      },

      /**
       * Map image to its base64 equivalent
       * @param imgWidget
       * @param {Boolean} usePlaceholder - true to use a generated placeHolder
       */
      addImage: function(imgWidget, usePlaceholder) {
        console.log("Image: add it with placeholder", usePlaceholder);
        if (usePlaceholder) {
          var size = imgWidget.getNaturalDimension(),
            width = size.width,
            height = size.height,
            backgroundColor = '#bbdefb',
            fontColor = '#000000',
            canvas = document.createElement('canvas');

          /* set canvas stage */
          canvas.id = "placeholder";
          canvas.width = width;
          canvas.height = height;

          /* set canvas stage */
          canvas.id = "placeholder";
          canvas.width = width;
          canvas.height = height;

          /* add content */
          var ctx = canvas.getContext('2d');
          ctx.fillStyle = backgroundColor;
          ctx.fillRect(0, 0, width, height);

          ctx.fillStyle = fontColor;
          ctx.font = '16px Courier';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.lineWidth = 4;
          ctx.strokeStyle = "#FF0000";
          // Drow cross
          ctx.beginPath();
          ctx.moveTo(0, 2);
          ctx.lineTo(canvas.width, canvas.height - 2);
          ctx.moveTo(0, canvas.height - 2);
          ctx.lineTo(canvas.width + 2, 0);
          ctx.strokeRect(0, 0, canvas.width, canvas.height);
          ctx.lineWidth = 2;
          //ctx.fillText($0.alt, (width / 2), (height / 2) + height/3)
          ctx.stroke();
          ctx.closePath();

          /* convert to image base64 */
          this._recordingsImages[imgWidget.getValue()] = canvas.toDataURL('image/png');
        } else {
          // Use real image encoded to base64 (take more space in output file)
          window.toDataURL(
            imgWidget.getValue(),
            function(dataUrl) {
              this._recordingsImages[imgWidget.getValue()] = dataUrl;
            }.bind(this),
            "image/png"
          );
        }

      },

      /**
       * Get the last record
       * @return {Object} last recorded entry
       */
      getLastRecord: function() {
        return this._recordings[this._recordings.length - 1];
      },

      /**
       * Function to download data to a file
       * @param {String?} filename - give a name to the file to download (if no name, generate it)
       * @return {boolean}
       */
      download: function(filename) {
        if (!this.isRecordingEnabled()) {
          console.warn(i18next.t("gwc.logPlayer.notEnabled"));
          return false;
        }

        var qs = context.UrlService.currentUrl().getQueryStringObject();
        var session = gbc.SessionService.getCurrent();
        filename = filename ? filename : (session.getAppId() + "-" + session.getSessionId().substr(0, 8) + (qs.withRealImages ?
          "_realImages" : "") + ".gbclog");

        var type = "json";
        var logContent = this.getLogContent();

        var file = new Blob([logContent], {
          type: type
        });
        if (window.navigator.msSaveOrOpenBlob) { // IE10+
          window.navigator.msSaveOrOpenBlob(file, filename);
        } else { // Others
          var a = document.createElement("a"),
            url = URL.createObjectURL(file);
          a.href = url;
          a.download = filename;
          document.body.appendChild(a);
          a.click();
          setTimeout(function() {
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
          }, 0);
        }
        this.clearLog();
      },

      /**
       * Get JSON stringified content of the log
       * @param {string} [format] - choose output format (json or string(default))
       * @return {string} content
       */
      getLogContent: function(format) {
        format = typeof format === "string" ? format : "string";
        this._recordingsHeaders.logs = this._recordings;
        this._recordingsHeaders.images = this._recordingsImages;
        return format === "string" ? JSON.stringify(this._recordingsHeaders, null, 2) : this._recordingsHeaders;
      },

      clearLog: function() {
        gbc.LocalSettingsService.write("logPlayer", null);
        this._recordingsHeaders = {};
        this._recordingsImages = {};
        this._recordings = [];
      }

    });
    context.InitService.register(context.LogService);
  });
;
"use strict";

modulum('MousePrefixedConsoleLogProvider', ['LogProviderBase'],
  function(context, cls) {

    /**
     * Console log provider to handle all mouse logs
     * @class MousePrefixedConsoleLogProvider
     * @memberOf classes
     * @extends classes.LogProviderBase
     */
    cls.MousePrefixedConsoleLogProvider = context.oo.Class(cls.LogProviderBase, /** @lends classes.PrefixedConsoleLogProvider.prototype */ {
      __name: "MousePrefixedConsoleLogProvider",
      _logger: null,

      /**
       * @inheritDoc
       */
      constructor: function(prefix, prefixStyle) {
        var _prefix = (prefixStyle ? "%c" : "") + prefix;
        this._logger = {
          debug: function() {
            var args = Array.prototype.slice.apply(arguments);
            if (prefixStyle) {
              args.unshift(prefixStyle);
            }
            args.unshift(_prefix);
            console.debug.apply(console, args);
          },
          log: function() {
            var args = Array.prototype.slice.apply(arguments);
            if (prefixStyle) {
              args.unshift(prefixStyle);
            }
            args.unshift(_prefix);
            console.log.apply(console, args);
          },
          info: function() {
            var args = Array.prototype.slice.apply(arguments);
            if (prefixStyle) {
              args.unshift(prefixStyle);
            }
            args.unshift(_prefix);
            console.info.apply(console, args);
          },
          warn: function() {
            var args = Array.prototype.slice.apply(arguments);
            if (prefixStyle) {
              args.unshift(prefixStyle);
            }
            args.unshift(_prefix);
            console.warn.apply(console, args);
          },
          error: function() {
            var args = Array.prototype.slice.apply(arguments);
            if (prefixStyle) {
              args.unshift(prefixStyle);
            }
            args.unshift(_prefix);
            console.error.apply(console, args);
          },
          record: function() {
            var args = Array.prototype.slice.call(arguments);
            var logStr = args[0];
            var mouse = logStr.match(/(onClick|onRightClick)/);
            var t = new Date().getTime();

            if (mouse) {
              var evt = args[1];
              var itemId = args[1].target.id || args[1].target.closest("gbc_WidgetBase") ? args[1].target.closest(
                "gbc_WidgetBase").getAttribute("data-aui-name") : null;

              var entry = {
                provider: prefix.replace(/\s/g, ''),
                t: t,
                itemId: itemId,
                itemElement: args[1].target.outerHTML,
                clientX: evt.clientX,
                clientY: evt.clientY,
                rightClick: mouse[1] === "onRightClick",
              };

              context.LogService.record(entry);
            }
          },
        };
      },

      /**
       * @inheritDoc
       */
      getLogger: function() {
        return this._logger;
      }
    });
  });
;
"use strict";

modulum('NetworkPrefixedConsoleLogProvider', ['LogProviderBase'],
  function(context, cls) {

    /**
     * Console log provider to handle all Network logs
     * @class NetworkPrefixedConsoleLogProvider
     * @memberOf classes
     * @extends classes.LogProviderBase
     */
    cls.NetworkPrefixedConsoleLogProvider = context.oo.Class(cls.LogProviderBase, /** @lends classes.PrefixedConsoleLogProvider.prototype */ {
      __name: "NetworkPrefixedConsoleLogProvider",
      _logger: null,

      /**
       * @inheritDoc
       */
      constructor: function(prefix, prefixStyle) {
        var _prefix = (prefixStyle ? "%c" : "") + prefix;
        this._logger = {
          debug: function() {
            var args = Array.prototype.slice.apply(arguments);
            if (prefixStyle) {
              args.unshift(prefixStyle);
            }
            args.unshift(_prefix);
            console.debug.apply(console, args);
          },
          log: function() {
            var args = Array.prototype.slice.apply(arguments);
            if (prefixStyle) {
              args.unshift(prefixStyle);
            }
            args.unshift(_prefix);
            console.log.apply(console, args);
          },
          info: function() {
            var args = Array.prototype.slice.apply(arguments);
            if (prefixStyle) {
              args.unshift(prefixStyle);
            }
            args.unshift(_prefix);
            console.info.apply(console, args);
          },
          warn: function() {
            var args = Array.prototype.slice.apply(arguments);
            if (prefixStyle) {
              args.unshift(prefixStyle);
            }
            args.unshift(_prefix);
            console.warn.apply(console, args);
          },
          error: function() {
            var args = Array.prototype.slice.apply(arguments);
            if (prefixStyle) {
              args.unshift(prefixStyle);
            }
            args.unshift(_prefix);
            console.error.apply(console, args);
          },
          record: function() {
            var args = Array.prototype.slice.call(arguments);
            var logStr = args.join(" ");
            var isRequest = logStr.indexOf("HTTP REQUEST") >= 0;
            var isResponse = logStr.indexOf("HTTP RESPONSE") >= 0;
            var t = new Date().getTime();

            if (isRequest || isResponse) {
              var urlInfo = args[1].match(
                /(\w*).*(POST|GET).*\/ua\/(\w+)\/([a-f0-9]*).*\??(appId=(\d*)&pageId=(\d*))?/);
              var appId = urlInfo ? parseInt(urlInfo[5]) : context.LogService.getLastRecord().appId;
              var pageId = urlInfo ? parseInt(urlInfo[6]) : context.LogService.getLastRecord().pageId;
              var uaType = urlInfo ? urlInfo[3] : "unknown";
              var entry = {
                provider: prefix.replace(/\s/g, ''),
                t: t,
                httpType: args[0].trim(),
                httpMethod: urlInfo && urlInfo[2],
                uaType: uaType,
                uaDetails: urlInfo && urlInfo[1],
                type: args[1].trim(),
                data: args[2] && ("" + args[2]).trim()
              };

              if (uaType === "sua") {
                entry.appId = appId;
                entry.pageId = pageId;
              }

              context.LogService.record(entry);
            }
          },
        };
      },

      /**
       * @inheritDoc
       */
      getLogger: function() {
        return this._logger;
      }
    });
  });
;
"use strict";

modulum('NoLogProvider', ['LogService', 'LogProviderBase'],
  function(context, cls) {

    var noLog = {};
    var levels = context.LogService.levels;
    for (var i = 0; i < levels.length; i++) {
      var item = levels[i];
      noLog[item] = Function.noop;
    }
    /**
     * @class NoLogProvider
     * @memberOf classes
     * @extends classes.LogProviderBase
     */
    cls.NoLogProvider = context.oo.Class(cls.LogProviderBase, /** @lends classes.NoLogProvider.prototype */ {
      __name: "NoLogProvider",

      getLogger: function() {
        return noLog;
      }
    });
  });
;
"use strict";

modulum('PrefixedConsoleLogProvider', ['LogProviderBase'],
  function(context, cls) {

    /**
     * @class PrefixedConsoleLogProvider
     * @memberOf classes
     * @extends classes.LogProviderBase
     */
    cls.PrefixedConsoleLogProvider = context.oo.Class(cls.LogProviderBase, /** @lends classes.PrefixedConsoleLogProvider.prototype */ {
      __name: "PrefixedConsoleLogProvider",
      _logger: null,

      constructor: function(prefix, prefixStyle) {
        var _prefix = (prefixStyle ? "%c" : "") + prefix;
        this._logger = {
          debug: function() {
            var args = Array.prototype.slice.apply(arguments);
            if (prefixStyle) {
              args.unshift(prefixStyle);
            }
            args.unshift(_prefix);
            console.debug.apply(console, args);
          },
          log: function() {
            var args = Array.prototype.slice.apply(arguments);
            if (prefixStyle) {
              args.unshift(prefixStyle);
            }
            args.unshift(_prefix);
            console.log.apply(console, args);
          },
          info: function() {
            var args = Array.prototype.slice.apply(arguments);
            if (prefixStyle) {
              args.unshift(prefixStyle);
            }
            args.unshift(_prefix);
            console.info.apply(console, args);
          },
          warn: function() {
            var args = Array.prototype.slice.apply(arguments);
            if (prefixStyle) {
              args.unshift(prefixStyle);
            }
            args.unshift(_prefix);
            console.warn.apply(console, args);
          },
          error: function() {
            var args = Array.prototype.slice.apply(arguments);
            if (prefixStyle) {
              args.unshift(prefixStyle);
            }
            args.unshift(_prefix);
            console.error.apply(console, args);
          },
          record: function() {
            var args = Array.prototype.slice.call(arguments);
            var logStr = args.join(" ");
            var t = new Date().getTime();

            var entry = {
              provider: prefix.replace(/\s/g, ''),
              t: t,
              log: logStr
            };
            context.LogService.record(entry);
          }
        };
      },
      getLogger: function() {
        return this._logger;
      }
    });
  });
;
"use strict";

modulum('UiPrefixedConsoleLogProvider', ['LogProviderBase'],
  function(context, cls) {

    /**
     * Console log provider to handle all UI logs
     * @class UiPrefixedConsoleLogProvider
     * @memberOf classes
     * @extends classes.LogProviderBase
     */
    cls.UiPrefixedConsoleLogProvider = context.oo.Class(cls.LogProviderBase, /** @lends classes.PrefixedConsoleLogProvider.prototype */ {
      __name: "UiPrefixedConsoleLogProvider",
      _logger: null,

      /**
       * @inheritDoc
       */
      constructor: function(prefix, prefixStyle) {
        var _prefix = (prefixStyle ? "%c" : "") + prefix;
        this._logger = {
          debug: function() {
            var args = Array.prototype.slice.apply(arguments);
            if (prefixStyle) {
              args.unshift(prefixStyle);
            }
            args.unshift(_prefix);
            console.debug.apply(console, args);
          },
          log: function() {
            var args = Array.prototype.slice.apply(arguments);
            if (prefixStyle) {
              args.unshift(prefixStyle);
            }
            args.unshift(_prefix);
            console.log.apply(console, args);
          },
          info: function() {
            var args = Array.prototype.slice.apply(arguments);
            if (prefixStyle) {
              args.unshift(prefixStyle);
            }
            args.unshift(_prefix);
            console.info.apply(console, args);
          },
          warn: function() {
            var args = Array.prototype.slice.apply(arguments);
            if (prefixStyle) {
              args.unshift(prefixStyle);
            }
            args.unshift(_prefix);
            console.warn.apply(console, args);
          },
          error: function() {
            var args = Array.prototype.slice.apply(arguments);
            if (prefixStyle) {
              args.unshift(prefixStyle);
            }
            args.unshift(_prefix);
            console.error.apply(console, args);
          },
          record: function() {
            var args = Array.prototype.slice.call(arguments);
            var logStr = args[0];
            var t = new Date().getTime();
            var name = args[2];
            var type = logStr.match(/\w*/);

            var data = {};
            if (args[3]) {
              if (name === "ContextMenuWidget") {
                data.x = args[3].x;
                data.auiTag = args[3]._auiTag;
                data.parentName = args[3].getParentWidget().__name;
              }
              if (name === "ImageWidget") {
                var imgWidget = args[3];
                data.size = imgWidget.getLayoutInformation().getMeasured();
                data.auiTag = imgWidget._auiTag;

                var qs = context.UrlService.currentUrl().getQueryStringObject();
                var useRealImage = !!qs.withRealImages; // QueryString  &withRealImages=1  will enable this

                context.LogService.addImage(imgWidget, !useRealImage); // add image for easy mapping
              }
            }

            var entry = {
              provider: prefix.replace(/\s/g, ''), // Change [UI      ] to [UI]
              t: t,
              type: type[0].toLowerCase(),
              status: args[1],
              name: name,
              data: data
            };

            context.LogService.record(entry);
          },
        };
      },

      /**
       * @inheritDoc
       */
      getLogger: function() {
        return this._logger;
      }
    });
  });
;
"use strict";

modulum('LogPlayerService',
  function(context, cls) {

    /**
     * Log Player Service to centralize log playing logic used in LogPlayerWidget and in UR Log Player
     * @namespace gbc.LogPlayerService
     * @gbcService
     */
    context.LogPlayerService = context.oo.StaticClass( /** @lends gbc.LogPlayerService */ {
      __name: "LogPlayerService",

      /**
       * @type {Map<number, Map<number, classes.VMApplication>>}
       */
      _fakeSessions: null,

      /**
       * Get the mock application registered with a session id and an application id
       * @param {number} sessionId
       * @param {number} appId
       * @returns {classes.VMApplication}
       */
      getApplication: function(sessionId, appId) {
        if (!this._fakeSessions) {
          this._fakeSessions = new Map();
        }
        if (!this._fakeSessions.has(sessionId)) {
          this._fakeSessions.set(sessionId, new Map());
        }
        var fakeSession = this._fakeSessions.get(sessionId);
        if (!fakeSession.has(appId)) {
          var app = window.gbc.MockService.fakeApplication();
          app.setRunning(true);
          app.info().webComponent = window.location.origin +
            window.location.pathname.replace(/\/[^\/]+$/, "/") +
            context.ThemeService.getResource("webcomponents");
          fakeSession.set(appId, app);
        }
        return fakeSession.get(appId);
      },

      /**
       * Set a given app visible
       * @param {classes.VMApplication} app- application to set visible
       */
      setVisibleApplication: function(app) {
        var session = app.getSession();
        if (session) {
          session.getWidget().setCurrentWidget(app.getUI().getWidget());
        }
      },

      /**
       * Unregister a mock application
       * @param sessionId
       * @param appId
       */
      removeApplication: function(sessionId, appId) {
        if (!this._fakeSessions) {
          this._fakeSessions = new Map();
        }
        var session = this._fakeSessions.get(sessionId);
        if (session) {
          session.delete(appId);
          if (!session.size) {
            this._fakeSessions.delete(sessionId);
          }
        }
      },

      /**
       * Clean all applications/session
       */
      cleanApplications: function() {
        if (this._fakeSessions) {
          this._fakeSessions.clear();
        }
      },

      /**
       * Replace resource reference with mock ones
       * @param {string} order
       * @param {Object?} imageMap
       * @returns {string}
       */
      mockOrderResources: function(order, imageMap) {
        var imgMock = context.ThemeService.getResource("img/logo.png"),
          ttfMock = context.ThemeService.getResource("fonts/materialdesignicons-webfont.ttf");

        var imgReplacer = function(tpl, data) {
          return tpl.replace(/([^"]+\.(png|jpg|gif|svg))(\?[^\\"]+)?/g, function(id) {
            return data && data[id] || imgMock;
          });
        };

        order = imgReplacer(order, imageMap);

        return order.replace(/"[^"]+\.ttf\?[^"]+"/g, "\"" + ttfMock + "\"") // Fonts
          .replace(/componentType "[^"]+"/g, "componentType \"empty\""); // webcomponents
      }
    });
  });
;
"use strict";

modulum('MockService', ['InitService'],
  function(context, cls) {

    /**
     * @class gbc.MockService
     */
    context.MockService = context.oo.StaticClass( /** @lends gbc.MockService */ {
      __name: "MockService",
      _init: false,
      init: function() {},

      fakeApplication: function(forUnit) {
        if (!this._init) {
          this._init = true;
          context.LogService.registerLogProvider(new cls.ConsoleLogProvider(), "networkProtocol", "FakeApp Network");
          context.LogService.registerLogProvider(new cls.BufferedConsoleLogProvider(), null);
          gbc.start();
        }
        var currentSession = context.SessionService.getCurrent();
        if (forUnit) {
          if (currentSession) {
            currentSession.destroy(true);
            currentSession = null;
          }

          // Force ListView to be Table for unit tests
          if (window.isMobile()) {
            window.gbc.ThemeService.setValue("theme-table-default-widget", "table");
          }
        }
        var params = {
          mode: "no"
        };
        var newApp = null;
        if (!currentSession) {
          newApp = context.SessionService.start("fake", params).getCurrentApplication();
          newApp.getSession()._sessionId = "00000000000000000000000000000000";
        } else {
          currentSession.start("fake", params);
          newApp = currentSession.getCurrentApplication();
        }
        newApp.applicationInfo.ignoreFrontcallModules = ["webcomponent"];
        return newApp;
      }
    });
    context.InitService.register(context.MockService);
  });
;
"use strict";

modulum('MouseService', ['InitService'],
  function(context, cls) {

    /**
     * @namespace gbc.MouseService
     */
    context.MouseService = context.oo.StaticClass( /** @lends gbc.MouseService */ {
      __name: "MouseService",

      /**
       *  Init mouse service
       */
      init: function() {
        document.body.on("click.MouseService", this._onClick.bind(this));
        document.body.on("contextmenu.MouseService", this._onRightClick.bind(this));
        document.body.on("dblclick.MouseService", this._onDblClick.bind(this));
      },

      /**
       * Click handler bound on body element. Catch all click events and propagate it to the corresponding widget.
       * @param event
       * @private
       */
      _onClick: function(event) {
        context.LogService.mouse.log("onClick event : ", event);

        var targetElement = event.target;

        // if overlay is visible, we hide displayed dropdowns and prevent default click events behaviors
        if (cls.DropDownWidget.hasAnyVisible() && !cls.DropDownWidget.isChildOfDropDown(targetElement)) {
          cls.DropDownWidget.hideAll();
          return false;
        }

        // search widget from dom event
        var widget = gbc.WidgetService.getWidgetFromElement(targetElement);

        // if a widget is found
        if (widget) {

          var rect = null;
          if ((!event.clientX || event.clientX < 0) && (!event.clientY || event.clientY < 0)) {
            rect = event.target.getBoundingClientRect();
            context.WidgetService.cursorX = rect.left;
            context.WidgetService.cursorY = rect.top;
          } else {
            context.WidgetService.cursorX = event.clientX;
            context.WidgetService.cursorY = event.clientY;
          }

          if (widget.isInTable()) {
            widget.emit(context.constants.widgetEvents.tableClick, event);
          }

          var bubbles = widget.manageMouseClick(event);

          // bubble event to parent *DOM* widget
          if (bubbles) {
            var widgetElement = targetElement.elementOrParent("gbc_WidgetBase");
            var parentWidgetElement = widgetElement.parent("gbc_WidgetBase");
            while (parentWidgetElement && bubbles) {
              var parentWidget = gbc.WidgetService.getWidgetFromElement(parentWidgetElement);
              if (parentWidget) {
                if (parentWidget.isInTable()) {
                  parentWidget.emit(context.constants.widgetEvents.tableClick, event);
                }
                bubbles = parentWidget.manageMouseClick(event);
              }
              parentWidgetElement = parentWidgetElement.parent("gbc_WidgetBase");
            }
          }
        }
      },

      /**
       * Click handler bound on body element. Catch all rightclick events and propagate it to the corresponding widget.
       * @param event
       * @private
       */
      _onRightClick: function(event) {
        context.LogService.mouse.log("onRightClick event : ", event);

        var targetElement = event.target;

        // if overlay is visible, we hide displayed dropdowns and prevent default click events behaviors
        if (cls.DropDownWidget.hasAnyVisible() && !cls.DropDownWidget.isChildOfDropDown(targetElement)) {
          cls.DropDownWidget.hideAll();
          event.preventCancelableDefault();
          return false;
        }

        // search widget from dom event
        var widget = gbc.WidgetService.getWidgetFromElement(targetElement);

        // if a widget is found
        if (widget) {

          var bubbles = widget.manageMouseRightClick(event);

          // bubble event to parent *DOM* widget
          if (bubbles) {
            var widgetElement = targetElement.elementOrParent("gbc_WidgetBase");
            var parentWidgetElement = widgetElement.parent("gbc_WidgetBase");
            while (parentWidgetElement && bubbles) {
              var parentWidget = gbc.WidgetService.getWidgetFromElement(parentWidgetElement);
              if (parentWidget) {
                bubbles = parentWidget.manageMouseRightClick(event);
              }
              parentWidgetElement = parentWidgetElement.parent("gbc_WidgetBase");
            }
          }
        }
      },

      /**
       * Click handler bound on body element. Catch all dblclick events and propagate it to the corresponding widget.
       * @param event
       * @private
       */
      _onDblClick: function(event) {
        context.LogService.mouse.log("onDblClick event : ", event);

        var targetElement = event.target;

        // search widget from dom event
        var widget = gbc.WidgetService.getWidgetFromElement(targetElement);

        // if a widget is found
        if (widget) {

          var bubbles = widget.manageMouseDblClick(event);

          // bubble event to parent *DOM* widget
          if (bubbles) {
            var widgetElement = targetElement.elementOrParent("gbc_WidgetBase");
            var parentWidgetElement = widgetElement.parent("gbc_WidgetBase");
            while (parentWidgetElement && bubbles) {
              var parentWidget = gbc.WidgetService.getWidgetFromElement(parentWidgetElement);
              if (parentWidget) {
                bubbles = parentWidget.manageMouseDblClick(event);
              }
              parentWidgetElement = parentWidgetElement.parent("gbc_WidgetBase");
            }
          }
        }
      }

    });
    context.InitService.register(context.MouseService);
  });
;
"use strict";

modulum('NativeService',
  function(context, cls) {

    /**
     * Native Service to interact with native in UR mode
     * @namespace gbc.NativeService
     * @gbcService
     */
    context.NativeService = context.oo.StaticClass( /** @lends gbc.NativeService */ {
      __name: "NativeService",

      /**
       *
       * @param {{name:string, args:Array}} data
       */
      onNativeAction: function(data) {
        if (data) {
          var app = context.SessionService.getCurrent().getCurrentApplication();
          switch (data.name) {
            case "notificationpushed":
              app.typeahead.nativeNotificationPushed();
              break;
            case "cordovacallback":
              app.typeahead.nativeCordovaCallback();
              break;
            case "back":
              app.typeahead.nativeBack(data.args);
              break;
            case "close":
              app.typeahead.nativeClose();
              break;
            default:
              break;
          }
        }
      },

      /**
       *
       * @param {*} data
       */
      onQuery: function(data) {
        var result = {
          queryId: data.queryId
        };
        switch (data.queryId) {
          case "getWidgetCoordinates":
            var app = context.SessionService.getCurrent().getCurrentApplication(),
              node = app.model.getNode(data.id),
              rect = node.getWidget().getElement().getBoundingClientRect();
            result.x = rect.left + rect.width / 2;
            result.y = rect.top + rect.height / 2;
            break;
          default:
            break;
        }
        context.__wrapper.queryResult(result);
      }
    });
  });
;
// jshint ignore:start

"use strict";
modulum("AuiProtocolParser",

  function(context) {
    /**
     *  @namespace gbc.AuiProtocolParser
     */
    context.AuiProtocolParser = (function() {
      "use strict";

      /*
       * Generated by PEG.js 0.9.0.
       *
       * http://pegjs.org/
       */

      function peg$subclass(child, parent) {
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
      }

      function peg$SyntaxError(message, expected, found, location) {
        this.message = message;
        this.expected = expected;
        this.found = found;
        this.location = location;
        this.name = "SyntaxError";

        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, peg$SyntaxError);
        }
      }

      peg$subclass(peg$SyntaxError, Error);

      function peg$parse(input) {
        var options = arguments.length > 1 ? arguments[1] : {},
          parser = this,

          peg$FAILED = {},

          peg$startRuleFunctions = {
            start: peg$parsestart
          },
          peg$startRuleFunction = peg$parsestart,

          peg$c0 = function(cnx) {
            return [cnx];
          },
          peg$c1 = function(attrs) {
            return {
              type: "meta",
              verb: "Connection",
              attributes: attrs
            };
          },
          peg$c2 = {
            type: "other",
            description: "OM Order"
          },
          peg$c3 = function(idGroup, list) {
            return {
              type: "om",
              id: idGroup,
              operations: list,
              header: null
            };
          },
          peg$c4 = function(bytes, idGroup, list) {
            return {
              type: "om",
              id: idGroup,
              operations: list,
              header: bytes
            };
          },
          peg$c5 = {
            type: "any",
            description: "any character"
          },
          peg$c6 = function(cmd) {
            return cmd;
          },
          peg$c7 = {
            type: "other",
            description: "OM command"
          },
          peg$c8 = {
            type: "other",
            description: "Add node"
          },
          peg$c9 = function(parentId, n) {
            return {
              type: "add",
              parent: parentId,
              node: n
            };
          },
          peg$c10 = {
            type: "other",
            description: "Update node"
          },
          peg$c11 = function(id, attrs) {
            return {
              type: "update",
              id: id,
              attributes: attrs
            };
          },
          peg$c12 = {
            type: "other",
            description: "RemoveNode"
          },
          peg$c13 = function(id) {
            return {
              type: "remove",
              id: id
            };
          },
          peg$c14 = function(attrs) {
            var result = {},
              len = attrs.length;
            for (var i = 0; i < len; i++) {
              result[attrs[i].name] = attrs[i].value;
            }
            return result;
          },
          peg$c15 = "value",
          peg$c16 = {
            type: "literal",
            value: "value",
            description: "\"value\""
          },
          peg$c17 = function(chars) {
            return {
              name: "value",
              value: chars.join("")
            };
          },
          peg$c18 = "valueChecked",
          peg$c19 = {
            type: "literal",
            value: "valueChecked",
            description: "\"valueChecked\""
          },
          peg$c20 = function(chars) {
            return {
              name: "valueChecked",
              value: chars.join("")
            };
          },
          peg$c21 = "valueUnchecked",
          peg$c22 = {
            type: "literal",
            value: "valueUnchecked",
            description: "\"valueUnchecked\""
          },
          peg$c23 = function(chars) {
            return {
              name: "valueUnchecked",
              value: chars.join("")
            };
          },
          peg$c24 = "name",
          peg$c25 = {
            type: "literal",
            value: "name",
            description: "\"name\""
          },
          peg$c26 = function(chars) {
            return {
              name: "name",
              value: chars.join("")
            };
          },
          peg$c27 = "comment",
          peg$c28 = {
            type: "literal",
            value: "comment",
            description: "\"comment\""
          },
          peg$c29 = function(chars) {
            return {
              name: "comment",
              value: chars.join("")
            };
          },
          peg$c30 = "text",
          peg$c31 = {
            type: "literal",
            value: "text",
            description: "\"text\""
          },
          peg$c32 = function(chars) {
            return {
              name: "text",
              value: chars.join("")
            };
          },
          peg$c33 = "style",
          peg$c34 = {
            type: "literal",
            value: "style",
            description: "\"style\""
          },
          peg$c35 = function(chars) {
            return {
              name: "style",
              value: chars.join("")
            };
          },
          peg$c36 = "aggregateValue",
          peg$c37 = {
            type: "literal",
            value: "aggregateValue",
            description: "\"aggregateValue\""
          },
          peg$c38 = function(chars) {
            return {
              name: "aggregateValue",
              value: chars.join("")
            };
          },
          peg$c39 = "aggregateText",
          peg$c40 = {
            type: "literal",
            value: "aggregateText",
            description: "\"aggregateText\""
          },
          peg$c41 = function(chars) {
            return {
              name: "aggregateText",
              value: chars.join("")
            };
          },
          peg$c42 = "acceleratorName",
          peg$c43 = {
            type: "literal",
            value: "acceleratorName",
            description: "\"acceleratorName\""
          },
          peg$c44 = function(chars) {
            return {
              name: "acceleratorName",
              value: chars.join("")
            };
          },
          peg$c45 = "acceleratorName2",
          peg$c46 = {
            type: "literal",
            value: "acceleratorName2",
            description: "\"acceleratorName2\""
          },
          peg$c47 = function(chars) {
            return {
              name: "acceleratorName2",
              value: chars.join("")
            };
          },
          peg$c48 = "acceleratorName3",
          peg$c49 = {
            type: "literal",
            value: "acceleratorName3",
            description: "\"acceleratorName3\""
          },
          peg$c50 = function(chars) {
            return {
              name: "acceleratorName3",
              value: chars.join("")
            };
          },
          peg$c51 = "acceleratorName4",
          peg$c52 = {
            type: "literal",
            value: "acceleratorName4",
            description: "\"acceleratorName4\""
          },
          peg$c53 = function(chars) {
            return {
              name: "acceleratorName4",
              value: chars.join("")
            };
          },
          peg$c54 = "acceleratorKey1",
          peg$c55 = {
            type: "literal",
            value: "acceleratorKey1",
            description: "\"acceleratorKey1\""
          },
          peg$c56 = function(chars) {
            return {
              name: "acceleratorKey1",
              value: chars.join("")
            };
          },
          peg$c57 = "acceleratorKey3",
          peg$c58 = {
            type: "literal",
            value: "acceleratorKey3",
            description: "\"acceleratorKey3\""
          },
          peg$c59 = function(chars) {
            return {
              name: "acceleratorKey3",
              value: chars.join("")
            };
          },
          peg$c60 = function(name, value) {
            return {
              name: name,
              value: value
            };
          },
          peg$c61 = function(n) {
            return n;
          },
          peg$c62 = function(nodeType, nodeId, attrs, children) {
            return {
              id: nodeId,
              type: nodeType,
              attributes: attrs,
              children: children
            };
          },
          peg$c63 = {
            type: "other",
            description: "needed space"
          },
          peg$c64 = /^[ \t\r\n]/,
          peg$c65 = {
            type: "class",
            value: "[ \\t\\r\\n]",
            description: "[ \\t\\r\\n]"
          },
          peg$c66 = {
            type: "other",
            description: "optional space"
          },
          peg$c67 = "meta",
          peg$c68 = {
            type: "literal",
            value: "meta",
            description: "\"meta\""
          },
          peg$c69 = "Connection",
          peg$c70 = {
            type: "literal",
            value: "Connection",
            description: "\"Connection\""
          },
          peg$c71 = "om",
          peg$c72 = {
            type: "literal",
            value: "om",
            description: "\"om\""
          },
          peg$c73 = "an",
          peg$c74 = {
            type: "literal",
            value: "an",
            description: "\"an\""
          },
          peg$c75 = "un",
          peg$c76 = {
            type: "literal",
            value: "un",
            description: "\"un\""
          },
          peg$c77 = "rn",
          peg$c78 = {
            type: "literal",
            value: "rn",
            description: "\"rn\""
          },
          peg$c79 = "{",
          peg$c80 = {
            type: "literal",
            value: "{",
            description: "\"{\""
          },
          peg$c81 = "}",
          peg$c82 = {
            type: "literal",
            value: "}",
            description: "\"}\""
          },
          peg$c83 = /^[0-9]/,
          peg$c84 = {
            type: "class",
            value: "[0-9]",
            description: "[0-9]"
          },
          peg$c85 = function(digits) {
            return parseInt(digits.join(""), 10);
          },
          peg$c86 = function(num) {
            var res = parseFloat(num);
            if (Number.isNaN(res)) {
              return num;
            } else {
              return res;
            }
          },
          peg$c87 = function(integer) {
            if (integer.length > 16) {
              return integer;
            } else {
              return parseInt(integer, 10);
            }
          },
          peg$c88 = function(chars) {
            return chars.join("");
          },
          peg$c89 = "0",
          peg$c90 = {
            type: "literal",
            value: "0",
            description: "\"0\""
          },
          peg$c91 = function() {
            return 0;
          },
          peg$c92 = "-",
          peg$c93 = {
            type: "literal",
            value: "-",
            description: "\"-\""
          },
          peg$c94 = /^[1-9]/,
          peg$c95 = {
            type: "class",
            value: "[1-9]",
            description: "[1-9]"
          },
          peg$c96 = function(sign, firstdigit, digits) {
            return (sign ? "-" : "") + firstdigit + digits.join("");
          },
          peg$c97 = ".",
          peg$c98 = {
            type: "literal",
            value: ".",
            description: "\".\""
          },
          peg$c99 = function(sign, digits, decimals) {
            return (sign ? "-" : "") + digits.join("") + "." + decimals.join("");
          },
          peg$c100 = function() {
            return "";
          },
          peg$c101 = "\"",
          peg$c102 = {
            type: "literal",
            value: "\"",
            description: "\"\\\"\""
          },
          peg$c103 = "\\",
          peg$c104 = {
            type: "literal",
            value: "\\",
            description: "\"\\\\\""
          },
          peg$c105 = "/",
          peg$c106 = {
            type: "literal",
            value: "/",
            description: "\"/\""
          },
          peg$c107 = "b",
          peg$c108 = {
            type: "literal",
            value: "b",
            description: "\"b\""
          },
          peg$c109 = function() {
            return "\b";
          },
          peg$c110 = "f",
          peg$c111 = {
            type: "literal",
            value: "f",
            description: "\"f\""
          },
          peg$c112 = function() {
            return "\f";
          },
          peg$c113 = "n",
          peg$c114 = {
            type: "literal",
            value: "n",
            description: "\"n\""
          },
          peg$c115 = function() {
            return "\n";
          },
          peg$c116 = "u",
          peg$c117 = {
            type: "literal",
            value: "u",
            description: "\"u\""
          },
          peg$c118 = function(digits) {
            return String.fromCharCode(parseInt(digits, 16));
          },
          peg$c119 = function(sequence) {
            return sequence;
          },
          peg$c120 = /^[\t\r -!#-[\]-\uFFFF]/,
          peg$c121 = {
            type: "class",
            value: "[\\t\\r\\x20-\\x21\\x23-\\x5B\\x5D-\\uFFFF]",
            description: "[\\t\\r\\x20-\\x21\\x23-\\x5B\\x5D-\\uFFFF]"
          },
          peg$c122 = /^[\x01-\x08\x0B-\f\x0E-\x1F]/,
          peg$c123 = {
            type: "class",
            value: "[\\x01-\\x08\\x0B-\\x0C\\x0E-\\x1F]",
            description: "[\\x01-\\x08\\x0B-\\x0C\\x0E-\\x1F]"
          },
          peg$c124 = /^[0-9a-fA-F]/,
          peg$c125 = {
            type: "class",
            value: "[0-9a-fA-F]",
            description: "[0-9a-fA-F]"
          },
          peg$c126 = function(c) {
            return c.join("");
          },
          peg$c127 = /^[A-Za-z]/,
          peg$c128 = {
            type: "class",
            value: "[A-Za-z]",
            description: "[A-Za-z]"
          },

          peg$currPos = 0,
          peg$savedPos = 0,
          peg$posDetailsCache = [{
            line: 1,
            column: 1,
            seenCR: false
          }],
          peg$maxFailPos = 0,
          peg$maxFailExpected = [],
          peg$silentFails = 0,

          peg$result;

        if ("startRule" in options) {
          if (!(options.startRule in peg$startRuleFunctions)) {
            throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
          }

          peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
        }

        function text() {
          return input.substring(peg$savedPos, peg$currPos);
        }

        function location() {
          return peg$computeLocation(peg$savedPos, peg$currPos);
        }

        function expected(description) {
          throw peg$buildException(
            null,
            [{
              type: "other",
              description: description
            }],
            input.substring(peg$savedPos, peg$currPos),
            peg$computeLocation(peg$savedPos, peg$currPos)
          );
        }

        function error(message) {
          throw peg$buildException(
            message,
            null,
            input.substring(peg$savedPos, peg$currPos),
            peg$computeLocation(peg$savedPos, peg$currPos)
          );
        }

        function peg$computePosDetails(pos) {
          var details = peg$posDetailsCache[pos],
            p, ch;

          if (details) {
            return details;
          } else {
            p = pos - 1;
            while (!peg$posDetailsCache[p]) {
              p--;
            }

            details = peg$posDetailsCache[p];
            details = {
              line: details.line,
              column: details.column,
              seenCR: details.seenCR
            };

            while (p < pos) {
              ch = input.charAt(p);
              if (ch === "\n") {
                if (!details.seenCR) {
                  details.line++;
                }
                details.column = 1;
                details.seenCR = false;
              } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
                details.line++;
                details.column = 1;
                details.seenCR = true;
              } else {
                details.column++;
                details.seenCR = false;
              }

              p++;
            }

            peg$posDetailsCache[pos] = details;
            return details;
          }
        }

        function peg$computeLocation(startPos, endPos) {
          var startPosDetails = peg$computePosDetails(startPos),
            endPosDetails = peg$computePosDetails(endPos);

          return {
            start: {
              offset: startPos,
              line: startPosDetails.line,
              column: startPosDetails.column
            },
            end: {
              offset: endPos,
              line: endPosDetails.line,
              column: endPosDetails.column
            }
          };
        }

        function peg$fail(expected) {
          if (peg$currPos < peg$maxFailPos) {
            return;
          }

          if (peg$currPos > peg$maxFailPos) {
            peg$maxFailPos = peg$currPos;
            peg$maxFailExpected = [];
          }

          peg$maxFailExpected.push(expected);
        }

        function peg$buildException(message, expected, found, location) {
          function cleanupExpected(expected) {
            var i = 1;

            expected.sort(function(a, b) {
              if (a.description < b.description) {
                return -1;
              } else if (a.description > b.description) {
                return 1;
              } else {
                return 0;
              }
            });

            while (i < expected.length) {
              if (expected[i - 1] === expected[i]) {
                expected.splice(i, 1);
              } else {
                i++;
              }
            }
          }

          function buildMessage(expected, found) {
            function stringEscape(s) {
              function hex(ch) {
                return ch.charCodeAt(0).toString(16).toUpperCase();
              }

              return s
                .replace(/\\/g, '\\\\')
                .replace(/"/g, '\\"')
                .replace(/\x08/g, '\\b')
                .replace(/\t/g, '\\t')
                .replace(/\n/g, '\\n')
                .replace(/\f/g, '\\f')
                .replace(/\r/g, '\\r')
                .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) {
                  return '\\x0' + hex(ch);
                })
                .replace(/[\x10-\x1F\x80-\xFF]/g, function(ch) {
                  return '\\x' + hex(ch);
                })
                .replace(/[\u0100-\u0FFF]/g, function(ch) {
                  return '\\u0' + hex(ch);
                })
                .replace(/[\u1000-\uFFFF]/g, function(ch) {
                  return '\\u' + hex(ch);
                });
            }

            var expectedDescs = new Array(expected.length),
              expectedDesc, foundDesc, i;

            for (i = 0; i < expected.length; i++) {
              expectedDescs[i] = expected[i].description;
            }

            expectedDesc = expected.length > 1 ?
              expectedDescs.slice(0, -1).join(", ") +
              " or " +
              expectedDescs[expected.length - 1] :
              expectedDescs[0];

            foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";

            return "Expected " + expectedDesc + " but " + foundDesc + " found.";
          }

          if (expected !== null) {
            cleanupExpected(expected);
          }

          return new peg$SyntaxError(
            message !== null ? message : buildMessage(expected, found),
            expected,
            found,
            location
          );
        }

        function peg$parsestart() {
          var s0, s1;

          s0 = peg$currPos;
          s1 = peg$parseconnection();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c0(s1);
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$parseorders();
          }

          return s0;
        }

        function peg$parseconnection() {
          var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;

          s0 = peg$currPos;
          s1 = peg$parse_();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseMETA();
            if (s2 !== peg$FAILED) {
              s3 = peg$parse__();
              if (s3 !== peg$FAILED) {
                s4 = peg$parseCONNECTION();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parse_();
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parseLBRACE();
                    if (s6 !== peg$FAILED) {
                      s7 = peg$parse_();
                      if (s7 !== peg$FAILED) {
                        s8 = peg$parseattributes();
                        if (s8 !== peg$FAILED) {
                          s9 = peg$parse_();
                          if (s9 !== peg$FAILED) {
                            s10 = peg$parseRBRACE();
                            if (s10 !== peg$FAILED) {
                              s11 = peg$parse_();
                              if (s11 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s1 = peg$c1(s8);
                                s0 = s1;
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }

          return s0;
        }

        function peg$parseorders() {
          var s0, s1;

          s0 = [];
          s1 = peg$parseorder();
          while (s1 !== peg$FAILED) {
            s0.push(s1);
            s1 = peg$parseorder();
          }

          return s0;
        }

        function peg$parseorder() {
          var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12;

          peg$silentFails++;
          s0 = peg$currPos;
          s1 = peg$parse_();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseOM();
            if (s2 !== peg$FAILED) {
              s3 = peg$parse__();
              if (s3 !== peg$FAILED) {
                s4 = peg$parseINTEGER();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parse_();
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parseLBRACE();
                    if (s6 !== peg$FAILED) {
                      s7 = peg$parse_();
                      if (s7 !== peg$FAILED) {
                        s8 = peg$parsecommandList();
                        if (s8 !== peg$FAILED) {
                          s9 = peg$parse_();
                          if (s9 !== peg$FAILED) {
                            s10 = peg$parseRBRACE();
                            if (s10 !== peg$FAILED) {
                              s11 = peg$parse_();
                              if (s11 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s1 = peg$c3(s4, s8);
                                s0 = s1;
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parse_();
            if (s1 !== peg$FAILED) {
              s2 = peg$parsebytesHeader();
              if (s2 !== peg$FAILED) {
                s3 = peg$parseOM();
                if (s3 !== peg$FAILED) {
                  s4 = peg$parse__();
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parseINTEGER();
                    if (s5 !== peg$FAILED) {
                      s6 = peg$parse_();
                      if (s6 !== peg$FAILED) {
                        s7 = peg$parseLBRACE();
                        if (s7 !== peg$FAILED) {
                          s8 = peg$parse_();
                          if (s8 !== peg$FAILED) {
                            s9 = peg$parsecommandList();
                            if (s9 !== peg$FAILED) {
                              s10 = peg$parse_();
                              if (s10 !== peg$FAILED) {
                                s11 = peg$parseRBRACE();
                                if (s11 !== peg$FAILED) {
                                  s12 = peg$parse_();
                                  if (s12 !== peg$FAILED) {
                                    peg$savedPos = s0;
                                    s1 = peg$c4(s2, s5, s9);
                                    s0 = s1;
                                  } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                  }
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c2);
            }
          }

          return s0;
        }

        function peg$parsebytesHeader() {
          var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

          s0 = peg$currPos;
          if (input.length > peg$currPos) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c5);
            }
          }
          if (s1 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c5);
              }
            }
            if (s2 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c5);
                }
              }
              if (s3 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s4 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c5);
                  }
                }
                if (s4 !== peg$FAILED) {
                  if (input.length > peg$currPos) {
                    s5 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c5);
                    }
                  }
                  if (s5 !== peg$FAILED) {
                    if (input.length > peg$currPos) {
                      s6 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s6 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c5);
                      }
                    }
                    if (s6 !== peg$FAILED) {
                      if (input.length > peg$currPos) {
                        s7 = input.charAt(peg$currPos);
                        peg$currPos++;
                      } else {
                        s7 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c5);
                        }
                      }
                      if (s7 !== peg$FAILED) {
                        if (input.length > peg$currPos) {
                          s8 = input.charAt(peg$currPos);
                          peg$currPos++;
                        } else {
                          s8 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$c5);
                          }
                        }
                        if (s8 !== peg$FAILED) {
                          if (input.length > peg$currPos) {
                            s9 = input.charAt(peg$currPos);
                            peg$currPos++;
                          } else {
                            s9 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$c5);
                            }
                          }
                          if (s9 !== peg$FAILED) {
                            s1 = [s1, s2, s3, s4, s5, s6, s7, s8, s9];
                            s0 = s1;
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }

          return s0;
        }

        function peg$parsecommandList() {
          var s0, s1;

          s0 = [];
          s1 = peg$parsecommandItem();
          while (s1 !== peg$FAILED) {
            s0.push(s1);
            s1 = peg$parsecommandItem();
          }

          return s0;
        }

        function peg$parsecommandItem() {
          var s0, s1, s2, s3, s4, s5, s6, s7;

          s0 = peg$currPos;
          s1 = peg$parse_();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseLBRACE();
            if (s2 !== peg$FAILED) {
              s3 = peg$parse_();
              if (s3 !== peg$FAILED) {
                s4 = peg$parsecommand();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parse_();
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parseRBRACE();
                    if (s6 !== peg$FAILED) {
                      s7 = peg$parse_();
                      if (s7 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c6(s4);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }

          return s0;
        }

        function peg$parsecommand() {
          var s0, s1;

          peg$silentFails++;
          s0 = peg$parseaddnode();
          if (s0 === peg$FAILED) {
            s0 = peg$parseupdatenode();
            if (s0 === peg$FAILED) {
              s0 = peg$parseremovenode();
            }
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c7);
            }
          }

          return s0;
        }

        function peg$parseaddnode() {
          var s0, s1, s2, s3, s4, s5, s6, s7;

          peg$silentFails++;
          s0 = peg$currPos;
          s1 = peg$parse_();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseAN();
            if (s2 !== peg$FAILED) {
              s3 = peg$parse__();
              if (s3 !== peg$FAILED) {
                s4 = peg$parseINTEGER();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parse__();
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parsenode();
                    if (s6 !== peg$FAILED) {
                      s7 = peg$parse_();
                      if (s7 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c9(s4, s6);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c8);
            }
          }

          return s0;
        }

        function peg$parseupdatenode() {
          var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;

          peg$silentFails++;
          s0 = peg$currPos;
          s1 = peg$parse_();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseUN();
            if (s2 !== peg$FAILED) {
              s3 = peg$parse__();
              if (s3 !== peg$FAILED) {
                s4 = peg$parseINTEGER();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parse_();
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parseLBRACE();
                    if (s6 !== peg$FAILED) {
                      s7 = peg$parse_();
                      if (s7 !== peg$FAILED) {
                        s8 = peg$parseattributes();
                        if (s8 !== peg$FAILED) {
                          s9 = peg$parse_();
                          if (s9 !== peg$FAILED) {
                            s10 = peg$parseRBRACE();
                            if (s10 !== peg$FAILED) {
                              s11 = peg$parse_();
                              if (s11 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s1 = peg$c11(s4, s8);
                                s0 = s1;
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c10);
            }
          }

          return s0;
        }

        function peg$parseremovenode() {
          var s0, s1, s2, s3, s4, s5;

          peg$silentFails++;
          s0 = peg$currPos;
          s1 = peg$parse_();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseRN();
            if (s2 !== peg$FAILED) {
              s3 = peg$parse__();
              if (s3 !== peg$FAILED) {
                s4 = peg$parseINTEGER();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parse_();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c13(s4);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c12);
            }
          }

          return s0;
        }

        function peg$parseattributes() {
          var s0, s1, s2;

          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseattribute();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseattribute();
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c14(s1);
          }
          s0 = s1;

          return s0;
        }

        function peg$parseattribute() {
          var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;

          s0 = peg$currPos;
          s1 = peg$parse_();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseLBRACE();
            if (s2 !== peg$FAILED) {
              s3 = peg$parse_();
              if (s3 !== peg$FAILED) {
                if (input.substr(peg$currPos, 5) === peg$c15) {
                  s4 = peg$c15;
                  peg$currPos += 5;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c16);
                  }
                }
                if (s4 !== peg$FAILED) {
                  s5 = peg$parse__();
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parsequotation_mark();
                    if (s6 !== peg$FAILED) {
                      s7 = [];
                      s8 = peg$parseschar();
                      while (s8 !== peg$FAILED) {
                        s7.push(s8);
                        s8 = peg$parseschar();
                      }
                      if (s7 !== peg$FAILED) {
                        s8 = peg$parsequotation_mark();
                        if (s8 !== peg$FAILED) {
                          s9 = peg$parse_();
                          if (s9 !== peg$FAILED) {
                            s10 = peg$parseRBRACE();
                            if (s10 !== peg$FAILED) {
                              s11 = peg$parse_();
                              if (s11 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s1 = peg$c17(s7);
                                s0 = s1;
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parse_();
            if (s1 !== peg$FAILED) {
              s2 = peg$parseLBRACE();
              if (s2 !== peg$FAILED) {
                s3 = peg$parse_();
                if (s3 !== peg$FAILED) {
                  if (input.substr(peg$currPos, 12) === peg$c18) {
                    s4 = peg$c18;
                    peg$currPos += 12;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c19);
                    }
                  }
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parse__();
                    if (s5 !== peg$FAILED) {
                      s6 = peg$parsequotation_mark();
                      if (s6 !== peg$FAILED) {
                        s7 = [];
                        s8 = peg$parseschar();
                        while (s8 !== peg$FAILED) {
                          s7.push(s8);
                          s8 = peg$parseschar();
                        }
                        if (s7 !== peg$FAILED) {
                          s8 = peg$parsequotation_mark();
                          if (s8 !== peg$FAILED) {
                            s9 = peg$parse_();
                            if (s9 !== peg$FAILED) {
                              s10 = peg$parseRBRACE();
                              if (s10 !== peg$FAILED) {
                                s11 = peg$parse_();
                                if (s11 !== peg$FAILED) {
                                  peg$savedPos = s0;
                                  s1 = peg$c20(s7);
                                  s0 = s1;
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parse_();
              if (s1 !== peg$FAILED) {
                s2 = peg$parseLBRACE();
                if (s2 !== peg$FAILED) {
                  s3 = peg$parse_();
                  if (s3 !== peg$FAILED) {
                    if (input.substr(peg$currPos, 14) === peg$c21) {
                      s4 = peg$c21;
                      peg$currPos += 14;
                    } else {
                      s4 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c22);
                      }
                    }
                    if (s4 !== peg$FAILED) {
                      s5 = peg$parse__();
                      if (s5 !== peg$FAILED) {
                        s6 = peg$parsequotation_mark();
                        if (s6 !== peg$FAILED) {
                          s7 = [];
                          s8 = peg$parseschar();
                          while (s8 !== peg$FAILED) {
                            s7.push(s8);
                            s8 = peg$parseschar();
                          }
                          if (s7 !== peg$FAILED) {
                            s8 = peg$parsequotation_mark();
                            if (s8 !== peg$FAILED) {
                              s9 = peg$parse_();
                              if (s9 !== peg$FAILED) {
                                s10 = peg$parseRBRACE();
                                if (s10 !== peg$FAILED) {
                                  s11 = peg$parse_();
                                  if (s11 !== peg$FAILED) {
                                    peg$savedPos = s0;
                                    s1 = peg$c23(s7);
                                    s0 = s1;
                                  } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                  }
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parse_();
                if (s1 !== peg$FAILED) {
                  s2 = peg$parseLBRACE();
                  if (s2 !== peg$FAILED) {
                    s3 = peg$parse_();
                    if (s3 !== peg$FAILED) {
                      if (input.substr(peg$currPos, 4) === peg$c24) {
                        s4 = peg$c24;
                        peg$currPos += 4;
                      } else {
                        s4 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c25);
                        }
                      }
                      if (s4 !== peg$FAILED) {
                        s5 = peg$parse__();
                        if (s5 !== peg$FAILED) {
                          s6 = peg$parsequotation_mark();
                          if (s6 !== peg$FAILED) {
                            s7 = [];
                            s8 = peg$parseschar();
                            while (s8 !== peg$FAILED) {
                              s7.push(s8);
                              s8 = peg$parseschar();
                            }
                            if (s7 !== peg$FAILED) {
                              s8 = peg$parsequotation_mark();
                              if (s8 !== peg$FAILED) {
                                s9 = peg$parse_();
                                if (s9 !== peg$FAILED) {
                                  s10 = peg$parseRBRACE();
                                  if (s10 !== peg$FAILED) {
                                    s11 = peg$parse_();
                                    if (s11 !== peg$FAILED) {
                                      peg$savedPos = s0;
                                      s1 = peg$c26(s7);
                                      s0 = s1;
                                    } else {
                                      peg$currPos = s0;
                                      s0 = peg$FAILED;
                                    }
                                  } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                  }
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  s1 = peg$parse_();
                  if (s1 !== peg$FAILED) {
                    s2 = peg$parseLBRACE();
                    if (s2 !== peg$FAILED) {
                      s3 = peg$parse_();
                      if (s3 !== peg$FAILED) {
                        if (input.substr(peg$currPos, 7) === peg$c27) {
                          s4 = peg$c27;
                          peg$currPos += 7;
                        } else {
                          s4 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$c28);
                          }
                        }
                        if (s4 !== peg$FAILED) {
                          s5 = peg$parse__();
                          if (s5 !== peg$FAILED) {
                            s6 = peg$parsequotation_mark();
                            if (s6 !== peg$FAILED) {
                              s7 = [];
                              s8 = peg$parseschar();
                              while (s8 !== peg$FAILED) {
                                s7.push(s8);
                                s8 = peg$parseschar();
                              }
                              if (s7 !== peg$FAILED) {
                                s8 = peg$parsequotation_mark();
                                if (s8 !== peg$FAILED) {
                                  s9 = peg$parse_();
                                  if (s9 !== peg$FAILED) {
                                    s10 = peg$parseRBRACE();
                                    if (s10 !== peg$FAILED) {
                                      s11 = peg$parse_();
                                      if (s11 !== peg$FAILED) {
                                        peg$savedPos = s0;
                                        s1 = peg$c29(s7);
                                        s0 = s1;
                                      } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                      }
                                    } else {
                                      peg$currPos = s0;
                                      s0 = peg$FAILED;
                                    }
                                  } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                  }
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                  if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    s1 = peg$parse_();
                    if (s1 !== peg$FAILED) {
                      s2 = peg$parseLBRACE();
                      if (s2 !== peg$FAILED) {
                        s3 = peg$parse_();
                        if (s3 !== peg$FAILED) {
                          if (input.substr(peg$currPos, 4) === peg$c30) {
                            s4 = peg$c30;
                            peg$currPos += 4;
                          } else {
                            s4 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$c31);
                            }
                          }
                          if (s4 !== peg$FAILED) {
                            s5 = peg$parse__();
                            if (s5 !== peg$FAILED) {
                              s6 = peg$parsequotation_mark();
                              if (s6 !== peg$FAILED) {
                                s7 = [];
                                s8 = peg$parseschar();
                                while (s8 !== peg$FAILED) {
                                  s7.push(s8);
                                  s8 = peg$parseschar();
                                }
                                if (s7 !== peg$FAILED) {
                                  s8 = peg$parsequotation_mark();
                                  if (s8 !== peg$FAILED) {
                                    s9 = peg$parse_();
                                    if (s9 !== peg$FAILED) {
                                      s10 = peg$parseRBRACE();
                                      if (s10 !== peg$FAILED) {
                                        s11 = peg$parse_();
                                        if (s11 !== peg$FAILED) {
                                          peg$savedPos = s0;
                                          s1 = peg$c32(s7);
                                          s0 = s1;
                                        } else {
                                          peg$currPos = s0;
                                          s0 = peg$FAILED;
                                        }
                                      } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                      }
                                    } else {
                                      peg$currPos = s0;
                                      s0 = peg$FAILED;
                                    }
                                  } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                  }
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                    if (s0 === peg$FAILED) {
                      s0 = peg$currPos;
                      s1 = peg$parse_();
                      if (s1 !== peg$FAILED) {
                        s2 = peg$parseLBRACE();
                        if (s2 !== peg$FAILED) {
                          s3 = peg$parse_();
                          if (s3 !== peg$FAILED) {
                            if (input.substr(peg$currPos, 5) === peg$c33) {
                              s4 = peg$c33;
                              peg$currPos += 5;
                            } else {
                              s4 = peg$FAILED;
                              if (peg$silentFails === 0) {
                                peg$fail(peg$c34);
                              }
                            }
                            if (s4 !== peg$FAILED) {
                              s5 = peg$parse__();
                              if (s5 !== peg$FAILED) {
                                s6 = peg$parsequotation_mark();
                                if (s6 !== peg$FAILED) {
                                  s7 = [];
                                  s8 = peg$parseschar();
                                  while (s8 !== peg$FAILED) {
                                    s7.push(s8);
                                    s8 = peg$parseschar();
                                  }
                                  if (s7 !== peg$FAILED) {
                                    s8 = peg$parsequotation_mark();
                                    if (s8 !== peg$FAILED) {
                                      s9 = peg$parse_();
                                      if (s9 !== peg$FAILED) {
                                        s10 = peg$parseRBRACE();
                                        if (s10 !== peg$FAILED) {
                                          s11 = peg$parse_();
                                          if (s11 !== peg$FAILED) {
                                            peg$savedPos = s0;
                                            s1 = peg$c35(s7);
                                            s0 = s1;
                                          } else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                          }
                                        } else {
                                          peg$currPos = s0;
                                          s0 = peg$FAILED;
                                        }
                                      } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                      }
                                    } else {
                                      peg$currPos = s0;
                                      s0 = peg$FAILED;
                                    }
                                  } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                  }
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                      if (s0 === peg$FAILED) {
                        s0 = peg$currPos;
                        s1 = peg$parse_();
                        if (s1 !== peg$FAILED) {
                          s2 = peg$parseLBRACE();
                          if (s2 !== peg$FAILED) {
                            s3 = peg$parse_();
                            if (s3 !== peg$FAILED) {
                              if (input.substr(peg$currPos, 14) === peg$c36) {
                                s4 = peg$c36;
                                peg$currPos += 14;
                              } else {
                                s4 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                  peg$fail(peg$c37);
                                }
                              }
                              if (s4 !== peg$FAILED) {
                                s5 = peg$parse__();
                                if (s5 !== peg$FAILED) {
                                  s6 = peg$parsequotation_mark();
                                  if (s6 !== peg$FAILED) {
                                    s7 = [];
                                    s8 = peg$parseschar();
                                    while (s8 !== peg$FAILED) {
                                      s7.push(s8);
                                      s8 = peg$parseschar();
                                    }
                                    if (s7 !== peg$FAILED) {
                                      s8 = peg$parsequotation_mark();
                                      if (s8 !== peg$FAILED) {
                                        s9 = peg$parse_();
                                        if (s9 !== peg$FAILED) {
                                          s10 = peg$parseRBRACE();
                                          if (s10 !== peg$FAILED) {
                                            s11 = peg$parse_();
                                            if (s11 !== peg$FAILED) {
                                              peg$savedPos = s0;
                                              s1 = peg$c38(s7);
                                              s0 = s1;
                                            } else {
                                              peg$currPos = s0;
                                              s0 = peg$FAILED;
                                            }
                                          } else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                          }
                                        } else {
                                          peg$currPos = s0;
                                          s0 = peg$FAILED;
                                        }
                                      } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                      }
                                    } else {
                                      peg$currPos = s0;
                                      s0 = peg$FAILED;
                                    }
                                  } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                  }
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                        if (s0 === peg$FAILED) {
                          s0 = peg$currPos;
                          s1 = peg$parse_();
                          if (s1 !== peg$FAILED) {
                            s2 = peg$parseLBRACE();
                            if (s2 !== peg$FAILED) {
                              s3 = peg$parse_();
                              if (s3 !== peg$FAILED) {
                                if (input.substr(peg$currPos, 13) === peg$c39) {
                                  s4 = peg$c39;
                                  peg$currPos += 13;
                                } else {
                                  s4 = peg$FAILED;
                                  if (peg$silentFails === 0) {
                                    peg$fail(peg$c40);
                                  }
                                }
                                if (s4 !== peg$FAILED) {
                                  s5 = peg$parse__();
                                  if (s5 !== peg$FAILED) {
                                    s6 = peg$parsequotation_mark();
                                    if (s6 !== peg$FAILED) {
                                      s7 = [];
                                      s8 = peg$parseschar();
                                      while (s8 !== peg$FAILED) {
                                        s7.push(s8);
                                        s8 = peg$parseschar();
                                      }
                                      if (s7 !== peg$FAILED) {
                                        s8 = peg$parsequotation_mark();
                                        if (s8 !== peg$FAILED) {
                                          s9 = peg$parse_();
                                          if (s9 !== peg$FAILED) {
                                            s10 = peg$parseRBRACE();
                                            if (s10 !== peg$FAILED) {
                                              s11 = peg$parse_();
                                              if (s11 !== peg$FAILED) {
                                                peg$savedPos = s0;
                                                s1 = peg$c41(s7);
                                                s0 = s1;
                                              } else {
                                                peg$currPos = s0;
                                                s0 = peg$FAILED;
                                              }
                                            } else {
                                              peg$currPos = s0;
                                              s0 = peg$FAILED;
                                            }
                                          } else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                          }
                                        } else {
                                          peg$currPos = s0;
                                          s0 = peg$FAILED;
                                        }
                                      } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                      }
                                    } else {
                                      peg$currPos = s0;
                                      s0 = peg$FAILED;
                                    }
                                  } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                  }
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                          if (s0 === peg$FAILED) {
                            s0 = peg$currPos;
                            s1 = peg$parse_();
                            if (s1 !== peg$FAILED) {
                              s2 = peg$parseLBRACE();
                              if (s2 !== peg$FAILED) {
                                s3 = peg$parse_();
                                if (s3 !== peg$FAILED) {
                                  if (input.substr(peg$currPos, 15) === peg$c42) {
                                    s4 = peg$c42;
                                    peg$currPos += 15;
                                  } else {
                                    s4 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                      peg$fail(peg$c43);
                                    }
                                  }
                                  if (s4 !== peg$FAILED) {
                                    s5 = peg$parse__();
                                    if (s5 !== peg$FAILED) {
                                      s6 = peg$parsequotation_mark();
                                      if (s6 !== peg$FAILED) {
                                        s7 = [];
                                        s8 = peg$parseschar();
                                        while (s8 !== peg$FAILED) {
                                          s7.push(s8);
                                          s8 = peg$parseschar();
                                        }
                                        if (s7 !== peg$FAILED) {
                                          s8 = peg$parsequotation_mark();
                                          if (s8 !== peg$FAILED) {
                                            s9 = peg$parse_();
                                            if (s9 !== peg$FAILED) {
                                              s10 = peg$parseRBRACE();
                                              if (s10 !== peg$FAILED) {
                                                s11 = peg$parse_();
                                                if (s11 !== peg$FAILED) {
                                                  peg$savedPos = s0;
                                                  s1 = peg$c44(s7);
                                                  s0 = s1;
                                                } else {
                                                  peg$currPos = s0;
                                                  s0 = peg$FAILED;
                                                }
                                              } else {
                                                peg$currPos = s0;
                                                s0 = peg$FAILED;
                                              }
                                            } else {
                                              peg$currPos = s0;
                                              s0 = peg$FAILED;
                                            }
                                          } else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                          }
                                        } else {
                                          peg$currPos = s0;
                                          s0 = peg$FAILED;
                                        }
                                      } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                      }
                                    } else {
                                      peg$currPos = s0;
                                      s0 = peg$FAILED;
                                    }
                                  } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                  }
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                            if (s0 === peg$FAILED) {
                              s0 = peg$currPos;
                              s1 = peg$parse_();
                              if (s1 !== peg$FAILED) {
                                s2 = peg$parseLBRACE();
                                if (s2 !== peg$FAILED) {
                                  s3 = peg$parse_();
                                  if (s3 !== peg$FAILED) {
                                    if (input.substr(peg$currPos, 16) === peg$c45) {
                                      s4 = peg$c45;
                                      peg$currPos += 16;
                                    } else {
                                      s4 = peg$FAILED;
                                      if (peg$silentFails === 0) {
                                        peg$fail(peg$c46);
                                      }
                                    }
                                    if (s4 !== peg$FAILED) {
                                      s5 = peg$parse__();
                                      if (s5 !== peg$FAILED) {
                                        s6 = peg$parsequotation_mark();
                                        if (s6 !== peg$FAILED) {
                                          s7 = [];
                                          s8 = peg$parseschar();
                                          while (s8 !== peg$FAILED) {
                                            s7.push(s8);
                                            s8 = peg$parseschar();
                                          }
                                          if (s7 !== peg$FAILED) {
                                            s8 = peg$parsequotation_mark();
                                            if (s8 !== peg$FAILED) {
                                              s9 = peg$parse_();
                                              if (s9 !== peg$FAILED) {
                                                s10 = peg$parseRBRACE();
                                                if (s10 !== peg$FAILED) {
                                                  s11 = peg$parse_();
                                                  if (s11 !== peg$FAILED) {
                                                    peg$savedPos = s0;
                                                    s1 = peg$c47(s7);
                                                    s0 = s1;
                                                  } else {
                                                    peg$currPos = s0;
                                                    s0 = peg$FAILED;
                                                  }
                                                } else {
                                                  peg$currPos = s0;
                                                  s0 = peg$FAILED;
                                                }
                                              } else {
                                                peg$currPos = s0;
                                                s0 = peg$FAILED;
                                              }
                                            } else {
                                              peg$currPos = s0;
                                              s0 = peg$FAILED;
                                            }
                                          } else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                          }
                                        } else {
                                          peg$currPos = s0;
                                          s0 = peg$FAILED;
                                        }
                                      } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                      }
                                    } else {
                                      peg$currPos = s0;
                                      s0 = peg$FAILED;
                                    }
                                  } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                  }
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                              if (s0 === peg$FAILED) {
                                s0 = peg$currPos;
                                s1 = peg$parse_();
                                if (s1 !== peg$FAILED) {
                                  s2 = peg$parseLBRACE();
                                  if (s2 !== peg$FAILED) {
                                    s3 = peg$parse_();
                                    if (s3 !== peg$FAILED) {
                                      if (input.substr(peg$currPos, 16) === peg$c48) {
                                        s4 = peg$c48;
                                        peg$currPos += 16;
                                      } else {
                                        s4 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                          peg$fail(peg$c49);
                                        }
                                      }
                                      if (s4 !== peg$FAILED) {
                                        s5 = peg$parse__();
                                        if (s5 !== peg$FAILED) {
                                          s6 = peg$parsequotation_mark();
                                          if (s6 !== peg$FAILED) {
                                            s7 = [];
                                            s8 = peg$parseschar();
                                            while (s8 !== peg$FAILED) {
                                              s7.push(s8);
                                              s8 = peg$parseschar();
                                            }
                                            if (s7 !== peg$FAILED) {
                                              s8 = peg$parsequotation_mark();
                                              if (s8 !== peg$FAILED) {
                                                s9 = peg$parse_();
                                                if (s9 !== peg$FAILED) {
                                                  s10 = peg$parseRBRACE();
                                                  if (s10 !== peg$FAILED) {
                                                    s11 = peg$parse_();
                                                    if (s11 !== peg$FAILED) {
                                                      peg$savedPos = s0;
                                                      s1 = peg$c50(s7);
                                                      s0 = s1;
                                                    } else {
                                                      peg$currPos = s0;
                                                      s0 = peg$FAILED;
                                                    }
                                                  } else {
                                                    peg$currPos = s0;
                                                    s0 = peg$FAILED;
                                                  }
                                                } else {
                                                  peg$currPos = s0;
                                                  s0 = peg$FAILED;
                                                }
                                              } else {
                                                peg$currPos = s0;
                                                s0 = peg$FAILED;
                                              }
                                            } else {
                                              peg$currPos = s0;
                                              s0 = peg$FAILED;
                                            }
                                          } else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                          }
                                        } else {
                                          peg$currPos = s0;
                                          s0 = peg$FAILED;
                                        }
                                      } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                      }
                                    } else {
                                      peg$currPos = s0;
                                      s0 = peg$FAILED;
                                    }
                                  } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                  }
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$FAILED;
                                }
                                if (s0 === peg$FAILED) {
                                  s0 = peg$currPos;
                                  s1 = peg$parse_();
                                  if (s1 !== peg$FAILED) {
                                    s2 = peg$parseLBRACE();
                                    if (s2 !== peg$FAILED) {
                                      s3 = peg$parse_();
                                      if (s3 !== peg$FAILED) {
                                        if (input.substr(peg$currPos, 16) === peg$c51) {
                                          s4 = peg$c51;
                                          peg$currPos += 16;
                                        } else {
                                          s4 = peg$FAILED;
                                          if (peg$silentFails === 0) {
                                            peg$fail(peg$c52);
                                          }
                                        }
                                        if (s4 !== peg$FAILED) {
                                          s5 = peg$parse__();
                                          if (s5 !== peg$FAILED) {
                                            s6 = peg$parsequotation_mark();
                                            if (s6 !== peg$FAILED) {
                                              s7 = [];
                                              s8 = peg$parseschar();
                                              while (s8 !== peg$FAILED) {
                                                s7.push(s8);
                                                s8 = peg$parseschar();
                                              }
                                              if (s7 !== peg$FAILED) {
                                                s8 = peg$parsequotation_mark();
                                                if (s8 !== peg$FAILED) {
                                                  s9 = peg$parse_();
                                                  if (s9 !== peg$FAILED) {
                                                    s10 = peg$parseRBRACE();
                                                    if (s10 !== peg$FAILED) {
                                                      s11 = peg$parse_();
                                                      if (s11 !== peg$FAILED) {
                                                        peg$savedPos = s0;
                                                        s1 = peg$c53(s7);
                                                        s0 = s1;
                                                      } else {
                                                        peg$currPos = s0;
                                                        s0 = peg$FAILED;
                                                      }
                                                    } else {
                                                      peg$currPos = s0;
                                                      s0 = peg$FAILED;
                                                    }
                                                  } else {
                                                    peg$currPos = s0;
                                                    s0 = peg$FAILED;
                                                  }
                                                } else {
                                                  peg$currPos = s0;
                                                  s0 = peg$FAILED;
                                                }
                                              } else {
                                                peg$currPos = s0;
                                                s0 = peg$FAILED;
                                              }
                                            } else {
                                              peg$currPos = s0;
                                              s0 = peg$FAILED;
                                            }
                                          } else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                          }
                                        } else {
                                          peg$currPos = s0;
                                          s0 = peg$FAILED;
                                        }
                                      } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                      }
                                    } else {
                                      peg$currPos = s0;
                                      s0 = peg$FAILED;
                                    }
                                  } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                  }
                                  if (s0 === peg$FAILED) {
                                    s0 = peg$currPos;
                                    s1 = peg$parse_();
                                    if (s1 !== peg$FAILED) {
                                      s2 = peg$parseLBRACE();
                                      if (s2 !== peg$FAILED) {
                                        s3 = peg$parse_();
                                        if (s3 !== peg$FAILED) {
                                          if (input.substr(peg$currPos, 15) === peg$c54) {
                                            s4 = peg$c54;
                                            peg$currPos += 15;
                                          } else {
                                            s4 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                              peg$fail(peg$c55);
                                            }
                                          }
                                          if (s4 !== peg$FAILED) {
                                            s5 = peg$parse__();
                                            if (s5 !== peg$FAILED) {
                                              s6 = peg$parsequotation_mark();
                                              if (s6 !== peg$FAILED) {
                                                s7 = [];
                                                s8 = peg$parseschar();
                                                while (s8 !== peg$FAILED) {
                                                  s7.push(s8);
                                                  s8 = peg$parseschar();
                                                }
                                                if (s7 !== peg$FAILED) {
                                                  s8 = peg$parsequotation_mark();
                                                  if (s8 !== peg$FAILED) {
                                                    s9 = peg$parse_();
                                                    if (s9 !== peg$FAILED) {
                                                      s10 = peg$parseRBRACE();
                                                      if (s10 !== peg$FAILED) {
                                                        s11 = peg$parse_();
                                                        if (s11 !== peg$FAILED) {
                                                          peg$savedPos = s0;
                                                          s1 = peg$c56(s7);
                                                          s0 = s1;
                                                        } else {
                                                          peg$currPos = s0;
                                                          s0 = peg$FAILED;
                                                        }
                                                      } else {
                                                        peg$currPos = s0;
                                                        s0 = peg$FAILED;
                                                      }
                                                    } else {
                                                      peg$currPos = s0;
                                                      s0 = peg$FAILED;
                                                    }
                                                  } else {
                                                    peg$currPos = s0;
                                                    s0 = peg$FAILED;
                                                  }
                                                } else {
                                                  peg$currPos = s0;
                                                  s0 = peg$FAILED;
                                                }
                                              } else {
                                                peg$currPos = s0;
                                                s0 = peg$FAILED;
                                              }
                                            } else {
                                              peg$currPos = s0;
                                              s0 = peg$FAILED;
                                            }
                                          } else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                          }
                                        } else {
                                          peg$currPos = s0;
                                          s0 = peg$FAILED;
                                        }
                                      } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                      }
                                    } else {
                                      peg$currPos = s0;
                                      s0 = peg$FAILED;
                                    }
                                    if (s0 === peg$FAILED) {
                                      s0 = peg$currPos;
                                      s1 = peg$parse_();
                                      if (s1 !== peg$FAILED) {
                                        s2 = peg$parseLBRACE();
                                        if (s2 !== peg$FAILED) {
                                          s3 = peg$parse_();
                                          if (s3 !== peg$FAILED) {
                                            if (input.substr(peg$currPos, 15) === peg$c57) {
                                              s4 = peg$c57;
                                              peg$currPos += 15;
                                            } else {
                                              s4 = peg$FAILED;
                                              if (peg$silentFails === 0) {
                                                peg$fail(peg$c58);
                                              }
                                            }
                                            if (s4 !== peg$FAILED) {
                                              s5 = peg$parse__();
                                              if (s5 !== peg$FAILED) {
                                                s6 = peg$parsequotation_mark();
                                                if (s6 !== peg$FAILED) {
                                                  s7 = [];
                                                  s8 = peg$parseschar();
                                                  while (s8 !== peg$FAILED) {
                                                    s7.push(s8);
                                                    s8 = peg$parseschar();
                                                  }
                                                  if (s7 !== peg$FAILED) {
                                                    s8 = peg$parsequotation_mark();
                                                    if (s8 !== peg$FAILED) {
                                                      s9 = peg$parse_();
                                                      if (s9 !== peg$FAILED) {
                                                        s10 = peg$parseRBRACE();
                                                        if (s10 !== peg$FAILED) {
                                                          s11 = peg$parse_();
                                                          if (s11 !== peg$FAILED) {
                                                            peg$savedPos = s0;
                                                            s1 = peg$c59(s7);
                                                            s0 = s1;
                                                          } else {
                                                            peg$currPos = s0;
                                                            s0 = peg$FAILED;
                                                          }
                                                        } else {
                                                          peg$currPos = s0;
                                                          s0 = peg$FAILED;
                                                        }
                                                      } else {
                                                        peg$currPos = s0;
                                                        s0 = peg$FAILED;
                                                      }
                                                    } else {
                                                      peg$currPos = s0;
                                                      s0 = peg$FAILED;
                                                    }
                                                  } else {
                                                    peg$currPos = s0;
                                                    s0 = peg$FAILED;
                                                  }
                                                } else {
                                                  peg$currPos = s0;
                                                  s0 = peg$FAILED;
                                                }
                                              } else {
                                                peg$currPos = s0;
                                                s0 = peg$FAILED;
                                              }
                                            } else {
                                              peg$currPos = s0;
                                              s0 = peg$FAILED;
                                            }
                                          } else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                          }
                                        } else {
                                          peg$currPos = s0;
                                          s0 = peg$FAILED;
                                        }
                                      } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                      }
                                      if (s0 === peg$FAILED) {
                                        s0 = peg$currPos;
                                        s1 = peg$parse_();
                                        if (s1 !== peg$FAILED) {
                                          s2 = peg$parseLBRACE();
                                          if (s2 !== peg$FAILED) {
                                            s3 = peg$parse_();
                                            if (s3 !== peg$FAILED) {
                                              s4 = peg$parseWORD();
                                              if (s4 !== peg$FAILED) {
                                                s5 = peg$parse__();
                                                if (s5 !== peg$FAILED) {
                                                  s6 = peg$parseVALUE();
                                                  if (s6 !== peg$FAILED) {
                                                    s7 = peg$parse_();
                                                    if (s7 !== peg$FAILED) {
                                                      s8 = peg$parseRBRACE();
                                                      if (s8 !== peg$FAILED) {
                                                        s9 = peg$parse_();
                                                        if (s9 !== peg$FAILED) {
                                                          peg$savedPos = s0;
                                                          s1 = peg$c60(s4, s6);
                                                          s0 = s1;
                                                        } else {
                                                          peg$currPos = s0;
                                                          s0 = peg$FAILED;
                                                        }
                                                      } else {
                                                        peg$currPos = s0;
                                                        s0 = peg$FAILED;
                                                      }
                                                    } else {
                                                      peg$currPos = s0;
                                                      s0 = peg$FAILED;
                                                    }
                                                  } else {
                                                    peg$currPos = s0;
                                                    s0 = peg$FAILED;
                                                  }
                                                } else {
                                                  peg$currPos = s0;
                                                  s0 = peg$FAILED;
                                                }
                                              } else {
                                                peg$currPos = s0;
                                                s0 = peg$FAILED;
                                              }
                                            } else {
                                              peg$currPos = s0;
                                              s0 = peg$FAILED;
                                            }
                                          } else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                          }
                                        } else {
                                          peg$currPos = s0;
                                          s0 = peg$FAILED;
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }

          return s0;
        }

        function peg$parsechildnodes() {
          var s0, s1;

          s0 = [];
          s1 = peg$parsenodeItem();
          while (s1 !== peg$FAILED) {
            s0.push(s1);
            s1 = peg$parsenodeItem();
          }

          return s0;
        }

        function peg$parsenodeItem() {
          var s0, s1, s2, s3, s4, s5, s6, s7;

          s0 = peg$currPos;
          s1 = peg$parse_();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseLBRACE();
            if (s2 !== peg$FAILED) {
              s3 = peg$parse_();
              if (s3 !== peg$FAILED) {
                s4 = peg$parsenode();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parse_();
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parseRBRACE();
                    if (s6 !== peg$FAILED) {
                      s7 = peg$parse_();
                      if (s7 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c61(s4);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }

          return s0;
        }

        function peg$parsenode() {
          var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16, s17;

          s0 = peg$currPos;
          s1 = peg$parse_();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseWORD();
            if (s2 !== peg$FAILED) {
              s3 = peg$parse__();
              if (s3 !== peg$FAILED) {
                s4 = peg$parseINTEGER();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parse_();
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parseLBRACE();
                    if (s6 !== peg$FAILED) {
                      s7 = peg$parse_();
                      if (s7 !== peg$FAILED) {
                        s8 = peg$parseattributes();
                        if (s8 !== peg$FAILED) {
                          s9 = peg$parse_();
                          if (s9 !== peg$FAILED) {
                            s10 = peg$parseRBRACE();
                            if (s10 !== peg$FAILED) {
                              s11 = peg$parse_();
                              if (s11 !== peg$FAILED) {
                                s12 = peg$parseLBRACE();
                                if (s12 !== peg$FAILED) {
                                  s13 = peg$parse_();
                                  if (s13 !== peg$FAILED) {
                                    s14 = peg$parsechildnodes();
                                    if (s14 !== peg$FAILED) {
                                      s15 = peg$parse_();
                                      if (s15 !== peg$FAILED) {
                                        s16 = peg$parseRBRACE();
                                        if (s16 !== peg$FAILED) {
                                          s17 = peg$parse_();
                                          if (s17 !== peg$FAILED) {
                                            peg$savedPos = s0;
                                            s1 = peg$c62(s2, s4, s8, s14);
                                            s0 = s1;
                                          } else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                          }
                                        } else {
                                          peg$currPos = s0;
                                          s0 = peg$FAILED;
                                        }
                                      } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                      }
                                    } else {
                                      peg$currPos = s0;
                                      s0 = peg$FAILED;
                                    }
                                  } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                  }
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }

          return s0;
        }

        function peg$parse__() {
          var s0, s1;

          peg$silentFails++;
          s0 = [];
          if (peg$c64.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c65);
            }
          }
          if (s1 !== peg$FAILED) {
            while (s1 !== peg$FAILED) {
              s0.push(s1);
              if (peg$c64.test(input.charAt(peg$currPos))) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c65);
                }
              }
            }
          } else {
            s0 = peg$FAILED;
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c63);
            }
          }

          return s0;
        }

        function peg$parse_() {
          var s0, s1;

          peg$silentFails++;
          s0 = [];
          if (peg$c64.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c65);
            }
          }
          while (s1 !== peg$FAILED) {
            s0.push(s1);
            if (peg$c64.test(input.charAt(peg$currPos))) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c65);
              }
            }
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c66);
            }
          }

          return s0;
        }

        function peg$parseMETA() {
          var s0;

          if (input.substr(peg$currPos, 4) === peg$c67) {
            s0 = peg$c67;
            peg$currPos += 4;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c68);
            }
          }

          return s0;
        }

        function peg$parseCONNECTION() {
          var s0;

          if (input.substr(peg$currPos, 10) === peg$c69) {
            s0 = peg$c69;
            peg$currPos += 10;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c70);
            }
          }

          return s0;
        }

        function peg$parseOM() {
          var s0;

          if (input.substr(peg$currPos, 2) === peg$c71) {
            s0 = peg$c71;
            peg$currPos += 2;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c72);
            }
          }

          return s0;
        }

        function peg$parseAN() {
          var s0;

          if (input.substr(peg$currPos, 2) === peg$c73) {
            s0 = peg$c73;
            peg$currPos += 2;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c74);
            }
          }

          return s0;
        }

        function peg$parseUN() {
          var s0;

          if (input.substr(peg$currPos, 2) === peg$c75) {
            s0 = peg$c75;
            peg$currPos += 2;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c76);
            }
          }

          return s0;
        }

        function peg$parseRN() {
          var s0;

          if (input.substr(peg$currPos, 2) === peg$c77) {
            s0 = peg$c77;
            peg$currPos += 2;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c78);
            }
          }

          return s0;
        }

        function peg$parseLBRACE() {
          var s0;

          if (input.charCodeAt(peg$currPos) === 123) {
            s0 = peg$c79;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c80);
            }
          }

          return s0;
        }

        function peg$parseRBRACE() {
          var s0;

          if (input.charCodeAt(peg$currPos) === 125) {
            s0 = peg$c81;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c82);
            }
          }

          return s0;
        }

        function peg$parseINTEGER() {
          var s0, s1, s2;

          s0 = peg$currPos;
          s1 = [];
          if (peg$c83.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c84);
            }
          }
          if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              if (peg$c83.test(input.charAt(peg$currPos))) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c84);
                }
              }
            }
          } else {
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c85(s1);
          }
          s0 = s1;

          return s0;
        }

        function peg$parseVALUE() {
          var s0, s1, s2, s3;

          s0 = peg$currPos;
          s1 = peg$parsequotation_mark();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseNUMBER();
            if (s2 !== peg$FAILED) {
              s3 = peg$parsequotation_mark();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c86(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsequotation_mark();
            if (s1 !== peg$FAILED) {
              s2 = peg$parseINT();
              if (s2 !== peg$FAILED) {
                s3 = peg$parsequotation_mark();
                if (s3 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c87(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parsequotation_mark();
              if (s1 !== peg$FAILED) {
                s2 = [];
                s3 = peg$parseschar();
                while (s3 !== peg$FAILED) {
                  s2.push(s3);
                  s3 = peg$parseschar();
                }
                if (s2 !== peg$FAILED) {
                  s3 = peg$parsequotation_mark();
                  if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c88(s2);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            }
          }

          return s0;
        }

        function peg$parseINT() {
          var s0, s1, s2, s3, s4;

          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 48) {
            s1 = peg$c89;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c90);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c91();
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 45) {
              s1 = peg$c92;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c93);
              }
            }
            if (s1 === peg$FAILED) {
              s1 = null;
            }
            if (s1 !== peg$FAILED) {
              if (peg$c94.test(input.charAt(peg$currPos))) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c95);
                }
              }
              if (s2 !== peg$FAILED) {
                s3 = [];
                if (peg$c83.test(input.charAt(peg$currPos))) {
                  s4 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c84);
                  }
                }
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  if (peg$c83.test(input.charAt(peg$currPos))) {
                    s4 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c84);
                    }
                  }
                }
                if (s3 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c96(s1, s2, s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }

          return s0;
        }

        function peg$parseNUMBER() {
          var s0, s1, s2, s3, s4, s5;

          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 45) {
            s1 = peg$c92;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c93);
            }
          }
          if (s1 === peg$FAILED) {
            s1 = null;
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            if (peg$c83.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c84);
              }
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              if (peg$c83.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c84);
                }
              }
            }
            if (s2 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 46) {
                s3 = peg$c97;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c98);
                }
              }
              if (s3 !== peg$FAILED) {
                s4 = [];
                if (peg$c83.test(input.charAt(peg$currPos))) {
                  s5 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c84);
                  }
                }
                while (s5 !== peg$FAILED) {
                  s4.push(s5);
                  if (peg$c83.test(input.charAt(peg$currPos))) {
                    s5 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c84);
                    }
                  }
                }
                if (s4 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c99(s1, s2, s4);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }

          return s0;
        }

        function peg$parseschar() {
          var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

          s0 = peg$currPos;
          s1 = peg$parseignored();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c100();
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$parseunescaped();
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parseescape();
              if (s1 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 34) {
                  s2 = peg$c101;
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c102);
                  }
                }
                if (s2 === peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 92) {
                    s2 = peg$c103;
                    peg$currPos++;
                  } else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c104);
                    }
                  }
                  if (s2 === peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 47) {
                      s2 = peg$c105;
                      peg$currPos++;
                    } else {
                      s2 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c106);
                      }
                    }
                    if (s2 === peg$FAILED) {
                      s2 = peg$currPos;
                      if (input.charCodeAt(peg$currPos) === 98) {
                        s3 = peg$c107;
                        peg$currPos++;
                      } else {
                        s3 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c108);
                        }
                      }
                      if (s3 !== peg$FAILED) {
                        peg$savedPos = s2;
                        s3 = peg$c109();
                      }
                      s2 = s3;
                      if (s2 === peg$FAILED) {
                        s2 = peg$currPos;
                        if (input.charCodeAt(peg$currPos) === 102) {
                          s3 = peg$c110;
                          peg$currPos++;
                        } else {
                          s3 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$c111);
                          }
                        }
                        if (s3 !== peg$FAILED) {
                          peg$savedPos = s2;
                          s3 = peg$c112();
                        }
                        s2 = s3;
                        if (s2 === peg$FAILED) {
                          s2 = peg$currPos;
                          if (input.charCodeAt(peg$currPos) === 110) {
                            s3 = peg$c113;
                            peg$currPos++;
                          } else {
                            s3 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$c114);
                            }
                          }
                          if (s3 !== peg$FAILED) {
                            peg$savedPos = s2;
                            s3 = peg$c115();
                          }
                          s2 = s3;
                          if (s2 === peg$FAILED) {
                            s2 = peg$currPos;
                            if (input.charCodeAt(peg$currPos) === 117) {
                              s3 = peg$c116;
                              peg$currPos++;
                            } else {
                              s3 = peg$FAILED;
                              if (peg$silentFails === 0) {
                                peg$fail(peg$c117);
                              }
                            }
                            if (s3 !== peg$FAILED) {
                              s4 = peg$currPos;
                              s5 = peg$currPos;
                              s6 = peg$parseHEXDIG();
                              if (s6 !== peg$FAILED) {
                                s7 = peg$parseHEXDIG();
                                if (s7 !== peg$FAILED) {
                                  s8 = peg$parseHEXDIG();
                                  if (s8 !== peg$FAILED) {
                                    s9 = peg$parseHEXDIG();
                                    if (s9 !== peg$FAILED) {
                                      s6 = [s6, s7, s8, s9];
                                      s5 = s6;
                                    } else {
                                      peg$currPos = s5;
                                      s5 = peg$FAILED;
                                    }
                                  } else {
                                    peg$currPos = s5;
                                    s5 = peg$FAILED;
                                  }
                                } else {
                                  peg$currPos = s5;
                                  s5 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s5;
                                s5 = peg$FAILED;
                              }
                              if (s5 !== peg$FAILED) {
                                s4 = input.substring(s4, peg$currPos);
                              } else {
                                s4 = s5;
                              }
                              if (s4 !== peg$FAILED) {
                                peg$savedPos = s2;
                                s3 = peg$c118(s4);
                                s2 = s3;
                              } else {
                                peg$currPos = s2;
                                s2 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s2;
                              s2 = peg$FAILED;
                            }
                          }
                        }
                      }
                    }
                  }
                }
                if (s2 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c119(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            }
          }

          return s0;
        }

        function peg$parseescape() {
          var s0;

          if (input.charCodeAt(peg$currPos) === 92) {
            s0 = peg$c103;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c104);
            }
          }

          return s0;
        }

        function peg$parsequotation_mark() {
          var s0;

          if (input.charCodeAt(peg$currPos) === 34) {
            s0 = peg$c101;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c102);
            }
          }

          return s0;
        }

        function peg$parseunescaped() {
          var s0;

          if (peg$c120.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c121);
            }
          }

          return s0;
        }

        function peg$parseignored() {
          var s0;

          if (peg$c122.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c123);
            }
          }

          return s0;
        }

        function peg$parseDIGIT() {
          var s0;

          if (peg$c83.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c84);
            }
          }

          return s0;
        }

        function peg$parseHEXDIG() {
          var s0;

          if (peg$c124.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c125);
            }
          }

          return s0;
        }

        function peg$parseWORD() {
          var s0, s1, s2;

          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseCHAR();
          if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parseCHAR();
            }
          } else {
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c126(s1);
          }
          s0 = s1;

          return s0;
        }

        function peg$parseCHAR() {
          var s0;

          if (peg$c127.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c128);
            }
          }
          if (s0 === peg$FAILED) {
            if (peg$c83.test(input.charAt(peg$currPos))) {
              s0 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c84);
              }
            }
          }

          return s0;
        }

        peg$result = peg$startRuleFunction();

        if (peg$result !== peg$FAILED && peg$currPos === input.length) {
          return peg$result;
        } else {
          if (peg$result !== peg$FAILED && peg$currPos < input.length) {
            peg$fail({
              type: "end",
              description: "end of input"
            });
          }

          throw peg$buildException(
            null,
            peg$maxFailExpected,
            peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
            peg$maxFailPos < input.length ?
            peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) :
            peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
          );
        }
      }

      return {
        SyntaxError: peg$SyntaxError,
        parse: peg$parse
      };
    })();
  });
// jshint ignore:end
;
"use strict";

modulum("AuiProtocolReader",
  function(context, cls) {
    /**
     * @class AuiProtocolReader
     * @memberOf classes
     */
    cls.AuiProtocolReader = context.oo.StaticClass(
      /** @lends classes.AuiProtocolReader */
      {
        __name: "AuiProtocolReader",
        translate: function(obj) {
          return context.AuiProtocolParser.parse(obj);
        }
      });
  });
;
"use strict";

modulum("AuiProtocolWriter",
  function(context, cls) {
    var auiTreeCode = "\x01";
    var escapeSpecials = function(text) {
      if (Object.isString(text)) {
        return text.replace(/\\/g, "\\\\").replace(/\n/g, "\\n").replace(/\t/g, "\\t").replace(/"/g, "\\\"");
      } else {
        return text;
      }
    };
    /** @ignore */
    var stringifiers = {
      /** @ignore */
      om: function(obj, application) {
        var result = [];
        if (application.info().wrapper && application.info().wrapper) {
          result.push(cls.AuiProtocolWriter.translate(obj.orders, application));
        } else {
          result.push("event _om ", obj.order, "{}{", cls.AuiProtocolWriter.translate(obj.orders, application), "}\n");
        }
        //noinspection JSDeprecatedSymbols
        var sendString = result.join("");
        var finalString = sendString;
        if (application.encapsulation) {
          var size = sendString.getBytesCount();
          var encodedSize = Number.encodeInteger(size);
          finalString = encodedSize + encodedSize + auiTreeCode + sendString;
        }
        return finalString;
      },
      /** @ignore */
      meta: function(obj) {
        var result = [];
        result.push("meta ", obj.verb, "{", stringifiers.attributes(obj.attributes), "}\n");
        return result.join("");
      },
      /** @ignore */
      functionCallEvent: function(obj) {
        var result = [];
        var datatypes = {
          "string": "STRING",
          "object": "RECORD",
          "array": "ARRAY"
        };
        result.push("{FunctionCallEvent 0{{result \"", obj.status, "\"}");
        if (!!obj.message) {
          result.push("{errorMessage \"" + escapeSpecials(obj.message) + "\"}");
        }
        result.push("}");
        if (Array.isArray(obj.values)) {
          result.push("{");
          for (var i = 0; i < obj.values.length; i++) {
            var value = obj.values[i];
            result.push("{FunctionCallReturn " + i + "{");
            var valtype = Object.prototype.toString.call(value) === '[object Array]' ? "array" : typeof value;
            if (datatypes[valtype]) {
              result.push("{dataType \"" + datatypes[typeof value] + "\"}");
            }
            if (value === null || value === undefined || value.length <= 0) {
              result.push("{isNull \"1\"}{value \"0\"}");
            } else if (Object.isBoolean(value)) {
              result.push("{isNull \"0\"}{value \"" + (value ? "1" : "0") + "\"}");
            } else {
              result.push("{isNull \"0\"}{value \"" + escapeSpecials(value.toString()) + "\"}");
            }
            result.push("}{}}");
          }
          result.push("}");
        }
        result.push("}");
        return result.join("");
      },
      /** @ignore */
      configureEvent: function(obj) {
        var result = [];
        result.push("{ConfigureEvent 0{", stringifiers.attributes(obj.attributes), "}}");
        return result.join("");
      },
      /** @ignore */
      keyEvent: function(obj) {
        var result = [];
        result.push("{KeyEvent 0{", stringifiers.attributes(obj.attributes), "}}");
        return result.join("");
      },
      /** @ignore */
      actionEvent: function(obj) {
        var result = [];
        result.push("{ActionEvent 0{", stringifiers.attributes(obj.attributes), "}}");
        return result.join("");
      },
      /** @ignore */
      rowSelectionEvent: function(obj) {
        var result = [];
        result.push("{RowSelectionEvent 0{", stringifiers.attributes(obj.attributes), "}}");
        return result.join("");
      },
      /** @ignore */
      dragDropEvent: function(obj) {
        var result = [];
        result.push("{DragDropEvent 0{", stringifiers.attributes(obj.attributes), "}}");
        return result.join("");
      },
      /** @ignore */
      attributes: function(attributeList) {
        var string = [];
        var keys = Object.keys(attributeList);
        for (var i = 0; i < keys.length; i++) {
          string.push("{", keys[i], " \"", escapeSpecials(attributeList[keys[i]]), "\"", "}");
        }
        return string.join("");
      },
      /** @ignore */
      _default: function(obj) {
        context.LogService.info("no aui protocol implementation for " + obj.type, obj);
        return "";
      }
    };
    /**
     * @namespace classes.AuiProtocolWriter
     */
    cls.AuiProtocolWriter = context.oo.StaticClass(
      /** @lends classes.AuiProtocolWriter */
      {
        __name: "AuiProtocolWriter",
        /**
         *
         * @param obj
         * @param application
         * @return {string}
         */
        translate: function(obj, application) {
          return (Array.isArray(obj) ? obj : [obj]).map(function(item) {
            return (stringifiers[item.type] || stringifiers._default)(item, application);
          }).join("");

        }
      });
  });
;
"use strict";

modulum("ProtocolInterface",
  function(context, cls) {
    /**
     * Base class for protocol interface.
     * @class ProtocolInterface
     * @memberOf classes
     */
    cls.ProtocolInterface = context.oo.Class(
      /** @lends classes.ProtocolInterface.prototype */
      {
        __name: "ProtocolInterface",
        isAlive: function() {
          return false;
        },
        trackPrompt: function() {
          return false;
        }
      });
  });
;
"use strict";

(
  function(context, cls) {

    /**
     * Direct protocol interface. manages the full protocol as a state machine
     * @class DirectInterface
     * @memberOf classes
     * @extends classes.ProtocolInterface
     */
    cls.DirectInterface = context.oo.Class({
      base: cls.ProtocolInterface
    }, function() {
      return /** @lends classes.DirectInterface.prototype */ {
        __name: "DirectInterface",
        /**
         * @type {classes.VMApplication}
         */
        application: null,
        /**
         * The Direct protocol is managed by Finite State Machine
         * @see https://github.com/jakesgordon/javascript-state-machine
         */
        directProtocol: null,
        _incomingData: null,
        eventQueue: null,
        eventInterval: null,
        eventIntervalTimeout: 30,
        onFirstGuiReady: null,
        /** @type {window.gbcWrapper} */
        _wrapper: null,
        /**
         * @constructs
         * @param application
         */
        constructor: function(application) {
          this.application = application;
          //application.encapsulation = true;
          this._incomingData = [];
          this.onFirstGuiReady = [];
          this.eventQueue = [];
          this._wrapper = application.info().wrapper;
          var directInterface = this;
          var directProtocol = this.directProtocol = context.StateMachine.create(
            /** @lends classes.DirectInterface#directProtocol */
            {
              /**
               * the general error handler
               */
              error: function(eventName, from, to, args, errorCode, errorMessage) {
                application.info().ending = cls.ApplicationEnding.notok("" + errorCode + ". " + errorMessage);
              },
              initial: "Start",
              /**
               * the different events of the state machine
               * @see the directStates constant
               */
              events: context.constants.network.directStates,
              callbacks: {
                /**
                 * whenever we leave a state
                 */
                onleavestate: function(action, from, to) {
                  context.LogService.networkProtocol.debug("PROTOCOL", from, " -> [", action, "] -> ", to);
                },
                onleaveStart: function(event, from, to, ending) {
                  directInterface.read(function(data) {
                    cls.DirectInitialAUI.run(data, application, function() {
                      window.setTimeout(function() {
                        application.setRunning(true);
                        directProtocol.transition();
                      }, 10);
                    });
                  });
                  return context.StateMachine.ASYNC;
                },
                onenterRecvInitialAUI: function() {
                  if (application.isProcessing()) {
                    directProtocol.waitForMoreInitialAUI();
                  } else {
                    window.setTimeout(function() {
                      directProtocol.guiMode();
                    }, 10);
                  }
                },
                onenterSendEmpty: function() {
                  directProtocol.getMoreOrder();
                },
                onleaveSendEmpty: function() {
                  if (!directInterface.application.hasError && !directInterface.application.ending) {
                    directInterface.read(function(data) {
                      cls.DirectRecvOrder.run(data, application, function() {
                        directProtocol.transition();
                      });
                    });
                    return StateMachine.ASYNC;
                  }
                },
                onenterRecvOrder: function() {
                  if (application.isProcessing()) {
                    directProtocol.waitForMoreOrder();
                  } else {
                    directProtocol.guiMode();
                  }
                },
                onenterGUI: function() {
                  if (directInterface.application.ending) {
                    if (directProtocol.transition) {
                      directProtocol.transition.cancel();
                    }
                    directProtocol.waitForEnd();
                  } else {
                    if (directInterface.onFirstGuiReady) {
                      var callbacks = directInterface.onFirstGuiReady;
                      directInterface.onFirstGuiReady = null;
                      while (callbacks.length) {
                        callbacks.splice(0, 1)[0]();
                      }
                    }

                    directInterface.eventInterval = window.setInterval(function() {
                      if (directInterface.eventQueue.length) {
                        directInterface.application.setProcessing();
                        window.setTimeout(function() {
                          directProtocol.sendOrder();
                        }, 10);
                        window.clearInterval(directInterface.eventInterval);
                      }
                    }, directInterface.eventIntervalTimeout);
                  }
                },
                onleaveGUI: function() {
                  window.clearInterval(directInterface.eventInterval);
                },
                onenterSendOrder: function() {
                  directProtocol.getOrderAnswer();
                },
                onleaveSendOrder: function(event, from, to) {
                  if (to !== "ApplicationEnd") {
                    var orders = directInterface.eventQueue;
                    directInterface.eventQueue = [];
                    cls.DirectSendOrders.run(orders.flatten(), application, directInterface);
                    directInterface.read(function(data) {
                      cls.DirectRecvOrder.run(data, application, function() {
                        directProtocol.transition();
                      });
                    });
                    return StateMachine.ASYNC;
                  }
                },
                /**
                 * when the application ends, we wait for a confirmation close
                 */
                onenterApplicationEnding: function() {
                  directProtocol.endApp();
                },
                /**
                 * until we  the application ends, we wait for a confirmation close
                 */
                onleaveApplicationEnding: function(event, from, to, closed) {
                  if (!closed) {
                    directInterface._wrapper.send("");
                    directInterface.read(function(data) {
                      cls.DirectRecvOrder.run(data, application, function() {
                        directProtocol.transition();
                      });
                    });
                    return StateMachine.ASYNC;
                  }
                },
                onenterApplicationEnd: function() {
                  application.stop();
                }
              }
            });
        },
        start: function() {
          this._wrapper.on(this._wrapper.events.RECEIVE, this._onReceive.bind(this));
          this._wrapper.URReady({
            UCName: "GBC",
            UCVersion: gbc.version,
            mobileUI: context.ThemeService.getValue("aui-mobileUI-default") ? 1 : 0
          });
          this.directProtocol.start();
        },
        event: function(events) {
          if (!!events) {
            if (this.application && !this.application.ending) {
              // detect short time when we are going to send a request to the VM but we didn't send yet
              this.application.pendingRequest = true;
              this.eventQueue.push(events);
              window.clearInterval(this.eventInterval);
              this.eventInterval = null;
              if (this.eventInterval === null) {
                this.eventInterval = window.setInterval(this._manageEvents.bind(this), this.eventIntervalTimeout);
              }
            } else {
              window.clearInterval(this.eventInterval);
              this.eventInterval = null;
            }
          }
        },
        /**
         * @returns {number} the delay in ms between network requests
         */
        getNetworkDelay: function() {
          return this._networkDelay;
        },
        /**
         * @param {number} delay the delay in ms between network requests
         */
        setNetworkDelay: function(delay) {
          this._networkDelay = delay;
        },
        _manageEvents: function() {
          if (this.application) {
            this.application.pendingRequest = false;
            if (this.application.isIdle() && this.directProtocol.can("sendOrder")) {
              if (this.eventQueue.length) {
                this.application.setProcessing();
                if (this._networkDelay > 0) {
                  window.setTimeout(this.directProtocol.sendOrder.bind(this.directProtocol), this._networkDelay);
                } else {
                  this.directProtocol.sendOrder();
                }
                window.clearInterval(this.eventInterval);
                this.eventInterval = null;
              } else {
                window.clearInterval(this.eventInterval);
                this.eventInterval = null;
              }
            }
          } else {
            window.clearInterval(this.eventInterval);
            this.eventInterval = null;
          }
        },
        newTask: function() {
          this._wrapper.childStart();
        },
        waitForNewApp: function(onSuccess, onFailure) {
          onSuccess();
        },
        interrupt: function() {
          this._wrapper.interrupt();
        },
        close: function() {
          this._wrapper.close();
        },
        destroy: function() {
          window.clearInterval(this.eventInterval);
          this.application = null;
          this.eventQueue = null;
          this._wrapper.close();
          this.directProtocol = null;
        },

        read: function(cb) {
          if (this._incomingData.length) {
            cb(this._incomingData.shift());
          } else {
            setTimeout(function() {
              this.read(cb);
            }.bind(this), 10);
          }
        },
        write: function(data, options) {
          this._wrapper.send(data, options);
        },
        _onReceive: function(event, src, data) {
          context.LogService.networkProtocol.debug("HTTP RESPONSE\n", "NATIVE RECEIVE", data);
          this._incomingData.push(data);
        }

      };
    });

  })(gbc, gbc.classes);
;
"use strict";

(
  function(context, cls) {
    /**
     * @class DirectInitialAUI
     * @memberOf classes
     */
    cls.DirectInitialAUI = context.oo.StaticClass(
      /** @lends classes.DirectInitialAUI */
      {
        run: function(data, application, callback) {
          application.model.logDvm(data);
          application.dvm.manageAuiOrders(data, callback);
        }
      });
  })(gbc, gbc.classes);
;
"use strict";

(
  function(context, cls) {
    /**
     * @class DirectRecvOrder
     * @memberOf classes
     */
    cls.DirectRecvOrder = context.oo.StaticClass(
      /** @lends classes.DirectRecvOrder */
      {
        run: function(data, application, callback) {
          if (!!data) {
            application.model.logDvm(data);
            application.dvm.manageAuiOrders(data, callback);
          } else {
            callback();
          }
        }
      });
  })(gbc, gbc.classes);
;
"use strict";

(
  function(context, cls) {
    /**
     * @class DirectSendOrders
     * @memberOf classes
     */
    cls.DirectSendOrders = context.oo.StaticClass(
      /** @lends classes.DirectSendOrders */
      {
        run: function(orders, application, directInterface) {
          var data = cls.AuiProtocolWriter.translate({
              type: "om",
              order: application.info().auiOrder++,
              orders: orders
            }, application),
            options = {};
          if (!!orders.find(function(item) {
              return item.noUserActivity;
            })) {
            options = {
              userActivity: "no"
            };
          }
          application.model.logFireEvent(data);
          directInterface.write(data, options);
        }
      });
  })(gbc, gbc.classes);
;
"use strict";

(
  /**
   * @param {gbc} context
   */
  function(context) {
    context.constants.network.directStates = [{
      name: "run",
      from: "none",
      to: "Start"
    }, {
      name: "start",
      from: "Start",
      to: "RecvInitialAUI"
    }, {
      name: "waitForMoreInitialAUI",
      from: "RecvInitialAUI",
      to: "SendEmpty"
    }, {
      name: "getMoreOrder",
      from: "SendEmpty",
      to: "RecvOrder"
    }, {
      name: "guiMode",
      from: ["RecvInitialAUI", "RecvOrder"],
      to: "GUI"
    }, {
      name: "sendOrder",
      from: "GUI",
      to: "SendOrder"
    }, {
      name: "getOrderAnswer",
      from: "SendOrder",
      to: "RecvOrder"
    }, {
      name: "waitForMoreOrder",
      from: "RecvOrder",
      to: "SendEmpty"
    }, {
      name: "waitForEnd",
      from: ["ApplicationEnding", "GUI", "SendHandShake"],
      to: "ApplicationEnding"
    }, {
      name: "endApp",
      from: ["SendStart", "SendStartTask", "SendHandShake", "GUI", "SendEmpty", "SendOrder", "ApplicationEnding"],
      to: "ApplicationEnd"
    }];
  })(gbc);
;
"use strict";

(
  function(context, cls) {

    /**
     *
     * @class NoInterface
     * @memberOf classes
     * @extends classes.ProtocolInterface
     */
    cls.NoInterface = context.oo.Class({
      base: cls.ProtocolInterface
    }, function() {
      return /** @lends classes.NoInterface.prototype */ {
        __name: "NoInterface",
        application: null,
        uaProtocol: null,
        ping: null,
        eventQueue: null,
        eventInterval: null,
        eventIntervalTimeout: 300,
        onFirstGuiReady: null,
        applicationEnding: null,
        taskCount: 0,
        _eventListener: null,
        /**
         * @constructs
         * @param application
         */
        constructor: function(application) {
          this.eventQueue = [];
          this._eventListener = new cls.EventListener();
        },
        start: function() {},
        event: function(events) {
          if (!!events) {
            if (!Array.isArray(events)) {
              events = [events];
            }
            this.eventQueue = this.eventQueue.concat(events);
            window.clearInterval(this.eventInterval);

            this.eventInterval = window.setInterval(function() {
              if (this.eventQueue.length) {
                this._eventListener.emit("events", this.eventQueue);
                window.clearInterval(this.eventInterval);
              } else {
                window.clearInterval(this.eventInterval);
              }
            }.bind(this), this.eventIntervalTimeout);
          } else {
            window.clearInterval(this.eventInterval);
          }
        },
        newTask: function() {},
        interrupt: function() {},
        close: function() {},
        destroy: function() {},
        waitForNewApp: function(onSuccess, onFailure) {
          onSuccess();
        },

        /**
         * Returns the queued events and clears the event list.
         * @returns {object[]} list of events to send to the VM
         */
        fetchEvents: function() {
          var events = this.eventQueue;
          this.eventQueue = [];
          return events;
        },
        onEvents: function(hook) {
          return this._eventListener.when("events", hook);
        }
      };
    });

  })(gbc, gbc.classes);
;
"use strict";

(
  function(context, cls) {
    /**
     * populates the headers from the response object
     * @memberOf UAInterface
     * @private
     * @param jqXHR the $.ajax jqXHR response
     * @returns {Object} a map of gbc aware headers
     * @ignore
     */
    var getHeaders = function(jqXHR) {
      var result = {};
      var keys = Object.keys(context.constants.network.headers);
      for (var k = 0; k < keys.length; k++) {
        var headerName = context.constants.network.headers[keys[k]];
        result[keys[k]] = jqXHR.getResponseHeader(headerName);
      }
      return result;
    };
    /**
     *
     * @param session
     * @param taskId
     * @param callback
     * @ignore
     */
    var runNewTask = function(session, taskId, callback) {
      window.setTimeout(function(session, taskId, callback) {
        var sessionInstance = (session instanceof cls.VMSession) ? session :
          context.SessionService.getSession(session);
        if (sessionInstance) {
          sessionInstance.startTask(taskId, callback);
        }
      }.bind(null, session, taskId, callback), 10);
    };

    /**
     * manages special headers from sever whenever a response is received
     * @memberOf UAInterface
     * @private
     * @param args the arguments of the $.ajax callback (data, status, jqXHR)
     * @param uaProtocol the uaProtocol instance
     * @param {classes.VMApplication} application
     * @param onSuccess the callback in case of success
     * @param {?boolean} fromNewTask
     * @ignore
     */
    var canRun = function(args, uaProtocol, application, onSuccess, fromNewTask) {
      if (!application) {
        if (uaProtocol.transition) {
          uaProtocol.transition.cancel();
        }
      } else {
        if (application.info() && application.info().ending) {
          application.setError();
          if (uaProtocol.transition) {
            uaProtocol.transition.cancel();
          }
          uaProtocol.headerError();
        } else {
          var headers = getHeaders(args[2]);
          if (headers.serverFeatures) {
            application.getSession().addServerFeatures((headers.serverFeatures || "").split(","));
          }
          if (headers.endUrl) {
            window.__desactivateEndingPopup = true;
            application.getSession().setEndUrl(headers.endUrl);
          }
          if (headers.sessionClosed) {
            application.getSession().closeSession();
            return;
          }
          if (fromNewTask && !headers.newTask) {
            application.getSession().waitedForNewTask();
          }
          if (headers.devmode === "true") {
            context.DebugService.activate();
          }
          if (headers.webComponent) {
            context.WebComponentService.setWebcomponentUrl(headers.webComponent);
          }
          if (headers.error) {
            application.setError();
            if (uaProtocol.transition) {
              uaProtocol.transition.cancel();
            }
            uaProtocol.headerError(headers.error);
          } else if (headers.closed) {
            if (uaProtocol.transition) {
              uaProtocol.transition.cancel();
            }
            application.setEnding();
            uaProtocol.endApp(headers.closed);
          } else if (headers.newTask) {
            runNewTask(application.getSession(), headers.newTask, function() {
              onSuccess(args[0], headers);
            });
          } else if (headers.contentType === "text/html") {
            window.__desactivateEndingPopup = true;
            window.location.reload();
          } else {
            onSuccess(args[0], headers);
          }
          if (!application.hasError && !application.ending) {
            application.getSession().displayLogPrompt(headers.prompt);
          }
        }
      }
    };
    /**
     * UAProxy protocol interface. manages the full protocol as a state machine
     * @class UAInterface
     * @memberOf classes
     * @extends classes.ProtocolInterface
     */
    cls.UAInterface = context.oo.Class({
      base: cls.ProtocolInterface
    }, function() {
      return /** @lends classes.UAInterface.prototype */ {
        __name: "UAInterface",
        sessionId: null,
        /** @type classes.VMApplication */
        application: null,
        uaProtocol: null,
        ping: null,
        eventQueue: null,
        eventInterval: null,
        eventIntervalTimeout: 30,
        _networkDelay: 0,
        onFirstGuiReady: null,
        applicationEnding: null,
        taskCount: 0,

        /**
         * @constructs
         * @param {classes.VMApplication} application
         */
        constructor: function(application) {
          this.application = application;
          this.sessionId = application.getSession()._identifier;
          this.onFirstGuiReady = [];
          this.eventQueue = [];
          var uaInterface = this;
          /**
           * The ua protocol is managed by Finite State Machine
           * @memberOf UAInterface
           * @see https://github.com/jakesgordon/javascript-state-machine
           */
          var uaProtocol = this.uaProtocol = context.StateMachine.create({
            /**
             * the general error handler
             * @ignore
             */
            error: function(eventName, from, to, args, errorCode, errorMessage, e) {
              console.error(eventName, from, to, args, errorCode, errorMessage);
              context.error(errorMessage, e);
              if (!application.ended) {
                application.info().ending = cls.ApplicationEnding.notok("" + errorCode + ". " + errorMessage);
              }
            },
            /**
             * the different events of the state machine
             * @see the uaStates constant
             * @ignore
             */
            events: context.constants.network.uaStates,
            callbacks: /** @ignore */ {
              /**
               * whenever we leave a state
               * @ignore
               */
              onleavestate: function(action, from, to) {
                context.LogService.networkProtocol.debug("STATE MACHINE(", application.applicationHash, ")", from,
                  " -> [", action, "] -> ", to);
              },
              /**
               * leave sendStart state
               * * if data is defined, it is either true if the app is closing, or an error message
               * * else we read the returning connection string
               * @ignore
               */
              onleaveSendStart: function(event, from, to, data) {
                if (!application.info().ending && !data) {
                  cls[application.info().task ? "UAStartupTask" : "UAStartup"].run(application, function(arg1, arg2, arg3, arg4,
                    arg5, arg6, arg7, arg8, arg9) {
                    canRun([arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9], uaProtocol, uaInterface.application,
                      function(data, headers) {
                        cls.UAConnectionString.run(data, headers, application);
                        uaProtocol.transition();
                      });
                  });
                  return context.StateMachine.ASYNC;
                }
              },
              /**
               * leave sendStartTask state (new task)
               * * if data is defined, it is either true if the app is closing, or an error message
               * * else we read the returning connection string
               * @ignore
               */
              onleaveSendStartTask: function(event, from, to, data) {
                if (!application.info().ending && !data) {
                  cls.UAStartupTask.run(application, function(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9) {
                    canRun([arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9], uaProtocol, uaInterface.application,
                      function(data, headers) {
                        cls.UAConnectionString.run(data, headers, application);
                        uaProtocol.transition();
                      });
                  });
                  return StateMachine.ASYNC;
                }
              },
              /**
               * When the connection string is ok, we handshake the server
               * @ignore
               */
              onenterRecvConnectionString: function() {
                uaProtocol.handShake();
              },
              /**
               * As we handshake the server, we ask for the initial aui tree
               * @ignore
               */
              onenterSendHandShake: function() {
                if (!application.info().ending) {
                  uaInterface.isRunning = true;
                  application.setProcessing();
                  uaProtocol.getInitialAUI();
                } else {
                  uaProtocol.headerError(";");
                }
              },
              /** @ignore */
              onleaveSendHandShake: function(event, from, to, ending) {
                if (!ending) {
                  if (uaInterface.application.ending) {
                    if (event !== "waitForEnd") {
                      if (uaProtocol.transition) {
                        uaProtocol.transition.cancel();
                      }
                      uaProtocol.waitForEnd();
                    }
                  } else {
                    cls.UAHandShake.run(application, function(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9) {
                      canRun([arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9], uaProtocol, uaInterface.application,
                        function(data, headers) {
                          cls.UAInitialAUI.run(data, headers, application, function() {
                            application.setRunning(true);
                            uaProtocol.transition();
                          });
                        });
                    });
                    return StateMachine.ASYNC;
                  }
                }
              },
              /** @ignore */
              onenterRecvInitialAUI: function() {
                if (application.isProcessing()) {
                  uaProtocol.waitForMoreInitialAUI();
                } else {
                  window.setTimeout(function() {
                    uaProtocol.guiMode();
                  }, 10);
                }
              },
              /** @ignore */
              onenterSendEmpty: function() {
                uaProtocol.getMoreOrder();
              },
              /** @ignore */
              onleaveSendEmpty: function() {
                if (!uaInterface.application.hasError && !uaInterface.application.ending) {
                  cls.UASendEmpty.run(application, function(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9) {
                    canRun([arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9], uaProtocol, uaInterface.application,
                      function(data, headers) {
                        cls.UARecvOrder.run(data, headers, application, function() {
                          uaProtocol.transition();
                        });
                      });
                  });
                  return StateMachine.ASYNC;
                }
              },
              /** @ignore */
              onenterRecvOrder: function() {
                if (application.isProcessing()) {
                  uaProtocol.waitForMoreOrder();
                } else {
                  uaProtocol.guiMode();
                }
              },
              /** @ignore */
              onenterGUI: function() {
                if (!uaInterface.application) {
                  uaProtocol.transition.cancel();
                  return;
                }
                if (uaInterface.application.ending) {
                  if (uaProtocol.transition) {
                    uaProtocol.transition.cancel();
                  }
                  uaProtocol.waitForEnd();
                } else {
                  if (uaInterface.onFirstGuiReady) {
                    var callbacks = uaInterface.onFirstGuiReady;
                    uaInterface.onFirstGuiReady = null;
                    while (callbacks.length) {
                      callbacks.splice(0, 1)[0]();
                    }
                  }
                  uaInterface.ping = window.setTimeout(function() {
                    uaProtocol.ping();
                  }, application.info().pingTimeout);

                  /** @ignore */
                  var localManageEvents = function(fireIndex) {
                    if (uaInterface.eventQueue && uaInterface.eventQueue.length) {
                      if (uaInterface.application.isIdle() && uaProtocol.can("sendOrder")) {
                        uaInterface.application.setProcessing();
                        uaProtocol.sendOrder(fireIndex);
                        window.clearInterval(uaInterface.eventInterval);
                        uaInterface.eventInterval = null;
                      }
                    }
                  };
                  if (uaInterface.eventQueue && uaInterface.eventQueue.length) {
                    if (uaInterface.eventInterval === null) {
                      uaInterface.eventInterval = window.setInterval(localManageEvents.bind(uaInterface), uaInterface
                        .eventIntervalTimeout);
                    }
                  }
                }
              },
              /** @ignore */
              onleaveGUI: function() {
                window.clearTimeout(uaInterface.ping);
                window.clearInterval(uaInterface.eventInterval);
                uaInterface.eventInterval = null;
              },
              /** @ignore */
              onenterSendOrder: function(event, from, to, count) {
                uaProtocol.getOrderAnswer();
              },
              /** @ignore */
              onleaveSendOrder: function(event, from, to) {
                if (to !== "ApplicationEnd" && to !== "HeaderError") {
                  var orders = uaInterface.eventQueue;
                  uaInterface.eventQueue = [];
                  orders = orders.flatten();
                  var httpOptions = null;
                  if (!!orders.find(function(item) {
                      return item.noUserActivity;
                    })) {
                    httpOptions = {
                      headers: {
                        "X-FourJs-User-Activity": "no"
                      }
                    };
                  }
                  cls.UASendOrders.run(orders, application, function(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8,
                    arg9) {
                    canRun([arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9], uaProtocol, uaInterface.application,
                      function(data, headers) {
                        cls.UARecvOrder.run(data, headers, application, function() {
                          uaProtocol.transition();
                        });
                      });
                  }, httpOptions);
                  return StateMachine.ASYNC;
                }
              },
              /**
               * the ping doesn't take care of the answer (apart from the headers)
               * @ignore
               */
              onenterPing: function() {
                cls.UAPing.run(application, function(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9) {
                  canRun([arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9], uaProtocol, uaInterface.application,
                    function() {
                      // no need to manage ping answer
                    });
                });
                uaProtocol.pingSent();
              },
              /**
               * when the application ends, we wait for a confirmation close
               * @ignore
               */
              onenterApplicationEnding: function(event, from, to) {
                uaProtocol.endApp(from === "SendHandShake");
              },
              /**
               * until we  the application ends, we wait for a confirmation close
               * @ignore
               */
              onleaveApplicationEnding: function(event, from, to, closed) {
                if (!closed && !uaInterface.application.hasError) {
                  cls.UASendEndingEmpty.run(application, function(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9) {
                    canRun([arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9], uaProtocol, uaInterface.application,
                      function(data, headers) {
                        cls.UARecvOrder.run(data, headers, application, function() {
                          if (application.ending) {
                            uaProtocol.transition();
                          } else {
                            uaProtocol.transition.cancel();
                            window.setTimeout(function() {
                              uaProtocol.waitForEnd();
                            }, 1000);
                          }
                        });
                      });
                  });
                  return StateMachine.ASYNC;
                }
              },
              /** @ignore */
              onenterHeaderError: function(event, from, to, msg) {
                if (msg && msg.indexOf("Auto Logout") === 0) {
                  application.info().ending = cls.ApplicationEnding.autoLogout(msg);
                } else {
                  application.info().ending = application.info().ending || cls.ApplicationEnding.uaProxy(msg);
                }
                uaProtocol.endApp();
              },
              /** @ignore */
              onenterApplicationEnd: function() {
                var session = application.getSession();
                var applicationInfo = application.info();
                applicationInfo.ending = applicationInfo.ending || cls.ApplicationEnding.ok;
                application.stop();
                var nextApp = session.getCurrentApplication();
                if (nextApp) {
                  session.getWidget().setCurrentWidget(nextApp.getUI().getWidget());
                }
              }
            }
          });
          uaProtocol.start();
        },
        start: function() {
          this.uaProtocol.getConnectionString();
        },
        event: function(events) {
          if (!!events) {
            if (this.application && !this.application.ending) {
              // detect short time when we are going to send a request to the VM but we didn't send yet
              this.application.pendingRequest = true;
              this.eventQueue.push(events);
              window.clearInterval(this.eventInterval);
              this.eventInterval = null;
              if (this.eventInterval === null) {
                this.eventInterval = window.setInterval(this._manageEvents.bind(this), this.eventIntervalTimeout);
              }
            } else {
              window.clearInterval(this.eventInterval);
              this.eventInterval = null;
            }
          }
        },
        /**
         * @returns {number} the delay in ms between network requests
         */
        getNetworkDelay: function() {
          return this._networkDelay;
        },
        /**
         * @param {number} delay the delay in ms between network requests
         */
        setNetworkDelay: function(delay) {
          this._networkDelay = delay;
        },
        _manageEvents: function() {
          if (this.application) {
            this.application.pendingRequest = false;
            if (this.application.isIdle() && this.uaProtocol.can("sendOrder")) {
              if (this.eventQueue.length) {
                this.application.setProcessing();
                if (this._networkDelay > 0) {
                  window.setTimeout(this.uaProtocol.sendOrder.bind(this.uaProtocol), this._networkDelay);
                } else {
                  this.uaProtocol.sendOrder();
                }
                window.clearInterval(this.eventInterval);
                this.eventInterval = null;
              } else {
                window.clearInterval(this.eventInterval);
                this.eventInterval = null;
              }
            }
          } else {
            window.clearInterval(this.eventInterval);
            this.eventInterval = null;
          }
        },
        newTask: function() {
          var session = this.application;
          if (this.application) {
            session = this.application.getSession();
          } else {
            session = context.SessionService.getCurrent();
          }
          session.waitingForNewTask();
          var uaProtocol = this.uaProtocol;
          cls.UANetwork.newTask(this.application || session, function(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9) {
            if (!!this.application) {
              canRun([arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9], uaProtocol, this.application, Function.noop, true);
            } else {
              var headers = getHeaders(arg3);
              if (headers.newTask) {
                runNewTask(this.sessionId, headers.newTask, Function.noop);
              } else {
                session.waitedForNewTask();
              }
            }
          }.bind(this));
        },
        interrupt: function() {
          cls.UANetwork.interrupt(this.application);
        },
        close: function() {
          if (this.application.info().session) {
            // if we sent a session ua/close there is no need to send app ua/close
            if (!this.application.info().sessionIsClosing) {
              cls.UANetwork.close(this.application);
            }
            if (this.uaProtocol.transition) {
              this.uaProtocol.transition.cancel();
            }
            this.uaProtocol.waitForEnd();
          }
        },
        closeSession: function() {
          if (this.application.info().session) {
            this.application.info().sessionIsClosing = true;
            cls.UANetwork.closeSession(this.application);
          }
        },
        destroy: function() {
          window.clearTimeout(this.ping);
          window.clearInterval(this.eventInterval);
          this.eventInterval = null;
          this.application = null;
          this.eventQueue = null;
          this.uaProtocol = null;
        },
        isAlive: function() {
          return !!this.uaProtocol;
        },
        trackPrompt: function() {
          var session = this.application && this.application.getSession();
          if (session && !session._isTrackingPrompt) {
            session._isTrackingPrompt = true;
            cls.UANetwork.trackPrompt(this.application, function(arg1, arg2, arg3) {
              var headers = getHeaders(arg3),
                session = this.application && this.application.getSession();
              if (session) {
                if (headers.sessionClosed) {
                  session.closeSession();
                }
                session._isTrackingPrompt = false;
                session.displayLogPrompt(headers.prompt);
              }
            }.bind(this));
          }
        },

        _waitChildWindowReadyness: function(win, timeLimit, cb) { // IE11...
          window.setTimeout(function() {
            if ((typeof win.addEventListener) !== "function") {
              if (Date.now() > timeLimit) {
                cb(true);
              } else {
                this._waitChildWindowReadyness(win, timeLimit, cb);
              }
            } else {
              cb(false);
            }
          }.bind(this), 50);
        },

        waitForNewApp: function(onSuccess, onFailure) {
          this.application.getSession()._addWaitingApplication(this.application);
          cls.UANetwork.waitTask(this.application, function(response, none, jqXhr) {
            var headers = getHeaders(jqXhr);
            if (headers.vmReady) {
              this.application.getSession()._removeWaitingApplication(this.application);
              var win = cls.WindowHelper.openWindow(cls.UANetwork.newApp(this.application), true);
              this._waitChildWindowReadyness(win,
                Date.now() + 2 * 60 * 1000, // maximum wait for new window of 2 minutes, after that should be considered as lost
                function(w, timeout) { // thank you IE
                  if (!timeout) {
                    this.application.getSession()._registerChildWindow(w);
                  }
                  onSuccess();
                }.bind(this, win));
            } else {
              if (this.application.info().ending) {
                onFailure();
              } else if (!headers.closed) {
                window.requestAnimationFrame(this.waitForNewApp.bind(this, onSuccess, onFailure));
              } else {
                onFailure();
              }
            }
          }.bind(this));
        }
      };
    });

  })(gbc, gbc.classes);
;
"use strict";

(
  function(context, cls) {
    /**
     * Standardized queries to access ua proxy
     * @namepace classes.UANetwork
     */
    cls.UANetwork = context.oo.StaticClass(function() {

      var httpQueries = /** @lends classes.UANetwork */ {
        /**
         * send start query
         * /ua/r?frontEndId1=...&frontEndId2=...
         */
        start: {
          verb: "GET",
          action: "r",
          /** @ignore */
          uriPart: function(application) {
            var info = application.info();
            var parts = [info.appId, "?Bootstrap=done"].join("");
            var keys = Object.keys(info.urlParameters),
              len = keys.length;
            for (var i = 0; i < len; i++) {
              var key = keys[i],
                id = "&" + key + "=";
              var args = info.urlParameters[key];
              if (args) {
                parts += id + (Array.isArray(args) ? args : [args]).join(id);
              }
            }
            return parts;
          }
        },

        /**
         * send wait new task
         * /ua/sua/session_id?appId=...
         */
        waitTask: {
          verb: "GET",
          action: "wait",
          /** @ignore */
          uriPart: function(application) {
            var info = application.info();
            return [info.session, "?appId=", (info.app || 0)].join("");
          }
        },

        /**
         * send start new task
         * /ua/sua/session_id?appId=...&pageId=1
         * post data : empty
         */
        runTask: {
          verb: "POST",
          action: "sua",
          /** @ignore */
          uriPart: function(application) {
            var info = application.info();
            if (info.app === application._session.__lastNewtaskRun) {
              return null;
            } else {
              application._session.__lastNewtaskRun = info.app;
            }
            return [info.session, "?appId=", (info.app || 0), "&pageId=1"].join("");
          }
        },

        /**
         * Get url for new task in new window
         * /ua/sua/session_id?appId=...
         */
        newApp: {
          urlOnly: true,
          action: "sua",
          /** @ignore */
          uriPart: function(application) {
            var info = application.info();
            var keys = Object.keys(info.urlParameters),
              len = keys.length,
              parts = [info.session, "?appId=", (info.app || 0)];
            for (var i = 0; i < len; i++) {
              var key = keys[i],
                id = "&" + key + "=";
              if (key !== "appId") {
                var args = info.urlParameters[key];
                if (args) {
                  parts.push(id + (Array.isArray(args) ? args : [args]).join(id));
                }
              }
            }
            return parts.join("");
          }
        },

        /**
         * send aui order(s)
         * /ua/sua/session_id?appId=...&pageId=...
         * post data : aui order(s)
         */
        auiOrder: {
          verb: "POST",
          action: "sua",
          appId: true,
          pageId: true
        },

        /**
         * send empty request
         * /ua/sua/session_id?appId=...&pageId=...
         * post data : empty
         */
        empty: {
          verb: "POST",
          action: "sua",
          appId: true,
          pageId: true
        },

        /**
         * send ping
         * /ua/ping/session_id?appId=...
         * post data : empty
         */
        ping: {
          verb: "POST",
          appId: true
        },

        /**
         * track prompt
         * /ua/sua/session_id
         */
        trackPrompt: {
          verb: "POST",
          action: "sua"
        },

        /**
         * send interrupt
         * /ua/interrupt/session_id?appId=...
         * post data : empty
         */
        interrupt: {
          verb: "POST",
          appId: true
        },

        /**
         * send close
         * /ua/close/session_id?appId=...
         * post data : empty
         */
        close: {
          verb: "POST",
          appId: true
        },

        /**
         * send close
         * /ua/close/session_id
         * post data : empty
         */
        closeSession: {
          action: "close",
          verb: "POST"
        },

        /**
         * send new task query
         * /ua/newtask/session_id
         */
        newTask: {
          verb: "POST",
          action: "newtask",
          sequence: true
        },

        /**
         * ft-lock-file
         */
        ftLockFile: {
          verb: "GET",
          customUrl: true,
          headers: {
            "X-FourJs-LockFile": true
          }
        }
      };
      var methods = {};
      var createQuery = function(query, info) {
        methods[query] = function(query, info, application, callback, data, httpOptions) {
          var appInfo = application.info(),
            url;
          if (info.customUrl) {
            url = httpOptions.customUrl;
          } else {
            var parts = [appInfo && (appInfo.customUA || appInfo.connector) || "", "/ua/", info.action || query, "/"],
              uriPart = cls.UANetwork._getUriPart(application, info);
            if (!uriPart) {
              return;
            } else {
              parts.push(uriPart);
            }
            url = parts.join("");
            if (info.urlOnly) {
              return url;
            }
          }
          var logMessage = [query, info.verb, url].join(" : ");
          context.LogService.networkProtocol.debug("HTTP REQUEST\n", logMessage, data);
          var xhr = new XMLHttpRequest();
          if (context.ThemeService.getValue("theme-network-use-credentials-headers")) {
            xhr.withCredentials = true;
          }
          xhr._tryCount = 0;
          xhr.open(info.verb, url, true);
          var defaultHeaders = Object.keys(context.constants.network.sentHeaders);
          for (var hk = 0; hk < defaultHeaders.length; hk++) {
            xhr.setRequestHeader(defaultHeaders[hk], context.constants.network.sentHeaders[defaultHeaders[hk]]);
          }

          if (info.headers) {
            var ikeys = Object.keys(info.headers);
            for (var ik = 0; ik < ikeys.length; ik++) {
              xhr.setRequestHeader(ikeys[ik], info.headers[ikeys[ik]]);
            }
          }
          if (httpOptions && httpOptions.headers) {
            var keys = Object.keys(httpOptions.headers);
            for (var k = 0; k < keys.length; k++) {
              xhr.setRequestHeader(keys[k], httpOptions.headers[keys[k]]);
            }
          }
          var invalid = false;
          xhr.onload = function(invalid, appInfo, logMessage, xhrEvent) {
            if (!invalid) {
              context.LogService.networkProtocol.debug("HTTP RESPONSE\n", logMessage, xhrEvent.target.response);
              if (callback) {
                callback.call(null, xhrEvent.target.response, null, xhrEvent.target);
              }
            }
          }.bind(null, invalid, appInfo, logMessage);
          xhr.onreadystatechange = function(appInfo, xhrEvent) {
            var error = true;
            if (xhr.readyState === XMLHttpRequest.DONE) {
              if (xhr.status === 404) {
                if (application.protocolInterface && application.protocolInterface.isRunning) {
                  appInfo.ending = cls.ApplicationEnding.notok("Session does not exist.");
                } else {
                  appInfo.ending = cls.ApplicationEnding.notFound;
                }
              } else if (xhr.status === 403) {
                appInfo.ending = cls.ApplicationEnding.forbidden;
              } else if (xhr.status >= 400) {
                appInfo.ending = cls.ApplicationEnding.notok(xhr.responseText);
              } else if (xhr.status >= 500) {
                context.LogService.networkProtocol.debug("HTTP RESPONSE", logMessage, xhr.status, xhr.statusText, xhr
                  .responseText);
                if (application.protocolInterface && application.protocolInterface.isRunning) {
                  appInfo.ending = cls.ApplicationEnding.notok("Session does not exist.");
                } else {
                  appInfo.ending = cls.ApplicationEnding.notFound;
                }
              } else if (xhr.status !== 200) {
                context.LogService.networkProtocol.debug("HTTP RESPONSE", logMessage, xhr.status, xhr.statusText, xhr
                  .responseText);
                error = false;
              } else {
                error = false;
              }
              if (error) {
                context.LogService.networkProtocol.debug("HTTP REQUEST ERROR", xhr.statusText, xhr.responseText);
                application.error("HTTP", "Network error (" + xhr.statusText + ")", xhr);
                if (callback) {
                  callback.call(null, xhrEvent.target.response, null, xhrEvent.target);
                }
              }
            }
          }.bind(null, appInfo);
          xhr.onerror = function(invalid, appInfo, logMessage, xhrEvent, textStatus, errorThrown) {
            if (xhr._tryCount < 5) {
              ++xhr._tryCount;
              var timeout = (xhr._tryCount < 5 ? Math.pow(2, xhr._tryCount) : 16) * 500;
              window.setTimeout(function() {
                xhr.open(info.verb, url, true);
                xhr.send((data ? data : null));
              }, timeout);
            } else {
              if (!invalid) {
                context.LogService.networkProtocol.debug("HTTP REQUEST ERROR", textStatus, errorThrown);
                appInfo.ending = cls.ApplicationEnding.notok("Server unreachable");
                application.error("HTTP", "Network error (" + textStatus + ")", xhrEvent);
                if (callback) {
                  callback.call(null, xhrEvent.target.response, null, xhrEvent.target);
                }
              }
            }
          }.bind(null, invalid, appInfo, logMessage);
          xhr.send((data ? data : null));
        }.bind(null, query, info);
      };
      var queryKeys = Object.keys(httpQueries);
      for (var i = 0; i < queryKeys.length; i++) {
        var query = queryKeys[i];
        var info = httpQueries[query];
        /**
         * For each sub cited methods, the same signature
         * @param application the current application
         * @param callback the callback in case of success
         * @param data the payload to send
         * @param httpOptions the http request options (like headers) to send
         */
        createQuery(query, info);
      }
      var result =
        /** @lends classes.UANetwork */
        {
          __name: "UANetwork",
          __sequence: 0,
          _getUriPart: function(application, info) {
            var appInfo = application.info();
            var uriParts = [];
            // Manage server prefix for cgi
            if (!!info.uriPart) {
              uriParts.push(info.uriPart(application));
            } else {
              uriParts.push(appInfo.session);
              var queryStarted = false;
              if (info.appId) {
                queryStarted = true;
                uriParts.push("?appId=", appInfo.app || 0);
                if (info.pageId) {
                  uriParts.push("&pageId=", appInfo.page++);
                }
              }
              if (info.sequence) {
                uriParts.push(queryStarted ? "&" : "?", "seq=", this.__sequence++);
              }
            }
            var uriPart = uriParts.join("");
            if (!uriPart) {
              return null;
            }
            return uriPart;
          }
        };

      var keys = Object.keys(methods);
      for (var k = 0; k < keys.length; k++) {
        result[keys[k]] = methods[keys[k]];
      }

      return result;

    });
  })(gbc, gbc.classes);
;
"use strict";

(
  function(context, cls) {
    /**
     * @class UAConnectionString
     * @memberOf classes
     */
    cls.UAConnectionString = context.oo.StaticClass(
      /** @lends classes.UAConnectionString */
      {
        run: function(data, headers, application) {
          application.model.logDvm(data);
          try {
            if (!application.info().session || application.info().task || application.getSession()._browserMultiPageModeAsChild) {
              if (!application.info().session) {
                var headersKeys = Object.keys(context.constants.network.startHeaders);
                for (var i = 0; i < headersKeys.length; i++) {
                  var key = headersKeys[i];
                  var value = context.constants.network.startHeaders[key];
                  var hvalue = headers[key];
                  if (hvalue === null) {
                    throw value.error;
                  }
                  application.info()[value.prop || key] = hvalue;
                }
                application.getSession().setSessionId(application.info().session);
                application.info().serverVersion = headers.server;
              }
              var t = application.info().timeout;
              application.info().pingTimeout = (t > 1 ? t > 5 ? t - 5 : t - 1 : t) * 1000;

              if (!application.getSession()._browserMultiPageModeAsChild) {
                //Update history to handle session number
                window.requestAnimationFrame(gbc.HistoryService.addHistory.bind(gbc.HistoryService, application, window.document.URL));
              }

              var vmMessages = cls.AuiProtocolReader.translate(data);

              if (vmMessages.length === 0 || vmMessages.length !== 1 && vmMessages[0].type !== "meta" || vmMessages[0].verb !==
                "Connection") {
                if (!data) {
                  throw "No connectionString received. Ensure your application is compiled and published.";
                } else {
                  throw "Received connectionString bad format : \"" + data + "\"";
                }
              }

              application.info().connectionInfo = vmMessages[0].attributes;
            }
          } catch (e) {
            var message = "" + e.toString();
            application.info().ending = cls.ApplicationEnding.notok(message);
          }
        }
      });
  })(gbc, gbc.classes);
;
"use strict";

(
  function(context, cls) {
    /**
     * @class UAHandShake
     * @memberOf classes
     */
    cls.UAHandShake = context.oo.StaticClass(
      /** @lends classes.UAHandShake */
      {
        run: function(application, callback) {
          // Performing the initial hanshake
          var data = cls.AuiProtocolWriter.translate({
            type: "meta",
            verb: "Client",
            attributes: {
              name: "GBC",
              version: context.version,
              encoding: "UTF-8",
              encapsulation: 0,
              filetransfer: 0,
              mobileUI: context.ThemeService.getValue("aui-mobileUI-default") ? 1 : 0
            }
          });
          application.model.logFireEvent(data);
          cls.UANetwork.auiOrder(application, callback, data);
        }
      });
  })(gbc, gbc.classes);
;
"use strict";

(
  function(context, cls) {
    /**
     * @class UAInitialAUI
     * @memberOf classes
     */
    cls.UAInitialAUI = context.oo.StaticClass(
      /** @lends classes.UAInitialAUI */
      {
        run: function(data, headers, application, callback) {
          application.model.logDvm(data);
          application.dvm.manageAuiOrders(data, callback);
        }
      });
  })(gbc, gbc.classes);
;
"use strict";

(
  function(context, cls) {
    /**
     * @class UAPing
     * @memberOf classes
     */
    cls.UAPing = context.oo.StaticClass(
      /** @lends classes.UAPing */
      {
        run: function(application, callback) {
          cls.UANetwork.ping(application, callback);
        }
      });
  })(gbc, gbc.classes);
;
"use strict";

(
  function(context, cls) {
    /**
     * @class UARecvOrder
     * @memberOf classes
     */
    cls.UARecvOrder = context.oo.StaticClass(
      /** @lends classes.UARecvOrder */
      {
        run: function(data, headers, application, callback) {
          if (!!data) {
            application.model.logDvm(data);
            application.dvm.manageAuiOrders(data, callback);
          } else {
            callback();
          }
        }
      });
  })(gbc, gbc.classes);
;
"use strict";

(
  function(context, cls) {
    /**
     * @class UASendEmpty
     * @memberOf classes
     */
    cls.UASendEmpty = context.oo.StaticClass(
      /**@lends classes.UASendEmpty */
      {
        run: function(application, callback) {
          cls.UANetwork.empty(application, callback);
        }
      });
  })(gbc, gbc.classes);
;
"use strict";

(
  function(context, cls) {
    /**
     * @class UASendEndingEmpty
     * @memberOf classes
     */
    cls.UASendEndingEmpty = context.oo.StaticClass(
      /** @lends classes.UASendEndingEmpty */
      {
        run: function(application, callback) {
          cls.UANetwork.empty(application, callback);
        }
      });
  })(gbc, gbc.classes);
;
"use strict";

(
  function(context, cls) {
    /**
     * @class UASendOrders
     * @memberOf classes
     */
    cls.UASendOrders = context.oo.StaticClass(
      /** @lends classes.UASendOrders */
      {
        run: function(orders, application, callback, httpOptions) {
          for (var o = 0; o < orders.length; o++) {
            if (orders[o].lazyResolve) {
              orders[o].lazyResolve();
            }
          }
          var data = cls.AuiProtocolWriter.translate({
            type: "om",
            order: application.info().auiOrder++,
            orders: orders
          }, application);
          application.model.logFireEvent(data);
          cls.UANetwork.auiOrder(application, callback, data, httpOptions);
        }
      });
  })(gbc, gbc.classes);
;
"use strict";

(
  function(context, cls) {
    /**
     * @class UAStartup
     * @memberOf classes
     */
    cls.UAStartup = context.oo.StaticClass(
      /** @lends classes.UAStartup */
      {
        run: function(application, callback) {
          var headers = {
            Accept: "application/octet-stream"
          };
          cls.UANetwork.start(application, callback, null, {
            headers: headers
          });
        }
      });
  })(gbc, gbc.classes);
;
"use strict";

(
  function(context, cls) {
    /**
     * @class UAStartupTask
     * @memberOf classes
     */
    cls.UAStartupTask = context.oo.StaticClass(
      /** @lends classes.UAStartupTask */
      {
        run: function(application, callback) {
          var headers = {
            Accept: "application/octet-stream"
          };
          cls.UANetwork.runTask(application, callback, null, {
            headers: headers
          });
        }
      });
  })(gbc, gbc.classes);
;
"use strict";

(
  /**
   * @param {gbc} context
   */
  function(context) {
    context.constants.network.uaStates = [{
      name: "start",
      from: "none",
      to: "SendStart"
    }, {
      name: "startTask",
      from: "none",
      to: "SendStartTask"
    }, {
      name: "getConnectionString",
      from: ["SendStart", "SendStartTask"],
      to: "RecvConnectionString"
    }, {
      name: "handShake",
      from: "RecvConnectionString",
      to: "SendHandShake"
    }, {
      name: "getInitialAUI",
      from: "SendHandShake",
      to: "RecvInitialAUI"
    }, {
      name: "waitForMoreInitialAUI",
      from: "RecvInitialAUI",
      to: "SendEmpty"
    }, {
      name: "getMoreOrder",
      from: "SendEmpty",
      to: "RecvOrder"
    }, {
      name: "guiMode",
      from: ["RecvInitialAUI", "RecvOrder"],
      to: "GUI"
    }, {
      name: "ping",
      from: "GUI",
      to: "Ping"
    }, {
      name: "pingSent",
      from: "Ping",
      to: "GUI"
    }, {
      name: "sendOrder",
      from: "GUI",
      to: "SendOrder"
    }, {
      name: "getOrderAnswer",
      from: "SendOrder",
      to: "RecvOrder"
    }, {
      name: "waitForMoreOrder",
      from: "RecvOrder",
      to: "SendEmpty"
    }, {
      name: "waitForEnd",
      from: ["ApplicationEnding", "GUI", "SendHandShake", "SendEmpty", "SendOrder"],
      to: "ApplicationEnding"
    }, {
      name: "headerError",
      from: ["SendStart", "SendStartTask", "SendHandShake", "SendEmpty", "SendOrder", "GUI", "Ping", "ApplicationEnding"],
      to: "HeaderError"
    }, {
      name: "endApp",
      from: ["HeaderError", "SendStart", "SendStartTask", "SendHandShake", "SendEmpty", "SendOrder", "Ping", "ApplicationEnding"],
      to: "ApplicationEnd"
    }];
  })(gbc);
;
"use strict";

modulum('OverlayService', ['InitService'],
  function(context, cls) {

    /**
     * Service to display or hide an overlay which intercepts all mouse events. Overlay can be invisible or visible (grey)
     * @namespace gbc.OverlayService
     * @gbcService
     * @publicdoc
     */
    context.OverlayService = context.oo.StaticClass( /** @lends gbc.OverlayService */ {
      __name: "OverlayService",

      /**
       * Map which contains all overlay defined during application life
       * @type {Map}
       */
      _overlayList: null,

      /**
       * Initialize the overlay management service
       */
      init: function() {
        this._overlayList = new Map();
      },

      /**
       * Create a new overlay object composed of element and custom flags
       * @returns {{timer: Function, visible: boolean, active: boolean, element: HTMLElement}}
       * @private
       */
      _create: function() {
        var overlayElement = document.createElement("div");
        overlayElement.addClasses("overlay", "hidden");
        return {
          element: overlayElement,
          active: false,
          visible: false,
          timer: null
        };
      },

      /**
       * Get the overlay associated with provided name
       * @param {string} name - overlay identifier
       * @returns {{timer: Function, visible: boolean, active: boolean, element: HTMLElement}} return overlay object
       * @publicdoc
       */
      get: function(name) {
        var overlay = this._overlayList.get(name);
        if (!overlay) { // create new overlay
          overlay = this._create();
          this._overlayList.set(name, overlay);
        }
        return overlay;
      },

      /**
       * Enable global overlay
       * @param {string} name - overlay identifier used to create and manage an associated overlay element
       * @param {HTMLElement} parentContainer - DOM element which contains overlay div. If none we add overlay directly under body
       * @publicdoc
       */
      enable: function(name, parentContainer) {
        var overlay = this.get(name);
        overlay.active = true;
        var containerElement = parentContainer || document.body;
        if (overlay.element.parentNode !== containerElement) {
          containerElement.appendChild(overlay.element);
        }
        overlay.element.removeClass("hidden");
      },

      /**
       * Disable global overlay
       * @param {string} name - overlay identifier
       * @publicdoc
       */
      disable: function(name) {
        var overlay = this.get(name);
        if (overlay.timer) {
          window.clearTimeout(overlay.timer);
          overlay.timer = null;
        }
        overlay.active = false;
        overlay.visible = false;
        overlay.element.addClass("hidden");
        overlay.element.removeClass("greybg");
      },

      /**
       * Define a cursor to put over the given overlay
       * @param {String} name - name of the overlay
       * @param {String} cursor - cursor to put over
       */
      setCursor: function(name, cursor) {
        var overlay = this.get(name);
        overlay.element.style.cursor = cursor;
      },

      /**
       * Makes overlay non transparent by setting its opacity
       * @param {string} name - overlay identifier
       * @param {boolean} visible - show/hide overlay by updating its transparency
       * @publicdoc
       */
      setOpacity: function(name, visible) {
        var overlay = this.get(name);
        if (overlay.visible !== visible) {
          overlay.visible = visible;
          if (overlay.timer) {
            window.clearTimeout(overlay.timer);
            overlay.timer = null;
          }
          if (overlay.visible) {
            overlay.timer = window.setTimeout(function() { // to be sure that class is added after "hidden" class is removed, else css transition doesn't work
              overlay.timer = null;
              overlay.element.addClass("greybg");
            }.bind(this), 300);
          } else {
            overlay.element.removeClass("greybg");
          }
        }
      }
    });
    context.InitService.register(context.OverlayService);
  });
;
"use strict";

modulum('SessionService', ['InitService'],
  function(context, cls) {

    /**
     * Service that manages Sessions
     * @namespace gbc.SessionService
     * @gbcService
     * @publicdoc
     */
    context.SessionService = context.oo.StaticClass( /** @lends gbc.SessionService */ {
      __name: "SessionService",

      /**
       * Label for event listener
       * @private
       */
      sessionAdded: "sessionAdded",
      /**
       * Label for event listener
       * @private
       */
      sessionRemoved: "sessionRemoved",

      /**
       * session identifier
       * @type {Number}
       * @private
       */
      _identifier: 0,
      /**
       * @type {classes.VMSession[]}
       */
      _sessions: null,
      _bySessionId: null,
      _eventListener: null,

      /**
       * Initialize the session Service
       */
      init: function() {
        this._eventListener = new cls.EventListener();
        this._sessions = [];
        this._bySessionId = {};
      },

      /**
       * Start an application
       * @param appName {string}
       * @param params {Object}
       * @returns {classes.VMSession}
       */
      start: function(appName, params) {
        var session = new cls.VMSession(this._identifier++);
        this._eventListener.emit(this.sessionAdded, session);
        var subAppInfo = context.bootstrapInfo.subAppInfo;
        if (subAppInfo) {
          session._baseInfos = (window.opener && window.opener.gbc &&
            window.opener.gbc.SessionService.getCurrent() &&
            window.opener.gbc.SessionService.getCurrent()._baseInfos);
          session.startTask(subAppInfo);
        } else {
          session.start(appName, params);
        }
        this._sessions.push(session);
        context.HostService.displaySession();
        return session;
      },

      /**
       * Start via a connection
       * @param {window.gbcWrapper} wrapper
       * @param {Object<string, *>} headers
       * @return {*}
       */
      startDirect: function(wrapper, headers) {
        var session = null;
        if (this._sessions.length) {
          session = this._sessions[0];
        } else {
          session = new cls.VMSession(this._identifier++);
          this._sessions.push(session);
          this._eventListener.emit(this.sessionAdded, session);
          context.HostService.displaySession();
        }
        session.startDirect(wrapper, headers);
        return session;
      },

      fromSessionId: function(id) {
        return this._bySessionId[id];
      },

      updateSessionId: function(session, id) {
        this._bySessionId[id] = session;
      },

      /**
       * Remove a session
       * @param session
       * @param restarting
       */
      remove: function(session, restarting) {
        this._bySessionId[session.getSessionId()] = null;
        this._sessions.remove(session);
        this._eventListener.emit(this.sessionRemoved, session);
        if (!this._sessions.length && !restarting) {
          var baseURI = document.baseURI;
          if (!baseURI) {
            var base = document.getElementsByTagName("base");
            if (base.length) {
              baseURI = base[0].href || "";
            }
          }
          context.UrlService.setCurrentUrl(baseURI.replace(/\/$/, "/index.html"));
          context.HostService.displayNoSession();
        }
      },

      /**
       * Return active sessions
       * @returns {classes.VMSession[]}
       */
      getSessions: function() {
        return this._sessions;
      },

      /**
       * Return a session by id
       * @param identifier {string} id of the session to get
       * @return {classes.VMSession} the requested session
       */
      getSession: function(identifier) {
        return this._sessions.filter(function(item) {
          return item._identifier === identifier;
        })[0];
      },

      /**
       * Get the current running session
       * @returns {classes.VMSession} the current session
       * @publicdoc
       */
      getCurrent: function() {
        if (this._sessions) {
          return this._sessions[this._sessions.length - 1];
        } else {
          return null;
        }
      },

      /**
       * Handler called once a sesion has been added
       * @param hook
       * @return {*|HandleRegistration|promise.Promise<any>|Q.Promise<void>|Q.Promise<string>}
       */
      onSessionAdded: function(hook) {
        return this._eventListener.when(this.sessionAdded, hook);
      },
      /**
       * Handler called once a sesion has been removed
       * @param hook
       * @return {*|HandleRegistration|promise.Promise<any>|Q.Promise<void>|Q.Promise<string>}
       */
      onSessionRemoved: function(hook) {
        return this._eventListener.when(this.sessionRemoved, hook);
      }
    });
    context.InitService.register(context.SessionService);
  });
;
"use strict";

modulum('TemplateService', ['InitService'],
  function(context, cls) {

    /**
     * @namespace gbc.TemplateService
     */
    context.TemplateService = context.oo.StaticClass( /** @lends gbc.TemplateService */ {
      __name: "TemplateService",
      _compiled: {},
      _rendered: {},
      init: function() {
        var templateKeys = Object.keys(window.gbcTemplates);
        for (var i = 0; i < templateKeys.length; i++) {
          var templateId = templateKeys[i];
          if (window.gbcTemplates.hasOwnProperty(templateId)) {
            this.registerRawTemplate(templateId, window.gbcTemplates[templateId]);
          }
        }
      },
      /**
       * Registers a new template (string) with the given id.
       * @param id the template id
       * @param template the template text
       */
      registerRawTemplate: function(id, template) {
        if (this._compiled[id]) {
          context.LogService.error("templateService.registerRawTemplate: template id already exists : " + id);
          return;
        }
        this._compiled[id] = template;
      },
      /**
       * Renders a node depending on the given template id.
       * @param templateId the template id to use for rendering
       * @returns string a string of the compiled template given the node and the template id
       */
      renderAs: function(templateId) {
        if (this._compiled.hasOwnProperty(templateId)) {
          return this._compiled[templateId];
        } else {
          return "";
        }
      },
      /**
       * Renders a node depending on the given template id.
       * @param templateId the template id to use for rendering
       * @param ascendance
       * @returns {Node} the compiled template given the node and the template id
       */
      renderDOM: function(templateId, ascendance) {
        if (!!this._rendered[templateId]) {
          return this._rendered[templateId].cloneNode(true);
        }

        var div = document.createElement('div');
        div.insertAdjacentHTML("beforeend", this.renderAs(templateId));
        var result = div.firstChild;
        var elements = div.querySelectorAll("*"),
          len = elements.length,
          attrNames = ascendance ? ascendance.map(function(item) {
            return "__" + item;
          }) : ["__" + templateId],
          alen = attrNames.length;
        for (var i = 0; i < len; i++) {
          for (var j = 0; j < alen; j++) {
            elements.item(i).setAttribute(attrNames[j], "");
          }
        }
        this._rendered[templateId] = result;
        return result.cloneNode(true);
      }

    });
    context.InitService.register(context.TemplateService);
  });
;
"use strict";

modulum('ThemeService',
  function(context, cls) {

    /**
     * Theme Service to customize the application
     * @namespace gbc.ThemeService
     * @gbcService
     */
    context.ThemeService = context.oo.StaticClass( /** @lends gbc.ThemeService */ {
      __name: "ThemeService",

      /**
       * internal event emitter
       * @private
       */
      _eventListener: new cls.EventListener(),

      /**
       * current theme parsed values
       * @type {*}
       * @private
       */
      _currentVariables: [],

      /**
       * current theme in DOM resources
       * @type {*}
       * @private
       */
      _currentResources: {},

      /**
       * current theme resources pathes
       * @type {*}
       * @private
       */
      _currentPathes: {},

      /**
       * list of usable themes
       * @type {*}
       * @private
       */
      _availableThemes: window.__gbcThemesInfo,

      /**
       * current theme name
       * @type {string}
       * @private
       */
      _currentThemeName: "",

      /**
       * collection of test functions used in theme conditions
       */
      _conditionMatchers: {
        isMobile: function() {
          return window.isMobile();
        },
        isPhone: function() {
          return window.isPhone();
        },
        isTablet: function() {
          return window.isTablet();
        },
        isDesktop: function() {
          return !window.isMobile();
        },
        isTouchDevice: function() {
          return window.isTouchDevice();
        },
        isUR: function() {
          return window.gbc.__wrapper.isNative();
        },
        isBrowser: function() {
          return window.gbc.__wrapper.isBrowser();
        },
        isChrome: function() {
          return window.browserInfo.isChrome;
        },
        isEdge: function() {
          return window.browserInfo.isEdge;
        },
        isFirefox: function() {
          return window.browserInfo.isFirefox;
        },
        isIE: function() {
          return window.browserInfo.isIE;
        },
        isOpera: function() {
          return window.browserInfo.isOpera;
        },
        isSafari: function() {
          return window.browserInfo.isSafari;
        },
        isAndroid: function() {
          return window.isAndroid();
        },
        isIOS: function() {
          return window.isIOS();
        }
      },

      /**
       * test theme conditions against matchers
       * @param {Array<string>} conditions list of theme conditions
       * @return {boolean} true if all conditions matches
       * @private
       */
      _conditionsMatches: function(conditions) {
        var i = 0,
          len = conditions && conditions.length || 0;
        for (; i < len; i++) {
          try {
            if (!this._conditionMatchers[conditions[i]]()) {
              return false;
            }
          } catch (e) {
            return false;
          }
        }
        return true;
      },

      /**
       * filter list of themes against their conditions
       * @param {Array} list list of themes
       * @return {Array} filtered list of themes
       * @private
       */
      _filterThemeList: function(list) {
        var result = [],
          i = 0,
          len = list && list.length || 0;
        for (; i < len; i++) {
          if (this._conditionsMatches(list[i].conditions)) {
            result.push(list[i]);
          }
        }
        return result;
      },

      /**
       * get a value from theme
       * @param {string} id the theme value id
       * @return {*} the value
       */
      getValue: function(id) {
        return context.ThemeService._currentVariables[id];
      },

      /**
       * set a value to the local theme - internal use only
       * @param {string} id the theme value id
       * @param {*} value the value
       * @ignore
       */
      setValue: function(id, value) {
        context.ThemeService._currentVariables[id] = value;
      },

      /**
       * get a resource path from theme
       * @param {string} id the theme resource id
       * @return {*} the resource path
       */
      getResource: function(id) {
        return context.ThemeService._currentPathes.themes[context.ThemeService._currentThemeName].indexOf(id) >= 0 ?
          ("themes/" + context.ThemeService._currentThemeName + "/resources/" + id) :
          ("resources/" + id);
      },

      /**
       * Thanks to Edge/IE, for need to be sure the current theme is well loaded
       * @returns {boolean} true if current theme is loaded
       * @private
       */
      _isCurrentThemeLoaded: function() {
        return !!context.ThemeService._currentPathes.themes[context.ThemeService._currentThemeName];
      },

      /**
       * Get available themes
       * @return {Array} the themes
       */
      getAvailableThemes: function() {
        return this._availableThemes;
      },

      /**
       * get current theme name
       * @return {string} the current theme name
       */
      getCurrentTheme: function() {
        return this._currentThemeName;
      },
      /**
       * parse theme variables from injected json
       * @return {{variables:Object, pathes:Object}} theme information
       * @private
       */
      _loadValues: function() {
        var styles = window.getComputedStyle(document.body, ":after"),
          vars = styles.getPropertyValue("content"),
          result = JSON.parse(Base64.fromBase64(vars)),
          variablesKeys = Object.keys(result.variables),
          i = 0,
          len = variablesKeys.length;
        for (; i < len; i++) {
          var key = variablesKeys[i];
          if (/^b64\(.*\)$/.test(result.variables[key])) {
            result.variables[key] = JSON.parse(Base64.fromBase64(result.variables[key].replace(/^b64\((.*)\)$/, "$1")));
          }
        }
        return result;
      },

      /**
       * load theme
       * @param {string} name theme name
       * @param {function} [callback] callback when theme has been loaded
       * @param {boolean} [noSave] true to avoid stored settings save
       */
      loadTheme: function(name, callback, noSave) {
        if (!noSave) {
          context.StoredSettingsService.setSettings('gwc.app.theme', name);
          // force writing in browser'storage in case of new window opening
          context.StoredSettingsService.sync();
        }
        if (context.ThemeService._currentThemeName !== name) {
          context.ThemeService._currentThemeName = name;
          var link = document.createElement("link");
          link.rel = "stylesheet";
          link.type = "text/css";
          link.href = "./themes/" + name + "/main.css";
          link.onload = function() {
            var themeInfo = context.ThemeService._loadValues();
            context.ThemeService._currentVariables = themeInfo.variables;
            context.ThemeService._currentPathes = themeInfo.pathes;
            if (this._isCurrentThemeLoaded()) {
              if (this._currentResources.link) {
                this._currentResources.link.remove();
              }
              this._currentResources.link = link;
              context.classes.WidgetFactory.registerThemeOverrides(themeInfo.widgetFactory);
              window.requestAnimationFrame(function() {
                // TODO: remove this second requestAnimationFrame when GBC-2251 is done (and fixes the font issue)
                window.requestAnimationFrame(function() {
                  this._onThemeLoaded();
                  if (typeof callback === "function") {
                    callback();
                  }
                }.bind(this));
              }.bind(this));
            } else {
              context.LogService.error("Theme '" + name + "' cannot be loaded!");
              link.remove();
              this.loadTheme(this._availableThemes[0].name, callback);
            }
          }.bind(this);
          link.onerror = function() {
            context.LogService.error("Theme '" + name + "' cannot be loaded!");
            link.remove();
            this.loadTheme(this._availableThemes[0].name, callback);
          }.bind(this);
          link.insertAfter(this._currentResources.link || document.head.getElementsByTagName("title")[0]);
        } else {
          if (typeof callback === "function") {
            callback();
          }
        }
      },

      /**
       * updates theme dependant elements in loaded gbc
       * @private
       */
      _onThemeLoaded: function() {
        this._eventListener.emit(context.constants.widgetEvents.themeChange);
        document.getElementById("favicon_element").href = context.ThemeService.getResource("img/gbc_logo.ico");
        var session = context.SessionService.getCurrent();
        if (session) {
          var apps = session.getApplications(),
            len = apps && apps.length || 0,
            i = 0;
          for (; i < len; i++) {
            var app = apps[i],
              layout = app && app.layout,
              model = app && app.model;
            if (layout) {
              layout.reset();
            }
            if (model) {
              model.getNodesByTag("Window").forEach(function(item) {
                item.getWidget().getLayoutEngine().reset(true);
              });
            }
          }
        }
      },

      /**
       * fired when theme changed
       * @param {Hook} hook the hook
       * @return {HandleRegistration} the handle registration
       */
      whenThemeChanged: function(hook) {
        return this._eventListener.when(context.constants.widgetEvents.themeChange, hook);
      },

      /**
       * load initial theme
       * @param {?string} initialTheme initial theme to load
       * @param {function} callback callback when theme has been loaded
       */
      initTheme: function(initialTheme, callback) {
        this._availableThemes = this._filterThemeList(this._availableThemes);
        if (this._availableThemes.length) {
          var storedTheme = context.StoredSettingsService.getSettings('gwc.app.theme');
          this.loadTheme(initialTheme ||
            storedTheme && this._availableThemes.find(function(item) {
              return item.name === storedTheme;
            }) && storedTheme ||
            this._availableThemes[0].name,
            callback, !!initialTheme);
        } else {
          this._displayConsoleScreenOfDeath();
        }
      },

      /**
       * Show critical error if no theme is available
       * @private
       */
      _displayConsoleScreenOfDeath: function() {
        window.critical.display("Internal failure: No applicable theme found.");
      }
    });
  });
;
"use strict";

modulum('TypeAheadAction', ['TypeAheadCommand'],
  /**
   * @param {gbc} context
   * @param {classes} cls
   */
  function(context, cls) {
    /**
     * TypeAhead action event.
     * @class TypeAheadAction
     * @memberOf classes
     * @extends classes.TypeAheadCommand
     */
    cls.TypeAheadAction = context.oo.Class(cls.TypeAheadCommand, function($super) {
      return /** @lends classes.TypeAheadAction.prototype */ {
        __name: "TypeAheadAction",

        /** @type boolean */
        _noUserActivity: false,

        /** @type boolean */
        _dialogTouched: false,

        /**
         * @param {classes.VMApplication} app owner
         * @param {classes.NodeBase} node action
         * @param {boolean} [noUserActivity] - true if action is not from a user interaction
         */
        constructor: function(app, node, noUserActivity) {
          $super.constructor.call(this, app, node);
          this._noUserActivity = !!noUserActivity;
          this._dialogTouched = (node.attribute('name') === 'dialogtouched');
        },

        /**
         * @inheritDoc
         */
        canBeExecuted: function() {
          var sendActionEvent = false;

          switch (this._node.getTag()) {
            case "StartMenuCommand":
              sendActionEvent = (this._node.attribute('disabled') !== 1);
              break;
            case "IdleAction":
              sendActionEvent = true;
              break;
            default:
              var parentNode = this._node.getParentNode();
              if (parentNode.getTag() === "TableColumn") {
                parentNode = parentNode.getParentNode(); // we want the table node
              }
              // Check if action is active
              var hasActionActiveAttr = this._node.isAttributeSetByVM('actionActive');
              var hasActiveAttr = this._node.isAttributeSetByVM('active');
              var hasParentActiveAttr = parentNode && parentNode.isAttributeSetByVM('active');

              var active = false;
              if (hasActionActiveAttr) {
                active = this._node.attribute('actionActive');
              } else if (hasActiveAttr) {
                active = this._node.attribute('active');
              }

              if (hasParentActiveAttr && parentNode.attribute('active')) {
                active = active && parentNode.attribute('active');
              }

              sendActionEvent = active;
          }

          return sendActionEvent;
        },

        /**
         * @inheritDoc
         */
        execute: function() {

          if (this.canBeExecuted()) {
            var event = new cls.VMActionEvent(this._node.getId());
            event.noUserActivity = this._noUserActivity;
            return {
              processed: true,
              vmEvents: [event]
            };
          }

          return {
            processed: false,
            vmEvents: []
          };
        },

        /**
         * @inheritDoc
         */
        isPredictable: function() {
          // when action is dialog touched consider that we stay in the same edit
          // we say that action is predictable to not activate bufferedKey mode in typeahead
          return this._dialogTouched;
        },

        /**
         * @inheritDoc
         */
        needsVmSync: function() {
          return true;
        }
      };
    });
  }
);
;
"use strict";

modulum('TypeAheadApplicationService', ['ApplicationServiceBase', 'ApplicationServiceFactory'],
  /**
   * @param {gbc} context
   * @param {classes} cls
   */
  function(context, cls) {
    /**
     * TypeAhead service.
     * This class is in charge of keeping track of the type-ahead commands.
     * Stack commands, schedule their execution on the server and validate or roll them back
     * Manages client side life cycle representation of the node.
     * @class TypeAheadApplicationService
     * @memberOf classes
     * @extends classes.ApplicationServiceBase
     */
    cls.TypeAheadApplicationService = context.oo.Class(cls.ApplicationServiceBase, function($super) {
      return /** @lends classes.TypeAheadApplicationService.prototype */ {
        __name: "TypeAheadApplicationService",

        /** @type {classes.TypeAheadCommand[]} */
        _commandsQueue: null,
        /** @type {classes.TypeAheadCommand[]} */
        _processingCommands: null,
        /** @type {classes.TypeAheadCommand[]} */
        _commandsWhileFrontCallQueue: null,
        /** @type {boolean} */
        _isFrozen: false,
        /** @type {number} */
        _lastCommandTime: 0,

        /** @type {boolean} */
        _bufferizeKeysMode: false,

        /** @type {classes.TypeAheadGroup[]} */
        _currentGroupCommandQueue: null,

        /**
         * @param {classes.VMApplication} app owner
         */
        constructor: function(app) {
          $super.constructor.call(this, app);
          this._commandsQueue = [];
          this._commandsWhileFrontCallQueue = [];
          this._processingCommands = [];
          this._currentGroupCommandQueue = [];
        },

        destroy: function() {
          $super.destroy.call(this);
          this._processingCommands = [];
          this._commandsQueue = [];
          this._commandsWhileFrontCallQueue = [];

          this._currentGroupCommandQueue = null;
        },

        /**
         * Returns true if the typeahead has command which are executed but not yet validated
         * @returns {boolean}
         */
        hasProcessingCommands: function() {
          return this._processingCommands.length !== 0;
        },

        /**
         * Rollback all commands in the queue
         */
        rollbackAllCommands: function() {
          this._commandsQueue = this._commandsQueue.concat(this._commandsWhileFrontCallQueue);
          this._commandsWhileFrontCallQueue = [];

          while (this._commandsQueue.length > 0) {
            var cmd = this._commandsQueue.shift();
            cmd.rollback();
          }
        },

        /**
         * Returns true if the typeahead has finished to process all commands
         * @returns {boolean}
         */
        hasFinished: function() {
          return !this.hasProcessingCommands() && !this.hasPendingCommands();
        },

        /**
         * @param cmd new command to add to the list
         */
        _addCommand: function(cmd) {
          if (this._application) {
            context.LogService.typeahead.log("[app" + this._application.applicationHash + "] " + cmd.__name + " command added",
              cmd);

            if (this._currentGroupCommandQueue.length > 0) { // if there is a current group command is added to this group
              this._currentGroupCommandQueue[this._currentGroupCommandQueue.length - 1].addCommand(cmd);
            } else {

              // if only one command of this type must be added, and there is already an existing command --> do nothing
              if (cmd.isUnique() && this.hasPendingCommands(cmd.__name)) {
                return;
              }

              // If a FrontCall is processing, queue it in a special buffer
              if (context.FrontCallService.functionCallIsProcessing()) {
                this._commandsWhileFrontCallQueue.push(cmd);
              } else {
                this._commandsQueue.push(cmd);
              }

              // Do this in a timeout, to allow to push more than one command and to merge some commands
              this._registerTimeout(
                function() { // don't use requestAnimationFrame because when a new tab is opened, animationframe is never called
                  this._executeNextCommand();
                }.bind(this), 0);

              // if command is not predictable, switch in bufferizeKeysMode
              if (!cmd.isPredictable()) {
                this.setBufferizeKeysMode(true);
              }
            }
          }
        },

        /**
         * Execute next command
         * @private
         */
        _executeNextCommand: function() {
          if (!this.hasPendingCommands()) {
            if (!this.hasProcessingCommands()) {
              // if there is no more commands to send or to validate, we unfreeze
              this.unfreeze();
            }
            return;
          }

          if (!this.hasProcessingCommands() && !this._application.isProcessing()) { // if app is processing don't send any command
            // If a frontCall is not processing, get bufferized commands while it was processing
            if (!context.FrontCallService.functionCallIsProcessing()) {
              this._commandsQueue = this._commandsQueue.concat(this._commandsWhileFrontCallQueue);
              this._commandsWhileFrontCallQueue = [];
            }

            var cmd = null;
            var events = [];

            var integrityOk = true;
            while (events.length === 0 && this._commandsQueue.length !== 0 && integrityOk) {
              do {
                cmd = this._commandsQueue.shift();
                context.LogService.typeahead.log("Executing " + cmd.__name + " command", cmd);

                // Merge beginning commands of the FIFO into cmd;
                while (this._commandsQueue.length !== 0 && cmd.merge(this._commandsQueue[0])) {
                  this._commandsQueue.shift();
                }

                integrityOk = cmd.checkIntegrity();
                if (integrityOk) {

                  // save existing typeahead list
                  var savedCommandsQueue = this._commandsQueue.slice();
                  this._commandsQueue = [];

                  var res = cmd.execute();

                  // all the commands created during the command execution must be added at the beginning of commandsQueue
                  this._commandsQueue = this._commandsQueue.concat(savedCommandsQueue);
                  savedCommandsQueue = [];

                  if (res.vmEvents.length > 0) { // if command generate vm events, add it to processingCommands list
                    events = events.concat(res.vmEvents);
                    this._processingCommands.push(cmd);
                  } else if (!res.processed) {
                    context.LogService.typeahead.log("Poping unused " + cmd.__name + " command", cmd);
                  }
                }

              } while (this._commandsQueue.length !== 0 && !cmd.needsVmSync() && integrityOk);
            }

            if (integrityOk === false) {
              context.LogService.typeahead.warn("Command integrity error --> rollback all commands", cmd);
              if (cmd) {
                cmd.rollback();
              }
              // if there is an integrity error in a command, ignore and rollback all next commands
              this.rollbackAllCommands();

              // after rollback need to restore the focus at the right place
              this._application.focus.restoreVMFocus(true);
            }

            if (events.length !== 0 && this._processingCommands.length !== 0) {
              this._lastCommandTime = this._processingCommands[this._processingCommands.length - 1].getTime();
              context.LogService.typeahead.log("Sending events to VM", events);
              this._application.protocolInterface.event(events);
            } else { // if there is no events to send, unfreeze
              this.unfreeze();
            }
          }
        },

        /**
         * @returns {boolean} return if typeahead is frozen or not
         */
        isFrozen: function() {
          return this._isFrozen;
        },

        /**
         * Unfreeze typeahead.
         */
        unfreeze: function() {
          if (this._isFrozen === true) { // unfreeze only it is frozen
            context.LogService.typeahead.log("Unfreeze");
            this.setBufferizeKeysMode(false);
            this._isFrozen = false;
            context.OverlayService.disable("typeahead");
          }
        },

        /**
         * Freeze typeahead. (overlay added to avoid mouse interaction)
         * @param {boolean} overlay -
         */
        freeze: function() {
          if (this._isFrozen === false) { // freeze only it is not frozen
            context.LogService.typeahead.log("Freeze");
            this._isFrozen = true;
            this.setBufferizeKeysMode(true);
            context.OverlayService.enable("typeahead");
          }
        },

        /**
         * @returns {boolean} return if typeahead is in bufferizeKeys mode
         */
        isBufferizeKeysMode: function() {
          return this._bufferizeKeysMode;
        },

        /**
         * @param {boolean} b - bufferizeKeys mode on/off
         */
        setBufferizeKeysMode: function(b) {
          this._bufferizeKeysMode = b;
          context.LogService.typeahead.log("BufferizeKeysMode = ", this._bufferizeKeysMode);
        },

        /**
         * Validate the last commands send to the VM
         * This function is called each time we received a message from VM
         * @param {boolean} isCurrentApp - is application the current one ?
         */
        validateLastCommand: function(isCurrentApp) {
          if (this._processingCommands.length !== 0) {
            var uiNode = this._application.uiNode();
            var hasFrontCall = !!uiNode && !!uiNode.getFirstChild('FunctionCall');
            var isLastCommandValidated = true;

            var cmd = null;
            // validate each commands
            while (this._processingCommands.length > 0 && isLastCommandValidated) {
              cmd = this._processingCommands.shift();
              isLastCommandValidated = cmd.validate();
            }

            // if one command is not validated or if there is a frontcall, rollback all next commands
            var needToRollback = (hasFrontCall || !isLastCommandValidated);

            if (needToRollback) {
              if (!isLastCommandValidated) { // last command validation has failed rollback it
                context.LogService.typeahead.warn("Command validation failed --> rollback it", cmd);
                cmd.rollback();
              }
              if (hasFrontCall) {
                context.LogService.typeahead.warn("FrontCall detected in command validation", cmd);
              }
              context.LogService.typeahead.warn("Rollback all next commands");

              while (this._processingCommands.length > 0) {
                cmd = this._processingCommands.shift();
                cmd.rollback();
              }

              this.rollbackAllCommands();

              var focusedNode = this._application.focus.getFocusedNode();
              if (focusedNode) {
                // Restoring the currently focused node's value
                var ctrl = focusedNode.getController();
                if (ctrl && ctrl._getAuiValue) { // focus on a ValueContainerBaseController
                  var auiValue = ctrl._getAuiValue();
                  if (auiValue !== ctrl._getWidgetValue()) {
                    focusedNode.getController().getWidget().setValue(auiValue);
                  }
                }
              }
            } else { // last commands are valid
              context.LogService.typeahead.log("Command(s) validation OK", this._processingCommands);
            }

            this._application.layout.when(context.constants.widgetEvents.afterLayoutFocusRestored, function() {
              // synchronize ui & business model focus with VM focus
              if (this.hasFinished() || hasFrontCall) {
                // there is no more commands, disable bufferizeKeys mode
                this.setBufferizeKeysMode(false);
                // force refocus dom for rollbacks, frontcall and action events
                this._application.focus.restoreVMFocus(!isLastCommandValidated || hasFrontCall);

              }
            }.bind(this), true);
          } else {
            context.LogService.typeahead.log("No command to validate");

            if (isCurrentApp) { // first page load
              // TODO this seems to be unnecessary, restoreVMFocus is already done in HostService::setDisplayedWindow function
              this._application.layout.when(context.constants.widgetEvents.afterLayoutFocusRestored, function() {
                this._application.focus.restoreVMFocus(false);
              }.bind(this), true);
            }
          }

          // try to send next commands
          this._executeNextCommand();
        },

        /**
         * Checks if the given node has pending VALUE command in the typeahead command list
         * @param {classes.NodeBase} [node]
         * @returns {boolean}
         */
        hasPendingValueCommands: function(node) {
          for (var i = 0; i < this._commandsQueue.length; ++i) {
            var cmd = this._commandsQueue[i];
            if (cmd instanceof cls.TypeAheadValue && (!node || cmd.getNode() === node)) {
              return true;
            }
          }
          return false;
        },

        /**
         * Checks if the given node has pending FOCUS command in the typeahead command list
         * @param {classes.NodeBase} [node]
         * @returns {boolean}
         */
        hasPendingFocusCommands: function(node) {
          for (var i = 0; i < this._commandsQueue.length; ++i) {
            var cmd = this._commandsQueue[i];
            if (cmd instanceof cls.TypeAheadFocus && (!node || cmd.getNode() === node)) {
              return true;
            }
          }
          return false;
        },

        /**
         * Checks if the given node has pending navigation command in the typeahead command list
         * @returns {boolean}
         */
        hasPendingNavigationCommands: function() {
          for (var i = 0; i < this._commandsQueue.length; ++i) {
            var cmd = this._commandsQueue[i];
            if ((cmd instanceof cls.TypeAheadCurrentRow || cmd instanceof cls.TypeAheadFocus) && (cls.ActionNode
                .isTableNavigationAction(
                  cmd._actionName) || cls.ActionNode.isFieldNavigationAction(cmd._actionName))) {
              return true;
            }
          }
          return false;
        },

        /**
         * Checks if the given node has pending FunctionCallResult command in the typeahead command list
         * @param {boolean} [processing] - check also if there is a frontcall command in processing commands list
         * @returns {boolean}
         */
        hasPendingFunctionCallResultCommands: function(processing) {
          var i;
          var cmd;
          for (i = 0; i < this._commandsQueue.length; ++i) {
            cmd = this._commandsQueue[i];
            if (cmd instanceof cls.TypeAheadFunctionCallResult) {
              return true;
            }
          }
          if (processing) {
            for (i = 0; i < this._processingCommands.length; ++i) {
              cmd = this._processingCommands[i];
              if (cmd instanceof cls.TypeAheadFunctionCallResult) {
                return true;
              }
            }
          }
          return false;
        },

        /**
         * Checks if there are pending commands in the typeahead
         * @param {String} [classname] - class name of the command
         * @returns {boolean}
         */
        hasPendingCommands: function(classname) {
          if (!classname) {
            return this._commandsQueue.length > 0;
          } else {
            for (var i = 0; i < this._commandsQueue.length; ++i) {
              var cmd = this._commandsQueue[i];
              if (cmd.__name === classname) {
                return true;
              }
            }
          }
          return false;
        },

        /**
         * @returns {number} the creation time of the last executed command
         */
        getLastCommandTime: function() {
          return this._lastCommandTime;
        },

        /**
         * Request focus on the given node
         * @param {classes.NodeBase} node - node which should get the focus
         * @param {number} [cursor1] - current starting cursor of the node
         * @param {number} [cursor2] - current ending cursor of the node
         * @param {string} [actionName] - name of the action leading to this focus change
         */
        focus: function(node, cursor1, cursor2, actionName) {
          this._addCommand(new cls.TypeAheadFocus(this.getApplication(), node, cursor1, cursor2, actionName));
        },

        /**
         * Send value on the given node
         * @param {classes.NodeBase} node - target node
         * @param {string} value - current value of the node
         */
        value: function(node, value) {
          // If the value command is part of a TypeAheadGroup, it's canBeExecuted should return false
          var canBeExecuted = this._currentGroupCommandQueue.length === 0;
          this._addCommand(new cls.TypeAheadValue(this.getApplication(), node, value, canBeExecuted));
        },

        /**
         * Send cursors of a given node
         * @param {classes.NodeBase} node - target node
         * @param {number} cursor1 - current starting cursor of the node
         * @param {number} cursor2 - current ending cursor of the node
         */
        cursors: function(node, cursor1, cursor2) {
          // If the value command is part of a TypeAheadGroup, it's canBeExecuted should return false
          var canBeExecuted = this._currentGroupCommandQueue.length === 0;
          this._addCommand(new cls.TypeAheadCursors(this.getApplication(), node, cursor1, cursor2, canBeExecuted));
        },

        /**
         * Send scroll change command. During a scroll, we freeze typeahead
         * @param {classes.TableNode|classes.MatrixNode} node
         * @param {number} offset
         */
        scroll: function(node, offset) {
          this.freeze();
          this._addCommand(new cls.TypeAheadScroll(this.getApplication(), node, offset));
        },

        /**
         * Send currentRow change command
         * @param {classes.TableNode|classes.MatrixNode} node
         * @param {string} actionName
         * @param {boolean} [ctrlKey] - ctrlKey pressed during command creation
         * @param {boolean} [shiftKey] - shiftKey pressed during command creation
         */
        currentRow: function(node, actionName, ctrlKey, shiftKey) {
          this._addCommand(new cls.TypeAheadCurrentRow(this.getApplication(), node, actionName, ctrlKey, shiftKey));
        },

        /**
         * Send rowSelection change command
         * @param {classes.TableNode} node
         * @param {boolean} ctrlKey
         * @param {boolean} shiftKey
         * @param {number} type - type of row selection (merge, toggle, selectAll)
         * @param {string} [actionName] - actionName used to change current row
         */
        rowSelection: function(node, ctrlKey, shiftKey, type, actionName) {
          this._addCommand(new cls.TypeAheadRowSelection(this.getApplication(), node, ctrlKey, shiftKey, type, actionName));
        },

        /**
         * Send action command
         * @param {classes.NodeBase} node
         * @param {boolean} [noUserActivity] - true if action is not from a user interaction
         */
        action: function(node, noUserActivity) {
          this._addCommand(new cls.TypeAheadAction(this.getApplication(), node, !!noUserActivity));
        },

        /**
         * Send a front call result
         * @param status front call result status
         * @param message front call result status message
         * @param values front call result values
         */
        functionCallResult: function(status, message, values) {
          this._addCommand(new cls.TypeAheadFunctionCallResult(this.getApplication(), status, message, values));
        },

        /**
         * Send VM event command
         * @param {classes.VMEventBase} event
         * @param {classes.NodeBase} [node]
         */
        event: function(event, node) {
          this._addCommand(new cls.TypeAheadEvent(this.getApplication(), event, node));
        },

        /**
         * Add an typeahead delayedKey command
         * @param {String} keyString string corresponding to the key
         * @param {Event} keyEvent
         */
        delayedKey: function(keyString, keyEvent) {
          this._addCommand(new cls.TypeAheadDelayedKey(this.getApplication(), keyString, keyEvent));
        },

        /**
         * Add an typeahead native back command
         * @param {String[]} actionList list of actions
         */
        nativeBack: function(actionList) {
          this._addCommand(new cls.TypeAheadNativeBack(this.getApplication(), actionList));
        },

        /**
         * Add an typeahead native close command
         */
        nativeClose: function() {
          this._addCommand(new cls.TypeAheadNativeClose(this.getApplication()));
        },

        /**
         * Add an typeahead native notificationpushed command
         */
        nativeNotificationPushed: function() {
          this._addCommand(new cls.TypeAheadNativeNotificationPushed(this.getApplication()));
        },

        /**
         * Add an typeahead native cordovacallback command
         */
        nativeCordovaCallback: function() {
          this._addCommand(new cls.TypeAheadNativeCordovaCallback(this.getApplication()));
        },

        /**
         * Add an typeahead callback command
         * @param {function} callback - function to call when command is executed
         */
        callback: function(callback) {
          this._addCommand(new cls.TypeAheadCallback(this.getApplication(), callback));
        },

        /** Start group command.
         *  all commands added between call of startGroupCommand() and finishGroupCommand()
         *  will be added in a group command.
         */
        startGroupCommand: function() {
          var groupCommand = new cls.TypeAheadGroup(this.getApplication(), [], null);
          this._currentGroupCommandQueue.push(groupCommand);
          context.LogService.typeahead.log("[app" + this._application.applicationHash + "] Start command group", groupCommand);
        },

        /** Finish group command and add it in the typeahead queue.
         */
        finishGroupCommand: function() {
          var groupCommand = this._currentGroupCommandQueue.pop();
          context.LogService.typeahead.log("[app" + this._application.applicationHash + "] Finish command group", groupCommand);
          this._addCommand(groupCommand);
        }
      };
    });
    cls.ApplicationServiceFactory.register("TypeAhead", cls.TypeAheadApplicationService);
  }
);
;
"use strict";

modulum('TypeAheadCallback', ['TypeAheadCommand'],
  /**
   * @param {gbc} context
   * @param {classes} cls
   */
  function(context, cls) {
    /**
     * TypeAhead callback.
     * @class TypeAheadCallback
     * @memberOf classes
     * @extends classes.TypeAheadCommand
     */
    cls.TypeAheadCallback = context.oo.Class(cls.TypeAheadCommand, function($super) {
      return /** @lends classes.TypeAheadCallback.prototype */ {
        __name: "TypeAheadCallback",

        /**
         * Function to execute
         * @function
         */
        _callback: null,

        /**
         * @param {classes.VMApplication} app owner
         * @param {function} callback
         */
        constructor: function(app, callback) {
          $super.constructor.call(this, app, null);
          this._callback = callback;
        },

        /**
         * @inheritDoc
         */
        execute: function() {
          if (this._callback) {
            this._callback();
          }

          return {
            processed: true,
            vmEvents: []
          };
        },

        /**
         * @inheritDoc
         */
        isPredictable: function() {
          return false;
        }
      };
    });
  }
);
;
"use strict";

modulum('TypeAheadCommand',
  /**
   * @param {gbc} context
   * @param {classes} cls
   */
  function(context, cls) {
    /**
     * TypeAhead commands base class.
     * @class TypeAheadCommand
     * @memberOf classes
     */
    cls.TypeAheadCommand = context.oo.Class(function() {
      return /** @lends classes.TypeAheadCommand.prototype */ {
        __name: "TypeAheadCommand",

        /**
         * Flag for augmentedFace
         * @type {boolean}
         */
        __virtual: true,

        /**
         * owning application
         * @type {classes.VMApplication}
         */
        _app: null,
        /**
         * command timestamp
         * @type {number}
         * */
        _time: 0,
        /**
         * linked AUI node
         * @type classes.NodeBase
         */
        _node: null,

        /**
         * @constructs
         * @param {classes.VMApplication} app owner
         * @param {classes.NodeBase} node linked AUI node
         */
        constructor: function(app, node) {
          this._app = app;
          this._time = Date.now();
          this._node = node;
        },

        /**
         * Returns if command can be executed.
         * @returns {boolean} true if command can be executed
         */
        canBeExecuted: function() {
          return true;
        },

        /**
         * Execute command
         * @returns {{processed: boolean, vmEvents: classes.VMEventBase[]}} object which contains a boolean to know if the command did something and an array containing the events to send to the VM
         */
        execute: function() {
          return {
            processed: false,
            vmEvents: []
          };
        },

        /**
         * Check if a command is valid and can be executed
         * For example a command on destroyed node is invalid
         * @returns {boolean} true if the command is valid, false otherwise
         */
        checkIntegrity: function() {
          var ok = true;
          if (!!this._node) {
            // check that the node is not destroyed
            ok = (this._node._destroyed === false);
          }
          return ok;
        },

        /**
         * test if the request has been accepted by the VM
         * @returns {boolean} true if the request has been accepted by the VM, false otherwise
         */
        validate: function() {
          return true;
        },

        /**
         * Rollback command
         */
        rollback: function() {
          this._app.getUI().getWidget().flash();
          context.LogService.typeahead.warn("Rollback command", this);
        },

        /**
         * merges with an other command
         * @param {classes.TypeAheadCommand} command the command to merge with
         * @returns {boolean} true if merged successfully
         */
        merge: function(command) {
          return false;
        },

        /**
         * test if this command needs to be sent to the VM before sending another one,
         * @returns {boolean} true if this command needs to be sent to the VM before sending another one, false otherwise
         */
        needsVmSync: function() {
          return false;
        },

        /**
         * Returns if result of command is predictable (or if we need to wait VM answer)
         * @returns {boolean} true if this command is predictable, false otherwise
         */
        isPredictable: function() {
          return true;
        },

        /**
         * Returns if only one command of this type must be added to typeahead queue
         * @return {boolean} true if command must be unique in typeahead queue
         */
        isUnique: function() {
          return false;
        },

        /**
         * get the linked AUI node
         * @returns {classes.NodeBase} the node associated to command
         */
        getNode: function() {
          return this._node;
        },

        /**
         * get the command timestamp
         * @returns {number} the command creation time
         */
        getTime: function() {
          return this._time;
        }
      };
    });
  }
);
;
"use strict";

modulum('TypeAheadCurrentRow', ['TypeAheadCommand'],
  /**
   * @param {gbc} context
   * @param {classes} cls
   */
  function(context, cls) {
    /**
     * TypeAhead currentRow event.
     * @class TypeAheadCurrentRow
     * @memberOf classes
     * @extends classes.TypeAheadCommand
     */
    cls.TypeAheadCurrentRow = context.oo.Class(cls.TypeAheadCommand, function($super) {
      return /** @lends classes.TypeAheadCurrentRow.prototype */ {
        $static: /** @lends classes.TypeAheadCurrentRow */ {
          /**
           * Compute new row according to an action
           * @param {classes.MatrixNode|classes.TableNode} containerNode
           * @param {string} actionName
           * @param {number} row - Reference current row
           * @param {boolean} [inputMode] - Input mode
           * @returns {number|null}
           */
          computeNewRowFromAction: function(containerNode, actionName, row, inputMode) {

            if (!cls.ActionNode.isTableNavigationAction(actionName)) {
              return null;
            }
            var pageSize = containerNode.attribute('pageSize');
            var size = containerNode.attribute('size');

            var newCurrentRow = null;

            if (actionName === 'nextrow') {
              newCurrentRow = cls.TypeAheadCurrentRow._computeNewRowFromDelta(containerNode, 1, row);
            } else if (actionName === 'prevrow') {
              newCurrentRow = cls.TypeAheadCurrentRow._computeNewRowFromDelta(containerNode, -1, row);
            } else if (actionName === 'nextpage') {
              newCurrentRow = cls.TypeAheadCurrentRow._computeNewRowFromDelta(containerNode, pageSize, row);
            } else if (actionName === 'prevpage') {
              newCurrentRow = cls.TypeAheadCurrentRow._computeNewRowFromDelta(containerNode, -pageSize, row);
            } else if (actionName === 'firstrow') {
              newCurrentRow = 0;
            } else if (actionName === 'lastrow') {
              newCurrentRow = size - 1;
            }

            // check that new row is in the correct size range [0...size]
            if (newCurrentRow >= size) {
              if (!inputMode || actionName !== "nextrow") { // only exception is in Input mode when the action is "nextrow"
                newCurrentRow = size - 1;
              }
            } else if (newCurrentRow < 0) {
              newCurrentRow = 0;
            }

            return newCurrentRow;
          },

          /**
           * Compute new row according to a delta value
           * @param {classes.MatrixNode|classes.TableNode} node
           * @param {number} delta
           * @param {number} currentRow - Reference current row
           * @returns {number}
           * @private
           */
          _computeNewRowFromDelta: function(node, delta, currentRow) {

            var size = node.attribute('size');

            var offset = node.attribute('offset');
            var pageSize = node.attribute('pageSize');

            var newCurrentRow = null;

            if (pageSize === 1) {
              newCurrentRow = currentRow + delta;
            } else {
              // handle step = +-/ pageSize behavior (like Explorer)
              if (delta === pageSize) {
                var isVerticalScrollAtEnd = node.getController().getWidget() ? node.getController().getWidget().isVerticalScrollAtEnd() :
                  false;
                if (offset + pageSize >= size || isVerticalScrollAtEnd) {
                  newCurrentRow = size;
                } else if (currentRow >= offset + pageSize - 1) {
                  //we are on the last row
                  newCurrentRow = currentRow + pageSize;
                } else {
                  //we move to the next page
                  newCurrentRow = offset + pageSize - 1;
                }
              } else if (delta === -(pageSize)) {
                if (currentRow < offset) {
                  newCurrentRow = Math.max(0, currentRow - pageSize + 1);
                } else if (currentRow === offset) {
                  newCurrentRow = offset - pageSize;
                } else {
                  newCurrentRow = offset;
                }
              } else {
                newCurrentRow = currentRow + delta;
              }
            }

            return newCurrentRow;
          }
        },
        __name: "TypeAheadCurrentRow",

        /** @type String */
        _actionName: null,

        /** @type {number} */
        _currentRowToValidate: -1,

        /** @type {boolean} */
        _ctrlKey: false,

        /** @type {boolean} */
        _shiftKey: false,

        /**
         * @param {classes.VMApplication} app owner
         * @param {classes.TableNode|classes.MatrixNode} node
         * @param {string} actionName - actionName used to change current row
         * @param {boolean} [ctrlKey] - ctrlKey pressed during command creation
         * @param {boolean} [shiftKey] - shiftKey pressed during command creation
         */
        constructor: function(app, node, actionName, ctrlKey, shiftKey) {
          $super.constructor.call(this, app, node);
          this._actionName = actionName;
          this._ctrlKey = !!ctrlKey ? ctrlKey : false;
          this._shiftKey = !!shiftKey ? shiftKey : false;
        },

        /**
         * @inheritDoc
         */
        execute: function() {
          var oldCurrentRow = this._node.attribute("currentRow");
          var dialogType = this._node.attribute('dialogType');
          var displayDialog = (dialogType === "Display" || dialogType === "DisplayArray");

          var newCurrentRow = cls.TypeAheadCurrentRow.computeNewRowFromAction(this._node, this._actionName, this._node.attribute(
            "currentRow"), !displayDialog);
          if (newCurrentRow !== null && (oldCurrentRow !== newCurrentRow)) {
            this._currentRowToValidate = newCurrentRow;
            var events = [];
            // if mrs and one modifier is pressed, we must not send ActionEvent but ConfigureEvent with currentRow
            var forceConfigureEvent = (this._ctrlKey || this._shiftKey) && (this._node.attribute('multiRowSelection') !== 0);
            var actionNode = this._app.action.getAction(this._actionName);
            if (!!actionNode && !forceConfigureEvent) {
              events.push(new cls.VMActionEvent(actionNode.getId()));
            } else {
              events.push(new cls.VMConfigureEvent(this._node.getId(), {
                currentRow: newCurrentRow
              }));
            }

            // Paged ScrollGrids need to compute the offset in the client to keep it in sync properly
            var scrollGridNode = this._node.getAncestor('ScrollGrid');
            if (scrollGridNode && scrollGridNode.getController().isPagedScrollGrid()) {
              var offset = scrollGridNode.attribute('offset');
              var pageSize = scrollGridNode.attribute('pageSize');
              var size = scrollGridNode.attribute('pageSize');
              if (newCurrentRow < offset || newCurrentRow >= offset + pageSize || newCurrentRow > size - pageSize) {
                offset = Math.floor(newCurrentRow / pageSize) * pageSize;
                events.push(new cls.VMConfigureEvent(this._node.getId(), {
                  offset: offset
                }));
              }
            }
            return {
              processed: true,
              vmEvents: events
            };
          }
          return {
            processed: false,
            vmEvents: []
          };
        },

        /**
         * @inheritDoc
         */
        validate: function() {
          var currentRow = this._node.attribute('currentRow');
          return this._currentRowToValidate === currentRow;
        },

        /**
         * @inheritDoc
         */
        rollback: function() {
          $super.rollback.call(this);
          if (this._node) {
            var ctrl = this._node.getController();
            if (ctrl) {
              var widget = ctrl.getWidget();
              if (widget && widget.setCurrentRow) {
                widget.setCurrentRow(this._node.attribute('currentRow'));
              }
            }
          }
        },

        /**
         * @returns {classes.NodeBase} the node to be focused
         */
        getNode: function() {
          return this._node;
        },

        /**
         * @inheritDoc
         */
        needsVmSync: function() {
          return true;
        }
      };
    });
  }
);
;
"use strict";

modulum('TypeAheadCursors', ['TypeAheadCommand'],
  /**
   * @param {gbc} context
   * @param {classes} cls
   */
  function(context, cls) {
    /**
     * TypeAhead cursors change
     * This class updates the cursors of a widget
     * @class TypeAheadCursors
     * @memberOf classes
     * @extends classes.TypeAheadCommand
     */
    cls.TypeAheadCursors = context.oo.Class(cls.TypeAheadCommand, function($super) {
      return /** @lends classes.TypeAheadCursors.prototype */ {
        __name: "TypeAheadCursors",

        /** @type {?number} */
        _cursor: null,
        /** @type {?number} */
        _cursor2: null,
        /** @type {boolean} */
        _canBeExecuted: true,

        /**
         * @param {classes.VMApplication} app owner
         * @param {classes.NodeBase} node - target node
         * @param {number} cursor1 - current starting cursor of the node
         * @param {number} [cursor2] - current ending cursor of the node
         * @param {boolean} [canBeExecuted] - true if the current command can be executed, false otherwise
         */
        constructor: function(app, node, cursor1, cursor2, canBeExecuted) {
          $super.constructor.call(this, app, node);
          this._cursor = cursor1;
          if (cursor2 !== undefined) {
            this._cursor2 = cursor2;
          }
          this._canBeExecuted = canBeExecuted;
        },

        /**
         * @inheritDoc
         */
        execute: function() {
          var ctrl = this._node.getController();
          var event = null;
          if (ctrl) {
            var node = this._node.isInTable() || this._node.isInMatrix() ? this._node.getParentNode().getParentNode() : this._node;
            var vmCursor = node.attribute('cursor');
            var vmCursor2 = node.attribute('cursor2');
            var cursorData = {};
            var hasData = false;
            // Sending only modified cursors to the VM.
            if (vmCursor !== this._cursor) {
              cursorData.cursor = this._cursor;
              hasData = true;
            }
            if (this._cursor2 !== null && vmCursor2 !== this._cursor2) {
              cursorData.cursor2 = this._cursor2;
              hasData = true;
            }
            if (hasData) {
              event = new cls.VMConfigureEvent(node.getId(), cursorData);
              return {
                processed: true,
                vmEvents: [event]
              };
            }
          }
          return {
            processed: false,
            vmEvents: []
          };
        },

        /**
         * @inheritDoc
         */
        canBeExecuted: function() {
          return this._canBeExecuted;
        }
      };
    });
  }
);
;
"use strict";

modulum('TypeAheadDelayedKey', ['TypeAheadCommand'],
  /**
   * @param {gbc} context
   * @param {classes} cls
   */
  function(context, cls) {
    /**
     * TypeAhead delayed key.
     * @class TypeAheadDelayedKey
     * @memberOf classes
     * @extends classes.TypeAheadCommand
     */
    cls.TypeAheadDelayedKey = context.oo.Class(cls.TypeAheadCommand, function($super) {
      return /** @lends classes.TypeAheadDelayedKey.prototype */ {
        __name: "TypeAheadDelayedKey",

        /** @type String */
        _keyString: null,

        /** @type Object */
        _keyEvent: null,

        /**
         * @param {classes.VMApplication} app owner
         * @param {String} keyString string corresponding to the key
         * @param {Object} keyEvent keyDown js event
         */
        constructor: function(app, keyString, keyEvent) {
          $super.constructor.call(this, app, null);
          this._keyString = keyString;
          this._keyEvent = keyEvent;
        },

        /**
         * @inheritDoc
         */
        execute: function() {
          var processed = false;
          var focusedVMNode = this._app.getFocusedVMNodeAndValue();
          if (focusedVMNode) {
            var controller = focusedVMNode.getController();
            if (controller) {
              this._app.focus.restoreVMFocus(); // to be sure cursors are correctly set before value & cursors manipulation
              processed = this._app.keyboard.processKey(this._keyString, this._keyEvent, false);
              if (!processed) {
                context.LogService.typeahead.log("DelayedKey execute typeahead function on", controller);
                processed = this._simulateBrowserBehavior(controller);
              }

              this._app.keyboard.executeKeyUp(this._keyString, this._keyEvent);
            }
          }
          return {
            processed: processed,
            vmEvents: []
          };
        },

        /**
         * Try mimic browser behavior on a controller widget
         * @param {classes.ControllerBase} controller - controller on which we try to execute the key
         * @returns {boolean} true if key has been processed
         */
        _simulateBrowserBehavior: function(controller) {

          if (!controller || !controller.getWidget()) {
            return false;
          }

          var widget = controller.getWidget();

          if (!(widget instanceof cls.FieldWidgetBase)) {
            return false;
          }

          if (!widget.hasInputElement() || !widget.hasCursors() || widget.isReadOnly() || widget.isNotEditable()) {
            return false;
          }

          var consumed = false;
          var value = widget.getValue().toString();
          var keyString = this._keyString;
          var cursors = widget.getCursors();

          var ctrlA = window.browserInfo.isSafari ? 'meta+a' : 'ctrl+a';
          if (keyString === 'space') { // needed for IE
            keyString = ' ';
          }
          if (keyString.length === 1) { // value key
            var firstPart = value.substr(0, cursors.start);
            var secondPart = value.substr(cursors.end);
            value = firstPart + keyString;
            var newCursorPos = value.length;
            value += secondPart;
            cursors.start = cursors.end = newCursorPos;
            consumed = true;
          } else switch (keyString) { // modifier key
            case widget.getStart():
              cursors.start = cursors.start > 0 ? cursors.start - 1 : 0;
              cursors.end = cursors.start;
              consumed = true;
              break;
            case widget.getEnd():
              cursors.start = cursors.end < value.length ? cursors.end + 1 : value.length;
              cursors.end = cursors.start;
              consumed = true;
              break;
            case 'home':
              cursors.start = cursors.end = 0;
              consumed = true;
              break;
            case 'end':
              cursors.start = cursors.end = value.length;
              consumed = true;
              break;
            case 'shift+' + widget.getStart():
              cursors.start = cursors.start > 0 ? cursors.start - 1 : 0;
              consumed = true;
              break;
            case 'shift+' + widget.getEnd():
              cursors.end = cursors.end < value.length ? cursors.end + 1 : value.length;
              consumed = true;
              break;
            case ctrlA:
              cursors.start = 0;
              cursors.end = value.length;
              consumed = true;
              break;
            case 'backspace':
              if (cursors.end > 0 && value) {
                if (cursors.start === cursors.end) {
                  value = value.slice(0, cursors.start - 1) + value.slice(cursors.start);
                  cursors.start = cursors.end = cursors.end - 1;
                } else {
                  value = value.slice(0, cursors.start) + value.slice(cursors.end);
                }
              }
              consumed = true;
              break;
            case 'del':
              if (cursors.end > -1 && value) {
                if (cursors.start === cursors.end) {
                  value = value.slice(0, cursors.start) + value.slice(cursors.start + 1);
                } else {
                  value = value.slice(0, cursors.start) + value.slice(cursors.end);
                }
              }
              consumed = true;
              break;
          }

          if (consumed) {
            widget.setEditing(true); // simulated delay key should imply some editing logic
            widget.setValue(value, false);
            widget.setCursors(cursors.start, cursors.end);
            widget.emit(context.constants.widgetEvents.change, false, true);
          }

          return consumed;
        },

        /**
         * @inheritDoc
         */
        isPredictable: function() {
          return false;
        },

        /**
         * @inheritDoc
         */
        checkIntegrity: function() {
          return true;
        }
      };
    });
  }
);
;
"use strict";

modulum('TypeAheadEvent', ['TypeAheadCommand'],
  /**
   * @param {gbc} context
   * @param {classes} cls
   */
  function(context, cls) {
    /**
     * TypeAhead event.
     * This class sends an event to the VM. Only applicable for non-validable and non-rollbackable commands.
     * @class TypeAheadEvent
     * @memberOf classes
     * @extends classes.TypeAheadCommand
     */
    cls.TypeAheadEvent = context.oo.Class(cls.TypeAheadCommand, function($super) {
      return /** @lends classes.TypeAheadEvent.prototype */ {
        __name: "TypeAheadEvent",

        /** @type {classes.VMEventBase} */
        _event: null,

        /**
         * @param {classes.VMApplication} app owner
         * @param {classes.VMEventBase} event to execute
         * @param {classes.NodeBase} [node] optional used only to check integrity of event
         */
        constructor: function(app, event, node) {
          $super.constructor.call(this, app, node);
          this._event = event;
        },

        /**
         * @inheritDoc
         */
        execute: function() {
          return {
            processed: true,
            vmEvents: [this._event]
          };
        },

        /**
         * @inheritDoc
         */
        needsVmSync: function() {
          return (this._event instanceof cls.VMActionEvent || this._event instanceof cls.VMKeyEvent);
        },

        /**
         * @inheritDoc
         */
        isPredictable: function() {
          return (!(this._event instanceof cls.VMActionEvent) && !(this._event instanceof cls.VMKeyEvent));
        },

      };
    });
  }
);
;
"use strict";

modulum('TypeAheadFocus', ['TypeAheadCommand'],
  /**
   * @param {gbc} context
   * @param {classes} cls
   */
  function(context, cls) {
    /**
     * TypeAhead focus check.
     * This class checks the current state of the AUI tree to ensure the appropriate node has the focus
     * @class TypeAheadFocus
     * @memberOf classes
     * @extends classes.TypeAheadCommand
     */
    cls.TypeAheadFocus = context.oo.Class(cls.TypeAheadCommand, function($super) {
      return /** @lends classes.TypeAheadFocus.prototype */ {
        __name: "TypeAheadFocus",

        /** @type {number} */
        _cursor: 0,
        /** @type {number} */
        _cursor2: 0,
        /** @type {?string} */
        _actionName: null,

        /** @type {number} */
        _currentRowToValidate: -1,
        /** @type {number} */
        _currentColumnToValidate: -1,

        /**
         * @param {classes.VMApplication} app owner
         * @param {classes.NodeBase} node that should have the focus
         * @param {number} cursor1 - current starting cursor of the node
         * @param {number} cursor2 - current ending cursor of the node
         * @param {string} actionName - name of the action leading to this focus change
         */
        constructor: function(app, node, cursor1, cursor2, actionName) {
          $super.constructor.call(this, app, node);
          this._cursor = cursor1 || 0;
          this._cursor2 = cursor2 || 0;
          this._actionName = actionName;
        },

        /**
         * @inheritDoc
         */
        execute: function() {
          var controller = this._node.getController();
          var events = [];
          if (controller) {
            if (this._node.isInTable()) {
              events = this._requestTableCellFocus();
            } else if (this._node.isInMatrix()) {
              events = this._requestMatrixCellFocus();
            } else if (this._node.getTag() === "Table") {
              events = this._requestTableFocus();
            } else if (this._node.getTag() === "ScrollGrid") {
              events = this._requestScrollGridFocus();
            } else {
              events = this._requestFieldFocus();
            }
          }
          return {
            processed: events.length > 0,
            vmEvents: events
          };
        },

        _sendKeyEvent: function() {
          var key = null;
          if (!!this._actionName && ['nextfield', 'prevfield'].indexOf(this._actionName) !== -1) {
            // Send the key event instead of a focus in the expected field.
            // This ensures that the VM and GBC computed the same field
            // This ensures proper rollbacks in case of BEFORE/AFTER FIELD triggers
            var actionNode = this._app.getDefaultActionForName(this._actionName);
            key = actionNode !== null ? actionNode.attribute('acceleratorName') : null;
            if (!key) {
              key = cls.ActionApplicationService.getLocalActionAccelerator(this._actionName);
            }
            if (key) {
              return [new cls.VMKeyEvent(key)];
            }
          }
          return [];
        },

        /**
         * @inheritDoc
         */
        validate: function() {
          var controller = this._node.getController();
          if (!controller) { // controller may be null if it has been destroyed during process
            return false;
          }
          if (this._node.isInTable()) {
            return this._validateTableCellFocus();
          } else if (this._node.isInMatrix()) {
            return this._validateMatrixCellFocus();
          } else if (this._node.getTag() === "ScrollGrid") {
            return this._validateScrollGridFocus();
          } else {
            return this._validateFocus();
          }
        },

        /**
         * @inheritDoc
         */
        rollback: function() {
          $super.rollback.call(this);

          var controller = this._node.getController();
          if (!controller) { // controller may be null if it has been destroyed during process
            return false;
          }
          if (this._node.isInTable()) {
            return this._rollbackTableCellFocus();
          }
        },

        /**
         * Request focus on a form field
         * @returns {classes.VMEventBase[]} the event to send to the VM.
         * @private
         */
        _requestFieldFocus: function() {
          var events = this._sendKeyEvent();
          if (events.length !== 0) {
            return events;
          }
          if (this._node.attribute('active') === 0) {
            // Do not request any focus if not active to not cancel selection of text during this operation (needed to CTRL-C)
            // https://agile.strasbourg.4js.com/jira/browse/GBC-669
            return [];
          }
          var ui = this._app.uiNode();

          if (ui.attribute('focus') !== this._node.getId()) {
            // special for webcomp
            var originWidgetNode = this._app.getFocusedVMNode();
            var originWidgetController = originWidgetNode.getController();
            var originWidget = originWidgetController.getWidget();
            if (originWidget && originWidget.flushWebcomponentData) {
              originWidget.flushWebcomponentData();
            }

            var event = new cls.VMConfigureEvent(this._node.getId(), {
              cursor: this._cursor,
              cursor2: this._cursor2
            });
            return [event];
          }
          return [];
        },

        /**
         * Requests the focus on a Table
         * @returns {classes.VMEventBase[]} the event to send to the VM.
         * @private
         */
        _requestTableFocus: function() {
          var events = this._sendKeyEvent();
          if (events.length !== 0) {
            return events;
          }

          var tableNode = this._node;

          // if table is not active or if it has already the focus
          if (tableNode.attribute('active') === 0 || this._app.getFocusedVMNode() === tableNode) {
            return []; // Nothing to do
          }

          // ask focus for first active table column index
          var columnIndex = 0;
          var columnNodes = tableNode.getChildren('TableColumn');
          for (var i = 0; i < columnNodes.length; i++) {
            var col = columnNodes[i];
            if (col.attribute('noEntry') === 0 && col.attribute('active') === 1) {
              columnIndex = i;
              break;
            }
          }
          var rowIndex = tableNode.attribute("currentRow");

          var event = new cls.VMConfigureEvent(tableNode.getId(), {
            currentColumn: columnIndex,
            currentRow: rowIndex
          });

          return [event];
        },

        /**
         * Requests the focus on a Table
         * @returns {classes.VMEventBase[]} the event to send to the VM.
         * @private
         */
        _requestScrollGridFocus: function() {
          var scrollGridNode = this._node;
          var valueNodeIndex = scrollGridNode.getController().getCurrentRow();
          var offset = scrollGridNode.attribute('offset');
          var vmCurrentRow = scrollGridNode.attribute('currentRow');
          var currentRow = valueNodeIndex + offset;

          this._currentRowToValidate = currentRow;

          var events = this._sendKeyEvent();
          if (events.length !== 0) {
            return events;
          }
          if (scrollGridNode.attribute('active') === 0) {
            // Restore the focus to its previous location
            return [];
          }
          if (currentRow !== vmCurrentRow) {
            var eventData = {
              currentRow: currentRow,
            };

            events = [];
            events.push(new cls.VMConfigureEvent(scrollGridNode.getId(), eventData));
            if (scrollGridNode.getController().isPagedScrollGrid()) {
              var pageSize = scrollGridNode.attribute('pageSize');
              var offsetEventData = {
                offset: Math.floor(currentRow / pageSize) * pageSize
              };
              events.push(new cls.VMConfigureEvent(scrollGridNode.getId(), offsetEventData));
            }
            return events;
          }
          return [];
        },

        /**
         * Request focus on a matrix field
         * @returns {classes.VMEventBase[]} the event to send to the VM.
         * @private
         */
        _requestMatrixCellFocus: function() {
          var containerNode = this._node.getParentNode().getParentNode();
          var ui = this._app.uiNode();
          var valueNodeIndex = this._node.getIndex();
          var offset = containerNode.attribute('offset');
          var vmCurrentRow = containerNode.attribute('currentRow');
          var currentRow = valueNodeIndex + offset;
          var isSameCurrentRow = currentRow === vmCurrentRow;

          var dialogType = containerNode.attribute('dialogType');
          var displayDialog = dialogType === "Display" || dialogType === "DisplayArray";

          this._currentRowToValidate = currentRow;
          var scrollGridNode = this._node.getAncestor("ScrollGrid");
          var isPagedScrollGrid = scrollGridNode && scrollGridNode.getController().isPagedScrollGrid();

          var events = this._sendKeyEvent();
          if (events.length !== 0) {
            if (isPagedScrollGrid) {
              events.push(new cls.VMConfigureEvent(containerNode.getId(), {
                offset: offset
              }));
            }
            return events;
          }
          if (containerNode.attribute('active') === 0) {
            // Restore the focus to its previous location
            return [];
          }
          if (ui.attribute('focus') !== containerNode.getId() || !isSameCurrentRow) {
            var eventData = {
              currentRow: currentRow,
            };
            if (!displayDialog) {
              eventData.cursor = this._cursor;
              eventData.cursor2 = this._cursor2;
            }

            events = [];
            events.push(new cls.VMConfigureEvent(containerNode.getId(), eventData));
            if (isPagedScrollGrid) {
              events.push(new cls.VMConfigureEvent(containerNode.getId(), {
                offset: offset
              }));
            }
            return events;
          }
          return [];
        },

        /**
         * Request focus on a table cell
         * @returns {classes.VMEventBase[]} the event to send to the VM.
         * @private
         */
        _requestTableCellFocus: function() {
          var containerNode = this._node.getParentNode().getParentNode();
          var tableNode = containerNode.getParentNode();
          var ui = this._app.uiNode();

          var eventParams = {};
          var valueNodeIndex = this._node.getIndex();
          var offset = tableNode.attribute('offset');
          eventParams.currentRow = valueNodeIndex + offset;

          this._currentRowToValidate = eventParams.currentRow;

          var needFocus = ui.attribute('focus') !== tableNode.getId() ||
            eventParams.currentRow !== tableNode.attribute('currentRow');

          var dialogType = containerNode.attribute('dialogType');
          var displayDialog = dialogType === "Display" || dialogType === "DisplayArray";
          var isActiveColumn = (containerNode.attribute('active') === 1);

          var focusOnField = tableNode.attribute('focusOnField') === 1;
          if (!displayDialog || focusOnField) { // Input, InputArray, Construct or FocusOnField attribute set
            eventParams.currentColumn = containerNode.getIndex('TableColumn');
            needFocus = needFocus || !tableNode.isAttributeSetByVM('currentColumn') || eventParams.currentColumn !== tableNode
              .attribute(
                'currentColumn');
            if (isActiveColumn) { // we check column on validation only if column is active
              this._currentColumnToValidate = eventParams.currentColumn;
            }
          }

          var events = this._sendKeyEvent();
          if (events.length !== 0) {
            return events;
          }
          if (!isActiveColumn && containerNode.attribute('noEntry') === 0) {
            // Restore the focus to its previous location
            return [];
          }
          if (needFocus) {
            var event = new cls.VMConfigureEvent(tableNode.getId(), eventParams);
            events = [event];
            if (!displayDialog) {
              var event2 = new cls.VMConfigureEvent(containerNode.getId(), {
                cursor: this._cursor,
                cursor2: this._cursor2
              });
              events = events.concat(event2);
            }
            return events;
          }
          return [];
        },

        /**
         * Checks that the appropriate scrollgrid line has the focus
         * @returns {boolean} true if the focus is set properly, false otherwise
         * @private
         */
        _validateScrollGridFocus: function() {
          var currentRow = this._node.attribute('currentRow');
          return this._currentRowToValidate === currentRow;
        },

        /**
         * Checks that the appropriate matrix cell has the focus
         * @returns {boolean} true if the focus is set properly, false otherwise
         * @private
         */
        _validateMatrixCellFocus: function() {
          var containerNode = this._node.getParentNode().getParentNode();
          var ui = this._app.uiNode();
          var dialogType = containerNode.attribute('dialogType');
          var displayDialog = dialogType === "Display" || dialogType === "DisplayArray";
          // validate focused column only in input/input array mode
          if (!displayDialog && ui.attribute("focus") !== containerNode.getId()) {
            return false;
          }

          var offset = containerNode.attribute('offset');
          var currentRow = containerNode.attribute('currentRow');
          return this._node.getIndex() === (currentRow - offset);
        },

        /**
         * Checks that the appropriate table cell has the focus
         * @returns {boolean} true if the focus is set properly, false otherwise
         * @private
         */
        _validateTableCellFocus: function() {
          var containerNode = this._node.getParentNode().getParentNode();
          var tableNode = containerNode.getParentNode();

          var ui = this._app.uiNode();
          if (ui.attribute("focus") !== tableNode.getId()) {
            return false;
          }

          var currentRow = tableNode.attribute('currentRow');

          var valid = (this._currentRowToValidate === currentRow);

          if (this._currentColumnToValidate >= 0) {
            var currentColumn = tableNode.attribute('currentColumn');
            valid = valid && (this._currentColumnToValidate === currentColumn);
          }

          return valid;
        },

        /**
         * Checks that the appropriate widget has the focus
         * @returns {boolean} true if the focus is set properly, false otherwise
         * @private
         */
        _validateFocus: function() {
          var ui = this._app.uiNode();
          return ui.attribute("focus") === this._node.getId();
        },

        /**
         * Rollback for table cell focus command
         * @private
         */
        _rollbackTableCellFocus: function() {
          var containerNode = this._node.getParentNode().getParentNode();
          var tableNode = containerNode.getParentNode();
          var tableCtrl = tableNode.getController();
          if (tableCtrl) {
            var tableWidget = tableCtrl.getWidget();
            if (tableWidget) {
              var offset = tableNode.attribute('offset');
              var auiCurrentRow = tableNode.attribute('currentRow');
              var auiCurrentColumn = tableNode.attribute('currentColumn');

              // reset current row and col to the aui values
              tableWidget.setCurrentRow(auiCurrentRow - offset);
              tableWidget.setCurrentColumn(auiCurrentColumn);
            }
          }
        },

        /**
         * @inheritDoc
         */
        needsVmSync: function() {
          return true;
        }
      };
    });
  }
);
;
"use strict";

modulum('TypeAheadFunctionCallResult', ['TypeAheadCommand'],
  /**
   * @param {gbc} context
   * @param {classes} cls
   */
  function(context, cls) {
    /**
     * TypeAhead event.
     * This class sends an event to the VM. Only applicable for non-validable and non-rollbackable commands.
     * @class TypeAheadFunctionCallResult
     * @memberOf classes
     * @extends classes.TypeAheadCommand
     */
    cls.TypeAheadFunctionCallResult = context.oo.Class(cls.TypeAheadCommand, function($super) {
      return /** @lends classes.TypeAheadFunctionCallResult.prototype */ {
        __name: "TypeAheadFunctionCallResult",

        _status: null,
        _message: null,
        _values: null,

        /**
         * @param app {classes.VMApplication} app owner
         * @param status front call result status
         * @param message front call result status message
         * @param values front call result values
         */
        constructor: function(app, status, message, values) {
          $super.constructor.call(this, app, null);
          this._status = status;
          this._message = message;
          this._values = values;
          // Got the function call result, so functioncall is not processing anymore
          context.FrontCallService.setFunctionCallProcessing(false);
        },

        /**
         * @inheritDoc
         */
        execute: function() {
          var event = new cls.VMFunctionCallEvent(this._status, this._message, this._values);
          return {
            processed: true,
            vmEvents: [event]
          };
        }
      };
    });
  }
);
;
"use strict";

modulum('TypeAheadGroup', ['TypeAheadCommand'],
  /**
   * @param {gbc} context
   * @param {classes} cls
   */
  function(context, cls) {
    /**
     * Group of commands
     * @class TypeAheadGroup
     * @memberOf classes
     * @extends classes.TypeAheadCommand
     */
    cls.TypeAheadGroup = context.oo.Class(cls.TypeAheadCommand, function($super) {
      return /** @lends classes.TypeAheadGroup.prototype */ {
        __name: "TypeAheadGroup",

        /** @type {classes.TypeAheadCommand[]} */
        _commands: null,

        /** @function */
        _executionFunc: null,

        /**
         * @param {classes.VMApplication} app owner
         * @param {classes.TypeAheadCommand[]} commands - list of command
         * @param {function} func - execution function, if func() return true all commands are executed else nothing is done
         */
        constructor: function(app, commands, func) {
          $super.constructor.call(this, app, null);
          this._commands = commands;
          this._executionFunc = func;
        },

        /**
         * Add a command in the group.
         * Last command added is used to know if all commands of the group can be executed
         * @param {classes.TypeAheadCommand} cmd - command to be added
         */
        addCommand: function(cmd) {
          if (!this._commands) {
            this._commands = [];
          }
          this._commands.push(cmd);

          this._executionFunc = cmd.canBeExecuted.bind(cmd);
        },

        /**
         * @inheritDoc
         */
        checkIntegrity: function() {
          // if one command of the group is false all the group must be rejected
          for (var i = 0; i < this._commands.length; i++) {
            var cmd = this._commands[i];
            if (cmd.checkIntegrity() === false) {
              return false;
            }
          }
          return true;
        },

        /**
         * @inheritDoc
         */
        isPredictable: function() {
          // if one command of the group is false all the group is not predicatble
          for (var i = 0; i < this._commands.length; i++) {
            var cmd = this._commands[i];
            if (cmd.isPredictable() === false) {
              return false;
            }
          }
          return true;
        },

        /**
         * @inheritDoc
         */
        execute: function() {
          if (this._executionFunc && this._executionFunc()) {

            while (this._commands.length !== 0) {
              var cmd = this._commands.shift();
              this._app.typeahead._addCommand(cmd);
            }

            return {
              processed: true,
              vmEvents: []
            };
          } else {
            return {
              processed: false,
              vmEvents: []
            };
          }
        }
      };
    });
  }
);
;
"use strict";

modulum('TypeAheadNativeBack', ['TypeAheadCommand'],
  /**
   * @param {gbc} context
   * @param {classes} cls
   */
  function(context, cls) {
    /**
     * TypeAhead native back action.
     * @class TypeAheadNativeBack
     * @memberOf classes
     * @extends classes.TypeAheadCommand
     */
    cls.TypeAheadNativeBack = context.oo.Class(cls.TypeAheadCommand, function($super) {
      return /** @lends classes.TypeAheadNativeBack.prototype */ {
        __name: "TypeAheadNativeBack",

        /** @type String[] */
        _actionList: null,

        /**
         * @param {classes.VMApplication} app owner
         * @param {String[]} actionList list of actions to execute
         */
        constructor: function(app, actionList) {
          $super.constructor.call(this, app, null);
          this._actionList = actionList;
        },

        /**
         * @inheritDoc
         */
        execute: function() {
          var found = false,
            list = this._actionList,
            len = list && list.length;
          var actionService = this._app.action;
          for (var i = 0; i < len; i++) {
            if (actionService.getAction(list[i])) {
              found = true;
              actionService.executeByName(list[i]);
              break;
            }
          }
          if (!found) {
            context.__wrapper.nativeCall({
              name: "noBackAction"
            });
          }

          return {
            processed: true,
            vmEvents: []
          };
        },

        /**
         * @inheritDoc
         */
        isPredictable: function() {
          return false;
        }
      };
    });
  }
);
;
"use strict";

modulum('TypeAheadNativeClose', ['TypeAheadCommand'],
  /**
   * @param {gbc} context
   * @param {classes} cls
   */
  function(context, cls) {
    /**
     * TypeAhead native close action.
     * @class TypeAheadNativeClose
     * @memberOf classes
     * @extends classes.TypeAheadCommand
     */
    cls.TypeAheadNativeClose = context.oo.Class(cls.TypeAheadCommand, function($super) {
      return /** @lends classes.TypeAheadNativeClose.prototype */ {
        __name: "TypeAheadNativeClose",

        /**
         * @param {classes.VMApplication} app owner
         */
        constructor: function(app) {
          $super.constructor.call(this, app, null);
        },

        /**
         * @inheritDoc
         */
        execute: function() {
          context.HostService.tryCloseButtonClick();

          return {
            processed: true,
            vmEvents: []
          };
        },

        /**
         * @inheritDoc
         */
        isPredictable: function() {
          return false;
        }
      };
    });
  }
);
;
"use strict";

modulum('TypeAheadNativeCordovaCallback', ['TypeAheadCommand'],
  /**
   * @param {gbc} context
   * @param {classes} cls
   */
  function(context, cls) {
    /**
     * TypeAhead native cordovacallback action.
     * @class TypeAheadNativeCordovaCallback
     * @memberOf classes
     * @extends classes.TypeAheadCommand
     */
    cls.TypeAheadNativeCordovaCallback = context.oo.Class(cls.TypeAheadCommand, function($super) {
      return /** @lends classes.TypeAheadNativeCordovaCallback.prototype */ {
        __name: "TypeAheadNativeCordovaCallback",

        /**
         * @param {classes.VMApplication} app owner
         */
        constructor: function(app) {
          $super.constructor.call(this, app, null);
        },

        /**
         * @inheritDoc
         */
        execute: function() {
          this._app.action.executeByName("cordovacallback");

          return {
            processed: true,
            vmEvents: []
          };
        },

        /**
         * @inheritDoc
         */
        isPredictable: function() {
          return false;
        },

        /**
         * @inheritDoc
         */
        isUnique: function() {
          return true;
        }
      };
    });
  }
);
;
"use strict";

modulum('TypeAheadNativeNotificationPushed', ['TypeAheadCommand'],
  /**
   * @param {gbc} context
   * @param {classes} cls
   */
  function(context, cls) {
    /**
     * TypeAhead native notificationpushed action.
     * @class TypeAheadNativeNotificationPushed
     * @memberOf classes
     * @extends classes.TypeAheadCommand
     */
    cls.TypeAheadNativeNotificationPushed = context.oo.Class(cls.TypeAheadCommand, function($super) {
      return /** @lends classes.TypeAheadNativeNotificationPushed.prototype */ {
        __name: "TypeAheadNativeNotificationPushed",

        /**
         * @param {classes.VMApplication} app owner
         */
        constructor: function(app) {
          $super.constructor.call(this, app, null);
        },

        /**
         * @inheritDoc
         */
        execute: function() {
          this._app.action.executeByName("notificationpushed");

          return {
            processed: true,
            vmEvents: []
          };
        },

        /**
         * @inheritDoc
         */
        isPredictable: function() {
          return false;
        },

        /**
         * @inheritDoc
         */
        isUnique: function() {
          return true;
        }
      };
    });
  }
);
;
"use strict";

modulum('TypeAheadRowSelection', ['TypeAheadCommand'],
  /**
   * @param {gbc} context
   * @param {classes} cls
   */
  function(context, cls) {
    /**
     * TypeAhead rowSelection event.
     * @class TypeAheadRowSelection
     * @memberOf classes
     * @extends classes.TypeAheadCommand
     */
    cls.TypeAheadRowSelection = context.oo.Class(cls.TypeAheadCommand, function($super) {
      return /** @lends classes.TypeAheadRowSelection.prototype */ {
        __name: "TypeAheadRowSelection",

        $static: /** @lends classes.TypeAheadRowSelection */ {
          currentRow: 1,
          toggle: 2,
          selectAll: 3,
        },

        /** @type boolean */
        _ctrlKey: false,

        /** @type boolean */
        _shiftKey: false,

        /** @type number */
        _type: 1,

        /** @type String */
        _actionName: null,

        /**
         *
         * @param {classes.VMApplication} app owner
         * @param {classes.TableNode} node
         * @param {boolean} ctrlKey - ctrl key pressed
         * @param {boolean} shiftKey - shift key pressed
         * @param {number} type - type of row selection (currentRow, toggle, selectAll)
         * @param {string} [actionName] - actionName used to change current row
         */
        constructor: function(app, node, ctrlKey, shiftKey, type, actionName) {
          $super.constructor.call(this, app, node);
          this._ctrlKey = ctrlKey;
          this._shiftKey = shiftKey;
          this._type = type;
          this._actionName = !!actionName ? actionName : null;
        },

        /**
         * Build row selection event
         * @param {number} row - base row to compute selection
         * @returns {classes.VMRowSelectionEvent} row selection event
         */
        buildRowSelectionEvent: function(row) {

          var controller = this._node.getController();
          var startIndex = row;
          var endIndex = row;
          var mode = "set";

          if (this._shiftKey) {
            if (controller.multiRowSelectionRoot === -1) {
              controller.multiRowSelectionRoot = this._node.attribute('currentRow');
            }

            startIndex = controller.multiRowSelectionRoot;
            endIndex = row;
            mode = this._ctrlKey ? "exset" : "set";

            controller.updateMultiRowSelectionRoot = false;
          } else if (this._ctrlKey) {
            var children = this._node.getChildren();
            var rowInfoListNode = children[children.length - 1];
            var rowInfoNode = rowInfoListNode.getChildren()[row - this._node.attribute('offset')];

            mode = rowInfoNode && rowInfoNode.attribute('selected') === 1 ? "unset" : "exset";
          }

          var event = new cls.VMRowSelectionEvent(this._node.getId(), {
            startIndex: startIndex,
            endIndex: endIndex,
            selectionMode: mode
          });

          return event;
        },

        /**
         * @inheritDoc
         */
        execute: function() {
          var events = [];

          if (this._type === cls.TypeAheadRowSelection.currentRow && !!this._actionName) {
            var newCurrentRow = cls.TypeAheadCurrentRow.computeNewRowFromAction(this._node, this._actionName, this._node.attribute(
              "currentRow"), false);
            events.push(this.buildRowSelectionEvent(newCurrentRow));
          } else if (this._type === cls.TypeAheadRowSelection.toggle) { // toggle selection of currentRow
            events.push(this.buildRowSelectionEvent(this._node.attribute("currentRow")));
          } else if (this._type === cls.TypeAheadRowSelection.selectAll) { // select all
            events.push(new cls.VMRowSelectionEvent(this._node.getId(), {
              startIndex: 0,
              endIndex: this._node.attribute('size') - 1,
              selectionMode: "set"
            }));
          }

          return {
            processed: events.length > 0,
            vmEvents: events
          };
        }
      };
    });
  }
);
;
"use strict";

modulum('TypeAheadScroll', ['TypeAheadCommand'],
  /**
   * @param {gbc} context
   * @param {classes} cls
   */
  function(context, cls) {
    /**
     * TypeAhead scroll event.
     * @class TypeAheadScroll
     * @memberOf classes
     * @extends classes.TypeAheadCommand
     */
    cls.TypeAheadScroll = context.oo.Class(cls.TypeAheadCommand, function($super) {
      return /** @lends classes.TypeAheadScroll.prototype */ {
        __name: "TypeAheadScroll",

        /** @type number */
        _offset: 0,

        /**
         * @param {classes.VMApplication} app owner
         * @param {classes.NodeBase} node scroll target
         * @param {number} offset new scroll offset
         */
        constructor: function(app, node, offset) {
          $super.constructor.call(this, app, node);
          this._offset = offset;
        },

        /**
         * @inheritDoc
         */
        execute: function() {
          var event = new cls.VMConfigureEvent(this._node.getId(), {
            offset: this._offset
          });
          return {
            processed: true,
            vmEvents: [event]
          };
        },

        /**
         * @inheritDoc
         */
        isPredictable: function() {
          return false;
        },

        /**
         * @inheritDoc
         */
        merge: function(command) {
          if (command instanceof cls.TypeAheadScroll) {
            if (command._node === this._node) {
              this._offset = command._offset;
              return true;
            }
          }
          return false;
        }
      };
    });
  }
);
;
"use strict";

modulum('TypeAheadValue', ['TypeAheadCommand'],
  /**
   * @param {gbc} context
   * @param {classes} cls
   */
  function(context, cls) {
    /**
     * TypeAhead field value change
     * This class updates the value of a widget
     * @class TypeAheadValue
     * @memberOf classes
     * @extends classes.TypeAheadCommand
     */
    cls.TypeAheadValue = context.oo.Class(cls.TypeAheadCommand, function($super) {
      return /** @lends classes.TypeAheadValue.prototype */ {
        __name: "TypeAheadValue",

        /** @type {?string} */
        _newValue: null,
        /** @type {boolean} */
        _canBeExecuted: true,

        /**
         * @param {classes.VMApplication} app owner
         * @param {classes.NodeBase} node - target node
         * @param {string} newValue - current value of the node
         * @param {boolean} [canBeExecuted] - true if the current command can be executed, false otherwise
         */
        constructor: function(app, node, newValue, canBeExecuted) {
          $super.constructor.call(this, app, node);
          this._newValue = newValue;
          this._canBeExecuted = canBeExecuted;
        },

        /**
         * @inheritDoc
         */
        checkIntegrity: function() {
          var ok = false;

          if (this._node && this._node.getController()) {
            var focusedVMNode = this._app.getFocusedVMNode();

            // integrity is ok if:
            // value node is in the focused table
            ok = (this._node.getAncestor("Table") === focusedVMNode);
            // value node is in the focused matrix
            ok = ok || (this._node.getAncestor("Matrix") === focusedVMNode);
            // value node is in a webcomponent (this a special case because value can be send even if webcomponent has the focus, specially when it is not active
            ok = ok || (this._node.getController() instanceof cls.WebComponentController);
            // or if value node is the focused one
            ok = ok || (focusedVMNode === this._node);
          }

          return ok && $super.checkIntegrity.call(this);
        },

        /**
         * @inheritDoc
         */
        execute: function() {
          var ctrl = this._node.getController();

          if (ctrl) {
            if (this._hasValueChanged(ctrl)) {
              var valueObj = {
                value: this._newValue,
              };
              var event = new cls.VMConfigureEvent(this._node.getId(), valueObj);
              return {
                processed: true,
                vmEvents: [event]
              };
            }
          }
          return {
            processed: false,
            vmEvents: []
          };
        },

        /**
         * @inheritDoc
         */
        rollback: function() {
          $super.rollback.call(this);
          if (this._node) {
            var ctrl = this._node.getController();
            if (ctrl && !(ctrl instanceof cls.WebComponentController)) { // TODO why ? can you explain
              var widget = ctrl.getWidget();
              if (widget) {
                widget.setValue(this._node.attribute('value'), true);
              }
            }
          }
        },

        /**
         * Checks if the value has changed
         * @returns {boolean} true if the value has changed, false otherwise
         * @private
         */
        _hasValueChanged: function(controller) {
          return this._newValue !== controller._getAuiValue();
        },

        /**
         * @inheritDoc
         */
        canBeExecuted: function() {
          return this._canBeExecuted;
        }
      };
    });
  }
);
;
"use strict";

modulum('QueryString',
  function(context, cls) {

    /**
     *
     * @class QueryString
     * @memberOf classes
     */
    cls.QueryString = context.oo.Class(function() {
      return /** @lends classes.QueryString.prototype */ {
        $static: /** @lends classes.QueryString */ {
          deletedTokenValue: {}
        },
        _contents: null,
        constructor: function(raw) {
          this._contents = {};
          this.fromRaw(raw);
        },
        fromRaw: function(raw) {
          if (raw instanceof cls.QueryString) {
            this._contents = raw.copyContentsObject();
          } else {
            if (Object.isString(raw)) {
              var tokens = raw.split("&");
              for (var i = 0; i < tokens.length; i++) {
                var token = tokens[i];
                if (!!token) {
                  var q = /([^=]+)(?:=(.*))/.exec(token);
                  if (q) {
                    this.add(q[1], q[2]);
                  }
                }
              }
            }
          }
        },
        copyContentsObject: function() {
          var result = {};
          var contentKeys = Object.keys(this._contents);
          for (var i = 0; i < contentKeys.length; i++) {
            var key = contentKeys[i];
            var values = this._contents[key];
            if (Array.isArray(values)) {
              result[key] = [];
              for (var v = 0; v < values.length; v++) {
                var value = values[v];
                result[key].push(value);
              }
            } else {
              if (values !== cls.QueryString.deletedTokenValue) {
                result[key] = values;
              }
            }
          }
          return result;
        },
        toString: function() {
          var result = [];
          var contentKeys = Object.keys(this._contents);
          for (var i = 0; i < contentKeys.length; i++) {
            var key = contentKeys[i];
            var values = this._contents[key];
            if (Array.isArray(values)) {
              for (var v = 0; v < values.length; v++) {
                var value = values[v];
                result.push(key + ((value === false || value === 0 || value === "" || !!value) ? ("=" + value) : ""));
              }
            } else {
              if (values !== cls.QueryString.deletedTokenValue) {
                result.push(key + ((values === false || values === 0 || values === "" || !!values) ? ("=" + values) : ""));
              }
            }
          }
          return result.join("&");
        },
        add: function(key, value) {
          if (this._contents.hasOwnProperty(key)) {
            if (Array.isArray(this._contents[key])) {
              this._contents[key].push(value);
            } else {
              this._contents[key] = [this._contents[key], value];
            }
          } else {
            this._contents[key] = value;
          }
        },
        /**
         *
         * @param key
         * @param value
         */
        remove: function(key, value) {
          if (value === false || value === 0 || value === "" || !!value) {
            if (Array.isArray(this._contents[key])) {
              if (this._contents[key].contains(value)) {
                this._contents[key].remove(value);
              }
              if (this._contents[key].length === 1) {
                this._contents[key] = this._contents[key][0];
              } else if (!this._contents[key].length) {
                this._contents[key] = cls.QueryString.deletedTokenValue;
              }
            } else if (this._contents.hasOwnProperty(key) && this._contents[key] === value) {
              this._contents[key] = cls.QueryString.deletedTokenValue;
            }
          } else if (this._contents.hasOwnProperty(key)) {
            this._contents[key] = cls.QueryString.deletedTokenValue;
          }
        },
        isEmpty: function() {
          return !Object.keys(this._contents).length;
        }
      };
    });
  });
;
"use strict";

modulum('Url',
  function(context, cls) {

    /**
     *
     * @class Url
     * @memberOf classes
     */
    cls.Url = context.oo.Class(function() {
      return /** @lends classes.Url.prototype */ {
        $static: /** @lends classes.Url */ {
          _defaultsPorts: {
            http: "80",
            https: "443"
          },
          isValid: function(urlString) {
            return !!window.RegExpUrl.test(urlString);
          },
          protocolDefaultPort: function(protocol) {
            return this._defaultsPorts[protocol] || "80";
          }
        },
        /**
         * @type {?string}
         */
        _protocol: null,
        /**
         * @type {?string}
         */
        _username: null,
        /**
         * @type {?string}
         */
        _password: null,
        /**
         * @type {?string}
         */
        _host: null,
        /**
         * @type {?string}
         */
        _port: null,
        /**
         * @type {?string}
         */
        _path: null,
        /**
         * @type {classes.QueryString}
         */
        _queryString: null,
        /**
         * @type {?string}
         */
        _hash: null,
        /**
         * @type {boolean}
         */
        _invalid: false,
        constructor: function(urlString) {
          this._queryString = new cls.QueryString();
          if (urlString instanceof cls.Url) {
            this.fromUrl(urlString);
          } else {
            this.fromUrlString(urlString);
          }
        },
        fromUrl: function(url) {
          this._protocol = url._protocol;
          this._username = url._username;
          this._password = url._password;
          this._host = url._host;
          this._port = url._port;
          this._path = url._path;
          this._queryString.fromRaw(url._queryString);
          this._hash = url._hash;
        },
        fromUrlString: function(urlString) {
          urlString = urlString || window.location.href;
          var parts = window.RegExpUrl.exec(urlString);
          this._invalid = !parts;
          if (!!parts) {
            this._protocol = parts[1];
            this._username = parts[2];
            this._password = parts[3];
            this._host = parts[4];
            this._port = parts[5];
            this._path = parts[6];
            this._queryString.fromRaw(parts[7]);
            this._hash = parts[8];
          }
        },
        originString: function() {
          return [
            (this._protocol || context.UrlService.currentUrl()._protocol), "://", (this._username ? (this._username + (this._password ?
              (":" + this._password) : "") + "@") : ""),
            this._host, (this._port ? (":" + this._port) : "")
          ].join("");
        },
        toRawString: function() {
          return this.originString() + (this._path || "");
        },
        toString: function() {
          var queryString = this._queryString && this._queryString.toString();
          return this.toRawString() +
            (!!queryString ? ("?" + queryString) : "") +
            (!!this._hash ? ("#" + this._hash) : "");
        },
        setQueryString: function(key, value) {
          this.removeQueryString(key);
          return this.addQueryString(key, value);
        },
        addQueryString: function(key, value) {
          (this._queryString = this._queryString || new cls.QueryString()).add(key, value);
          return this;
        },
        removeQueryString: function(key, value) {
          if (this._queryString) {
            this._queryString.remove(key, value);
            if (!this._queryString.toString().length) {
              this._queryString = null;
            }
          }
          return this;
        },
        hasSameOrigin: function(url) {
          if (!(url instanceof cls.Url)) {
            if (Object.isString(url)) {
              url = new cls.Url(url);
            } else {
              return false;
            }
          }
          return (url._protocol === this._protocol) &&
            (url._username === this._username) &&
            (url._password === this._password) &&
            (url._host === this._host) &&
            (
              (url._port || cls.Url.protocolDefaultPort(url._protocol)) ===
              (this._port || cls.Url.protocolDefaultPort(this._protocol))
            );
        },
        hasSamePath: function(url) {
          if (!(url instanceof cls.Url)) {
            if (Object.isString(url)) {
              url = new cls.Url(url);
            } else {
              return false;
            }
          }
          return (url._path === this._path);
        },
        isUaR: function() {
          return this._path.indexOf("/ua/r/") >= 0;
        },
        getQueryStringObject: function() {
          return this._queryString.copyContentsObject();
        }
      };
    });
  });
;
"use strict";

modulum('UrlService', ['InitService'],
  function(context, cls) {

    /**
     * @class gbc.UrlService
     */
    context.UrlService = context.oo.StaticClass( /** @lends gbc.UrlService */ {
      __name: "UrlService",
      /** @type classes.Url */
      _current: null,
      init: function() {
        this._current = new cls.Url();
      },

      currentUrl: function() {
        return new cls.Url(this._current);
      },
      setCurrentUrl: function(url, forceLocation) {
        if (forceLocation) {
          window.location.href = url;
        } else {
          this._current = new cls.Url(url);
          if (window.isURLParameterEnabled("qainfo")) {
            this._current.addQueryString("qainfo", 1);
          }
          if (window.isURLParameterEnabled("noquitpopup")) {
            this._current.addQueryString("noquitpopup", 1);
          }
          window.history.pushState(null, "Genero Browser Client", this._current.toString());
        }
      },

      isValid: function(url) {
        var reWebUrl = new RegExp(
          "^" +
          // protocol identifier
          "(?:(?:https?|ftp)://)" +
          // user:pass authentication
          "(?:\\S+(?::\\S*)?@)?" +
          "(?:" +
          // IP address exclusion
          // private & local networks
          "(?!(?:10|127)(?:\\.\\d{1,3}){3})" +
          "(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})" +
          "(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})" +
          // IP address dotted notation octets
          // excludes loopback network 0.0.0.0
          // excludes reserved space >= 224.0.0.0
          // excludes network & broacast addresses
          // (first & last IP address of each class)
          "(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])" +
          "(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}" +
          "(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))" +
          "|" +
          // host name
          "(?:(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)" +
          // domain name
          "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*" +
          // TLD identifier
          "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))" +
          ")" +
          // port number
          "(?::\\d{2,5})?" +
          // resource path
          "(?:/\\S*)?" +
          "$", "i"
        );

        return !!url && !!url.match(reWebUrl);

      },
      goTo: function(urlString) {
        var url = new cls.Url(urlString);
        if (cls.Url.isValid(urlString)) {
          var params = url.getQueryStringObject() || {};
          var currentUrl = this.currentUrl();
          if (url.isUaR() && (url.hasSameOrigin(currentUrl) || window.isURLParameterEnabled("crossdomain"))) {
            var urlParts = url.toRawString().split("/ua/r/");
            params.customUA = urlParts[0];
            params.app = urlParts[1];
            var historyUrl = currentUrl.setQueryString("app", params.app);
            if (url.originString() !== params.customUA) {
              historyUrl.setQueryString("customUA", params.customUA);
            } else {
              historyUrl = url;
            }
            this.setCurrentUrl(historyUrl);
            context.SessionService.start(params.app, params);
          } else if (url.hasSameOrigin(currentUrl) && url.hasSamePath(currentUrl)) {
            if (params.app) {
              this.setCurrentUrl(url.toString());
              context.SessionService.start(params.app, params);
            }
          } else {
            this.setCurrentUrl(url.toString(), true);
          }

        } else {
          this.setCurrentUrl(this.currentUrl().setQueryString("app", encodeURIComponent(urlString)).toString(), true);
        }
      }
    });
    context.InitService.register(context.UrlService);
  });
;
"use strict";

modulum('WebComponentService', ['InitService'],
  function(context, cls) {

    /**
     * Proxy Service used to forward webcomponent api
     * @namespace gbc.WebComponentService
     * @gbcService
     */
    context.WebComponentService = context.oo.StaticClass(
      /** @lends gbc.WebComponentService */
      {
        __name: "WebComponentService",
        /**
         * List of proxies
         * @type {Object}
         */
        _proxies: {},

        /**
         * Keep track of webcomponent URL provided by the GAS
         * @type {url}
         */
        _webcomponentUrl: null,

        /**
         * Init function, called once and mandatory
         */
        init: function() {

        },

        /**
         * Add or edit a new proxy
         * @param uid
         * @param widget
         */
        setProxy: function(uid, widget) {
          this._proxies[uid] = this._api(widget);
        },

        /**
         * Get a registered proxy
         * @param uid
         * @returns {*}
         */
        getProxy: function(uid) {
          return this._proxies[uid];
        },

        /**
         * Get the webcomponent URL defined by the GAS
         * @returns {url}
         */
        getWebcomponentUrl: function() {
          return this._webcomponentUrl;
        },

        /**
         * Set the webcomponent URL
         * @param url
         */
        setWebcomponentUrl: function(url) {
          this._webcomponentUrl = url;
        },

        /**
         * Api that will be binded to webcomponent
         * @returns {{setFocus: function, setData: function, action: function}}
         * @private
         */
        _api: function() {
          return /** @ignore */ {
            //Generates a focus request
            /** @ignore */
            setFocus: function(element) {
              context.LogService.gICAPI.log("Emit a focus request");
              element.emit(context.constants.widgetEvents.requestFocus);
            },
            //Registers data to be sent to the program, in order to set the form field value in the program.
            /** @ignore */
            setData: function(element, dataStr) {
              //Ensure dataStr is a string
              if (typeof dataStr !== "string") {
                dataStr = JSON.stringify(dataStr);
                context.LogService.gICAPI.warn("Data sent is not of type string, it will be automatically stringified");
              }
              element.emit(cls.WebComponentWidget.dataEvent, dataStr);
            },
            //Triggers an action event, which will execute the corresponding ON ACTION code.
            /** @ignore */
            action: function(element, actionName) {
              //Ensure actionName is a string, cancel and log otherwise
              if (typeof actionName === "string") {
                context.LogService.gICAPI.log("Call Action(" + actionName + ")");
                element.emit(cls.WebComponentWidget.actionEvent, actionName);
              } else {
                context.LogService.gICAPI.error("Action identifier is not of type string, action canceled.");
              }
            }
          };
        }

      });
    context.InitService.register(context.WebComponentService);
  });
;
"use strict";

modulum('WidgetService', ['InitService'],
  function(context, cls) {

    /**
     * @namespace gbc.WidgetService
     */
    context.WidgetService = context.oo.StaticClass( /** @lends gbc.WidgetService */ {
      __name: "WidgetService",

      /** @type number */
      cursorX: 0,
      /** @type number */
      cursorY: 0,

      /** @type classes.EventListener */
      _eventListener: null,

      /** @type {Map<string,classes.WidgetBase>} */
      _widgetsMap: null,

      /** @type {Array<string>} */
      _currentAppIds: null,

      /**
       *  Init widget service
       */
      init: function() {
        this._eventListener = new cls.EventListener();
        this._widgetsMap = new Map();
        this._currentAppIds = [];
      },

      /**
       * Register VM application
       * @param app {classes.VMApplication} - app
       */
      registerVMApplication: function(app) {
        this._currentAppIds.push(app.applicationHash);
      },

      /**
       * Unregister VM application
       * @param app {classes.VMApplication} - app
       */
      unregisterVMApplication: function(app) {

        var widgets = this.getAllWidgets(app.applicationHash);
        if (widgets.length !== 0) {
          gbc.error("WidgetService::unregisterVMApplication --> all widgets of the application are not destroyed");
          console.log(widgets);

          // anyway clean the widgets
          widgets.forEach(function(w) {
            if (!w.isDestroyed()) {
              w.destroy();
            }
          }.bind(this));
        }

        this._currentAppIds.remove(app.applicationHash);
      },

      /**
       * Register widget
       * @param widget {classes.WidgetBase} - widget
       */
      registerWidget: function(widget) {
        this._widgetsMap.set(widget.getUniqueIdentifier(), widget);

        if (widget.getApplicationIdentifier() === null) {
          gbc.error("WidgetService::registerWidget --> widget has no application id");
        }
      },

      /**
       * Unregister widget
       * @param widget {classes.WidgetBase} - widget
       */
      unregisterWidget: function(widget) {
        var success = this._widgetsMap.delete(widget.getUniqueIdentifier());
        if (!success) {
          gbc.error("WidgetService::unregisterWidget --> widget is not registered");
        }
      },

      /**
       * Get a widget from its uuid
       * @param uuid {String} - uuid of widget
       * @returns {classes.WidgetBase} widget
       */
      getWidget: function(uuid) {
        var widget = this._widgetsMap.get(uuid);
        return !!widget ? widget : null;
      },

      /**
       * Returns a Widget from a dom element
       * @param {Element} elem - dom element
       * @param {String} [widgetClass] - class name of the widget that we want to return (default=gbc_WidgetBase)
       * @return {classes.WidgetBase} Widget pointer
       */
      getWidgetFromElement: function(elem, widgetClass) {
        widgetClass = !!widgetClass ? widgetClass : "gbc_WidgetBase";
        var widget = null;
        if (elem && elem.elementOrParent) {
          var widgetElement = elem.elementOrParent(widgetClass);
          if (widgetElement) {
            var widgetUuid = widgetElement.id.slice(2);
            widget = context.WidgetService.getWidget(widgetUuid);
          }
        }
        return widget;
      },

      /**
       * Get all widgets of a given app
       * @param {String} [appId] - app id or null for all apps
       * @return {Array<classes.WidgetBase>} array of widgets
       */
      getAllWidgets: function(appId) {
        appId = (typeof(appId) === "undefined") ? null : appId;
        var widgets = [];
        this._widgetsMap.forEach(function(value, key, map) {
          if (appId === null || value.getApplicationIdentifier() === appId) {
            widgets.push(value);
          }
        });
        return widgets;
      },

      /**
       * Get number of widgets
       * @param {String} [appId] - app id or null for all apps
       * @return {number} number of widgets
       */
      getAllWidgetsCount: function(appId) {
        appId = (typeof(appId) === "undefined") ? null : appId;
        if (appId === null) {
          return this._widgetsMap.size;
        } else {
          return this.getAllWidgets(appId).length;
        }
      },

      /**
       * Emit an event
       * @param {string} type event type to emit
       * @param {*} data - data
       */
      _emit: function(type, data) {
        this._eventListener.emit(type, data);
      },

      // TODO comment
      onWidgetCreated: function(kind, hook) {
        this._eventListener.when(context.constants.widgetEvents.created, function(evt, src, data) {
          if (!hook) {
            hook = kind;
            kind = null;
          }
          if (!kind || data.__name === kind) {
            hook(evt, src, data);
          }
        });
      }

    });
    context.InitService.register(context.WidgetService);
  });
;
"use strict";

modulum('ClipboardHelper',
  function(context, cls) {

    /**
     * Helper to use clipboard
     * @namespace classes.ClipboardHelper
     */
    cls.ClipboardHelper = context.oo.StaticClass(function() {
      return /** @lends classes.ClipboardHelper */ {
        __name: "ClipboardHelper",

        /**
         * Copy text to clipboard
         * Copies a string to the clipboard. Must be called from within an
         * event handler such as click. May return false if it failed, but
         * this is not always possible. Browser support for Chrome 43+,
         * Firefox 42+, Safari 10+, Edge and IE 10+.
         * IE: The clipboard feature may be disabled by an administrator. By
         * default a prompt is shown the first time the clipboard is
         * used (per session).
         * @param text text to copy
         * @param focusElement if !== null after copy the focus will be set on this element
         * @param callback function
         */
        copyTo: function(text, focusElement, callback) {
          var useModalWindow = false;
          if (window.clipboardData && window.clipboardData.setData) {
            // IE specific code path to prevent textarea being shown while dialog is visible.
            window.clipboardData.setData("Text", text);

          } else if (document.queryCommandSupported && document.queryCommandSupported("copy")) {
            var textarea = document.createElement("textarea");
            if (text === "") {
              text = " "; // use space string to clean clipboard else it does nothing
            }
            textarea.textContent = text;
            textarea.style.position = "fixed"; // Prevent scrolling to bottom of page in MS Edge.
            document.body.appendChild(textarea);
            textarea.select();
            try {
              var ret = document.execCommand("copy"); // Security exception may be thrown by some browsers
              useModalWindow = !ret;
            } catch (ex) {
              console.warn("Copy to clipboard failed.", ex);
            } finally {
              document.body.removeChild(textarea);
            }
          }

          // Fallback if copy failed
          if (useModalWindow) {
            this._copyToUsingModal(text, focusElement, callback);
          } else {
            if (!!focusElement) {
              focusElement.domFocus();
            }
            if (!!callback) {
              callback(true);
            }
          }
        },

        /** Use modal window with a textarea to copy to clipboard
         *
         * @param text text to copy
         * @param focusElement if !== null after copy the focus will be set on this element
         * @param callback function
         */
        _copyToUsingModal: function(text, focusElement, callback) {

          var modal = cls.WidgetFactory.createWidget("Modal", {
            appHash: gbc.systemAppId
          });

          modal._gbcSystemModal();
          modal.copyOk = false;

          modal.setClosable(true, true, true);

          var title = cls.WidgetFactory.createWidget("Label", {
            appHash: gbc.systemAppId
          });
          title.setValue(i18next.t("gwc.clipboard.title"));

          var textarea = document.createElement("textarea");
          textarea.textContent = text;
          textarea.readOnly = true;
          textarea.rows = 10;
          textarea.style.width = "100%";

          textarea.on('keydown.ClipboardHelper', function(event) {
            var char = String.fromCharCode(event.which || event.keyCode); // select all
            if (char.toLowerCase() === 'c' && (event.ctrlKey === true || event.metaKey === true)) {
              // destroy modal in a requestAnimationFrame to be sure browser has the time to do "copy"
              window.requestAnimationFrame(function() {
                modal.copyOk = true;
                modal.hide();
              }.bind(this));
            }
          }.bind(this));
          modal.getElement().querySelector(".mt-dialog-content").addClasses("mt-field", "gbc_textEditWidget");
          modal.setHeader(title.getElement());
          modal.setContent(textarea);

          document.body.appendChild(modal.getElement());

          textarea.domFocus();

          modal.onClose(function() { // on close focus element and call callback function
            title.destroy();
            modal.destroy();

            textarea.off('keydown.ClipboardHelper');
            if (!!focusElement) {
              focusElement.domFocus();
            }
            if (!!callback) {
              callback(modal.copyOk);
            }
          }.bind(this), true);

          modal.show();
          textarea.select();
        }
      };
    });
  });
;
"use strict";

modulum('DateTimeHelper',
  function(context, cls) {

    /**
     * Helpers for time related widgets.
     * @namespace classes.DateTimeHelper
     */
    cls.DateTimeHelper = context.oo.StaticClass(function() {
      return /** @lends classes.DateTimeHelper */ {
        __name: "DateTimeHelper",

        /**
         * Transform Informix DBDATE Format (ex : MDY4/) to traditional format
         * @param dbformat
         */
        parseDbDateFormat: function(dbformat) {
          // supported DBDATE separators are '-', '/', '.' and '0'. Default is '/'. '0' means no separator
          var sep = dbformat.match(/[.\/\-0]/) || '/';
          sep = sep.toString();
          if (sep === '0') {
            sep = "";
          }
          var format = "";
          for (var i = 0; i < 4; i++) {
            var c = dbformat[i];
            // add separator & duplicate char if 'D' or 'M'. if 'Y', multiply by its next number.
            format += (i !== 0 ? sep : "") + new Array((c === "Y" ? ~~dbformat[++i] : 2) + 1).join(c);
          }
          return format;
        },

        /**
         * Convert Date time to Locale format
         * @param datetimestring
         * @param format
         * @return {*}
         */
        toDbDateFormat: function(datetimestring, format) {
          // Deprecated by MomentJs but needed for Safari. Using new Date('ISO string') raise invalid date on Safari.
          var localDateTime = context.moment(datetimestring);
          // Date object may be valid under Chrome and invalid for other browsers with incomplete date values such as "dd mm" format
          if (localDateTime.isValid()) {
            return localDateTime.format(format);
          } else {
            return datetimestring;
          }
        },

        /**
         * Convert Date time to ISO format
         * @param datetimestring
         * @param format
         * @returns {*|string}
         */
        toISOFormat: function(datetimestring, format) {
          var currentISODateTime = "";
          if (datetimestring) {
            var d = context.moment(datetimestring, format);
            if (!d.isValid()) {
              return datetimestring;
            }
            var hasSec = !!~format.toLowerCase().indexOf("s");
            currentISODateTime = d.format("YYYY-MM-DD " + (hasSec ? "HH:mm:ss" : "HH:mm"));
          }
          return currentISODateTime;
        },

        /**
         * Convert Date time to Locale format
         * @param datetimestring
         * @param seconds
         * @returns {string}
         */
        toLocaleFormat: function(datetimestring, seconds) {
          var localDateTime = context.moment(datetimestring);
          if (localDateTime.isValid()) {
            return localDateTime.format("L") + " " + localDateTime.format((seconds ? "LTS" : "LT"));
          } else {
            return datetimestring;
          }
        },

        /**
         * Get client locale format
         * @param seconds
         * @returns {string}
         */
        getLocaleFormat: function(seconds) {
          var localData = context.moment.localeData();
          return localData.longDateFormat("L") + " " + localData.longDateFormat((seconds ? "LTS" : "LT"));
        },

        /**
         * Get client locale format
         * @param seconds
         * @returns {string}
         */
        getISOFormat: function(seconds) {
          return "YYYY-MM-DD HH:mm" + (seconds ? ":ss" : "");
        },

        /**
         * Builds a time fragment handling object.
         * Ex: For minutes: group(60) increments from 0 to 59 and wraps.
         * @param {number} highLimit upper limit
         * @returns {{fromText: Function, increaseValue: Function, decreaseValue: Function, getText: Function}}
         */
        timeFragment: function(highLimit) {
          var limit = highLimit;
          var maxChars = String(highLimit).length;
          var value = 0;
          return {
            /**
             * @param {string} text
             * @param {boolean} force
             * @ignore
             * @returns {boolean}
             */
            fromText: function(text, force) {
              if (!text) {
                return false;
              }
              var isComplete = true;
              var intValue = parseInt(text, 10);

              if (isNaN(intValue)) {
                value = 0;
              } else {
                if (text.length > maxChars) {
                  value = limit - 1;
                } else if (text.length === maxChars) {
                  if (intValue >= limit) {
                    value = limit - 1;
                  } else {
                    value = intValue;
                  }
                } else {
                  /*if ((intValue * 10) >= limit || force) {
                    value = intValue;
                  } else {*/
                  isComplete = false;
                  //}
                }

              }
              return isComplete;
            },
            /**
             * @ignore
             * @returns {boolean} true if the value has wrapped.
             */
            increaseValue: function() {
              if ((value + 1) === limit) {
                value = 0;
                return true;
              } else {
                value++;
                return false;
              }
            },
            /**
             * @ignore
             * @returns {boolean} true if the value has wrapped
             */
            decreaseValue: function() {
              if (value === 0) {
                value = limit - 1;
                return true;
              } else {
                value--;
                return false;
              }
            },
            /**
             * @ignore
             * @returns {string} the current value
             */
            getText: function() {
              return value.pad(2);
            }
          };
        },

        /**
         * Convert traditional year of date to Ming guo year format
         * @param {string} datestring
         * @returns {string} return ming guo year
         */
        mingGuoToGregorianYears: function(datestring) {
          var str = datestring.match(/\d{3}/);
          if (str) {
            var year = str.toString();
            return datestring.replace(year, "" + (~~year + 1911));
          } else {
            return datestring;
          }
        },

        gregorianToMingGuoYears: function(date) {
          return date.getFullYear() - 1911;
        }
      };
    });
  });
;
"use strict";

modulum('DebugHelper',
  function(context, cls) {
    /**
     *
     * @class DebugHelper
     * @memberOf classes
     */
    cls.DebugHelper = context.oo.StaticClass(function() {
      return /** @lends classes.DebugHelper */ {
        activateDebugHelpers: function() {
          if (!window.gbcNode) {
            /**
             *
             * @param elementOrIdRef
             * @return {classes.NodeBase}
             */
            window.gbcNode = function(elementOrIdRef) {
              if (typeof(elementOrIdRef) === 'object') {
                var element = elementOrIdRef;
                while (element) {
                  var classList = element.classList;
                  for (var i = 0; i < classList.length; ++i) {
                    var cls = classList[i];
                    if (cls.startsWith("aui__")) {
                      var id = parseInt(cls.substr(5), 10);
                      return context.SessionService.getCurrent().getCurrentApplication().getNode(id);
                    }
                  }
                  element = element.parentElement;
                }
                return null;
              } else {
                return context.SessionService.getCurrent().getCurrentApplication().getNode(elementOrIdRef);
              }
            };
          }
          if (!window.gbcJsonAui) {
            window.gbcJsonAui = function() {
              var rootNode = window.gbcNode(0);
              return rootNode._attributes;
            };
          }
          if (!window.gbcController) {
            window.gbcController = function(elementOrIdRef) {
              var node = window.gbcNode(elementOrIdRef);
              return node ? node.getController() : null;
            };
          }
          if (!window.gbcWidget) {
            /**
             *
             * @param elementOrIdRef
             * @returns {classes.WidgetBase}
             */
            window.gbcWidget = function(elementOrIdRef) {
              var controller = window.gbcController(elementOrIdRef);
              return controller ? controller.getWidget() : null;
            };
          }
          if (!window.gbcMeasuring) {
            window.gbcMeasuring = function() {
              var list = document.getElementsByClassName("g_measured"),
                len = list.length,
                i = 0;
              for (; i < len; i++) {
                list[i].removeClass("g_measured").addClasses("g_measuring", "__debug");
              }
            };
          }
        }
      };
    });
  });
;
"use strict";

modulum('Factory', ['LogService'],
  function(context, cls) {
    /**
     * @memberOf classes
     * @class Factory
     * @template T
     * @memberOf classes
     */
    cls.Factory = context.oo.Class(function() {
      return /** @lends classes.Factory.prototype */ {
        __name: "Factory",
        _default: null,
        _fabrics: null,
        _topic: "",
        /**
         * @constructs
         * @param {string} topic
         * @param {?function=} defaultConstructor
         */
        constructor: function(topic, defaultConstructor) {
          this._topic = topic;
          this._default = defaultConstructor || null;
          this._fabrics = {};
        },
        /**
         *
         * @param {?function=} constructor
         */
        setDefault: function(constructor) {
          this._default = constructor;
        },
        /**
         *
         * @param {string} id
         * @param {function} constructor
         */
        register: function(id, constructor) {
          if (!!this._fabrics[id]) {
            context.LogService.debug("Factory (" + this._topic + ") already registered : " + id);
          }
          if (typeof(constructor) === "function") {
            this._fabrics[id] = constructor;
          }
        },
        /**
         *
         * @param {string} id
         */
        unregister: function(id) {
          this._fabrics[id] = null;
        },
        /**
         *
         * @param {string} id
         */
        has: function(id) {
          return !!this._fabrics[id];
        },
        /**
         *
         * @param {string} id
         * @returns {T}
         */
        create: function(id, arg1, arg2, arg3, arg4, arg5) {
          var Fabric = this._fabrics[id] || this._default;
          if (Fabric) {
            return new Fabric(arg1, arg2, arg3, arg4, arg5);
          }
          context.LogService.debug("Factory (" + this._topic + ") not found : " + id);
          return null;
        }
      };
    });
  });
;
"use strict";

modulum('KeyboardHelper',
  function(context, cls) {

    /**
     * Helper functions for keyboard.
     * @namespace classes.KeyboardHelper
     */
    cls.KeyboardHelper = context.oo.StaticClass(function() {
      return /** @lends classes.KeyboardHelper */ {
        __name: "KeyboardHelper",

        /**
         *
         * @param sequence
         * @return {boolean}
         */
        isModifier: function(sequence) {
          return ["ctrl", "shift", "alt", "meta"].indexOf(sequence) !== -1;
        },

        /**
         *
         * @param {string} keyString - string of the key
         * @return {boolean}
         */
        isSpecialCommand: function(keyString) {
          var result = ["home", "end", "left", "right", "up", "down", "del", "backspace"].contains(keyString);
          result = result || (keyString.startsWith("ctrl+") || keyString.startsWith("meta+")) && keyString.indexOf("alt") === -1;
          return result;
        },

        /**
         *
         * @param char
         * @return {boolean}
         */
        isDecimal: function(char) {
          return /^[,.+\-0-9]+$/.test(char);
        },
        /**
         *
         * @param char
         * @return {boolean}
         */
        isNumeric: function(char) {
          return /^\d+$/.test(char);
        },

        /**
         * Check if a string length is equal to 1
         * @param {string} str
         * @returns {boolean}
         */
        isChar: function(str) {
          return str.length === 1;
        },
        /**
         *
         * @param char
         * @return {boolean}
         */
        isLetter: function(char) {
          return /^[A-Za-z\u00C0-\u017F]+$/.test(char); // alphabetic characters + special accent chars
        },

        /**
         * Validate new number with typed char at specified position
         * @param initialValue
         * @param position
         * @param typedChar
         * @param min
         * @param max
         * @returns {boolean}
         */
        validateNumber: function(initialValue, position, typedChar, min, max) {
          var newVal = "";
          if (position === 0) {
            newVal = typedChar + initialValue;
          } else {
            newVal = initialValue.substr(0, position) + typedChar + initialValue.substr(position);
          }
          if (newVal === '-' || newVal === '+') {
            return true;
          } else {
            // TODO what happens if newVal contains ',' shall we not replace ',' by '.' ?
            var newNumber = parseInt(newVal, 10);
            return !isNaN(newVal) && (!max || newNumber <= max);
          }
        },

        /**
         * Convert VM bindings to key combination that we can interpret in a browser
         * @param {string} bindName - vm key to convert to dom key
         * @returns {string} browser key combination
         */
        convertVMKeyToBrowserKey: function(bindName) {
          var key = bindName.toString().toLowerCase();
          if (key === "return") {
            return "enter";
          }
          key = key.replace("prior", "pageup");
          key = key.replace("next", "pagedown");
          key = key.replace("-", "+");
          key = key.replace("control", "mod"); //handle mac keyboard as well
          return key;
        },

        /**
         * Transform key to vmKey
         * @param {string} bindName browserKey
         * @returns {string} vmKey
         */
        convertBrowserKeyToVMKey: function(bindName) {
          var key = (bindName || "");
          key = key.toLowerCase();
          key = key.replace("pageup", "prior");
          key = key.replace("pagedown", "next");
          // Special case where the accelerator is '+'
          if (key.length !== 1) {
            key = key.replace(/\+/g, '-');
          }
          key = key.replace("ctrl", "control");
          key = key.replace("esc", "escape");
          key = key.replace("mod", "control"); //handle mac keyboard as well
          key = key.replace("ins", "insert");
          return key;
        }
      };
    });
  });
;
'use strict';

modulum('ModelHelper', ['EventListener'],
  function(context, cls) {
    /**
     * Helper to ease AUI tree access for customized widgets,
     * Manages client side life cycle representation of the node.
     * @class ModelHelper
     * @memberOf classes
     * @extends classes.EventListener
     * @publicdoc Base
     */
    cls.ModelHelper = context.oo.Class(cls.EventListener, function($super) {
      return /** @lends classes.ModelHelper.prototype */ {
        __name: 'ModelHelper',

        /** @type {classes.WidgetBase} */
        _widget: null,
        /** @type {?Function[]} */
        _newApplicationsListeners: null,
        /** @type {?Function[]} */
        _closeApplicationsListeners: null,
        /** @type {?Function[]} */
        _sessionEndListeners: null,
        /** @type {?Function[]} */
        _auiUpdateListeners: null,
        /** @type {?Function[]} */
        _currentWindowListeners: null,
        /** @type {?Function[]} */
        _activeListenersHandlers: null,

        /**
         * @constructs
         * @param {classes.WidgetBase} widget the widget to handle
         */
        constructor: function(widget) {
          $super.constructor.call(this);
          this._widget = widget;
        },

        /**
         * Unbind all active listeners and destroy the current instance.
         */
        destroy: function() {
          // unbind all active listeners
          var h = null;
          if (this._activeListenersHandlers) {
            while (this._activeListenersHandlers.length > 0) {
              h = this._activeListenersHandlers.pop();
              if (h) {
                h(); // unregister listener
              }
            }
            h = null;
            this._activeListenersHandlers = null;
          }
          this._newApplicationsListeners = null;
          this._closeApplicationsListeners = null;
          this._sessionEndListeners = null;
          this._auiUpdateListeners = null;
          this._currentWindowListeners = null;

          this._widget = null;
          $super.destroy.call(this);
        },

        /**
         * Registers a listener which will be called when a new application is started
         * @param listener {Function=} - the function to call when a new application is started
         * @returns {function(this:classes.ModelHelper)} The unregister handler. Simply call this function to stop listening for new applications
         * @publicdoc
         */
        addNewApplicationListener: function(listener) {
          if (this._activeListenersHandlers === null) {
            this._activeListenersHandlers = [];
          }
          if (this._newApplicationsListeners === null) {
            this._newApplicationsListeners = [];

            var onApplicationAdded = function(event, sender, app) {
              // for each iteration we recheck if array is defined because modelhelper may have been destroyed in a previous iteration
              for (var i = 0; this._newApplicationsListeners && i < this._newApplicationsListeners.length; ++i) {
                this._newApplicationsListeners[i](app);
              }
            }.bind(this);

            this._activeListenersHandlers.push(context.SessionService.onSessionAdded(function(event, sender, session) {
              // If null, widget may have been destroyed. We stop to create listeners. Otherwise, we attach new one.
              if (this._activeListenersHandlers) {
                this._activeListenersHandlers.push(session.when(context.constants.baseEvents.applicationAdded,
                  onApplicationAdded));
              }
            }.bind(this)));
            var session = context.SessionService.getCurrent();
            if (session) {
              this._activeListenersHandlers.push(session.when(context.constants.baseEvents.applicationAdded, onApplicationAdded));
            }
          }
          this._newApplicationsListeners.push(listener);

          return function() {
            if (this._newApplicationsListeners) {
              this._newApplicationsListeners.remove(listener);
            }
          }.bind(this);
        },

        /**
         * Registers a listener which will be called when an application is closed
         * @param listener {Function=} - the function to call when an application is closed
         * @returns {function(this:classes.ModelHelper)} The unregister handler. Simply call this function to stop listening for closed applications
         * @publicdoc
         */
        addCloseApplicationListener: function(listener) {
          if (this._activeListenersHandlers === null) {
            this._activeListenersHandlers = [];
          }
          if (this._closeApplicationsListeners === null) {
            this._closeApplicationsListeners = [];

            var onApplicationClosed = function(event, sender, app) {
              // for each iteration we recheck if array is defined because modelhelper may have been destroyed in a previous iteration
              for (var i = 0; this._closeApplicationsListeners && i < this._closeApplicationsListeners.length; ++i) {
                this._closeApplicationsListeners[i](app);
              }
            }.bind(this);

            this._activeListenersHandlers.push(context.SessionService.onSessionAdded(function(event, sender, session) {
              // If null, widget may have been destroyed. We stop to create listeners. Otherwise, we attach new one.
              if (this._activeListenersHandlers) {
                this._activeListenersHandlers.push(session.when(context.constants.baseEvents.applicationRemoved,
                  onApplicationClosed));
              }
            }.bind(this)));
            var session = context.SessionService.getCurrent();
            if (session) {
              this._activeListenersHandlers.push(session.when(context.constants.baseEvents.applicationRemoved, onApplicationClosed));
            }
          }
          this._closeApplicationsListeners.push(listener);

          return function() {
            if (this._closeApplicationsListeners) {
              this._closeApplicationsListeners.remove(listener);
            }
          }.bind(this);
        },

        /**
         * Registers a listener which will be called when all applications are closed and session end page is displayed.
         * @param listener {Function=} - the function to call when session end page is displayed
         * @returns {function(this:classes.ModelHelper)} The unregister handler. Simply call this function to stop listening for session end
         * @publicdoc
         */
        addSessionEndListener: function(listener) {
          if (this._activeListenersHandlers === null) {
            this._activeListenersHandlers = [];
          }
          if (this._sessionEndListeners === null) {
            this._sessionEndListeners = [];

            var onSessionEndClosed = function(event, sender, sessionId) {
              // for each iteration we recheck if array is defined because modelhelper may have been destroyed in a previous iteration
              for (var i = 0; this._sessionEndListeners && i < this._sessionEndListeners.length; ++i) {
                this._sessionEndListeners[i](sessionId);
              }
            }.bind(this);

            this._activeListenersHandlers.push(context.SessionService.onSessionAdded(function(event, sender, session) {
              // If null, widget may have been destroyed. We stop to create listeners. Otherwise, we attach new one.
              if (this._activeListenersHandlers) {
                this._activeListenersHandlers.push(session.when(context.constants.baseEvents.displayEnd, onSessionEndClosed));
              }
            }.bind(this)));
            var session = context.SessionService.getCurrent();
            if (session) {
              this._activeListenersHandlers.push(session.when(context.constants.baseEvents.displayEnd, onSessionEndClosed));
            }
          }
          this._sessionEndListeners.push(listener);

          return function() {
            if (this._sessionEndListeners) {
              this._sessionEndListeners.remove(listener);
            }
          }.bind(this);
        },

        /**
         * Registers a listener which will be called when the current window changes
         * @param listener {Function=} - the function to call when the current window changes
         * @returns {function(this:classes.ModelHelper)} The unregister handler. Simply call this function to stop listening for window changes
         * @publicdoc
         */
        addCurrentWindowChangeListener: function(listener) {
          if (this._activeListenersHandlers === null) {
            this._activeListenersHandlers = [];
          }
          if (this._currentWindowListeners === null) {
            this._currentWindowListeners = [];

            this._activeListenersHandlers.push(context.HostService.onCurrentWindowChange(
              /**
               * @param {classes.Event} event event object
               * @param {Object} src event emitter
               * @param {classes.WindowWidget} win data
               */
              function(event, sender, win) {
                var i = 0;
                var windowNode = null;
                var w = win;
                var appHash = null;
                while (w) {
                  if (w._appHash !== undefined) {
                    appHash = w._appHash;
                    break;
                  }
                  w = w.getParentWidget();
                }
                if (appHash !== null) {
                  var app = null;
                  var session = context.SessionService.getCurrent();
                  for (i = 0; i < session._applications.length; ++i) {
                    var a = session._applications[i];
                    if (a.applicationHash === appHash) {
                      app = a;
                      break;
                    }
                  }
                  windowNode = app.model.getNode(win._auiTag);
                }
                // for each iteration we recheck if array is defined because modelhelper may have been destroyed in a previous iteration
                for (i = 0; this._currentWindowListeners && i < this._currentWindowListeners.length; ++i) {
                  this._currentWindowListeners[i](windowNode);
                }
              }.bind(this)));
          }
          this._currentWindowListeners.push(listener);

          return function() {
            if (this._currentWindowListeners) {
              this._currentWindowListeners.remove(listener);
            }
          }.bind(this);
        },

        /**
         * Registers a listener which will be called when any DVM answer is received.
         * You can update your widget in the provided callback
         * This listening method is general to all started applications. If your UI updates are heavy, prefer more fine grained update notification mechanisms
         * @param {Function=} listener - the function to call when a new application is started
         * @returns {function(this:classes.ModelHelper)} The unregister handler. Simply call this function to stop listening for new applications
         * @publicdoc
         */
        addAuiUpdateListener: function(listener) {
          if (this._activeListenersHandlers === null) {
            this._activeListenersHandlers = [];
          }
          if (this._auiUpdateListeners === null) {
            this._auiUpdateListeners = [];

            this._activeListenersHandlers.push(context.SessionService.onSessionAdded(function(event, session) {
              // If null, widget may have been destroyed. We stop to create listeners. Otherwise, we attach new one.
              if (this._activeListenersHandlers) {
                this._activeListenersHandlers.push(session.when(context.constants.baseEvents.applicationAdded, this._onApplicationAdded
                  .bind(this)));
              }
            }.bind(this)));
            var session = context.SessionService.getCurrent();
            if (session) {
              for (var i = 0; i < session._applications.length; ++i) {
                this._activeListenersHandlers.push(session._applications[i].dvm.onOrdersManaged(this._dispatchUpdate.bind(this)));
              }
            }
          }
          this._auiUpdateListeners.push(listener);
          return function() {
            if (this._auiUpdateListeners) {
              this._auiUpdateListeners.remove(listener);
            }
          }.bind(this);
        },

        _dispatchUpdate: function(event, src, data) {
          // for each iteration we recheck if array is defined because modelhelper may have been destroyed in a previous iteration
          for (var i = 0; this._auiUpdateListeners && i < this._auiUpdateListeners.length; ++i) {
            this._auiUpdateListeners[i](src, data);
          }
        },

        _onApplicationAdded: function(event, app) {
          if (this._activeListenersHandlers) {
            this._activeListenersHandlers.push(app.dvm.onOrdersManaged(this._dispatchUpdate.bind(this)));
          }
        },

        /**
         * Get the current application
         * @returns {?classes.VMApplication} the currently visible application or null if it cannot be found.
         * @publicdoc
         */
        getCurrentApplication: function() {
          var session = context.SessionService.getCurrent();
          if (session) {
            return session.getCurrentApplication();
          }
          return null;
        },

        /**
         * Get the widget application
         * @returns {?classes.VMApplication} the VM application to which this widget is attached. null if the widget isn't below a VM application
         * @publicdoc
         */
        getApplication: function() {
          var session = context.SessionService.getCurrent();
          if (session) {
            for (var i = 0; i < session.getApplications().length; ++i) {
              var app = session.getApplications()[i];
              if (app.applicationHash === this._widget._appHash) {
                return app;
              }
            }
          }
          return null;
        },

        /**
         * Get a node with its id
         * @param {number} idRef - the VM id of the node to return
         * @returns {?classes.NodeBase} the requested node or null if it couldn't be found
         * @publicdoc
         */
        getNode: function(idRef) {
          var app = this.getApplication();
          if (app) {
            return app.model.getNode(idRef);
          }
          return null;
        },

        /**
         * Get the UserInterface Node
         * @returns {?classes.NodeBase} the UserInterface node of the current application or null if it coulnd't be found
         * @publicdoc
         */
        getUserInterfaceNode: function() {
          return this.getNode(0);
        },

        /**
         * Get Anchor Node of the widget
         * @returns {?classes.NodeBase} the AUI anchor node of this widget. Generally the corresponding node or the node holding the displayed value
         * @publicdoc
         */
        getAnchorNode: function() {
          if (this._widget._auiTag !== null) {
            var app = this.getApplication();
            if (app) {
              return app.model.getNode(this._widget._auiTag);
            }
          }
          return null;
        },

        /**
         * Applies only to entry fields (FormField, Matrix or TableColumn)
         * @returns {?classes.NodeBase} the field node corresponding to the widget or null if it doesn't apply
         * @publicdoc
         */
        getFieldNode: function() {
          var anchorNode = this.getAnchorNode();
          if (anchorNode) {
            if (anchorNode.getTag() === 'FormField') {
              return anchorNode;
            } else if (anchorNode.getTag() === 'Value') {
              return anchorNode.getParentNode().getParentNode();
            }
          }
          return null;
        },

        /**
         * Applies only to entry fields (FormField, Matrix or TableColumn)
         * A decoration node is the node holding visual information (Edit, CheckBox, ComboBox, etc...)
         * @returns {?classes.NodeBase} the decoration node corresponding to the widget or null if it doesn't apply
         * @publicdoc
         */
        getDecorationNode: function() {
          var fieldNode = this.getFieldNode();
          if (fieldNode) {
            return fieldNode.getChildren()[0];
          }
          return null;
        },

        /**
         * Try to find & execute an action by name (search in the active Dialog/Menu of the current Window).
         * Note that the focused widget with pending changes will send its value to the VM
         * @param {string} name of the action
         * @returns {boolean} true if an action has been found and executed, false otherwise.
         * @publicdoc
         */
        executeActionByName: function(name) {
          var actionExecuted = false;
          var currentApp = this.getCurrentApplication();
          if (currentApp) {
            // TODO GBC-1760 we should use ActionApplicationService to search an action
            var activeWindow = currentApp.getVMWindow();
            if (activeWindow) {
              var activeDialog = activeWindow.getActiveDialog();
              if (activeDialog) {
                var action = activeDialog.getFirstChildWithAttribute(null, 'name', name);
                if (action) {
                  currentApp.action.execute(action.getId(), null, {
                    sendValue: true
                  });
                  actionExecuted = true;
                }
              }
            }
          }
          return actionExecuted;
        }
      };
    });
  }
);
;
"use strict";

modulum('NodeHelper',
  function(context, cls) {
    /**
     * Memory implementation of an AUI Node.
     *
     * Reflects the state of the AUI node in the DVM.
     *
     * @namespace classes.NodeHelper
     * @extends classes.EventListener
     */
    cls.NodeHelper = context.oo.StaticClass(function() {
      return /** @lends classes.NodeHelper */ {
        /**
         *
         * @param {string} nodeTag
         */
        getDefaultAttributes: function(nodeTag) {
          var result = context.constants.nodeAttributes[nodeTag];
          return result || [];
        },
        /**
         *
         * @param {classes.NodeBase} node
         * @param {string} attributeName
         */
        setAttributeDefaultValue: function(node, attributeName) {
          node._attributes[attributeName] = this.getAttributeDefaultValue(node._tag, attributeName);
        },
        /**
         *
         * @param {string} nodeTag
         * @param {string} attributeName
         */
        getAttributeDefaultValue: function(nodeTag, attributeName) {
          var value = null;
          var defaultsForTag = context.constants.attributeDefaultValuesByNodeType[nodeTag];
          var defaultsForAny = context.constants.attributeDefaultValues;

          if (!!defaultsForTag && defaultsForTag.hasOwnProperty(attributeName)) {
            value = defaultsForTag[attributeName];
          } else {
            value = defaultsForAny[attributeName];
          }
          return value;
        },
        /**
         *
         * @param {classes.NodeBase} node
         * @param {classes.NodeBase=} originNode
         * @param [boolean=} useAUIPositionToAttachWidget - use position in AUI tree parent node to add widget at the correct position
         */
        addToParentWidget: function(node, originNode, useAUIPositionToAttachWidget) {
          originNode = originNode || node;
          if (!originNode.getController()) {
            this.failed("adding from node without controller", originNode._tag);
          } else if (!originNode.getController().getWidget()) {
            this.failed("adding from node without widget", originNode._tag);
          } else {
            node = node.getParentNode();
            if (!node) {
              if (originNode._id > 0) { // Don't display error for UserInterface which doesn't have parent
                this.failed("could not find parent widget", originNode._tag);
              }
            } else {
              if (!node.getController()) {
                this.addToParentWidget(node, originNode, useAUIPositionToAttachWidget);
              } else {
                if (!node.getController().getWidget()) {
                  this.addToParentWidget(node, originNode, useAUIPositionToAttachWidget);
                } else {
                  if (!node.getController().getWidget().addChildWidget) {
                    this.failed("Parent widget cannot hosts children");
                  } else {
                    var opt;
                    if (useAUIPositionToAttachWidget) {
                      opt = {};
                      opt.position = originNode.getIndex();
                    }
                    node.getController().getWidget().addChildWidget(originNode.getController().getWidget(), opt);
                  }
                }
              }
            }
          }
        },
        /**
         *
         * @param msg
         * @params {*[]} params
         */
        failed: function(msg, param) {
          gbc.error(msg, param);
        }
      };
    });
  });
;
"use strict";

(
  function(context) {
    /**
     *
     * @type {HTMLElement}
     * @private
     */
    context.__testhostelement = null;
    if (context.gbc.unitTestMode) {
      if (!context.__testhostelement) {
        context.__testhostelement = document.createElement("div");
        context.__testhostelement.setAttribute("class", "unittesthost");

        context.__testhostelement.style.position = "absolute";
        context.__testhostelement.style.top = "-1000px";
        context.__testhostelement.style.left = "-1000px";
        context.__testhostelement.style.width = "600px";
        context.__testhostelement.style.height = "600px";
        context.__testhostelement.style.zIndex = 55;

        document.body.appendChild(context.__testhostelement);
      }
      /**
       * @memberOf gbc
       * @private
       */
      context.gbc.__unitTestingCloseCurrentSession = function() {
        var session = context.gbc.SessionService && context.gbc.SessionService.getCurrent();
        if (session) {
          var apps = session.getApplications().slice(),
            appsLen = apps.length;
          for (var i = 0; i < appsLen; i++) {
            if (apps[i]) {
              apps[i].stop();
              apps[i].destroy();
            }
          }
          var app = session && session.getCurrentApplication();
          while (app) {
            var currentApp = app;
            try {
              app.stop();
              app.destroy();
            } catch (e) {}
            app = session && session.getCurrentApplication();
            app = currentApp !== app && app;
          }
          context.gbc.SessionService.getCurrent().destroy(true);
        }
        if (!window.gbc.__unitTestingModeActivated) {
          window.gbc.__unitTestingModeActivated = true;
          window.gbc.__unitTestingModeActivated = true;
          window.__desactivateEndingPopup = true;
          window.gbc.showExitWarning = function() {};
        }
      };
      /**
       * @memberOf Window
       * @param {classes.NodeBase} node
       * @param attrs
       * @param noApply
       */
      context.testUpdateAttributes = function(node, attrs, noApply) {
        if (!!node) {
          context.styler.bufferize();
          var mods = [];
          mods[node._id] = true;
          node.updateAttributes(attrs);
          if (!noApply) {
            var treeModificationTrack = new context.gbc.classes.TreeModificationTracker();
            (node._id === 0 ? node : node.getAncestor("UserInterface")).applyBehaviors(treeModificationTrack, true, true);
          }
          context.styler.flush();
        }
      };
    }
  })(window);
;
"use strict";

modulum('ServerHelper',
  function(context, cls) {

    /**
     * Helper for server informations
     * @namespace classes.ServerHelper
     */
    cls.ServerHelper = context.oo.StaticClass(function() {
      return /** @lends classes.ServerHelper */ {
        __name: "ServerHelper",
        verRE: /GAS\/([0-9]+)\.([0-9]+)\.([0-9]+)(-([0-9]+))?/,
        /**
         * is version valid
         * @param ver
         * @return {boolean}
         */
        isValid: function(ver) {
          return this.verRE.test(ver);
        },
        /**
         * compare versions
         * @param a
         * @param b
         * @return {number}
         */
        compare: function(a, b) {
          var pa = this.verRE.exec(a) || [];
          var pb = this.verRE.exec(b) || [];
          for (var i = 0; i < 3; i++) {
            var na = Number(pa[i + 1]);
            var nb = Number(pb[i + 1]);
            if (na > nb) {
              return 1;
            }
            if (nb > na) {
              return -1;
            }
            if (!isNaN(na) && isNaN(nb)) {
              return 1;
            }
            if (isNaN(na) && !isNaN(nb)) {
              return -1;
            }
          }
          return 0;
        }
      };
    });
  });
;
"use strict";

modulum('WindowHelper',
  function(context, cls) {

    /**
     * Helper to use Window
     * @namespace classes.WindowHelper
     */
    cls.WindowHelper = context.oo.StaticClass(function() {
      return /** @lends classes.WindowHelper */ {
        __name: "WindowHelper",
        _opened: [],
        /**
         * open browser window
         * @param url
         * @param once
         * @return {Window}
         */
        openWindow: function(url, once) {
          if (once) {
            if (this._opened.indexOf(url) >= 0) {
              return null;
            }
            this._opened.push(url);
          }
          return window.open(url);
        },
        /**
         * close browser window
         */
        closeWindow: function() {
          window.close();
        }
      };
    });
  });
;
"use strict";

modulum('ActionDefaultNode', ['StandardNode', 'NodeFactory'],
  function(context, cls) {
    /**
     * AUI Node ActionDefault
     *
     * @class ActionDefaultNode
     * @memberOf classes
     * @extends classes.StandardNode
     */
    cls.ActionDefaultNode = context.oo.Class(cls.StandardNode, function($super) {
      return /** @lends classes.ActionDefaultNode.prototype */ {
        constructor: function(parent, tag, id, attributes, app) {
          $super.constructor.call(this, parent, tag, id, attributes, app);
        }
      };
    });
    cls.NodeFactory.register("ActionDefault", cls.ActionDefaultNode);
  });
;
"use strict";

modulum('ActionNode', ['StandardNode', 'NodeFactory'],
  function(context, cls) {
    /**
     * Action node (AUI)
     * @class ActionNode
     * @memberOf classes
     * @extends classes.StandardNode
     */
    cls.ActionNode = context.oo.Class(cls.StandardNode, function($super) {
      return /** @lends classes.ActionNode.prototype */ {

        $static: /** @lends classes.ActionNode */ {
          /**
           * Return true if actionName correspond to a field navigation action
           * @param {string} actionName - name of the action
           * @returns {boolean} true if action is field navigation
           */
          isFieldNavigationAction: function(actionName) {

            return (['nextfield', 'prevfield'].indexOf(actionName) > -1);
          },

          /**
           * Return true if actionName correspond to a table/matrix navigation action
           * @param {string} actionName - name of the action
           * @returns {boolean} true if action is table navigation
           */
          isTableNavigationAction: function(actionName) {

            return (['nextrow', 'prevrow',
              'firstrow', 'lastrow',
              'nextpage', 'prevpage'
            ].indexOf(actionName) > -1);
          }
        },

        /**
         * Send action event to VM.
         */
        execute: function() {
          var actionService = this.getApplication().getActionApplicationService();
          actionService.execute(this._id);
        }
      };
    });
    cls.NodeFactory.register("Action", cls.ActionNode);
  });
;
"use strict";

modulum('ButtonNode', ['StandardNode', 'NodeFactory'],
  function(context, cls) {
    /**
     * @class ButtonNode
     * @memberOf classes
     * @extends classes.StandardNode
     */
    cls.ButtonNode = context.oo.Class(cls.StandardNode, function() {
      return /** @lends classes.ButtonNode.prototype */ {
        __name: "ButtonNode",
        /**
         * @inheritDoc
         */
        _createController: function(additionalBindings) {
          return cls.ControllerFactory.create(this._tag, {
            anchor: this,
            parent: this._parent,
            ui: this.getApplication().getNode(0),
            additionalBindings: additionalBindings
          });
        }
      };
    });
    cls.NodeFactory.register("Button", cls.ButtonNode);
  });
;
"use strict";

modulum('FormFieldNode', ['NodeBase', 'NodeFactory'],
  function(context, cls) {
    /**
     * @class FormFieldNode
     * @memberOf classes
     * @extends classes.NodeBase
     */
    cls.FormFieldNode = context.oo.Class(cls.NodeBase, function() {
      return /** @lends classes.FormFieldNode.prototype */ {
        /**
         * @inheritDoc
         */
        _createController: function() {
          var decoratorNode = this._children[0];
          var controllerType = decoratorNode && decoratorNode._tag;
          return cls.ControllerFactory.create(controllerType, {
            anchor: this,
            parent: this._parent,
            ui: this.getApplication().getNode(0),
            decorator: decoratorNode,
            container: this
          });
        },
        /**
         * @inheritDoc
         */
        _createChildrenControllers: function(_queue) {},

        /**
         * @inheritDoc
         */
        getStyleAttribute: function(styleAttr, forcedPseudoSelectors) {
          // On FormFields, take the decorator node into account
          var decoratorNode = this.getChildren()[0];
          var pseudoSelectors = forcedPseudoSelectors || this._computePseudoSelectors();
          return decoratorNode._getStyleAttributeImpl(styleAttr, pseudoSelectors);
        }
      };
    });
    cls.NodeFactory.register("FormField", cls.FormFieldNode);
  });
;
"use strict";

modulum('IdleActionNode', ['NodeBase', 'NodeFactory'],
  function(context, cls) {
    /**
     * @class IdleActionNode
     * @memberOf classes
     * @extends classes.NodeBase
     */
    cls.IdleActionNode = context.oo.Class(cls.NodeBase, function($super) {
      return /** @lends classes.IdleActionNode.prototype */ {

        _timer: null,
        _timeout: 1000,
        _suffix: null,

        constructor: function(parent, tag, id, attributes, app) {
          $super.constructor.call(this, parent, tag, id, attributes, app);
          this._isTimer = this.attribute("isTimer");

          this._suffix = "idleAction_" + id;

          var timeoutAttr = this.attribute("timeout");
          if (timeoutAttr > 0) {
            var timeout = timeoutAttr * 1000 || this._timeout;
            this.setTimeout(timeout);

            if (this._isTimer) {
              this.start();
            } else {
              this.activate();
            }
          }
        },

        /**
         * Stop the timer and start it again
         */
        reset: function() {
          this.stop();
          this._timer = window.setTimeout(this.onTimer.bind(this), this._timeout);
        },

        /**
         * Stop the timer
         */
        stop: function() {
          if (this._timer) {
            window.clearTimeout(this._timer);
            this._timer = null;
          }
        },

        /**
         * Start the timer
         * note: alias for reset()
         */
        start: function() {
          this.reset();
        },

        /**
         * Check if timer is running
         * @returns {boolean} true if running, false otherwise
         */
        isRunning: function() {
          return !!this._timer;
        },

        /**
         * Define the timeout value for this timer
         * @param {number} timeout time in ms
         */
        setTimeout: function(timeout) {
          this._timeout = timeout;
          if (this.isRunning()) {
            this.reset();
          }
        },

        /**
         * Action trigged when timer is over: send the event to the VM
         */
        onTimer: function() {
          this._timer = null;
          if (this.getApplication() && !this.getApplication().ending) {
            //Do not send the event if the parent container is not active
            if (this.getParentNode() && this.getParentNode().attribute("active")) {
              this.getApplication().action.execute(this.getId(), null, {
                noUserActivity: true,
                sendValue: true
              });
            }
            this.getApplication().dvm.onOrdersManaged(this.start.bind(this), true);
          }
        },

        /**
         * Activate the area where the idle will be caught
         */
        activate: function() {

          this._application._ui.getWidget().getElement()
            .on("mousemove." + this._suffix, this.reset.bind(this))
            .on("mousedown." + this._suffix, this.reset.bind(this))
            .on("keydown." + this._suffix, this.reset.bind(this));
          this.start();
        },

        /**
         * Desactivate the area where the idle wont be caught
         */
        desactivate: function() {
          this._application._ui.getWidget().getElement()
            .off("mousemove." + this._suffix)
            .off("mousedown." + this._suffix)
            .off("keydown." + this._suffix);
          this.stop();
        },

        destroy: function() {
          this.stop();
          $super.destroy.call(this);
        }
      };
    });
    cls.NodeFactory.register("IdleAction", cls.IdleActionNode);
  });
;
"use strict";

modulum('ImageFontNode', ['NodeBase', 'NodeFactory'],
  function(context, cls) {
    /**
     * @class ImageFontNode
     * @memberOf classes
     * @extends classes.NodeBase
     */
    cls.ImageFontNode = context.oo.Class(cls.NodeBase, function($super) {
      return /** @lends classes.ImageFontNode.prototype */ {
        _ttfName: null,
        _stylesheetId: null,
        constructor: function(parent, tag, id, attributes, app) {
          $super.constructor.call(this, parent, tag, id, attributes, app);
          var ttfFile = context.__wrapper.wrapResourcePath(this.attribute("href"));
          this._ttfName = "image2font_" + this.attribute("name").replace(".ttf", "");
          this._stylesheetId = this._ttfName + this.getApplication().info().session + this.getApplication().applicationHash;
          var styleRules = {
            "@font-face": {
              "font-family": this._ttfName,
              "src": "url('" + ttfFile + "')"
            }
          };
          context.styler.appendStyleSheet(styleRules, this._stylesheetId, true);
        },
        destroy: function() {
          context.styler.removeStyleSheet(this._stylesheetId);
          $super.destroy.call(this);
        }
      };
    });
    cls.NodeFactory.register("ImageFont", cls.ImageFontNode);
  });
;
"use strict";

modulum('ItemNode', ['StandardNode', 'NodeFactory'],
  function(context, cls) {
    /**
     * @class ItemNode
     * @memberOf classes
     * @extends classes.StandardNode
     */
    cls.ItemNode = context.oo.Class(cls.StandardNode, function($super) {
      return /** @lends classes.ItemNode.prototype */ {
        constructor: function(parent, tag, id, attributes, app) {
          this._canEmitNodeMutation = true;
          $super.constructor.call(this, parent, tag, id, attributes, app);
        }
      };
    });
    cls.NodeFactory.register("Item", cls.ItemNode);
  });
;
"use strict";

modulum('MatrixNode', ['StandardNode', 'NodeFactory'],
  function(context, cls) {
    /**
     * @class MatrixNode
     * @memberOf classes
     * @extends classes.StandardNode
     */
    cls.MatrixNode = context.oo.Class(cls.StandardNode, function() {
      return /** @lends classes.MatrixNode.prototype */ {
        __name: "MatrixNode",
        /**
         * @inheritDoc
         */
        _createChildrenControllers: function(_queue) {
          for (var i = 1; i < this._children.length; i++) {
            this._children[i].createController(_queue);
          }
        },

        /**
         * Will get current value node in matrix
         * @param {boolean} inputModeOnly - return value node only if is node is in INPUT mode
         * @returns {*}
         */
        getCurrentValueNode: function(inputModeOnly) {
          var dialogType = this.attribute('dialogType');
          var isInputMode = (dialogType === "Input" || dialogType === "InputArray" || dialogType === "Construct");
          if (!inputModeOnly || isInputMode) {
            var currentRow = this.attribute("currentRow") || 0;
            var offset = this.attribute("offset");
            var valueIndex = currentRow - offset;
            if (this._children[1]._children[valueIndex]) {
              return this._children[1]._children[valueIndex];
            }
          }
          return null;
        }
      };
    });
    cls.NodeFactory.register("Matrix", cls.MatrixNode);
  });
;
"use strict";

modulum('NoControllerNode', ['NodeBase', 'NodeFactory'],
  function(context, cls) {
    /**
     * @class NoControllerNode
     * @memberOf classes
     * @extends classes.NodeBase
     */
    cls.NoControllerNode = context.oo.Class(cls.NodeBase, function() {
      return /** @lends classes.NoControllerNode.prototype */ {};
    });
    cls.NodeFactory.register("ActionDefaultList", cls.NoControllerNode);
    cls.NodeFactory.register("StyleAttribute", cls.NoControllerNode);
    cls.NodeFactory.register("ImageFonts", cls.NoControllerNode);
    cls.NodeFactory.register("DialogInfo", cls.NoControllerNode);
  });
;
"use strict";
modulum('NodeBase', ['EventListener'],
  function(context, cls) {
    /**
     * Memory implementation of an AUI Node.
     *
     * Reflects the state of the AUI node in the DVM.
     *
     * @class NodeBase
     * @memberOf classes
     * @extends classes.EventListener
     * @publicdoc Base
     */
    cls.NodeBase = context.oo.Class(cls.EventListener, function($super) {
      return /** @lends classes.NodeBase.prototype */ {
        $static: /** @lends classes.NodeBase */ {
          stylesSeparatorRegExp: /\s+/,
          /**
           * @type {Object.<string, string>}
           */
          __attributeChangedEventNames: {},
          __attributeChangedPrefixEventName: "g_attributeChanged",
          /**
           *
           * @param {string} attrName
           * @return {*}
           */
          attributeChangedEventName: function(attrName) {
            if (!this.__attributeChangedEventNames[attrName]) {
              this.__attributeChangedEventNames[attrName] = this.__attributeChangedPrefixEventName + attrName;
            }
            return this.__attributeChangedEventNames[attrName];
          },
          notInheritedAttributes: ["backgroundColor", "border"]
        },
        __name: "NodeBase",
        /**
         * parent node in aui tree
         * @type {classes.NodeBase}
         */
        _parent: null,
        _parentInfo: null,
        /**
         * aui id
         * @type {?number}
         */
        _id: null,
        /**
         * children nodes
         * @type {classes.NodeBase[]}
         */
        _children: null,
        /**
         * linked controller
         * @type {classes.ControllerBase}
         */
        _controller: null,
        /**
         * owning application
         * @type {classes.VMApplication}
         */
        _application: null,
        /**
         * node tag name
         * @type {?string}
         */
        _tag: null,
        /**
         * node's attribute set
         * @type {Object.<string, *>}
         * */
        _attributes: null,
        /**
         * flag set of vm provided attributes
         * @type {Object.<string, boolean>}
         * */
        _attributesSetByVM: null,
        /**
         * list of styles applied by the vm
         * @type {string[]}
         */
        _vmStyles: null,
        /**
         * node's attribute values set that where set previously
         * @type {Object.<string, *>}
         */
        _previousAttributes: null,
        /**
         * list
         * @type {Object[]}
         */
        _stylesByPseudoSelectors: null,
        /**
         * list
         * @type {string[]}
         */
        _activePseudoSelectors: null,
        /**
         * list
         * @type {Object}
         */
        _pseudoSelectorsUsedInSubTree: null,
        /**
         * flag
         * @type {boolean}
         */
        _canEmitNodeMutation: false,
        /**
         * list
         * @type {Object.<string, *>}
         */
        _initialStyleAttributes: null,
        /**
         * @constructs
         * @param {classes.NodeBase} parent parent node
         * @param {string|nodeInfo} tag tag name (WINDOW, GROUP, MENU, etc...) or an object containing type, id, attributes
         * @param {?number|classes.VMApplication} id id
         * @param {Object=} attributes attributes list
         * @param {classes.VMApplication} app application
         */
        constructor: function(parent, tag, id, attributes, app) {
          $super.constructor.call(this);

          this._pseudoSelectorsUsedInSubTree = {};

          if (!!tag && !!tag.attributes) {
            app = id;
            attributes = tag.attributes;
            id = tag.id;
            tag = tag.type;
          }
          this._parent = parent;
          this._id = id;
          this._application = app;
          this._children = [];
          this._tag = tag;

          this._parentInfo = {
            inMatrix: Boolean(this.getAncestor("Matrix")),
            inScrollGrid: Boolean(this.getAncestor("ScrollGrid")),
            inTable: Boolean(this.getAncestor("TableColumn")),
            inStack: Boolean(this.getAncestor("Stack"))
          };

          this._attributes = {};
          this._vmStyles = [];
          this._initialStyleAttributes = {};
          this._attributesSetByVM = {};
          this._previousAttributes = {};
          // Set the default attributes
          var nodeAttributes = cls.NodeHelper.getDefaultAttributes(tag);
          for (var i = 0; i < nodeAttributes.length; i++) {
            cls.NodeHelper.setAttributeDefaultValue(this, nodeAttributes[i]);
          }
          // Set the attributes with VM info
          var attributesToSet = Object.keys(attributes);
          for (var a = 0; a < attributesToSet.length; a++) {
            var attributeName = attributesToSet[a];
            this._attributesSetByVM[attributeName] = true;
            this._attributes[attributeName] = attributes[attributeName];
            if (attributeName === "style") {
              var styles = attributes[attributeName] && attributes[attributeName].trim();
              if (styles) {
                this._vmStyles = styles.split(cls.NodeBase.stylesSeparatorRegExp);
              }
            }
          }

          // Attaching the node to its parent children list
          if (parent !== null) {
            var valueIndex = parent.addChildNode(this);
            if (this._parentInfo.inTable) {
              this._parentInfo.inFirstTableRow = (valueIndex === 0);
            }
          }

          // Registering the node in the global hash
          if (this._application) {
            this._application.model.addNode(id, this);
          }
          if (this._parent && (context.ThemeService.getValue("aui-mutation-watch") || this._canEmitNodeMutation)) {
            this._parent._emitNodeCreated(this);
          }
        },
        /**
         * Destroy a node (and remove all its references)
         */
        destroy: function() {
          // destroy children first
          while (this._children.length > 0) {
            this._children[this._children.length - 1].destroy();
          }
          if (this._parent) {
            this._parent._emitNodeDestroyed(this);
          }
          // Remove node from the parent children list
          if (this._id !== 0) {
            this._parent.removeChildNode(this);
          }
          this.destroyController();
          if (this._application) {
            this._application.model.removeNode(this._id);
            this._application = null;
          }
          this._children = null;
          this._parent = null;

          this._stylesByPseudoSelectors = null;
          this._activePseudoSelectors = null;
          this._pseudoSelectorsUsedInSubTree = null;
          this._initialStyleAttributes = null;
          this._vmStyles = null;

          this._attributesSetByVM = null;
          this._attributes = null;
          this._previousAttributes = null;

          $super.destroy.call(this);
        },

        _emitNodeCreated: function(node) {
          this.emit(context.constants.baseEvents.nodeCreated, node);
          if (this._parent) {
            this._parent._emitNodeCreated(node);
          }
        },
        _emitNodeDestroyed: function(node) {
          this.emit(context.constants.baseEvents.nodeDestroyed, node);
          if (this._parent) {
            this._parent._emitNodeDestroyed(node);
          }
        },

        /**
         * tag name of this node
         * @returns {string} tag name of this node
         */
        getTag: function() {
          return this._tag;
        },

        /**
         * add child node
         * @param {classes.NodeBase} node node to add
         * @return {number} index of newly added element
         */
        addChildNode: function(node) {
          var index = this._children.length;
          this._children.push(node);
          return index;
        },
        /**
         * remove child node
         * @param {classes.NodeBase} node node to remove
         */
        removeChildNode: function(node) {
          this._children.splice(this._children.indexOf(node), 1);
        },
        /**
         * get parent node
         * @returns {classes.NodeBase} the parent node
         * @publicdoc
         */
        getParentNode: function() {
          return this._parent;
        },
        /**
         * get children (direct only)
         * @param {string=} tag if provided, returns only child nodes of the given type.
         * @returns {classes.NodeBase[]} list of matching children
         * @publicdoc
         */
        getChildren: function(tag) {
          if (tag) {
            var result = [];
            var length = this._children.length;
            for (var i = 0; i < length; ++i) {
              var child = this._children[i];
              if (child._tag === tag) {
                result.push(child);
              }
            }
            return result;
          } else {
            return this._children.slice();
          }
        },
        /**
         * Get the raw list of children. Be aware this list could change while
         * it is passed through. If you are not sure, prefer getChildren that clones the list
         * @returns {classes.NodeBase[]}
         */
        getRawChildren: function() {
          return this._children;
        },
        /**
         * get first direct child
         * @param {string=} tag if provided, returns only a child node of the given type.
         * @returns {classes.NodeBase} the node found
         */
        getFirstChild: function(tag) {
          if (tag) {
            var length = this._children.length;
            for (var i = 0; i < length; ++i) {
              var child = this._children[i];
              if (child._tag === tag) {
                return child;
              }
            }
          } else if (!!this._children.length) {
            return this._children[0];
          }
          return null;
        },
        /**
         * get the last child
         * @param {string=} tag if provided, returns only a child node of the given type.
         * @returns {classes.NodeBase} the last child
         */
        getLastChild: function(tag) {
          if (tag) {
            var length = this._children.length;
            for (var i = length - 1; i > -1; i--) {
              var child = this._children[i];
              if (child._tag === tag) {
                return child;
              }
            }
          } else if (!this._children.isEmpty()) {
            return this._children[this._children.length - 1];
          }
          return null;
        },
        /**
         * Usage:
         *  - getChildrenWithAttribute("TagName", "attributeName", "attributeValue");
         *  - getChildrenWithAttribute("attributeName", "attributeValue");
         *  - getChildrenWithAttribute("attributeName");
         * @param {?string} tag node tag name
         * @param {string} attributeName searched attribute name
         * @param {?string} attributeValue searched attribute value
         * @returns {classes.NodeBase[]} List of matching nodes
         */
        getChildrenWithAttribute: function(tag, attributeName, attributeValue) {
          if (!attributeName) {
            attributeName = tag;
            tag = null;
          }
          var result = [];
          var length = this._children.length;
          for (var i = 0; i < length; ++i) {
            var child = this._children[i];
            if (!tag || child._tag === tag) {
              if (child.isAttributePresent(attributeName)) {
                var value = child.attribute(attributeName);
                if (typeof attributeValue === "undefined" || attributeValue === value) {
                  result.push(child);
                }
              }
            }
          }
          return result;
        },
        /**
         * Usage:
         *  - getFirstChildWithAttribute("TagName", "attributeName", "attributeValue");
         *  - getFirstChildWithAttribute("attributeName", "attributeValue");
         *  - getFirstChildWithAttribute("attributeName");
         * @param {?string=} tag node tag name
         * @param {string} attributeName searched attribute name
         * @param {?string=} attributeValue searched attribute value
         * @returns {classes.NodeBase} first matching node or null
         */
        getFirstChildWithAttribute: function(tag, attributeName, attributeValue) {
          if (!attributeName) {
            attributeName = tag;
            tag = null;
          }
          var length = this._children.length;
          for (var i = 0; i < length; ++i) {
            var child = this._children[i];
            if (!tag || child._tag === tag) {
              if (child.isAttributePresent(attributeName)) {
                var value = child.attribute(attributeName);
                if (typeof attributeValue === "undefined" || attributeValue === value) {
                  return child;
                }
              }
            }
          }
          return null;
        },
        /**
         * get first child with id
         * @param {number} id - node id
         * @returns {classes.NodeBase} first matching node or null
         */
        getFirstChildWithId: function(id) {
          if (this._children) {
            var length = this._children.length;
            for (var i = 0; i < length; ++i) {
              var child = this._children[i];
              if (child._id === id) {
                return child;
              }
            }
          }
          return null;
        },
        /**
         * Will return the first ancestor that has this tag, null otherwise.
         * @param {string} tag name of the ancestor node
         * @returns {classes.NodeBase} a node if found, null otherwise
         */
        getAncestor: function(tag) {
          var result = this._parent;
          while (result && result._tag !== tag) {
            result = result._parent;
          }
          return result;
        },
        /**
         * Will return the first ancestor that has this tag and potential style, null otherwise.
         * @param {string} tag name of the ancestor node
         * @param {string} style name of the ancestor node style to match
         * @returns {classes.NodeBase} a node if found, null otherwise
         */
        getAncestorWithStyle: function(tag, style) {
          var found = false,
            result = this;
          while (!found) {
            result = result._parent;
            found = !result ||
              result._tag === tag &&
              (!style || (result._vmStyles.indexOf(style) >= 0));
          }
          return result;
        },
        /**
         * get all descendants of tag type
         * @param {string} tag tag name of the descendants
         * @returns {classes.NodeBase[]} list of descendants matching the given tag
         * @public
         */
        getDescendants: function(tag) {
          return this._getDescendants(tag);
        },

        /**
         * get all descendants of tag type (recursion)
         * @param {string} tag tag name of the descendants
         * @param {classes.NodeBase[]} [result] optional array to populate. (For internal use only)
         * @returns {classes.NodeBase[]} list of descendants matching the given tag
         * @private
         */
        _getDescendants: function(tag, result) {
          if (result === undefined) {
            result = [];
          } else if (tag === this._tag || tag === null) {
            // Matching tags should only be added for children
            result.push(this);
          }
          var length = this._children.length;
          for (var i = 0; i < length; ++i) {
            var child = this._children[i];
            child._getDescendants(tag, result);
          }
          return result;
        },

        /**
         * get first index of tag
         * @param {string=} tag tag name of the siblings to consider
         * @returns {number} The index of this node in its parent's children array
         */
        getIndex: function(tag) {
          var siblings = this._parent._children;
          var length = siblings.length;
          var index = 0;
          for (var i = 0; i < length; ++i) {
            var sibling = siblings[i];
            if (sibling === this) {
              break;
            }
            if (!tag || sibling._tag === tag) {
              ++index;
            }
          }
          return index;
        },

        /**
         * Will get the previous Sibling node
         * @param {?string|string[]} tag optional tag name to limit result by name
         * @returns {?classes.NodeBase} next Sibling if exists
         */
        getPreviousSibling: function(tag) {
          var children = this.getParentNode().getChildren();
          var initialIndex = children.indexOf(this);
          var index = -1;
          if (tag) {
            if (!Array.isArray(tag)) {
              tag = [tag];
            }
            for (var i = initialIndex - 1; i >= 0; i--) {
              var child = children[i];
              if (tag.indexOf(child._tag) !== -1) {
                index = i;
                break;
              }
            }
          } else {
            index = initialIndex - 1;
          }
          if (index < 0) {
            return null;
          }
          return children[index];
        },

        /**
         * Will get the next Sibling node
         * @param {?string|string[]} tag optional tag name to limit result by name
         * @returns {?classes.NodeBase} next Sibling if exists
         */
        getNextSibling: function(tag) {
          var children = this.getParentNode().getChildren(),
            len = children.length;
          var initialIndex = children.indexOf(this);
          var index = len;
          if (tag) {
            if (!Array.isArray(tag)) {
              tag = [tag];
            }
            for (var i = initialIndex + 1; i < len; i++) {
              var child = children[i];
              if (tag.indexOf(child._tag) !== -1) {
                index = i;
                break;
              }
            }
          } else {
            index = initialIndex + 1;
          }
          if (index >= len) {
            return null;
          } else {
            return children[index];
          }
        },
        /**
         * Get descendant with attribute
         * @param {?string} tag tag name
         * @param {string} attributeName attribute name
         * @param {*} [attributeValue] the value to find
         * @returns {classes.NodeBase} matching nodes
         */
        findNodeWithAttribute: function(tag, attributeName, attributeValue) {
          var tagged = this.getDescendants(tag);
          for (var i = 0; i < tagged.length; i++) {
            var child = tagged[i];
            if (child.isAttributePresent(attributeName)) {
              var value = child.attribute(attributeName);
              if (typeof attributeValue === "undefined" || attributeValue === value) {
                return child;
              }
            }
          }
          return null;
        },

        /**
         * Execute callback for this node and each descendant
         * @param {function} callback function to call
         */
        forThisAndEachDescendant: function(callback) {
          callback(this);
          for (var i = 0; i < this._children.length; ++i) {
            this._children[i].forThisAndEachDescendant(callback);
          }
        },

        /**
         *get owning application
         * @returns {classes.VMApplication} owning application
         * @publicdoc
         */
        getApplication: function() {
          return this._application;
        },
        /**
         * update attribute values
         * @param {Object.<string, *>} attributes new values
         */
        updateAttributes: function(attributes) {
          var attributesToSet = Object.keys(attributes);
          for (var a = 0; a < attributesToSet.length; a++) {
            var attributeName = attributesToSet[a];
            this._attributesSetByVM[attributeName] = true;
            this._previousAttributes[attributeName] = this._attributes[attributeName];
            this._attributes[attributeName] = attributes[attributeName];
            if (attributeName === "style") {
              var styles = attributes[attributeName] && attributes[attributeName].trim();
              this._vmStyles = styles ? styles.split(cls.NodeBase.stylesSeparatorRegExp) : [];
            }
          }
        },
        /**
         * get attribute value
         * @param {string} attributeName attribute name
         * @returns {*} attribute value
         * @publicdoc
         */
        attribute: function(attributeName) {
          return this._attributes[attributeName];
        },
        /**
         * get attribute previous value
         * @param {string} attributeName attribute name
         * @returns {*} attribute previous value
         */
        previousAttribute: function(attributeName) {
          return this._previousAttributes[attributeName];
        },

        /**
         * set by vm info
         * @param {string} attributeName name of the attribute
         * @returns {boolean} true if the attribute has been set by the VM, false otherwise
         */
        isAttributeSetByVM: function(attributeName) {
          return this._attributesSetByVM.hasOwnProperty(attributeName);
        },
        /**
         * attribute existence
         * @param {string} attributeName name of the attribute
         * @returns {boolean} true if the attribute exists
         */
        isAttributePresent: function(attributeName) {
          return this._attributes.hasOwnProperty(attributeName);
        },
        /**
         * attach hook when attribute changes
         * @param {string} attributeName attribute name
         * @param {function} handler the hook
         * @returns {HandleRegistration} the handler to release the hook
         * @publicdoc
         */
        onAttributeChanged: function(attributeName, handler) {
          return this.when(cls.NodeBase.attributeChangedEventName(attributeName), this._onAttributeChanged.bind(null, handler));
        },
        /**
         * hook wrapper
         * @param {function} handler the hook
         * @param {classes.Event} event the event
         * @param {classes.NodeBase} node the src node
         * @param {*} data data bag
         * @private
         */
        _onAttributeChanged: function(handler, event, node, data) {
          handler(event, node, data);
        },

        /**
         * find whether or not this node is in the given list (or one of its parents)
         * @param list the list to check
         * @param lookIfAParentIs look for parents as well
         * @returns {boolean}
         */
        containedInList: function(list, lookIfAParentIs) {
          if (list && list.length) {
            if (list.indexOf(this) >= 0) {
              return true;
            }
            if (lookIfAParentIs) {
              var parent = this.getParentNode();
              while (parent) {
                if (list.indexOf(parent) >= 0) {
                  return true;
                }
                parent = parent.getParentNode();
              }
            }
          }
          return false;
        },

        /**
         * update applicable styles
         * @param {boolean} [recursive] do it recursively
         * @param {boolean} [stylesChanged] if done recursively, did the 4st styles changed?
         * @param {Array} [styleAttributesChanged] if done recursively, list of nodes which changed style attribute
         * @param {classes.TreeModificationTracker} [treeModificationTrack] if done recursively, need information about node tree changes
         */
        updateApplicableStyles: function(recursive, stylesChanged, styleAttributesChanged, treeModificationTrack) {
          var i, ui = this.getApplication().uiNode();
          if (!recursive || stylesChanged ||
            this.containedInList(styleAttributesChanged, true) ||
            treeModificationTrack.isNodeCreated(this._id) ||
            treeModificationTrack.attributeChanged(this._id, "style")) {
            var matchingAttributesByPseudoSelectors = {};
            var styleLists = ui.getChildren('StyleList');
            for (i = 0; i < styleLists.length; i++) {
              var styleList = styleLists[i];
              styleList.populateMatchingStyles(matchingAttributesByPseudoSelectors, this);
            }
            this._stylesByPseudoSelectors = [];
            var pseudoSelectorKeys = Object.keys(matchingAttributesByPseudoSelectors);
            for (i = 0; i < pseudoSelectorKeys.length; i++) {
              var pseudoSelectorKey = pseudoSelectorKeys[i];
              var styleAttributes = matchingAttributesByPseudoSelectors[pseudoSelectorKey];
              var styles = {};
              var styleAttributeKeys = Object.keys(styleAttributes);
              for (var k = 0; k < styleAttributeKeys.length; k++) {
                var styleAttributeName = styleAttributeKeys[k];
                styles[styleAttributeName] = styleAttributes[styleAttributeName];
              }
              this._stylesByPseudoSelectors.push({
                pseudoSelector: styleAttributes[styleAttributeKeys[0]].getParentNode().getPseudoSelectors(),
                styles: styles
              });
            }
            // Sort by pseudo-selector priority
            this._stylesByPseudoSelectors.sort(this._pseudoSelectorPrioritySorter);
          }
          if (!!recursive) {
            for (i = 0; i < this._children.length; ++i) {
              this._children[i].updateApplicableStyles(true, stylesChanged, styleAttributesChanged, treeModificationTrack);
            }
          }
        },
        resetActivePseudoSelectors: function() {
          this._activePseudoSelectors = null;
        },
        resetPseudoSelectorsUsedInSubTree: function() {
          this._pseudoSelectorsUsedInSubTree = {};
        },
        updatePseudoSelectorsUsedInSubTree: function(recursive) {
          var pseudoSelectors = {},
            i;
          if (this._stylesByPseudoSelectors) {
            for (i = 0; i < this._stylesByPseudoSelectors.length; ++i) {
              var entry = this._stylesByPseudoSelectors[i];
              for (var j = 0; j < entry.pseudoSelector.length; ++j) {
                pseudoSelectors[entry.pseudoSelector[j]] = true;
              }
            }
          }
          pseudoSelectors = Object.keys(pseudoSelectors);
          for (i = 0; i < pseudoSelectors.length; ++i) {
            var pseudoSelector = pseudoSelectors[i];
            var p = this;
            while (p !== null) {
              if (!p._pseudoSelectorsUsedInSubTree[pseudoSelector]) {
                p._pseudoSelectorsUsedInSubTree[pseudoSelector] = true;
                p = p._parent;
              } else {
                break;
              }
            }
          }

          if (!!recursive) {
            for (i = 0; i < this._children.length; ++i) {
              this._children[i].updatePseudoSelectorsUsedInSubTree(true);
            }
          }
        },

        setInitialStyleAttributes: function() {
          var initialStyles = this._stylesByPseudoSelectors.filter(function(item) {
            return !item.pseudoSelector.length;
          })[0];
          if (initialStyles) {
            var keys = Object.keys(initialStyles.styles),
              len = keys.length;
            for (var i = 0; i < len; i++) {
              this._initialStyleAttributes[keys[i]] = initialStyles.styles[keys[i]]._attributes.value;
            }
          }
        },

        _pseudoSelectorPrioritySorter: function(pss1, pss2) {
          var firstStyleAttr1 = pss1.styles[Object.keys(pss1.styles)[0]];
          var firstStyleAttr2 = pss2.styles[Object.keys(pss2.styles)[0]];
          var pss1Weight = firstStyleAttr1.getParentNode().getWeight();
          var pss2Weight = firstStyleAttr2.getParentNode().getWeight();
          if (pss1Weight === pss2Weight) {
            pss1Weight = firstStyleAttr1.getParentNode().getPseudoSelectorWeight();
            pss2Weight = firstStyleAttr2.getParentNode().getPseudoSelectorWeight();
          }
          return pss2Weight - pss1Weight;
        },
        /**
         * return the value of the specified style attribute for the current node
         * @param {string} styleAttr the style attribute
         * @param {?string[]} [forcedPseudoSelectors] activate pseudo selectors
         * @returns {string} the style
         */
        getStyleAttribute: function(styleAttr, forcedPseudoSelectors) {
          return this._getStyleAttributeImpl(styleAttr, forcedPseudoSelectors);
        },

        /**
         * return the value of the specified style attribute for the current node
         * This is the implementation method which computes the style.
         * The public getStyleAttribute method invokes this method directly or forwards it
         * to the appropriate node depending on the context (FormFieldNode, ValueNode)
         * @param {string} styleAttr the style attribute
         * @param {?string[]} forcedPseudoSelectors activate pseudo selectors
         * @returns {?string} the style
         */
        _getStyleAttributeImpl: function(styleAttr, forcedPseudoSelectors) {
          if (!this._application.usedStyleAttributes[styleAttr]) {
            return null;
          }
          var pseudoSelectors = forcedPseudoSelectors;
          if (!pseudoSelectors) {
            if (!this._activePseudoSelectors) {
              this._activePseudoSelectors = this._computePseudoSelectors();
            }
            pseudoSelectors = this._activePseudoSelectors;
          }
          var matchingStyleAttribute = null;
          var pseudoSelectorCheck = function(ps) {
            return pseudoSelectors.indexOf(ps) !== -1;
          };
          if (this._stylesByPseudoSelectors) {
            for (var i = 0; i < this._stylesByPseudoSelectors.length; ++i) {
              var pseudoSelectorStyle = this._stylesByPseudoSelectors[i];
              // dict lookup first, as it is faster
              var styleAttribute = pseudoSelectorStyle.styles[styleAttr];
              if (styleAttribute !== undefined) {
                var matches = pseudoSelectorStyle.pseudoSelector.every(pseudoSelectorCheck);
                if (matches) {
                  matchingStyleAttribute = styleAttribute;
                  break;
                }
              }
            }
          }
          if (matchingStyleAttribute) {
            return matchingStyleAttribute.attribute('value');
            // do not look in parent for formfield or action buttons having a not inherited attribute
          } else if ((
              this.getTag() !== "FormField" &&
              this.getTag() !== "TopMenu" &&
              this.getTag() !== "ToolBar" &&
              this.getTag() !== "TopMenuGroup" &&
              this.getTag() !== "TopMenuCommand" &&
              this.getTag() !== "ToolBarItem" &&
              this.getTag() !== "Button" &&
              this.getTag() !== "MenuAction" &&
              this.getTag() !== "Action") || !cls.NodeBase.notInheritedAttributes.contains(
              styleAttr)) {
            var parent = this.getParentNode();
            if (parent) {
              return parent._getStyleAttributeImpl(styleAttr, pseudoSelectors);
            }
          }
          return null;
        },
        /**
         * compute pseudo selectors
         * @returns {Array} computed pseudo selectors
         * @protected
         */
        _computePseudoSelectors: function() {
          var focusedNodeIdRef = this.getApplication().uiNode().attribute('focus');
          var pseudoSelectors = this._populatePseudoSelectors({
            __dialogTypeDefined: false,
            __activeDefined: false
          }, focusedNodeIdRef);
          var availableSelectors = [];
          var keys = Object.keys(pseudoSelectors);
          for (var i = 0; i < keys.length; i++) {
            var ps = keys[i];
            if (pseudoSelectors[ps]) {
              availableSelectors.push(ps);
            }
          }
          return availableSelectors;
        },

        /**
         * populate pseudo selectors
         * @param {?Object.<string, boolean>=} pseudoSelectors a dictionnary which will be populated. Keys are the active pseudo-selectors
         * @param {number} focusedNodeIdRef the idref of the focused node. Passed as parameter to avoid tree lookups.
         * @returns {Object} returns the pseudoSelectors parameter
         * @private
         */
        _populatePseudoSelectors: function(pseudoSelectors, focusedNodeIdRef) {
          if (focusedNodeIdRef === 0) {
            return pseudoSelectors; // no need to compute for userinterface node
          }
          var dialogType = this.attribute('dialogType');
          if (focusedNodeIdRef === this._id &&
            (dialogType && (dialogType === 'Display' || dialogType === 'DisplayArray') || this._tag !== 'Table' && this._tag !==
              'Matrix') && !Object.isBoolean(pseudoSelectors.focus)) {
            // Table and Matrix focus is ignored as the real focused item is their current element
            pseudoSelectors.focus = true;
          }
          var active = this.attribute('active');
          // active will be undefined if the current node doesn't have this attribute
          if (active !== undefined) {
            if (!pseudoSelectors.__dialogTypeDefined) {
              if (!!active || (!!(this.attribute('noEntry')) && this._tag === 'TableColumn')) {
                if (!!dialogType) {
                  pseudoSelectors.__dialogTypeDefined = true;
                  if (dialogType === 'Display' || dialogType === 'DisplayArray') {
                    pseudoSelectors.display = true;
                    pseudoSelectors.input = false;
                    pseudoSelectors.query = false;
                  } else if (dialogType === 'Input' || dialogType === 'InputArray') {
                    pseudoSelectors.display = false;
                    pseudoSelectors.input = true;
                    pseudoSelectors.query = false;
                  } else if (dialogType === 'Construct') {
                    pseudoSelectors.display = false;
                    pseudoSelectors.input = false;
                    pseudoSelectors.query = true;
                  }
                }
              } else {
                pseudoSelectors.__dialogTypeDefined = true;
                pseudoSelectors.display = false;
                pseudoSelectors.input = false;
                pseudoSelectors.query = false;
              }
            }
            if (!pseudoSelectors.__activeDefined) {
              pseudoSelectors.__activeDefined = true;
              if (!!active) {
                pseudoSelectors.active = true;
              } else {
                pseudoSelectors.inactive = true;
              }
            }
          }

          if (!!this._parent) {
            return this._parent._populatePseudoSelectors(pseudoSelectors, focusedNodeIdRef);
          } else {
            return pseudoSelectors;
          }
        },

        /**
         * Override this method when no controller should automatically be created for this node, neither for the
         * node itself nor for its children
         * This method is called in createController()
         * @return {boolean} true if this node and its children controllers' are allowed to be created automatically
         */
        autoCreateController: function() {
          if (this._parent) {
            return this._parent.autoCreateChildrenControllers();
          } else {
            return true;
          }
        },

        /**
         * Override this method when no controller should automatically be created for the children of this node.
         * The node itself will have a controller created.
         * @return {boolean} true if this node's children controllers' are allowed to be created automatically
         */
        autoCreateChildrenControllers: function() {
          if (this._parent) {
            return this._parent.autoCreateChildrenControllers();
          } else {
            return true;
          }
        },

        /**
         * create controllers recursively
         * @param {number[]} [_queue] aui id queue
         * @param {boolean} [force] force controller creation
         */
        createController: function(_queue, force) {
          if (force || this.autoCreateController()) {
            var queue = _queue || [];
            if (!this._controller) {
              queue.push(this._id);
              this._createChildrenControllers(queue);
            }
            if (!_queue) {
              for (var i = 0; i < queue.length; i++) {
                var node = this._application.model.getNode(queue[i]);
                node._controller = node._createController();
                node.emit(context.constants.baseEvents.controllerCreated);
              }
            }
          }
        },
        /**
         * attach hook when controller created
         * @param {Hook} hook event hook
         * @return {HandleRegistration} a handle to unregister the hook
         */
        whenControllerCreated: function(hook) {
          return this.when(context.constants.baseEvents.controllerCreated, hook);
        },
        /**
         * Applies all behaviors
         * @param {classes.TreeModificationTracker} treeModificationTrack collection of affected nodes
         * @param {boolean} recursive apply behaviors to child nodes as well
         * @param {boolean} force force apply behaviors
         */
        applyBehaviors: function(treeModificationTrack, recursive, force) {
          var stillDirty = false;
          var park = [this];
          if (recursive) {
            while (park.length) {
              var i = park.shift();
              park.unshift.apply(park, i._children);
              if (i._controller) {
                stillDirty = i._controller.applyBehaviors(treeModificationTrack, force) || stillDirty;
              }
            }
          } else {
            if (this._controller) {
              stillDirty = this._controller.applyBehaviors(treeModificationTrack, force) || stillDirty;
            }
          }
          return stillDirty;
        },
        /**
         * creates a controller associated to the node
         * @returns {classes.ControllerBase} the created controller
         * @public
         */
        _createController: function() {
          return null;
        },
        /**
         * create the controllers in child nodes
         * @param {Array<classes.ControllerBase>} _queue traversing array
         * @protected
         */
        _createChildrenControllers: function(_queue) {
          for (var i = 0; i < this._children.length; i++) {
            this._children[i].createController(_queue);
          }
        },
        /**
         * Removes the associated controller
         */
        destroyController: function() {
          if (this._controller) {
            this._controller.destroy();
            this._controller = null;
          }
        },
        /**
         * attaches the node's UI in DOM
         * @returns {HTMLElement} the attached element, if any
         */
        attachUI: function() {
          for (var i = 0; i < this._children.length; i++) {
            this._children[i].attachUI();
          }
          if (!!this.getController() && !!this.getController().getWidget()) {
            this.getController().attachUI();
            return this.getController().getWidget().getElement();
          } else {
            return null;
          }
        },
        /**
         * get the node's controller
         * @returns {classes.ControllerBase} the node's controller
         */
        getController: function() {
          return this._controller;
        },

        /**
         * Gets the node's widget
         * @returns {classes.WidgetBase} the node's widget
         * @publicdoc
         */
        getWidget: function() {
          return !!this._controller ? this._controller.getWidget() : null;
        },

        /**
         * gets the node's aui id
         * @returns {number} the node's aui id
         */
        getId: function() {
          return this._id;
        },
        onNodeCreated: function(hook, tag) {
          return this.when(context.constants.baseEvents.nodeCreated, this._onNodeCreated.bind(null, tag, hook));
        },
        _onNodeCreated: function(tag, hook, event, src, node) {
          if (!tag || tag === node._tag) {
            hook(event, src, node);
          }
        },
        onNodeRemoved: function(hook, tag) {
          return this.when(context.constants.baseEvents.nodeDestroyed, this._onNodeRemoved.bind(this, tag, hook));
        },
        _onNodeRemoved: function(tag, hook, event, src, node) {
          if (!tag || tag === node._tag) {
            hook(event, src, node);
          }
        },
        /**
         * Once all children are created, emit the corresponding event
         */
        childrenCreated: function() {
          this.emit(context.constants.baseEvents.childrenNodeCreated);
        },

        /**
         * Renders this node as a json object
         * @param {boolean} recursive includes children nodes
         * @return {Object} a json object representing this node
         */
        getJson: function(recursive) {
          if (typeof recursive === "undefined") {
            recursive = false;
          }

          var jsonTree = {
            id: this._id,
            name: this._tag,
            attributes: this._attributes,
            children: recursive ? [] : null
          };

          if (recursive) {
            if (this._children.length > 0) {
              for (var i = 0; i < this._children.length; i++) {
                jsonTree.children.push(this._children[i].getJson(true));
              }
            } else {
              jsonTree.children = false;
            }
          }

          return this._id === 0 ? [jsonTree] : jsonTree;
        },

        isInTable: function() {
          return Boolean(this._parentInfo && this._parentInfo.inTable);
        },

        isInMatrix: function() {
          return Boolean(this._parentInfo && this._parentInfo.inMatrix);
        },

        isInScrollGrid: function() {
          return Boolean(this._parentInfo && this._parentInfo.inScrollGrid);
        },

        isInFirstTableRow: function() {
          return Boolean(this._parentInfo && this._parentInfo.inFirstTableRow);
        },

        isInStack: function() {
          return Boolean(this._parentInfo && this._parentInfo.inStack);
        }
      };
    });
  });
;
"use strict";
/**
 * @typedef {Object} nodeInfo
 * @property {string} type
 * @property {number} id
 * @property {Object.<string, *>} attributes
 * @property {nodeInfo[]} children
 */

modulum('NodeFactory', ['Factory', 'StandardNode'],

  function(context, cls) {
    /**
     * @namespace classes.NodeFactory
     */
    cls.NodeFactory = context.oo.StaticClass(function() {
      /**
       *
       * @type {classes.Factory<classes.NodeBase>}
       */
      var factory = new cls.Factory("Node", cls.StandardNode);
      return /** @lends classes.NodeFactory */ {
        /**
         *
         * @param {string} type
         * @param {Function} constructor
         */
        register: function(type, constructor) {
          factory.register(type, constructor);
        },
        /**
         *
         * @param {string} type
         */
        unregister: function(type) {
          factory.unregister(type);
        },
        /**
         *
         * @param {string} type
         * @returns {classes.NodeBase}
         */
        create: function(type, arg1, arg2, arg3, arg4, arg5) {
          return factory.create(type, arg1, arg2, arg3, arg4, arg5);
        },
        /**
         * Create recursively all model nodes for the given nodeInfo
         * @param {classes.NodeBase} parent parent node
         * @param {nodeInfo} nodeInfo node information
         * @param {classes.VMApplication=} app owner application
         * @param {classes.TreeModificationTracker} treeModificationTrack tree modifications log
         * @returns {classes.NodeBase[]} created nodes
         */
        createRecursive: function(parent, nodeInfo, app, treeModificationTrack) {
          return this._createRecursive(parent, nodeInfo, app, treeModificationTrack, true);
        },
        /**
         * Create recursively all model nodes for the given nodeInfo
         * Internal implementation
         * @param {classes.NodeBase} parent parent node
         * @param {nodeInfo} nodeInfo node information
         * @param {classes.VMApplication=} app owner application
         * @param {classes.TreeModificationTracker} treeModificationTrack tree modifications log
         * @param {boolean} isSubTreeRoot true if the node to create is a subtree root
         * @returns {classes.NodeBase[]} created nodes
         * @private
         */
        _createRecursive: function(parent, nodeInfo, app, treeModificationTrack, isSubTreeRoot) {
          if (!app.ended) {
            var current = factory.create.call(factory, nodeInfo.type, parent, nodeInfo, app);
            treeModificationTrack.nodeCreated(current._id, isSubTreeRoot);
            if (nodeInfo.children && Array.isArray(nodeInfo.children)) {
              for (var i = 0; i < nodeInfo.children.length; i++) {
                this._createRecursive(current, nodeInfo.children[i], app, treeModificationTrack);
              }
            }
            current.childrenCreated();
            return current;
          }
          return null;
        }
      };
    });
  });
;
"use strict";

modulum('PropertyArrayNode', ['StandardNode', 'NodeFactory'],
  function(context, cls) {
    /**
     * @class PropertyArrayNode
     * @memberOf classes
     * @extends classes.StandardNode
     */
    cls.PropertyArrayNode = context.oo.Class(cls.StandardNode, function($super) {
      return /** @lends classes.PropertyArrayNode.prototype */ {
        constructor: function(parent, tag, id, attributes, app) {
          this._canEmitNodeMutation = true;
          $super.constructor.call(this, parent, tag, id, attributes, app);
        }
      };
    });
    cls.NodeFactory.register("PropertyArray", cls.PropertyArrayNode);
  });
;
"use strict";

modulum('PropertyDictNode', ['StandardNode', 'NodeFactory'],
  function(context, cls) {
    /**
     * @class PropertyDictNode
     * @memberOf classes
     * @extends classes.StandardNode
     */
    cls.PropertyDictNode = context.oo.Class(cls.StandardNode, function($super) {
      return /** @lends classes.PropertyDictNode.prototype */ {
        constructor: function(parent, tag, id, attributes, app) {
          this._canEmitNodeMutation = true;
          $super.constructor.call(this, parent, tag, id, attributes, app);
        }
      };
    });
    cls.NodeFactory.register("PropertyDict", cls.PropertyDictNode);
  });
;
"use strict";

modulum('PropertyNode', ['StandardNode', 'NodeFactory'],
  function(context, cls) {
    /**
     * @class PropertyNode
     * @memberOf classes
     * @extends classes.StandardNode
     */
    cls.PropertyNode = context.oo.Class(cls.StandardNode, function($super) {
      return /** @lends classes.PropertyNode.prototype */ {
        constructor: function(parent, tag, id, attributes, app) {
          this._canEmitNodeMutation = true;
          $super.constructor.call(this, parent, tag, id, attributes, app);
        }
      };
    });
    cls.NodeFactory.register("Property", cls.PropertyNode);
  });
;
"use strict";

modulum('RowInfoNode', ['StandardNode', 'NodeFactory'],
  function(context, cls) {
    /**
     * @class RowInfoNode
     * @memberOf classes
     * @extends classes.StandardNode
     */
    cls.RowInfoNode = context.oo.Class(cls.StandardNode, function() {
      return /** @lends classes.RowInfoNode.prototype */ {
        /**
         * @inheritDoc
         */
        _createController: function() {
          return cls.ControllerFactory.create(this._tag, {
            anchor: this,
            parent: this._parent,
            table: this._parent._parent,
            ui: this.getApplication().getNode(0)
          });
        }
      };
    });
    cls.NodeFactory.register("RowInfo", cls.RowInfoNode);
  });
;
"use strict";

modulum('ScrollGridNode', ['StandardNode', 'NodeFactory'],
  function(context, cls) {
    /**
     * @class ScrollGridNode
     * @memberOf classes
     * @extends classes.StandardNode
     */
    cls.ScrollGridNode = context.oo.Class(cls.StandardNode, function($super) {
      return /** @lends classes.ScrollGridNode.prototype */ {
        /**
         * @inheritDoc
         */
        autoCreateChildrenControllers: function() {
          // Stretchable and Paged ScrollGrids have their custom
          // line controllers in StretchableScrollGridPageSizeVMBehavior
          return this.attribute("wantFixedPageSize") !== 0;
        }
      };
    });
    cls.NodeFactory.register("ScrollGrid", cls.ScrollGridNode);
  });
;
"use strict";

modulum('StandardNode', ['NodeBase'],
  function(context, cls) {
    /**
     * AUI Node default
     *
     * @class StandardNode
     * @memberOf classes
     * @extends classes.NodeBase
     */
    cls.StandardNode = context.oo.Class(cls.NodeBase, function() {
      return /** @lends classes.StandardNode.prototype */ {
        __name: "StandardNode",
        /**
         *
         * @inheritDoc
         */
        _createController: function() {
          return cls.ControllerFactory.create(this._tag, {
            anchor: this,
            parent: this._parent,
            ui: this.getApplication().getNode(0)
          });
        }
      };
    });
  });
;
"use strict";

modulum('StyleListNode', ['NodeBase', 'NodeFactory'],
  function(context, cls) {
    /**
     * @class StyleListNode
     * @memberOf classes
     * @extends classes.NodeBase
     */
    cls.StyleListNode = context.oo.Class(cls.NodeBase, function($super) {
      return /** @lends classes.StyleListNode.prototype */ {
        constructor: function(parent, tag, id, attributes, app) {
          $super.constructor.call(this, parent, tag, id, attributes, app);
          this.getApplication().styleListsChanged = true;
        },

        destroy: function() {
          this.getApplication().styleListsChanged = true;
          $super.destroy.call(this);
        },

        populateMatchingStyles: function(matchingAttributesByPseudoSelectors, node) {
          var children = this.getRawChildren();
          for (var i = 0; i < children.length; i++) {
            var styleNode = children[i];
            styleNode.populateMatchingStyles(matchingAttributesByPseudoSelectors, node);
          }
        }
      };
    });
    cls.NodeFactory.register("StyleList", cls.StyleListNode);
  });
;
"use strict";

modulum('StyleNode', ['NodeBase', 'NodeFactory'],
  function(context, cls) {
    /**
     * @class StyleNode
     * @memberOf classes
     * @extends classes.NodeBase
     */
    cls.StyleNode = context.oo.Class(cls.NodeBase, function($super) {
      return /** @lends classes.StyleNode.prototype */ {
        $static: {
          _pseudoSelectorsPriority: {
            focus: 1024,
            query: 512,
            display: 256,
            input: 128,
            even: 64,
            odd: 32,
            inactive: 16,
            active: 8,
            message: 4,
            error: 2,
            summaryLine: 1
          }
        },
        _parsedElementType: null,
        _parsedStyleName: null,
        _parsedPseudoSelectors: null,
        /** @type {number} */
        _weight: 0,
        /** @type {number} */
        _pseudoSelectorWeight: 0,

        constructor: function(parent, tag, id, attributes, app) {
          $super.constructor.call(this, parent, tag, id, attributes, app);
          var name = this.attribute("name");
          var dotIndex = name.indexOf('.');
          var colonIndex = name.indexOf(':');
          this._parsedStyleName = "";
          if (dotIndex === -1 && colonIndex === -1) { // ElementType || *
            this._parsedElementType = name;
            this._weight = name === '*' ? 1 : 2;
          } else if (dotIndex !== -1 && colonIndex === -1) { // ElementType.stylename || .stylename
            this._parsedElementType = name.substring(0, dotIndex);
            this._parsedStyleName = name.substring(dotIndex + 1);
            this._weight = !this._parsedElementType.length ? 3 : 6;
          } else if (dotIndex === -1 && colonIndex !== -1) { // ElementType:pseudoselector || :pseudoselector
            this._parsedElementType = name.substring(0, colonIndex);
            this._parsedPseudoSelectors = name.substring(colonIndex).split(':').splice(1).sort();
            this._weight = !this._parsedElementType.length ? 4 : 5;
          } else { // ElementType.stylename:pseudoselector || .stylename:pseudoselector
            this._parsedElementType = name.substring(0, dotIndex);
            this._parsedStyleName = name.substring(dotIndex + 1, colonIndex);
            this._parsedPseudoSelectors = name.substr(colonIndex).split(':').splice(1).sort();
            this._weight = !this._parsedElementType.length ? 7 : 8;
          }
          this._parsedPseudoSelectors = this._parsedPseudoSelectors || [];
          for (var i = 0; i < this._parsedPseudoSelectors.length; i++) {
            var pseudoSelector = this._parsedPseudoSelectors[i];
            this._pseudoSelectorWeight += cls.StyleNode._pseudoSelectorsPriority[pseudoSelector];
          }
        },

        getPseudoSelectors: function() {
          return this._parsedPseudoSelectors;
        },

        getWeight: function() {
          return this._weight;
        },

        getPseudoSelectorWeight: function() {
          return this._pseudoSelectorWeight;
        },

        matches: function(node) {
          var isMatching = true;
          if (this._parsedElementType.length !== 0) {
            isMatching = this._parsedElementType === '*' || this._parsedElementType === node.getTag();
          }
          if (isMatching && this._parsedStyleName.length !== 0) {
            var styleNames = node.attribute('style');
            if (!!styleNames) {
              isMatching = styleNames.split(' ').indexOf(this._parsedStyleName) !== -1;
            } else {
              isMatching = false;
            }
          }
          return isMatching;
        },

        populateMatchingStyles: function(matchingAttributesByPseudoSelectors, node) {
          if (!!this.getRawChildren().length && this.matches(node)) {
            var psKey = '';
            if (!!this._parsedPseudoSelectors.length) {
              psKey = ':' + this._parsedPseudoSelectors.join(':');
            }
            var dict = matchingAttributesByPseudoSelectors[psKey];
            if (!dict) {
              dict = {};
              matchingAttributesByPseudoSelectors[psKey] = dict;
            }
            for (var i = 0; i < this._children.length; ++i) {
              var child = this._children[i];
              var childName = child.attribute('name');
              var styleAttribute = dict[childName];
              if (!styleAttribute || styleAttribute.getParentNode()._weight < this._weight) {
                dict[childName] = child;
              }
            }
          }
        }
      };
    });
    cls.NodeFactory.register("Style", cls.StyleNode);
  });
;
"use strict";

modulum('TableActionsNode', ['StandardNode', 'NodeFactory'],
  function(context, cls) {
    /**
     * @class TableActionsNode
     * @memberOf classes
     * @extends classes.StandardNode
     */
    cls.TableActionsNode = context.oo.Class(cls.StandardNode, function($super) {
      return /** @lends classes.TableActionsNode.prototype */ {

        /**
         * @inheritDoc
         */
        createController: function(_queue, force) {
          // force creation of controller and children controllers
          $super.createController.call(this, _queue, true);
        },

        /**
         * @inheritDoc
         */
        autoCreateChildrenControllers: function() {
          return true;
        }
      };
    });
    cls.NodeFactory.register("TableActions", cls.TableActionsNode);
  });
;
"use strict";

modulum('TableColumnNode', ['NodeBase', 'NodeFactory'],
  function(context, cls) {
    /**
     * @class TableColumnNode
     * @memberOf classes
     * @extends classes.NodeBase
     */
    cls.TableColumnNode = context.oo.Class(cls.NodeBase, function() {
      return /** @lends classes.TableColumnNode.prototype */ {
        /**
         * @inheritDoc
         */
        _createChildrenControllers: function(_queue) {
          for (var i = 1; i < this._children.length; i++) {
            var child = this._children[i];
            if (child._tag === "ValueList") {
              for (var j = 0; j < child._children.length; j++) { // create value controller
                child._children[j].createController(_queue);
              }
            } else {
              child.createController(_queue);
            }
          }
        },
        /**
         * @inheritDoc
         */
        _createController: function() {
          var decoratorNode = this._children[0];

          return cls.ControllerFactory.create(this._tag, {
            anchor: this,
            parent: this._parent,
            ui: this.getApplication().getNode(0),
            decorator: decoratorNode
          });
        }
      };
    });
    cls.NodeFactory.register("TableColumn", cls.TableColumnNode);
  });
;
"use strict";

modulum('TableNode', ['StandardNode', 'NodeFactory'],
  function(context, cls) {
    /**
     * @class TableNode
     * @memberOf classes
     * @extends classes.StandardNode
     */
    cls.TableNode = context.oo.Class(cls.StandardNode, function($super) {
      return /** @lends classes.TableNode.prototype */ {

        /** @type boolean */
        _isTree: false,

        /**
         * @inheritDoc
         */
        setInitialStyleAttributes: function() {
          $super.setInitialStyleAttributes.call(this);
          var defaultWidget = context.ThemeService.getValue("theme-table-default-widget");

          if (defaultWidget && !this._isTree) {
            if (defaultWidget.toLowerCase() === "listview" && typeof(this._initialStyleAttributes.tableType) === "undefined") {
              // if there theme default is listview and there is no tableType 4ST defined
              this._initialStyleAttributes.tableType = "listView";
            }
          }
        },

        /**
         * @inheritDoc
         */
        autoCreateChildrenControllers: function() {
          // Tables as ListViews have their custom line controllers in ListViewPageSizeVMBehavior
          return !this.isListView();
        },

        /**
         * @inheritDoc
         */
        updateAttributes: function(attributes) {
          $super.updateAttributes.call(this, attributes);
          if (attributes.bufferSize !== undefined) {
            var treeInfo = this.getFirstChild('TreeInfo');
            if (treeInfo) {
              treeInfo.applyBehaviors(null, true, true);
            }
          }
        },

        /**
         * Return if table is a tree view.
         * @return {boolean} true if it is a tree
         */
        isTreeView: function() {
          return this._isTree;
        },

        /**
         * Return if table is a listview.
         * @return {boolean} true if it is a listview
         */
        isListView: function() {
          return (this._initialStyleAttributes.tableType === "listView");
        },

        getCurrentRowValueIndex: function() {
          return this.attribute('currentRow') - this.attribute('offset');
        },

        /**
         * Will get current value node in table
         * @param {boolean} inputModeOnly - return value node only if is node is in INPUT mode
         * @returns {*}
         */
        getCurrentValueNode: function(inputModeOnly) {
          var dialogType = this.attribute('dialogType');
          var isInputMode = (dialogType === "Input" || dialogType === "InputArray" || dialogType === "Construct");
          if (!inputModeOnly || isInputMode) {
            var valueIndex = this.getCurrentRowValueIndex();
            var columnNodes = this.getChildren('TableColumn');
            if (!this.isAttributeSetByVM('currentColumn')) {
              return null; // if attribute is not specified by VM consider that there is no current value
            }
            var currentColumn = this.attribute('currentColumn');
            if (currentColumn < columnNodes.length) {
              var columnNode = columnNodes[currentColumn];
              var valueListNode = columnNode.getFirstChild('ValueList');
              if (valueListNode) {
                var valueNodes = valueListNode.getChildren();
                if (valueIndex >= 0 && valueIndex < valueNodes.length) {
                  return valueNodes[valueIndex];
                }
              }
            }
          }
          return null;
        }
      };
    });
    cls.NodeFactory.register("Table", cls.TableNode);
  });
;
"use strict";

modulum('TreeInfoNode', ['NodeBase', 'NodeFactory'],
  function(context, cls) {
    /**
     * @class TreeInfoNode
     * @memberOf classes
     * @extends classes.NodeBase
     */
    cls.TreeInfoNode = context.oo.Class(cls.NodeBase, function($super) {

      return /** @lends classes.TreeInfoNode.prototype */ {
        constructor: function(parent, tag, id, attributes, app) {
          // when a treeInfo node is created must immediately inform parent table node
          if (parent.getWidget()) {
            // If this node is created while the table has already built its widget, stop the application
            window.requestAnimationFrame(function() {
              parent.getApplication().stop("Can't dynamically transform a table to a TreeView");
            });
          } else {
            parent._isTree = true;
          }
          $super.constructor.call(this, parent, tag, id, attributes, app);
        },
      };

    });
    cls.NodeFactory.register("TreeInfo", cls.TreeInfoNode);
  });
;
"use strict";

modulum('ValueNode', ['NodeBase', 'NodeFactory'],
  function(context, cls) {
    /**
     * @class ValueNode
     * @memberOf classes
     * @extends classes.NodeBase
     */
    cls.ValueNode = context.oo.Class(cls.NodeBase, function($super) {
      return /** @lends classes.ValueNode.prototype */ {
        /**
         * @inheritDoc
         */
        _createController: function() {
          var containerNode = this._parent && this._parent._parent;
          var decoratorNode = containerNode && containerNode._children[0];
          var controllerType = decoratorNode && decoratorNode._tag;
          var tableNode = containerNode._tag === 'TableColumn' ? containerNode._parent : undefined;
          return cls.ControllerFactory.create(controllerType, {
            anchor: this,
            parent: this._parent,
            ui: this.getApplication().getNode(0),
            decorator: decoratorNode,
            container: containerNode,
            table: tableNode,
            treeItem: null
          });
        },

        /**
         * @inheritDoc
         */
        getStyleAttribute: function(styleAttr, forcedPseudoSelectors) {
          // On value nodes, the styles should be interpreted as if they where asked on the decorator node
          var decoratorNode = this._parent._parent._children[0];
          var pseudoSelectors = forcedPseudoSelectors || this._computePseudoSelectors();
          return decoratorNode._getStyleAttributeImpl(styleAttr, pseudoSelectors);
        },

        /**
         * @inheritDoc
         */
        _populatePseudoSelectors: function(pseudoSelectors, focusedNodeIdRef) {
          var container = this._parent._parent;
          var positionHolder = container;
          var index = this.getIndex();
          var offset = null;

          if (container.getTag() === 'TableColumn') {
            var table = container._parent;
            if (table.getId() === focusedNodeIdRef) {
              pseudoSelectors.focus = false;
              var dialogType = container.attribute('dialogType');
              if (dialogType === "Input" || dialogType === "InputArray") {
                var currentRow = table.attribute('currentRow');
                offset = table.attribute('offset');
                if (currentRow - offset === index) {
                  var currentColumn = table.attribute('currentColumn');
                  if (currentColumn === container.getIndex()) {
                    pseudoSelectors.focus = true;
                  }
                }
              }
            }
            positionHolder = table;
          }

          offset = positionHolder.attribute('offset');
          if ((offset + index + 1) % 2) {
            pseudoSelectors.odd = true;
          } else {
            pseudoSelectors.even = true;
          }
          return $super._populatePseudoSelectors.call(this, pseudoSelectors, focusedNodeIdRef);
        }
      };
    });
    cls.NodeFactory.register("Value", cls.ValueNode);
  });
;
"use strict";

modulum('WindowNode', ['StandardNode', 'NodeFactory'],
  function(context, cls) {
    /**
     * @class WindowNode
     * @memberOf classes
     * @extends classes.StandardNode
     */
    cls.WindowNode = context.oo.Class(cls.StandardNode, function() {
      return /** @lends classes.WindowNode.prototype */ {

        isCurrentWindowNode: function() {
          var uiNode = this.getApplication().getNode(0);
          return uiNode.attribute('currentWindow') === this.getId();
        },

        isTraditional: function() {
          var uiNode = this.getApplication().getNode(0);
          if (uiNode.attribute("uiMode") === "traditional") {
            var formNode = this.getFirstChild("Form");
            if (formNode) {
              var screenNode = formNode.getFirstChild("Screen");
              if (screenNode) {
                return true;
              }
            }
          }
          return false;
        },

        getFirstTraditionalWindow: function() {
          var children = this.getApplication().getNode(0).getChildren();
          for (var i = 0; i < children.length; ++i) {
            var child = children[i];
            if (child.getTag() === "Window" && child.isTraditional()) {
              return child;
            }
          }
          return null;
        },

        getActiveDialog: function() {
          var length = this._children.length;
          for (var i = length - 1; i >= 0; --i) {
            var child = this._children[i];
            if (child._tag === 'Menu' || child._tag === 'Dialog') {
              if (child.attribute('active') === 1) {
                return child;
              }
            }
          }
        },

        isModal: function() {
          var windowTypeAttr = this.getStyleAttribute("windowType");
          return windowTypeAttr === "modal" || windowTypeAttr === "popup";
        },
        _setProcessingStyle: function(processing) {
          var widget = this._controller && this._controller.getWidget();
          if (widget && widget._setProcessingStyle) {
            widget._setProcessingStyle(processing);
          }
        }
      };
    });
    cls.NodeFactory.register("Window", cls.WindowNode);
  });
;
"use strict";

/**
 * @typedef {Object} ControllerBindings
 * @property {classes.NodeBase} anchor
 * @property {?classes.NodeBase} decorator
 * @property {?classes.NodeBase} container
 * @property {?Object} additionalBindings
 */

modulum('ControllerBase', ['EventListener'],
  /**
   * @namespace Controllers
   * @param {gbc} context
   * @param {classes} cls
   */
  function(context, cls) {
    /**
     * Base controller for an AUI node.
     * Manages client side life cycle representation of the node.
     * @class ControllerBase
     * @memberOf classes
     * @extends classes.EventListener
     */
    cls.ControllerBase = context.oo.Class(cls.EventListener, function($super) {
      return /** @lends classes.ControllerBase.prototype */ {
        __name: "ControllerBase",
        /**
         * list of controller's node binding
         * @type {?ControllerBindings}
         */
        _nodeBindings: null,
        /**
         * linked behaviors
         * @type {Object[]}
         */
        _behaviors: null,
        /**
         * controller's widget
         * @type {classes.WidgetBase}
         */
        _widget: null,
        /**
         * controller's widget kind
         * @type {?string}
         */
        _widgetKind: null,
        /**
         * controller's widget active status
         * @type {?boolean}
         */
        _widgetActive: null,
        /**
         * controller's widget nbmp
         * @type {?string}
         */
        _widgetType: null,
        /**
         * if false, don't create controller's widget automatically
         * @type {boolean}
         */
        _autoCreateWidget: true,

        /**
         * Use position in AUI tree parent node to add widget at the correct position
         * @type {boolean}
         */
        _useAUIPositionToAttachUI: false,

        /**
         * @constructs
         * @param {ControllerBindings} bindings
         */
        constructor: function(bindings) {
          $super.constructor.call(this);
          this._nodeBindings = bindings;
          this._behaviors = [];
          this.createWidget();
          this._initBehaviors();
          if (gbc.qaMode) {
            this._addBehavior(cls.QAInfoVMBehavior);
          }
          this._addBehavior(cls.AuiNameVMBehavior);
        },

        _initWidgetKind: function() {
          if (this._nodeBindings.container) {
            this._widgetKind = this._nodeBindings.container.attribute("dialogType");
            this._widgetActive = this._nodeBindings.container.attribute("active");
          }
          this._widgetType = this._getWidgetType(this._widgetKind, this._widgetActive);
        },

        isInMatrix: function() {
          return this.getAnchorNode() && this.getAnchorNode().isInMatrix();
        },

        isInTable: function() {
          return this.getAnchorNode() && this.getAnchorNode().isInTable();
        },

        isInFirstTableRow: function() {
          return this.getAnchorNode() && this.getAnchorNode().isInFirstTableRow();
        },

        isInStack: function() {
          return this.getAnchorNode() && this.getAnchorNode().isInStack();
        },

        isInScrollGrid: function() {
          return this.getAnchorNode() && this.getAnchorNode().isInScrollGrid();
        },

        /**
         * init behaviors: override in children class
         * @protected
         * @abstract
         */
        _initBehaviors: function() {},

        /**
         * Link behavior to the controller
         * @param {Function} BehaviorClass the behavior class to link
         * @param {*} [config] configuration object
         * @protected
         */
        _addBehavior: function(BehaviorClass, config) {
          var behaviorContainer = {
            _behavior: BehaviorClass,
            dirty: true
          };
          if (BehaviorClass.setup) {
            BehaviorClass.setup(this, behaviorContainer, config);
          }
          this._behaviors.push(behaviorContainer);
          BehaviorClass.firstAttach(this, behaviorContainer);
        },
        /**
         * Applies all behaviors attached to this controller
         * @param {Array} treeModificationTrack list of nodes where behaviors were applied
         * @param {?boolean} force true force apply all
         * @return {boolean} true if behaviors went dirty
         */
        applyBehaviors: function(treeModificationTrack, force) {
          var remainingDirty = false,
            invalidatesFollowing = false,
            len = this._behaviors.length;
          for (var i = 0; i < len; i++) {
            var behaviorContainer = this._behaviors[i];
            var behavior = behaviorContainer._behavior;
            if (behavior === cls.QAInfoVMBehavior || behavior === cls.AuiNameVMBehavior) {
              behavior.apply(this, behaviorContainer);
            } else {
              if (force || invalidatesFollowing || behavior.canApply(this, behaviorContainer, treeModificationTrack)) {
                invalidatesFollowing = behavior.apply(this, behaviorContainer) || invalidatesFollowing;
              }
              remainingDirty = remainingDirty || behavior.dirty;
            }
          }
          return remainingDirty;
        },
        /**
         * attach widget
         * @protected
         */
        _attachWidget: function() {
          for (var i = 0; i < this._behaviors.length; i++) {
            var behaviorContainer = this._behaviors[i];
            behaviorContainer._behavior.attachWidget(this, behaviorContainer);
          }
        },
        /**
         * detach widget
         * @protected
         */
        _detachWidget: function() {
          for (var i = 0; i < this._behaviors.length; i++) {
            var behaviorContainer = this._behaviors[i];
            behaviorContainer._behavior.detachWidget(this, behaviorContainer);
          }
        },
        /**
         * destroy behaviors
         * @protected
         */
        _destroyBehaviors: function() {
          for (var i = 0; i < this._behaviors.length; i++) {
            var behaviorContainer = this._behaviors[i];
            behaviorContainer._behavior.cleanup(this, behaviorContainer);
            behaviorContainer._behavior = null;
          }
          this._behaviors.length = 0;
          this._behaviors = null;
        },
        /**
         * @inheritDoc
         */
        destroy: function() {
          this._destroyBehaviors();
          this.detachUI();
          this._nodeBindings = null;
          this._widget = null;
          $super.destroy.call(this);
        },
        /**
         * Get the anchor node
         * @returns {classes.NodeBase} the anchor node
         */
        getAnchorNode: function() {
          return this._nodeBindings && this._nodeBindings.anchor;
        },
        /**
         * Get the application node
         * @returns {classes.NodeBase} the ui node
         */
        getUINode: function() {
          return this._nodeBindings && this._nodeBindings.ui;
        },
        /**
         * get the nodes linked to the controller
         * @returns {ControllerBindings} the nodes
         */
        getNodeBindings: function() {
          return this._nodeBindings;
        },
        /**
         * create widget
         * @returns {classes.WidgetBase} the widget
         */
        createWidget: function() {
          if (!this._widget && this.autoCreateWidget()) {
            this._initWidgetKind();
            this._widget = this._createWidget(this._widgetType);
          }
          return this._widget;
        },

        /**
         * create widget from given type
         * @param {string} widgetType the widget type
         * @returns {classes.WidgetBase} the widget
         */
        createWidgetFromType: function(widgetType) {
          if (!this._widget) {
            this._widgetType = widgetType;
            this._widget = this._createWidget(this._widgetType);
          }
          return this._widget;
        },

        /**
         * Check if the widget should be automatically created.
         * @return {boolean} true if controller will create widget automatically
         */
        autoCreateWidget: function() {
          return this._autoCreateWidget;
        },

        /**
         * Set if widget should be automatically created
         * @param {boolean} b true if widget should be automatically created
         */
        setAutoCreateWidget: function(b) {
          this._autoCreateWidget = b;
        },

        /**
         * Basic widget types depending of dialogType. To override for specific rules
         * @param {string} kind widget dialogType
         * @param {boolean} [active] is dialog active ?
         * @returns {string} widget type
         * @protected
         */
        _getWidgetType: function(kind, active) {
          return this.__name.replace("Controller", "");
        },

        /**
         * create widget
         * @param {string} [type] the widget type
         * @returns {classes.WidgetBase} the created widget
         * @protected
         */
        _createWidget: function(type) {
          return cls.WidgetFactory.createWidget(type, {
            appHash: this.getAnchorNode().getApplication().applicationHash,
            appWidget: this.getAnchorNode().getApplication().getUI().getWidget(),
            auiTag: this.getAnchorNode().getId(),
            inTable: this.isInTable(),
            inMatrix: this.isInMatrix(),
            inScrollGrid: this.isInScrollGrid()
          }, this.getAnchorNode());
        },
        /**
         * Recreate widget depending on dialogType
         * @param {string} kind widget kind
         * @param {boolean} active is dialog active ?
         */
        changeWidgetKind: function(kind, active) {
          if ((kind !== this._widgetKind || active !== this._widgetActive) && this.autoCreateWidget()) {
            this._widgetKind = kind;
            this._widgetActive = active;
            var type = this._getWidgetType(kind, active);
            if (type !== this._widgetType) {
              this._widgetType = type;
              var oldWidget = this._widget;
              this._detachWidget();
              this._widget = this._createWidget(type);
              if (this._widget) {
                if (oldWidget) {
                  oldWidget.replaceWith(this._widget);
                } else {
                  // No older widget to replace, attach new one
                  this.attachUI();
                }
              }

              if (oldWidget) {
                oldWidget.destroy();
              }
              this._attachWidget();
              return true;
            } else if (this._widget.setWidgetMode) {
              this._widget.setWidgetMode(kind, active);
            }
          }
          return false;
        },

        /**
         * attach UI
         */
        attachUI: function() {
          cls.NodeHelper.addToParentWidget(this.getAnchorNode(), null, this._useAUIPositionToAttachUI);
        },

        /**
         * detach UI
         */
        detachUI: function() {
          if (this._widget) {
            this._widget.destroy();
            this._widget = null;
          }
        },

        /**
         * get the widget
         * @returns {classes.WidgetBase} the widget
         */
        getWidget: function() {
          return this._widget;
        },

        /**
         * Returns current internal widget (in table or matrix)
         * @returns {classes.WidgetBase} current internal widget
         * @public
         */
        getCurrentInternalWidget: function() {
          var widget = null;
          var node = this.getAnchorNode();
          if (node.getCurrentValueNode) {
            var valueNode = node.getCurrentValueNode(false);
            if (valueNode) {
              var controller = valueNode.getController();
              if (controller) {
                widget = controller.getWidget();
              }
            }
          }
          return widget;
        },

        /**
         * Ensures the widget corresponding to this controller is visible to the user
         * @param {boolean} [executeAction] - true to execute action linked (e.g. for a page, the linked action when showing)
         * @return {boolean} true if a layout is needed after that
         */
        ensureVisible: function(executeAction) {
          var p = this.getAnchorNode().getParentNode(),
            result = false;
          while (p !== null) {
            var controller = p.getController();
            if (controller !== null) {
              result = result || controller.ensureVisible(executeAction);
              break;
            }
            p = p.getParentNode();
          }
          return result;
        },

        /**
         * Try to set focus to controller's widget
         */
        setFocus: function() {
          if (this._widget && this._widget.setFocus) {
            this._widget.setFocus();
          }
          // Hide filter menu item from chrome bar
          this.getUINode().getController().getWidget().showChromeBarFilterMenuItem(false);
        },

        /**
         * update dirty state of style application behaviors
         *
         * @param {boolean} noUsageCheck if false or not defined, set as dirty in all cases
         * @param {boolean} noRecurse if false or not defined, do it recursively
         * @protected
         */
        setStyleBasedBehaviorsDirty: function(noUsageCheck, noRecurse) {
          var app = this.getAnchorNode().getApplication();
          for (var i = 0; i < this._behaviors.length; i++) {
            var behaviorContainer = this._behaviors[i];
            var behavior = behaviorContainer._behavior,
              len = behavior.usedStyleAttributes && behavior.usedStyleAttributes.length;
            if (len) {
              if (noUsageCheck) {
                behaviorContainer.dirty = true;
              } else {
                for (var j = 0; j < len; ++j) {
                  if (app.usedStyleAttributes[behavior.usedStyleAttributes[j]]) {
                    behaviorContainer.dirty = true;
                    break;
                  }
                }
              }
            }
          }
          if (!noRecurse) {
            var children = this.getAnchorNode().getRawChildren();
            for (i = 0; i < children.length; ++i) {
              var child = children[i];
              var ctrl = child.getController();
              if (ctrl) {
                ctrl.setStyleBasedBehaviorsDirty(noUsageCheck);
              }
            }
          }
        },

        /**
         * Set stored setting for this controller
         * @param key {string} Setting key
         * @param value {*} Setting value
         */
        setStoredSetting: function(key, value) {},

        /**
         * Get stored setting for this controller
         * @param key {string} Setting key
         * @returns {*} the stored settings object, if any
         */
        getStoredSetting: function(key) {
          return null;
        },

        /**
         * Sends the updated value to the DVM
         * @param {boolean} [dirty] - if true send only if widget has been edited
         */
        sendWidgetValue: function(dirty) {},

        /**
         * Sends the updated cursors to the DVM
         * @param {boolean} [dirty] - if true send only if widget has been edited
         */
        sendWidgetCursors: function(dirty) {},

        /**
         * Check if Widget should be display in chromebar or keep the default behavior
         * @return {Boolean} true if it's displayed in the chromebar
         */
        isInChromeBar: function() {
          // Legacy mode means no chromebar
          if (gbc.ThemeService.getValue("theme-legacy-topbar")) {
            return false;
          }
          var anchor = this.getAnchorNode();
          var ancestorWindow = anchor.getAncestor("Window");
          var isInTabbedContainer = anchor.getApplication().getSession().getTabbedContainerModeHostApplication();
          var ancestorMenu = anchor.getAncestor("Menu");
          var isMenuWinMsg = ancestorMenu && ancestorMenu._vmStyles.indexOf("winmsg") >= 0 || anchor._vmStyles.indexOf("winmsg") >=
            0; //menu item in winmsg
          var isDialogMenu = ancestorMenu && ancestorMenu._vmStyles.indexOf("dialog") >= 0;
          var isPopupMenu = ancestorMenu && ancestorMenu._vmStyles.indexOf("popup") >= 0 || anchor._vmStyles.indexOf("popup") >=
            0; //menu item in popup
          var isWinMsg = ancestorWindow && ancestorWindow._vmStyles.indexOf("winmsg") >= 0; //menu item in winmsg
          var isWinModal = ancestorWindow && ancestorWindow.getStyleAttribute("windowType") === "modal"; //menu item in modal window

          // Position style for all MENU (and MENU items under this instruction)
          var ringMenuPositionStyle = ancestorWindow && (ancestorWindow._initialStyleAttributes.ringMenuPosition || gbc.ThemeService
            .getValue("gbc-WindowWidget-defaultRingMenuPosition"));
          // Position style for all ACTIONs in a DIALOG
          var actionPanelPositionStyle = ancestorWindow && (ancestorWindow._initialStyleAttributes.actionPanelPosition || gbc
            .ThemeService
            .getValue("gbc-WindowWidget-defaultActionPanelPosition"));

          // Position style for TOOLBAR
          // For the window toolbar, get the parent window style
          // For a global toolbar, get the first window style in userInterface node
          var tbWindow = ancestorWindow || anchor.getAncestor("UserInterface").getChildren("Window")[0];
          var toolbarPositionStyle = tbWindow && (tbWindow._initialStyleAttributes.toolBarPosition || gbc.ThemeService.getValue(
            "gbc-WindowWidget-defaultToolBarPosition"));

          // In tabbed container mode, override the default theme / 4ST to never use the chromebar
          if (isInTabbedContainer) {
            toolbarPositionStyle = toolbarPositionStyle === "chrome" ? "top" : toolbarPositionStyle;
            ringMenuPositionStyle = ringMenuPositionStyle === "chrome" ? "right" : ringMenuPositionStyle;
            actionPanelPositionStyle = actionPanelPositionStyle === "chrome" ? "right" : actionPanelPositionStyle;
          }

          // This final step defines if the position is in chromeBar
          var position4STChrome = false;
          if (this.isInstanceOf(cls.ToolBarController) || this.isInstanceOf(cls.ToolBarItemController)) {
            position4STChrome = toolbarPositionStyle === "chrome";
          } else if (this.isInstanceOf(cls.MenuActionController) || this.isInstanceOf(cls.MenuController)) {
            position4STChrome = ringMenuPositionStyle === "chrome";
          } else if (this.isInstanceOf(cls.ActionController)) {
            position4STChrome = actionPanelPositionStyle === "chrome";
          } else if (this.isInstanceOf(cls.DialogController)) {
            position4STChrome = actionPanelPositionStyle === "chrome";
          }

          // Don't display menus as chromebar on modal or popup
          return position4STChrome && !isDialogMenu && !isMenuWinMsg && !isPopupMenu && !isWinMsg && !isWinModal;
        }

      };
    });
  });
;
"use strict";

modulum('ControllerFactory', ['Factory'],
  function(context, cls) {
    /**
     * @namespace classes.ControllerFactory
     */
    cls.ControllerFactory = context.oo.StaticClass(function() {
      /**
       *
       * @type {classes.Factory}
       */
      var factory = new cls.Factory("Controller");
      return /** @lends classes.ControllerFactory */ {
        /**
         *
         * @param {string} id
         * @param {Function} constructor
         */
        register: function(id, constructor) {
          factory.register(id, constructor);
        },
        /**
         *
         * @param {string} id
         */
        unregister: function(id) {
          factory.unregister(id);
        },
        /**
         *
         * @param {string} id
         * @returns {classes.ControllerBase}
         */
        create: function(id, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9) {
          return factory.create(id, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
        }
      };
    });
  });
;
"use strict";

modulum('ControllerGroup', ['EventListener'],
  function(context, cls) {
    /**
     * Base controller for an AUI node.
     * Manages client side life cycle representation of the node.
     * @class ControllerGroup
     * @memberOf classes
     * @extends classes.EventListener
     */
    cls.ControllerGroup = context.oo.Class(cls.EventListener, function($super) {
      return /** @lends classes.ControllerGroup.prototype */ {
        __name: "ControllerGroup",
        /**
         * @type {classes.NodeBase}
         */
        _anchorNode: null,
        /**
         * @type {classes.ControllerBase[]}
         */
        _controllers: null,

        /**
         * @param {classes.NodeBase} anchorNode bindings
         */
        constructor: function(anchorNode) {
          $super.constructor.call(this);
          this._anchorNode = anchorNode;
          this._controllers = [];
        },

        addController: function(controller) {
          this._controllers.push(controller);
        },

        getControllers: function() {
          return this._controllers;
        },

        /**
         * Applies all behaviors of sub-controllers
         */
        applyBehaviors: function(treeModificationTrack, force) {
          for (var i = 0; i < this._controllers.length; ++i) {
            this._controllers[i].applyBehaviors(treeModificationTrack, force);
          }
        },

        destroy: function() {
          for (var i = 0; i < this._controllers.length; ++i) {
            this._controllers[i].destroy();
          }
        },
        /**
         * Get the anchor node
         * @returns {classes.NodeBase}
         */
        getAnchorNode: function() {
          return this._anchorNode;
        },

        getWidget: function() {
          if (this._controllers.length) {
            return this._controllers[this._controllers.length - 1].getWidget();
          } else {
            return null;
          }
        },

        setStyleBasedBehaviorsDirty: function(noUsageCheck, noRecurse) {
          for (var i = 0; i < this._controllers.length; ++i) {
            this._controllers[i].setStyleBasedBehaviorsDirty(noUsageCheck, noRecurse);
          }
        },

        ensureVisible: function() {}
      };
    });
  }
);
;
"use strict";

modulum('CanvasArcController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class CanvasArcController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.CanvasArcController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.CanvasArcController.prototype */ {
        __name: "CanvasArcController",

        _initBehaviors: function() {
          this._addBehavior(cls.CanvasArcParametersVMBehavior);
          this._addBehavior(cls.CanvasFillColorVMBehavior);
          this._addBehavior(cls.CanvasItemOnClickUIBehavior);
        }
      };
    });
    cls.ControllerFactory.register("CanvasArc", cls.CanvasArcController);

  });
;
"use strict";

modulum('CanvasCircleController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class CanvasCircleController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.CanvasCircleController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.CanvasCircleController.prototype */ {
        __name: "CanvasCircleController",

        _initBehaviors: function() {
          this._addBehavior(cls.CanvasCircleParametersVMBehavior);
          this._addBehavior(cls.CanvasFillColorVMBehavior);
          this._addBehavior(cls.CanvasItemOnClickUIBehavior);
        }
      };
    });
    cls.ControllerFactory.register("CanvasCircle", cls.CanvasCircleController);

  });
;
"use strict";

modulum('CanvasController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class CanvasController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.CanvasController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.CanvasController.prototype */ {
        __name: "CanvasController",
        _afterLayoutHandler: null,

        _initBehaviors: function() {
          $super._initBehaviors.call(this);
          this._addBehavior(cls.LayoutInfoVMBehavior);
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);

          var layoutService = this.getAnchorNode().getApplication().layout;
          this._afterLayoutHandler = layoutService.afterLayout(this.onAfterLayout.bind(this));
        },

        destroy: function() {
          if (this._afterLayoutHandler) {
            this._afterLayoutHandler();
          }
          $super.destroy.call(this);
        },

        onAfterLayout: function() {
          var children = this.getAnchorNode().getChildren();
          for (var i = 0; i < children.length; ++i) {
            var ctrl = children[i].getController();
            if (ctrl.onAfterLayout) {
              ctrl.onAfterLayout();
            }
          }
        }
      };
    });
    cls.ControllerFactory.register("Canvas", cls.CanvasController);

  });
;
"use strict";

modulum('CanvasLineController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class CanvasLineController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.CanvasLineController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.CanvasLineController.prototype */ {
        __name: "CanvasLineController",

        _initBehaviors: function() {
          this._addBehavior(cls.CanvasLineParametersVMBehavior);
          this._addBehavior(cls.CanvasFillColorVMBehavior);
          this._addBehavior(cls.CanvasItemOnClickUIBehavior);
        }
      };
    });
    cls.ControllerFactory.register("CanvasLine", cls.CanvasLineController);

  });
;
"use strict";

modulum('CanvasOvalController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class CanvasOvalController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.CanvasOvalController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.CanvasOvalController.prototype */ {
        __name: "CanvasOvalController",

        _initBehaviors: function() {
          this._addBehavior(cls.CanvasOvalParametersVMBehavior);
          this._addBehavior(cls.CanvasFillColorVMBehavior);
          this._addBehavior(cls.CanvasItemOnClickUIBehavior);
        }
      };
    });
    cls.ControllerFactory.register("CanvasOval", cls.CanvasOvalController);

  });
;
"use strict";

modulum('CanvasPolygonController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class CanvasPolygonController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.CanvasPolygonController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.CanvasPolygonController.prototype */ {
        __name: "CanvasPolygonController",

        _initBehaviors: function() {
          this._addBehavior(cls.CanvasPolygonParametersVMBehavior);
          this._addBehavior(cls.CanvasFillColorVMBehavior);
          this._addBehavior(cls.CanvasItemOnClickUIBehavior);
        }
      };
    });
    cls.ControllerFactory.register("CanvasPolygon", cls.CanvasPolygonController);

  });
;
"use strict";

modulum('CanvasRectangleController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class CanvasRectangleController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.CanvasRectangleController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.CanvasRectangleController.prototype */ {
        __name: "CanvasRectangleController",

        _initBehaviors: function() {
          this._addBehavior(cls.CanvasRectangleParametersVMBehavior);
          this._addBehavior(cls.CanvasFillColorVMBehavior);
          this._addBehavior(cls.CanvasItemOnClickUIBehavior);
        }
      };
    });
    cls.ControllerFactory.register("CanvasRectangle", cls.CanvasRectangleController);

  });
;
"use strict";

modulum('CanvasTextController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class CanvasTextController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.CanvasTextController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.CanvasTextController.prototype */ {
        __name: "CanvasTextController",

        _initBehaviors: function() {
          this._addBehavior(cls.CanvasTextParametersVMBehavior);
          this._addBehavior(cls.CanvasFillColorVMBehavior);
          this._addBehavior(cls.CanvasItemOnClickUIBehavior);
        },

        onAfterLayout: function() {
          this.applyBehaviors(null, true);
        }
      };
    });
    cls.ControllerFactory.register("CanvasText", cls.CanvasTextController);

  });
;
"use strict";

modulum('FolderController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class FolderController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.FolderController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.FolderController.prototype */ {
        __name: "FolderController",
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.LayoutInfoVMBehavior);
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // 4st behaviors
          this._addBehavior(cls.TabPosition4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);

          // vm behaviors
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.TitleVMBehavior);
          this._addBehavior(cls.CollapserPosition4STBehavior);

          // ui behaviors
          this._addBehavior(cls.ChangePageUIBehavior);

          var layoutService = this.getAnchorNode().getApplication().layout;
          this._afterLayoutHandler = layoutService.afterLayout(this.onAfterLayout.bind(this));
        },

        onAfterLayout: function() {
          if (this.getWidget() && this.getWidget().updateScrollersVisibility) {
            this.getWidget().updateScrollersVisibility();
          }
        },

        destroy: function() {
          if (this._afterLayoutHandler) {
            this._afterLayoutHandler();
          }
          $super.destroy.call(this);
        }

      };
    });
    cls.ControllerFactory.register("Folder", cls.FolderController);

  });
;
"use strict";

modulum('FormController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class FormController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.FormController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.FormController.prototype */ {
        __name: "FormController",
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.LayoutInfoVMBehavior);
          // END WARNING

          if (this.getAnchorNode().getParentNode().isTraditional()) {
            this._addBehavior(cls.TraditionalFormSizingVMBehavior);
          }

          // 4st behaviors
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);

          // vm behaviors
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.ColorVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontWeightVMBehavior);
          this._addBehavior(cls.TextDecorationVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.TextVMBehavior);
          this._addBehavior(cls.VisibleIdVMBehavior);

          // ui behaviors
        },

        attachUI: function() {
          if (this._widget) {
            var layoutService = this.getAnchorNode().getApplication().layout;
            this._afterLayoutHandler = layoutService.afterLayout(function() {
              this._widget.removeClass("visibility-hidden");
              if (this._afterLayoutHandler) {
                this._afterLayoutHandler();
                this._afterLayoutHandler = null;
              }
            }.bind(this));
            this._widget.addClass("visibility-hidden");
          }
          $super.attachUI.call(this);
        },

        detachUI: function() {
          if (this._afterLayoutHandler) {
            this._afterLayoutHandler();
            this._afterLayoutHandler = null;
          }
          $super.detachUI.call(this);
        },

        destroy: function() {
          if (this._afterLayoutHandler) {
            this._afterLayoutHandler();
            this._afterLayoutHandler = null;
          }
          $super.destroy.call(this);
        }
      };
    });
    cls.ControllerFactory.register("Form", cls.FormController);

  });
;
"use strict";

modulum('GridController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class GridController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.GridController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.GridController.prototype */ {
        __name: "GridController",
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.LayoutInfoVMBehavior);
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // 4st behaviors
          this._addBehavior(cls.Reverse4STBehavior);

          // vm behaviors
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          // ui behaviors

          this._addBehavior(cls.GridAutomaticStack4STBehavior);
        },
        /**
         * @inheritDoc
         */
        ensureVisible: function(executeAction) {
          var widget = this.getAnchorNode().getWidget();
          widget.emit(context.constants.widgetEvents.splitViewChange, widget);
          return $super.ensureVisible.call(this, executeAction);
        }
      };
    });
    cls.ControllerFactory.register("Grid", cls.GridController);

  });
;
"use strict";

modulum('GroupController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class GroupController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.GroupController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.GroupController.prototype */ {
        __name: "GroupController",

        /**
         * @inheritDoc
         */
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.LayoutInfoVMBehavior);
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // 4st behaviors
          this._addBehavior(cls.FontStyle4STBehavior);
          this._addBehavior(cls.FontSize4STBehavior);
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);
          this._addBehavior(cls.Collapsible4STBehavior);
          this._addBehavior(cls.CollapserPosition4STBehavior);

          // vm behaviors
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.ColorVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontWeightVMBehavior);
          this._addBehavior(cls.TextDecorationVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.TextVMBehavior);
          // ui behaviors
          this._addBehavior(cls.GridAutomaticStack4STBehavior);
        },

        /**
         * @inheritDoc
         */
        ensureVisible: function(executeAction) {
          var widget = this.getAnchorNode().getWidget(),
            result = widget.setCollapsed(false);
          widget.emit(context.constants.widgetEvents.splitViewChange, widget);
          return result || $super.ensureVisible.call(this, executeAction);
        }
      };
    });
    cls.ControllerFactory.register("Group", cls.GroupController);

  });
;
"use strict";

modulum('HBoxController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class HBoxController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.HBoxController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.HBoxController.prototype */ {
        __name: "HBoxController",

        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.LayoutInfoVMBehavior);
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // 4st behaviors
          this._addBehavior(cls.Reverse4STBehavior);
          this._addBehavior(cls.SplitViewArrows4STBehavior);
          this._addBehavior(cls.SplitViewDots4STBehavior);

          // vm behaviors
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.SplitterVMBehavior);
          // ui behaviors
          this._addBehavior(cls.OnSplitterUIBehavior);
        },

        /**
         * @inheritDoc
         */
        _createWidget: function(type) {
          return cls.WidgetFactory.createWidget(type, {
            appHash: this.getAnchorNode().getApplication().applicationHash,
            appWidget: this.getAnchorNode().getApplication().getUI().getWidget(),
            auiTag: this.getAnchorNode().getId(),
            inTable: this.isInTable(),
            inMatrix: this.isInMatrix(),
            inScrollGrid: this.isInScrollGrid(),
            uiWidget: this.getUINode().getController().getWidget()
          }, this.getAnchorNode());
        },

        _getWidgetType: function() {
          // Create splitview widget if 4ST attribute is set.
          // Let widget enable/disable splitview mechanism depending of screen size dynamically
          var isHBoxSplitView = this.getAnchorNode()._initialStyleAttributes.splitViewRendering === "yes";
          var type = "HBox";
          if (isHBoxSplitView) {
            type = "HBoxSplitView";
          }
          return type;
        },
        /**
         * @inheritDoc
         */
        ensureVisible: function(executeAction) {
          var widget = this.getAnchorNode().getWidget();
          widget.emit(context.constants.widgetEvents.splitViewChange, widget);
          return $super.ensureVisible.call(this, executeAction);
        }
      };
    });
    cls.ControllerFactory.register("HBox", cls.HBoxController);

  });
;
"use strict";

modulum('MatrixController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class MatrixController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.MatrixController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.MatrixController.prototype */ {
        __name: "MatrixController",
        _currentRow: 0,

        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          this.setCurrentRow(this.getAnchorNode().attribute("currentRow"));
          // pseudo-selector behaviors
          this._addBehavior(cls.FocusCurrentCellPseudoSelectorBehavior);
          this._addBehavior(cls.OffsetPseudoSelectorBehavior);
        },

        /**
         * @inheritDoc
         */
        setFocus: function() {
          var widget = this.getCurrentInternalWidget();
          if (widget) {
            if (this.isInScrollGrid()) {
              var scrollGridNode = this.getAnchorNode().getAncestor('ScrollGrid');
              var scrollGridController = scrollGridNode.getController();
              // show filter when matrix is in scrollgrid
              scrollGridController.showReduceFilter();
            }
            widget.setFocus();
          } else {
            var appWidget = context.SessionService.getCurrent().getCurrentApplication().getUI().getWidget();
            if (appWidget) {
              var uiWidget = appWidget._uiWidget;
              if (uiWidget) {
                uiWidget.setFocus();
              }
            }
          }
        },

        setCurrentRow: function(currentRow) {
          this._currentRow = currentRow;
        },

        getCurrentRow: function() {
          return this._currentRow;
        },

        updateCurrentRow: function(matrixNode, currentRow) {
          // Check if we are in a ScrollGrid
          var scrollGridNode = matrixNode.getAncestor('ScrollGrid');
          var scrollGridWidget = scrollGridNode ? scrollGridNode.getController().getWidget() : null;
          if (scrollGridWidget && scrollGridWidget.setCurrentRow) { // SCROLLGRID
            if (currentRow === -1 && scrollGridNode.attribute("active") === 1) {
              // if one matrix in scrollgrid has a currentRow equal to -1 --> focusOnField activated
              scrollGridWidget.setFocusOnField(true);
            }
            scrollGridWidget.setCurrentRow(currentRow);
          } else { // SIMPLE MATRIX
            var dialogType = matrixNode.attribute('dialogType');
            var displayDialog = dialogType === "Display" || dialogType === "DisplayArray";
            if (matrixNode.getTag() === "Matrix" && displayDialog) {
              matrixNode.getController().updateAllSiblingMatrixCurrentRow(currentRow, true);
            }
          }
          return null;
        },

        updateAllSiblingMatrixCurrentRow: function(currentRow, updateCss) {
          var matrixParent = this.getAnchorNode().getParentNode();
          if (matrixParent) {
            var childrenMatrix = matrixParent.getChildren("Matrix");
            if (childrenMatrix) {
              for (var i = 0; i < childrenMatrix.length; i++) {
                // update processing current row
                var colMatrix = childrenMatrix[i];
                var matrixCtrl = colMatrix.getController();
                if (matrixCtrl) {
                  var previousRow = matrixCtrl.getCurrentRow();
                  if (matrixCtrl && matrixCtrl.setCurrentRow) {
                    matrixCtrl.setCurrentRow(currentRow);
                  }
                  // update current row css
                  if (updateCss) {
                    var widgets = colMatrix.getFirstChild("ValueList").getChildren();
                    if (currentRow <= widgets.length - 1 && previousRow <= widgets.length - 1) {

                      var previousWidget = widgets[previousRow];
                      if (previousWidget) {
                        previousWidget.getController().getWidget().removeClass("currentRow");
                      }
                      var newWidget = widgets[currentRow];
                      if (newWidget) {
                        newWidget.getController().getWidget().addClass("currentRow");
                      }
                    }
                  }
                }
              }
            }
          }
        },

        /**
         * Sends the updated value to the DVM
         * @private
         */
        sendWidgetValue: function(dirty) {
          var valueNode = this.getAnchorNode().getCurrentValueNode(true);
          if (valueNode) {
            var ctrl = valueNode.getController();
            ctrl.sendWidgetValue(dirty);
          }
        },
      };
    });
    cls.ControllerFactory.register("Matrix", cls.MatrixController);

  });
;
"use strict";

modulum('PageController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class PageController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.PageController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.PageController.prototype */ {
        __name: "PageController",
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.LayoutInfoVMBehavior);
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // ui behaviors
          this._addBehavior(cls.OnClickUIBehavior);
          // 4st behaviors
          this._addBehavior(cls.FontStyle4STBehavior);
          this._addBehavior(cls.FontSize4STBehavior);
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);

          // vm behaviors
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.ColorVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontWeightVMBehavior);
          this._addBehavior(cls.TextDecorationVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.TextVMBehavior);
          this._addBehavior(cls.TitleVMBehavior);
          this._addBehavior(cls.ImageVMBehavior);
        },

        /**
         *
         * @param {string=} type
         * @returns {classes.WidgetBase}
         * @protected
         */
        _createWidget: function(type) {
          var pageWidget = $super._createWidget.call(this, type);
          var parentPageWidget = null;
          var parentPageNode = this.getAnchorNode().getAncestor("Page");
          if (parentPageNode) {
            parentPageWidget = parentPageNode.getController().getWidget();
          }
          pageWidget.emit(context.constants.widgetEvents.ready, parentPageWidget);
          return pageWidget;
        },

        /**
         * @inheritDoc
         */
        ensureVisible: function(executeAction) {
          var folderWidget = this.getAnchorNode().getParentNode().getController().getWidget();
          folderWidget.setCurrentPage(this.getWidget(), executeAction === true);
          folderWidget.emit(context.constants.widgetEvents.splitViewChange, this.getWidget());
          return $super.ensureVisible.call(this, executeAction);
        }
      };
    });
    cls.ControllerFactory.register("Page", cls.PageController);

  });
;
"use strict";

modulum('RowInfoController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class RowInfoController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.RowInfoController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.RowInfoController.prototype */ {
        __name: "RowInfoController",
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // vm behaviors
          this._addBehavior(cls.RowSelectedVMBehavior);
          // ui behaviors
        }
      };
    });
    cls.ControllerFactory.register("RowInfo", cls.RowInfoController);

  });
;
"use strict";

modulum('ScreenController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class ScreenController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.ScreenController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.ScreenController.prototype */ {
        __name: "ScreenController",
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.LayoutInfoVMBehavior);
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // 4st behaviors
          this._addBehavior(cls.Reverse4STBehavior);

          // vm behaviors
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);

          // ui behaviors
        },
        _getWidgetType: function() {
          var uiNode = this.getAnchorNode().getApplication().getNode(0);
          if (uiNode.attribute("uiMode") === "traditional") {
            return "TraditionalScreen";
          } else {
            return "Grid";
          }
        }
      };
    });
    cls.ControllerFactory.register("Screen", cls.ScreenController);

  });
;
"use strict";

modulum('ScrollAreaController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class ScrollAreaController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.ScrollAreaController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.ScrollAreaController.prototype */ {
        __name: "ScrollAreaController",
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.LayoutInfoVMBehavior);
          // END WARNING

          // 4st behaviors
          this._addBehavior(cls.Reverse4STBehavior);
          this._addBehavior(cls.ThinScrollBarDisplayTime4STBehavior);

          // vm behaviors
          this._addBehavior(cls.EnabledVMBehavior);
          this._addBehavior(cls.ScrollVMBehavior);

          // ui behaviors
          this._addBehavior(cls.ScrollUIBehavior);
        },

        /**
         * @inheritDoc
         */
        sendWidgetValue: function(dirty) {
          var ui = this.getUINode();
          var focusedNode = ui.getApplication().getNode(ui.attribute('focus'));
          var focusedWidgetController = focusedNode.getController();
          focusedWidgetController.sendWidgetValue(dirty);
        }
      };
    });
    cls.ControllerFactory.register("ScrollArea", cls.ScrollAreaController);

  });
;
"use strict";

modulum('ScrollGridController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class ScrollGridController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.ScrollGridController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.ScrollGridController.prototype */ {
        __name: "ScrollGridController",
        /** @type {?classes.ScrollGridLineController[]} */
        _lineControllers: null,
        /** @type {?boolean} */
        _isPagedScrollGrid: null,
        /** @type {number} */
        _currentRow: -1,

        /**
         * @inheritDoc
         */
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          var isStretchable = this.getAnchorNode().attribute("wantFixedPageSize") === 0;
          this.nativeVerticalScroll = isStretchable;

          if (isStretchable) {
            this._lineControllers = [];
          }

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.LayoutInfoVMBehavior);
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // pseudo-selector behaviors
          this._addBehavior(cls.ActivePseudoSelectorBehavior);

          // vm behaviors
          this._addBehavior(cls.EnabledVMBehavior);
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          if (isStretchable) {
            this._addBehavior(cls.NativeScrollVMBehavior);
            this._addBehavior(cls.StretchableScrollGridPageSizeVMBehavior);
          } else {
            this._addBehavior(cls.ScrollVMBehavior);
          }

          // 4st behaviors
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);
          this._addBehavior(cls.RowActionTrigger4STBehavior);
          this._addBehavior(cls.Highlight4STBehavior);
          if (isStretchable) {
            this._addBehavior(cls.ItemsAlignment4STBehavior);
            this._addBehavior(cls.ReduceFilter4STBehavior);
          }

          //ui behaviors
          this._addBehavior(cls.RowActionUIBehavior);
          if (this.isPagedScrollGrid()) {
            this._addBehavior(cls.OnLayoutPagedUIBehavior);
            this._addBehavior(cls.ScrollOffsetUIBehavior);
          } else {
            this._addBehavior(cls.ScrollUIBehavior);
            if (isStretchable) {
              this._addBehavior(cls.OnLayoutUIBehavior);
            }
          }
        },

        /**
         * @inheritDoc
         */
        _createWidget: function(type) {
          var parentPageWidget = null;
          var uiWidget = this.getUINode().getController().getWidget();
          var wantFixedPageSize = this.getAnchorNode().attribute("wantFixedPageSize") !== 0;
          var widgetKind = wantFixedPageSize ? 'ScrollGrid' : 'StretchableScrollGrid';
          var parentPageNode = this.getAnchorNode().getAncestor("Page");
          if (parentPageNode) {
            parentPageWidget = parentPageNode.getController().getWidget();
          }
          return cls.WidgetFactory.createWidget(widgetKind, {
            appHash: this.getAnchorNode().getApplication().applicationHash,
            appWidget: this.getAnchorNode().getApplication().getUI().getWidget(),
            auiTag: this.getAnchorNode().getId(),
            uiWidget: uiWidget,
            folderPageWidget: parentPageWidget
          }, this.getAnchorNode());
        },

        /**
         * @inheritDoc
         */
        sendWidgetValue: function(dirty) {
          var ui = this.getUINode();
          var focusedNode = ui.getApplication().getNode(ui.attribute('focus'));
          var focusedWidgetController = focusedNode.getController();
          focusedWidgetController.sendWidgetValue(dirty);
        },

        /**
         * Add a ScrollGrid line controller
         * @param {classes.ScrollGridLineController} lineController
         */
        pushLineController: function(lineController) {
          this._lineControllers.push(lineController);
        },

        /**
         * Removes the last ScrollGrid line controller
         * @returns {classes.ScrollGridLineController}
         */
        popLineController: function() {
          return this._lineControllers.pop();
        },

        /**
         * @param {number} index index of the line controller
         * @returns {classes.ScrollGridLineController} the line controller
         */
        getLineController: function(index) {
          return this._lineControllers[index];
        },

        /**
         * @returns {number} the number of line controllers
         */
        getLineControllersCount: function() {
          return this._lineControllers.length;
        },

        /**
         * @param {number} currentRow the new current row
         */
        setCurrentRow: function(currentRow) {
          this._currentRow = currentRow;
        },

        /**
         * @returns {number} the current row
         */
        getCurrentRow: function() {
          return this._currentRow;
        },

        /**
         * @return {boolean} true if this is a paged ScrollGrid
         */
        isPagedScrollGrid: function() {
          if (this._isPagedScrollGrid === null && this.getAnchorNode()) {
            var anchorNode = this.getAnchorNode();
            this._isPagedScrollGrid = anchorNode._initialStyleAttributes.customWidget === "pagedScrollGrid" && anchorNode.attribute(
              "wantFixedPageSize") === 0;
          }
          return this._isPagedScrollGrid;
        },

        /**
         * @inheritDoc
         */
        ensureVisible: function(executeAction) {
          var widget = this.getAnchorNode().getWidget();
          widget.emit(context.constants.widgetEvents.splitViewChange, widget);
          return $super.ensureVisible.call(this, executeAction);
        },

        /**
         * Show filter in chrome bar.
         */
        showReduceFilter: function() {
          var widget = this.getWidget();
          if (widget.hasReduceFilter) {
            var showFilter = widget.hasReduceFilter();
            // show filter menu item from chrome bar
            var filterAttribute = this.getAnchorNode().attribute("filter");
            this.getUINode().getController().getWidget().showChromeBarFilterMenuItem(showFilter, filterAttribute);
          }
        },
      };
    });
    cls.ControllerFactory.register("ScrollGrid", cls.ScrollGridController);

  });
;
"use strict";

modulum('ScrollGridLineController', ['EventListener'],
  function(context, cls) {
    /**
     * @class ScrollGridLineController
     * @memberOf classes
     * @extends classes.EventListener
     */
    cls.ScrollGridLineController = context.oo.Class(cls.EventListener, function($super) {
      return /** @lends classes.ScrollGridLineController.prototype */ {
        __name: "ScrollGridLineController",
        _widget: null,
        _index: -1,
        _scrollGridNode: null,

        constructor: function(scrollGridNode, index) {
          this._scrollGridNode = scrollGridNode;
          this._index = index;
          this._widget = cls.WidgetFactory.createWidget('StretchableScrollGridLine', scrollGridNode.getController().getWidget().getBuildParameters());
          this._widget.when(context.constants.widgetEvents.click, this._onClick.bind(this));
          var children = this._scrollGridNode.getChildren();
          for (var i = 0; i < children.length; ++i) {
            this._createControllers(children[i], this._widget);
          }
        },

        _createControllers: function(node, parentWidget) {
          var ctrl = null;
          var widget = null;
          if (node.getTag() === "Matrix") {
            if (node._controller === null) {
              node._controller = node._createController();
            }
            var valueList = node.getFirstChild("ValueList");
            if (valueList) {
              var valueNode = valueList.getChildren()[this._index];
              ctrl = valueNode.getController();
              if (!ctrl) {
                ctrl = valueNode._createController({
                  scrollGridLineController: this
                });
                valueNode._controller = ctrl;
                widget = ctrl.createWidget();
                ctrl.applyBehaviors();
                parentWidget.addChildWidget(widget);
                ctrl._attachWidget();
              }
            }
          } else {
            var ctrlGroup = null;
            var nodeController = node._controller;
            if (!nodeController) {
              ctrlGroup = new cls.ControllerGroup(node);
              node._controller = ctrlGroup;
            } else if (nodeController.isInstanceOf(cls.ControllerGroup)) {
              ctrlGroup = nodeController;
            } else {
              return; // if controller is already created and it is not a ControllerGroup, nothing to do
            }
            ctrl = node._createController({
              scrollGridLineController: this
            });
            if (ctrl) {
              ctrlGroup.addController(ctrl);
              widget = ctrl.createWidget();
              ctrl.applyBehaviors();
              parentWidget.addChildWidget(widget);
              ctrl._attachWidget();
              if (node.getTag() === "HBox" || node.getTag() === "Group") {
                var nodeChildren = node.getChildren();
                for (var i = 0; i < nodeChildren.length; ++i) {
                  this._createControllers(nodeChildren[i], widget);
                }
              }
            }
          }
        },

        destroy: function() {
          this._recursiveRemove(this._scrollGridNode);
          this._widget.destroy();
        },

        _recursiveRemove: function(node) {
          var children = node.getChildren();
          for (var i = 0; i < children.length; ++i) {
            this._recursiveRemove(children[i], this._index);
          }
          if (node._controller) {
            if (node._controller instanceof cls.ControllerGroup) {
              var ctrls = node._controller.getControllers();
              ctrls[this._index].destroy();
              ctrls.splice(this._index);
            } else if (node.getTag() === "Value" && node.getIndex() === this._index) {
              node._controller.destroy();
              node._controller = null;
            }
          }
        },

        getWidget: function() {
          return this._widget;
        },

        getIndex: function() {
          return this._index;
        },

        _onClick: function(event, domEvent) {
          var currentRow = this._scrollGridNode.attribute("currentRow");
          var newCurrentRow = this._scrollGridNode.attribute("offset") + this._index;
          if (newCurrentRow !== currentRow) {
            this.getWidget().getParentWidget().setCurrentRow(this._index);
            this._scrollGridNode.getController().setCurrentRow(this._index);
            this._scrollGridNode.getApplication().typeahead.focus(this._scrollGridNode);
          }
        },
      };
    });
  });
;
"use strict";

modulum('SpacerItemController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class SpacerItemController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.SpacerItemController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.SpacerItemController.prototype */ {
        __name: "SpacerItemController",

      };
    });
    cls.ControllerFactory.register("SpacerItem", cls.SpacerItemController);

  });
;
"use strict";

modulum('StackController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class StackController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.StackController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.StackController.prototype */ {
        __name: "StackController",
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.LayoutInfoVMBehavior);
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // 4st behaviors
          this._addBehavior(cls.Reverse4STBehavior);

          // vm behaviors
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          // ui behaviors
        }
      };
    });
    cls.ControllerFactory.register("Stack", cls.StackController);

  });
;
"use strict";

modulum('TableActionController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class TableActionController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.TableActionController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.TableActionController.prototype */ {
        __name: "TableActionController",

        /**
         * @inheritDoc
         */
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // vm behaviors
          this._addBehavior(cls.EnabledButtonVMBehavior);
          this._addBehavior(cls.TextActionVMBehavior);
          this._addBehavior(cls.ImageVMBehavior);
          this._addBehavior(cls.HiddenVMBehavior);

          // ui behaviors
          this._addBehavior(cls.OnClickUIBehavior);
        },

        /**
         * @inheritDoc
         */
        _getWidgetType: function(kind, active) {
          return "MenuLabel";
        }
      };
    });
    cls.ControllerFactory.register("TableAction", cls.TableActionController);

  });
;
"use strict";

modulum('TableActionsController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class TableActionsController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.TableActionsController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.TableActionsController.prototype */ {
        __name: "TableActionsController",

        /**
         * @inheritDoc
         */
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // ui behaviors
          this._addBehavior(cls.ContextMenuUIBehavior);
        },

        /**
         * @inheritDoc
         */
        _getWidgetType: function(kind, active) {
          return "ContextMenu";
        }
      };
    });
    cls.ControllerFactory.register("TableActions", cls.TableActionsController);

  });
;
"use strict";

modulum('TableColumnController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class TableColumnController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.TableColumnController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.TableColumnController.prototype */ {
        __name: "TableColumnController",
        _isTreeViewColumn: false,

        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE

          // END WARNING

          // vm behaviors
          this._addBehavior(cls.EnabledVMBehavior);
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.ColorVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontWeightVMBehavior);
          this._addBehavior(cls.TextDecorationVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.TableTextVMBehavior);
          this._addBehavior(cls.TableRowHeightVMBehavior);
          this._addBehavior(cls.AggregateVMBehavior);
          this._addBehavior(cls.TableTabIndexVMBehavior);
          this._addBehavior(cls.TextAlignVMBehavior);
          this._addBehavior(cls.UnhidableVMBehavior);
          this._addBehavior(cls.UnmovableVMBehavior);
          this._addBehavior(cls.UnsizableVMBehavior);

          // ui behaviors
          this._addBehavior(cls.RowActionUIBehavior);
          this._addBehavior(cls.TableColumnSortUIBehavior);
          this._addBehavior(cls.TableColumnHideUIBehavior);
          this._addBehavior(cls.TableColumnOrderUIBehavior);
          this._addBehavior(cls.TableColumnDndUIBehavior);
          this._addBehavior(cls.TableColumnResizeUIBehavior);
          this._addBehavior(cls.TableColumnAfterLastItemClickUIBehavior);
          if (this._isTreeViewColumn) {
            this._addBehavior(cls.TreeItemKeyExpandUIBehavior);
            this._addBehavior(cls.TreeItemToggleUIBehavior);
          }

          // 4st behaviors
          this._addBehavior(cls.Reverse4STBehavior);
        },

        /**
         * @inheritDoc
         */
        _createWidget: function(type) {

          var tableColumnNode = this.getNodeBindings().anchor;
          var tableNode = tableColumnNode.getParentNode();

          this._isTreeViewColumn = !!tableNode.getFirstChild('TreeInfo') && tableNode.getFirstChild('TableColumn') ===
            tableColumnNode;

          var widget = cls.WidgetFactory.createWidget('TableColumn', {
            appHash: this.getAnchorNode().getApplication().applicationHash,
            appWidget: this.getAnchorNode().getApplication().getUI().getWidget(),
            auiTag: this.getAnchorNode().getId(),
            isTreeView: this._isTreeViewColumn
          }, tableColumnNode);

          widget.setDefaultWidth(this.getStoredSetting("width"));

          return widget;
        },

        /**
         * @inheritDoc
         */
        setStoredSetting: function(key, value) {
          var anchor = this.getNodeBindings().anchor;
          var columnIndex = anchor.getParentNode().getChildren("TableColumn").indexOf(anchor);
          anchor.getParentNode().getController().setStoredSetting("columns.col" + columnIndex +
            "." + key, value);
        },

        /**
         * @inheritDoc
         */
        getStoredSetting: function(key) {
          var anchor = this.getNodeBindings().anchor;
          var columnIndex = anchor.getParentNode().getChildren("TableColumn").indexOf(anchor);
          return anchor.getParentNode().getController().getStoredSetting("columns.col" + columnIndex +
            "." + key);
        }
      };
    });
    cls.ControllerFactory.register("TableColumn", cls.TableColumnController);

  });
;
"use strict";

modulum('TableController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class TableController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.TableController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.TableController.prototype */ {
        __name: "TableController",

        _storedSettingsKey: null,

        // specific variables used for multirow selection
        multiRowSelectionRoot: -1,
        updateMultiRowSelectionRoot: false,

        _isListView: false,

        forceDefaultSettings: false,
        nativeVerticalScroll: true,

        /**
         * @param {ControllerBindings} bindings
         */
        constructor: function(bindings) {
          this._isListView = bindings.anchor._initialStyleAttributes.tableType === "listView";
          $super.constructor.call(this, bindings);
          this._initStoredSettings();
        },

        /**
         * @inheritDoc
         */
        _createWidget: function(type) {
          var parentPageWidget = null;
          var uiWidget = this.getUINode().getController().getWidget();
          var parentPageNode = this.getAnchorNode().getAncestor("Page");
          if (parentPageNode) {
            parentPageWidget = parentPageNode.getController().getWidget();
          }

          return cls.WidgetFactory.createWidget('Table', {
            appHash: this.getAnchorNode().getApplication().applicationHash,
            appWidget: this.getAnchorNode().getApplication().getUI().getWidget(),
            auiTag: this.getAnchorNode().getId(),
            uiWidget: uiWidget,
            folderPageWidget: parentPageWidget
          }, this.getAnchorNode());
        },

        /**
         * Initialize Stored Setting
         * @private
         */
        _initStoredSettings: function() {
          var node = this.getNodeBindings().anchor;

          // Build stored settings key
          var formName = node.getAncestor("Form").attribute("name");
          var tabName = node.attribute("tabName");
          this._storedSettingsKey = "gwc.forms." + formName + ".tables." + tabName;

          //Check if there are stored settings with a wrong validation key
          var validationKey = this.getStoredSettingsValidationKey();
          var storedValidationKey = this.getStoredSetting("validationKey");

          if (!!storedValidationKey && storedValidationKey !== validationKey) {
            // in this case remove stored settings because the validationKey doesn't match
            gbc.StoredSettingsService.removeSettings(this._storedSettingsKey);
          }

          this.setStoredSetting("validationKey", validationKey);
        },

        /**
         * @inheritDoc
         */
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.LayoutInfoVMBehavior);
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // pseudo-selector behaviors
          this._addBehavior(cls.FocusCurrentCellPseudoSelectorBehavior);
          this._addBehavior(cls.OffsetPseudoSelectorBehavior);
          this._addBehavior(cls.Reverse4STBehavior);

          // vm behaviors
          this._addBehavior(cls.TableDialogTypeVMBehavior);
          if (this._isListView) { // This behavior creates widgets it's better to call it before other behaviors
            this._addBehavior(cls.ListViewPageSizeVMBehavior);
          }
          this._addBehavior(cls.EnabledVMBehavior);
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.ColorVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.FocusOnFieldVMBehavior);
          this._addBehavior(cls.TableCurrentVMBehavior);
          this._addBehavior(cls.VisibleRowsVMBehavior);
          this._addBehavior(cls.MultiRowSelectionVMBehavior);
          this._addBehavior(cls.TableSortVMBehavior);
          this._addBehavior(cls.NativeScrollVMBehavior);
          this._addBehavior(cls.WantFixedPageSizeVMBehavior);
          this._addBehavior(cls.PageSizeVMBehavior);

          // ui behaviors
          this._addBehavior(cls.ScrollUIBehavior);
          this._addBehavior(cls.OnLayoutUIBehavior);
          this._addBehavior(cls.RowAndSelectionUIBehavior);
          this._addBehavior(cls.TableFrozenUIBehavior);
          this._addBehavior(cls.TableResetToDefaultUIBehavior);
          this._addBehavior(cls.TableCopyCurrentUIBehavior);
          this._addBehavior(cls.RequestFocusUIBehavior);
          if (this._isListView) {
            this._addBehavior(cls.RowActionUIBehavior); // for normal table rowaction behavior is on tablecolumncontroller
          }

          // 4st behaviors
          this._addBehavior(cls.TableType4STBehavior);
          this._addBehavior(cls.FrozenColumns4STBehavior);
          this._addBehavior(cls.TableHeader4STBehavior);
          this._addBehavior(cls.ShowGrid4STBehavior);
          this._addBehavior(cls.AllowWebSelection4STBehavior);
          this._addBehavior(cls.Highlight4STBehavior);
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.ForceDefaultSettings4STBehavior);
          this._addBehavior(cls.ResizeFillsEmptySpace4STBehavior);
          this._addBehavior(cls.RowActionTrigger4STBehavior);
          this._addBehavior(cls.ReduceFilter4STBehavior);
        },

        /**
         * Build row selection event
         * @param {number} row - row selected
         * @param {boolean} ctrlKey - true if ctrl key is pressed
         * @param {boolean} shiftKey - true if shift key is pressed
         * @returns {object} row selection event
         */
        buildRowSelectionEvent: function(row, ctrlKey, shiftKey) {

          var node = this.getNodeBindings().anchor;
          var startIndex = row;
          var endIndex = row;
          var mode = "set";

          if (shiftKey) {
            if (this.multiRowSelectionRoot === -1) {
              this.multiRowSelectionRoot = node.attribute('currentRow');
            }

            startIndex = this.multiRowSelectionRoot;
            endIndex = row;
            mode = ctrlKey ? "exset" : "set";

            this.updateMultiRowSelectionRoot = false;
          } else if (ctrlKey) {
            var children = node.getChildren();
            var rowInfoListNode = children[children.length - 1];
            var rowInfoNode = rowInfoListNode.getChildren()[row - node.attribute('offset')];
            mode = rowInfoNode.attribute('selected') === 1 ? "unset" : "exset";
          }

          return new cls.VMRowSelectionEvent(node.getId(), {
            startIndex: startIndex,
            endIndex: endIndex,
            selectionMode: mode
          });
        },

        /**
         * @inheritDoc
         */
        setFocus: function() {
          var widget = this.getWidget();
          if (widget.isInputMode()) {
            widget = this.getCurrentInternalWidget();
          } else {
            var showFilter = (widget.hasReduceFilter() && !widget.isTreeView());
            // show filter menu item from chrome bar
            var filterAttribute = this.getAnchorNode().attribute("filter");
            this.getUINode().getController().getWidget().showChromeBarFilterMenuItem(showFilter, filterAttribute);
          }

          if (widget) {
            widget.setFocus();
          }
        },

        /**
         * @inheritDoc
         */
        sendWidgetValue: function(dirty) {
          var valueNode = this.getAnchorNode().getCurrentValueNode(true);
          if (valueNode) {
            valueNode.getController().sendWidgetValue(dirty);
          }
        },

        /**
         * Build and return validationKey for stored settings
         * @returns {string} validationKey
         */
        getStoredSettingsValidationKey: function() {
          var anchor = this.getNodeBindings().anchor;
          var validationKey = "";

          validationKey += anchor.attribute("pageSize") + ";";
          validationKey += anchor.attribute("sortColumn") + ";";
          validationKey += anchor.attribute("sortType") + ";";

          var columns = anchor.getChildren("TableColumn");
          for (var i = 0; i < columns.length; i++) {
            var column = columns[i];
            validationKey += column.getFirstChild().attribute("width") + ";";
          }

          if (anchor.getStyleAttribute("tableType") === "frozenTable") {
            validationKey += anchor.getStyleAttribute("leftFrozenColumns") + ";";
            validationKey += anchor.getStyleAttribute("rightFrozenColumns") + ";";
          }

          return validationKey;
        },

        /**
         * @inheritDoc
         */
        setStoredSetting: function(key, value) {
          if (this.forceDefaultSettings) {
            return null;
          } else {
            gbc.StoredSettingsService.setSettings(this._storedSettingsKey + "." + key, value);
          }
        },

        /**
         * @inheritDoc
         */
        getStoredSetting: function(key) {
          if (this.forceDefaultSettings) {
            return null;
          } else {
            return gbc.StoredSettingsService.getSettings(this._storedSettingsKey + "." + key);
          }
        },

        /**
         * Reset Stored Setting
         */
        resetStoredSetting: function() {
          if (!this.forceDefaultSettings) {
            gbc.StoredSettingsService.setSettings(this._storedSettingsKey, {}, true);
          }
        },

        /**
         * Returns if table should be rendered as a listview
         * @returns {boolean}
         */
        isListView: function() {
          return this._isListView;
        },

        /**
         * @inheritDoc
         */
        ensureVisible: function(executeAction) {
          var widget = this.getAnchorNode().getWidget();
          widget.emit(context.constants.widgetEvents.splitViewChange, widget);
          return $super.ensureVisible.call(this, executeAction);
        }
      };
    });
    cls.ControllerFactory.register("Table", cls.TableController);

  });
;
"use strict";

modulum('TreeItemController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class TreeItemController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.TreeItemController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.TreeItemController.prototype */ {
        __name: "TreeItemController",

        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // 4st behaviors

          // vm behaviors
          this._addBehavior(cls.TreeItemDecorationVMBehavior);
        },

        createWidget: function() {
          // TreeItems don't create own widgets, they simply act on the corresponding table column
          return null;
        }
      };
    });
    cls.ControllerFactory.register("TreeItem", cls.TreeItemController);
  });
;
"use strict";

modulum('UserInterfaceController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class UserInterfaceController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.UserInterfaceController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.UserInterfaceController.prototype */ {
        __name: "UserInterfaceController",
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.LayoutInfoVMBehavior);
          // END WARNING

          // vm behaviors
          this._addBehavior(cls.FocusPseudoSelectorBehavior);
          this._addBehavior(cls.RuntimeStatusVMBehavior);
          this._addBehavior(cls.ApplicationTitleVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.CurrentWindowVMBehavior);
          this._addBehavior(cls.StartMenuPositionUIBehavior);
          this._addBehavior(cls.ImageVMBehavior);
          this._addBehavior(cls.DBDateVMBehavior);
          this._addBehavior(cls.CurrentTitleVMBehavior);

          // 4st behaviors
          this._addBehavior(cls.Reverse4STBehavior);
          this._addBehavior(cls.BrowserMultiPage4STBehavior);

        },
        _createWidget: function(type) {
          var widget = $super._createWidget.call(this, type);
          widget.setSidebarWidget(this.getNodeBindings().anchor.getApplication().getUI().getWidget().getSidebarWidget());

          // Hack to prevent firefox to relayout and change richtext cursors
          var messageWidget = widget.getMessageWidget();
          messageWidget.setDummyMessage();
          widget.addChildWidget(messageWidget);

          return widget;
        }
      };
    });
    cls.ControllerFactory.register("UserInterface", cls.UserInterfaceController);

  });
;
"use strict";

modulum('VBoxController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class VBoxController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.VBoxController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.VBoxController.prototype */ {
        __name: "VBoxController",
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.LayoutInfoVMBehavior);
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // 4st behaviors
          this._addBehavior(cls.Reverse4STBehavior);

          // vm behaviors
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.SplitterVMBehavior);

          // ui behaviors
          this._addBehavior(cls.OnSplitterUIBehavior);
        },
        /**
         * @inheritDoc
         */
        ensureVisible: function(executeAction) {
          var widget = this.getAnchorNode().getWidget();
          widget.emit(context.constants.widgetEvents.splitViewChange, widget);
          return $super.ensureVisible.call(this, executeAction);
        }
      };
    });
    cls.ControllerFactory.register("VBox", cls.VBoxController);

  });
;
"use strict";

modulum('WindowController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class WindowController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.WindowController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.WindowController.prototype */ {
        __name: "WindowController",
        _isWidgetOwner: true,

        constructor: function(bindings) {
          $super.constructor.call(this, bindings);
        },
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.LayoutInfoVMBehavior);
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // vm behaviors
          this._addBehavior(cls.WindowTitleVMBehavior);
          this._addBehavior(cls.WindowParentVMBehavior);
          this._addBehavior(cls.ColorVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontWeightVMBehavior);
          this._addBehavior(cls.TextDecorationVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.ImageVMBehavior);
          this._addBehavior(cls.TextVMBehavior);
          this._addBehavior(cls.WindowTypeVMBehavior);
          this._addBehavior(cls.CurrentTitleVMBehavior);

          // 4st behaviors
          this._addBehavior(cls.WindowOptionClose4STBehavior);
          this._addBehavior(cls.FontStyle4STBehavior);
          this._addBehavior(cls.FontSize4STBehavior);
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.ToolBarPosition4STBehavior);
          this._addBehavior(cls.StartMenuPosition4STBehavior);
          this._addBehavior(cls.BackgroundImage4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);
          this._addBehavior(cls.Position4STBehavior); // to keep after Reverse4STBehavior

          // ui behaviors
          this._addBehavior(cls.WindowCloseUIBehavior);

          this._addBehavior(cls.Sizable4STBehavior);
          this._addBehavior(cls.TabbedContainer4STBehavior);
        },

        // TODO incompatible override
        createWidget: function() {
          var anchorNode = this.getAnchorNode();
          if (anchorNode.isTraditional()) {
            var firstTraditionalWindow = anchorNode.getFirstTraditionalWindow();
            this._isWidgetOwner = firstTraditionalWindow === anchorNode;
            if (this._isWidgetOwner) {
              this._widget = cls.WidgetFactory.createWidget("Window", {
                appHash: this.getAnchorNode().getApplication().applicationHash,
                appWidget: this.getAnchorNode().getApplication().getUI().getWidget(),
                auiTag: anchorNode.getId(),
                chromeBar: anchorNode.getParentNode().getWidget().getChromeBarWidget()
              }, anchorNode);
              this._widget.addClass("gbc_TraditionalContainerWindow");
            } else {
              this._widget = firstTraditionalWindow.getController().getWidget();
            }
          } else {
            this._widget = cls.WidgetFactory.createWidget("Window", {
              appHash: this.getAnchorNode().getApplication().applicationHash,
              appWidget: this.getAnchorNode().getApplication().getUI().getWidget(),
              auiTag: anchorNode.getId(),
              chromeBar: anchorNode.getParentNode().getWidget().getChromeBarWidget()
            }, anchorNode);
          }
          this._widget.isModal = anchorNode.isModal();

          // Hack to prevent firefox to relayout and change richtext cursors
          var messageWidget = this._widget.getMessageWidget();
          messageWidget.setDummyMessage();
          this._widget.addChildWidget(messageWidget);
        },

        setStyleBasedBehaviorsDirty: function(noUsageCheck, noRecurse) {
          $super.setStyleBasedBehaviorsDirty.call(this, noUsageCheck, noRecurse);
          this._widget.isModal = this.getAnchorNode().isModal();
        },

        attachUI: function() {
          if (this._isWidgetOwner) {
            $super.attachUI.call(this);
          }
        },

        detachUI: function() {
          if (this._isWidgetOwner) {
            $super.detachUI.call(this);
          }
        }
      };
    });
    cls.ControllerFactory.register("Window", cls.WindowController);

  });
;
"use strict";

modulum('DragDropInfoController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class DragDropInfoController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.DragDropInfoController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.DragDropInfoController.prototype */ {
        __name: "DragDropInfoController",

        /**
         * @param {ControllerBindings} bindings
         */
        constructor: function(bindings) {
          $super.constructor.call(this, bindings);

          var anchor = this.getNodeBindings().anchor;
          // vm behaviors
          this._addBehavior(cls.DndAcceptedVMBehavior);

          context.DndService.dragDropInfoNode = anchor;
          context.DndService.dndAccepted = false;
        },

        /**
         *
         */
        destroy: function() {
          $super.destroy.call(this);

          context.DndService.dragDropInfoNode = null;
          context.DndService.dndAccepted = false;
        },

        createWidget: function() {
          // DragDropInfo don't create own widgets
          return null;
        }
      };
    });
    cls.ControllerFactory.register("DragDropInfo", cls.DragDropInfoController);
  });
;
"use strict";

modulum('FunctionCallController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * FunctionCallController
     * This handle any function call from the VM
     * @class FunctionCallController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.FunctionCallController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.FunctionCallController.prototype */ {
        __name: 'FunctionCallController',

        /**
         * @inheritDoc
         */
        constructor: function(bindings) {
          $super.constructor.call(this, bindings);
          context.FrontCallService.setFunctionCallProcessing(true);

          var functionCallNode = this.getAnchorNode(),
            app = functionCallNode.getApplication();

          var moduleName = functionCallNode.attribute('moduleName').toLowerCase();
          var functionName = functionCallNode.attribute('name').toLowerCase();

          if (app.applicationInfo.ignoreFrontcallModules && app.applicationInfo.ignoreFrontcallModules.indexOf(moduleName) >= 0) {
            this.setReturnValues([]);
          } else if (context.__wrapper.isNative() && !context.__wrapper.isFrontcallURForced(moduleName, functionName)) {
            context.__wrapper.frontcall(functionCallNode.getId(), function(nativeResult) {
              if (nativeResult.status === cls.VMFunctionCallEvent.success) {
                this.setReturnValues([nativeResult.result]);
              } else if (nativeResult.status === cls.VMFunctionCallEvent.unknownModule ||
                nativeResult.status === cls.VMFunctionCallEvent.unknownFunction) {
                this.browserFrontcall(moduleName, functionName, app);
              } else if (nativeResult.status === cls.VMFunctionCallEvent.stackError) {
                this.parametersError(nativeResult.errorMessage);
              } else {
                this.runtimeError(nativeResult.errorMessage);
              }
            }.bind(this));
          } else {
            this.browserFrontcall(moduleName, functionName, app);
          }
        },

        browserFrontcall: function(moduleName, functionName, app) {
          var module = context.FrontCallService.modules[moduleName];
          if (!!module) {
            var moduleFunction = module[functionName];
            if (!!moduleFunction) {
              var result = moduleFunction.apply(this, this._parseArgs());
              // If the return value of the front call isn't an array (undefined),
              // it is up to the front-call to invoke this.setReturnValues
              // This is to implement asynchonous front-calls
              if (Array.isArray(result)) {
                this.setReturnValues(result);
              }
            } else {
              app.dvm.afterManagingCurrentOrders(function() {
                app.typeahead.functionCallResult(cls.VMFunctionCallEvent.unknownFunction);
              }.bind(this));
            }
          } else {
            app.dvm.afterManagingCurrentOrders(function() {
              app.typeahead.functionCallResult(cls.VMFunctionCallEvent.unknownModule);
            }.bind(this));
          }
        },

        /**
         * This node doesn't need to create a widget
         * @return {null}
         * @private
         */
        _createWidget: function() {
          return null;
        },

        /**
         * Parse arguments of a functionCall
         * @return {Array} - List of the parsed parameters
         * @private
         */
        _parseArgs: function() {
          var functionCallNode = this.getAnchorNode();
          var paramNodes = functionCallNode.getChildren();
          var params = [];
          for (var i = 0; i < paramNodes.length; ++i) {
            var paramNode = paramNodes[i];
            if (paramNode.getTag() === 'FunctionCallParameter') {
              if (paramNode.attribute('isNull')) {
                params.push(null);
              } else {
                var dataType = paramNode.attribute('dataType');
                var value = paramNode.attribute('value');
                if (dataType === 'INTEGER' || dataType === 'SMALLINT') {
                  params.push(parseInt(value, 10));
                } else if (dataType === 'FLOAT' || dataType === 'DOUBLE') {
                  params.push(parseFloat(value));
                } else if (dataType === 'RECORD') {
                  params.push(JSON.parse(value));
                } else if (dataType.indexOf('ARRAY') >= 0) {
                  params.push(JSON.parse(value));
                } else {
                  params.push(value);
                }
              }
            }
          }
          return params;
        },

        /**
         * The front call may call this method if a wrong number of parameters is given
         * @param message error message
         */
        parametersError: function(message) {
          var functionCallNode = this.getAnchorNode(),
            app = functionCallNode.getApplication();
          var moduleName = functionCallNode.attribute("moduleName");
          var functionName = functionCallNode.attribute("name");
          var msg = "Wrong number of parameters when invoking '" + moduleName + "." + functionName + "'";
          if (message) {
            msg += ':\n' + message;
          }
          app.dvm.afterManagingCurrentOrders(function() {
            app.typeahead.functionCallResult(cls.VMFunctionCallEvent.stackError, msg);
          });
        },

        /**
         * The front call may call this method in case of runtime errors
         * @param message error message
         */
        runtimeError: function(message) {
          var functionCallNode = this.getAnchorNode(),
            app = functionCallNode.getApplication();
          var moduleName = functionCallNode.attribute('moduleName');
          var functionName = functionCallNode.attribute('name');
          var msg = "Runtime error when invoking '" + moduleName + "." + functionName + "'";
          if (message) {
            msg += ':\n' + message;
          }
          app.dvm.afterManagingCurrentOrders(function() {
            app.typeahead.functionCallResult(cls.VMFunctionCallEvent.functionError, msg);
          });
        },

        /**
         * The front call may call this method to set the return values in asynchronous mode
         * @param result list of result values
         */
        setReturnValues: function(result) {
          for (var i = 0; i < result.length; ++i) {
            if (typeof result[i] === 'object') {
              result[i] = JSON.stringify(result[i]);
            }
          }
          var functionCallNode = this.getAnchorNode(),
            app = functionCallNode.getApplication();

          app.dvm.afterManagingCurrentOrders(function() {
            app.typeahead.functionCallResult(cls.VMFunctionCallEvent.success, null, result);
          });

        }
      };
    });
    cls.ControllerFactory.register('FunctionCall', cls.FunctionCallController);
  });
;
"use strict";

modulum('ActionController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class ActionController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.ActionController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.ActionController.prototype */ {
        __name: "ActionController",

        constructor: function(bindings) {
          $super.constructor.call(this, bindings);
        },

        /**
         * @inheritDoc
         */
        _initBehaviors: function() {
          $super._initBehaviors.call(this);
          var anchor = this.getNodeBindings().anchor;

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.LayoutInfoVMBehavior);
          // END WARNING

          // pseudo-selector behaviors
          this._addBehavior(cls.ActivePseudoSelectorBehavior);
          this._addBehavior(cls.FontStyle4STBehavior);
          this._addBehavior(cls.FontSize4STBehavior);
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);

          // vm behaviors
          this._addBehavior(cls.EnabledButtonVMBehavior);
          this._addBehavior(cls.ActionEnabledVMBehavior);
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.ColorVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontWeightVMBehavior);
          this._addBehavior(cls.TextDecorationVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.TextActionVMBehavior);
          this._addBehavior(cls.ImageVMBehavior);
          this._addBehavior(cls.TitleVMBehavior);
          if (anchor.attribute('name') === 'close') {
            this._addBehavior(cls.WindowCanCloseVMBehavior);
          }

          // ScaleIcon requires that the image is already present
          this._addBehavior(cls.ScaleIcon4STBehavior, true);

          // ui behaviors
          this._addBehavior(cls.OnClickUIBehavior);
          this._addBehavior(cls.InterruptUIBehavior);

        },

        _getWidgetType: function(kind, active) {
          var type;

          if (this.isInChromeBar()) {
            type = "ChromeBarItem";
          } else {
            type = $super._getWidgetType.call(this, kind, active);
          }
          return type;
        }
      };
    });
    cls.ControllerFactory.register("Action", cls.ActionController);

  });
;
"use strict";

modulum('ActionDefaultController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class ActionDefaultController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.ActionDefaultController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.ActionDefaultController.prototype */ {
        __name: "ActionDefaultController",

        constructor: function(bindings) {
          $super.constructor.call(this, bindings);
        },

        /**
         * @inheritDoc
         */
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // vm behaviors
          this._addBehavior(cls.ActionDefaultAcceleratorVMBehavior);
        },

        /**
         * @inheritDoc
         */
        createWidget: function() {
          return null;
        },
      };
    });
    cls.ControllerFactory.register("ActionDefault", cls.ActionDefaultController);

  });
;
"use strict";

modulum('DialogController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class DialogController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.DialogController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.DialogController.prototype */ {
        __name: "DialogController",
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.LayoutInfoVMBehavior);
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // pseudo-selector behaviors
          this._addBehavior(cls.ActivePseudoSelectorBehavior);
          // 4st behaviors
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);

          // vm behaviors
          this._addBehavior(cls.MenuEnabledVMBehavior);
          this._addBehavior(cls.ColorVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontWeightVMBehavior);
          this._addBehavior(cls.TextDecorationVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);

          // 4ST styles
          this._addBehavior(cls.ActionPanelPosition4STBehavior);
          this._addBehavior(cls.ActionPanelButtonTextAlign4STBehavior);
          this._addBehavior(cls.ActionPanelButtonTextHidden4STBehavior);
        },

        /**
         * @inheritDoc
         */
        attachUI: function() {
          if (this._widget) {
            var chromeBar = this.isInChromeBar() ? this.getUINode().getWidget().getChromeBarWidget() : false;
            if (!chromeBar) {
              this.getAnchorNode().getAncestor('Window').getController().getWidget().addMenu(this._widget);
            } else {
              chromeBar.addMenu(this._widget);
            }
          }
        }
      };
    });
    cls.ControllerFactory.register("Dialog", cls.DialogController);

  });
;
"use strict";

modulum('MenuActionController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class MenuActionController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.MenuActionController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.MenuActionController.prototype */ {
        __name: "MenuActionController",

        constructor: function(bindings) {
          $super.constructor.call(this, bindings);
        },

        _initBehaviors: function() {
          $super._initBehaviors.call(this);
          var anchor = this.getNodeBindings().anchor;

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.LayoutInfoVMBehavior);
          // END WARNING

          // pseudo-selector behaviors
          this._addBehavior(cls.ActivePseudoSelectorBehavior);
          // 4st behaviors
          this._addBehavior(cls.FontStyle4STBehavior);
          this._addBehavior(cls.FontSize4STBehavior);
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);

          // vm behaviors
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.EnabledButtonVMBehavior);
          this._addBehavior(cls.ActionEnabledVMBehavior);
          this._addBehavior(cls.ColorVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontWeightVMBehavior);
          this._addBehavior(cls.TextDecorationVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.TextActionVMBehavior);
          this._addBehavior(cls.ImageVMBehavior);
          this._addBehavior(cls.TitleVMBehavior);
          if (anchor.attribute('name') === 'close') {
            this._addBehavior(cls.WindowCanCloseVMBehavior);
          }

          // ScaleIcon requires that the image is already present
          this._addBehavior(cls.ScaleIcon4STBehavior, true);

          // ui behaviors
          this._addBehavior(cls.OnClickUIBehavior);
          this._addBehavior(cls.InterruptUIBehavior);

          // aria behaviors
          this._addBehavior(cls.NavigationAriaBehavior);

        },

        destroy: function() {
          $super.destroy.call(this);
        },

        _getWidgetType: function(kind, active) {
          var type;

          if (this.isInChromeBar()) {
            type = "ChromeBarItem";
          } else {
            type = $super._getWidgetType.call(this, kind, active);
          }
          return type;
        }

      };
    });
    cls.ControllerFactory.register("MenuAction", cls.MenuActionController);

  });
;
"use strict";

modulum('MenuController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class MenuController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.MenuController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.MenuController.prototype */ {
        __name: "MenuController",
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.LayoutInfoVMBehavior);
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // pseudo-selector behaviors
          this._addBehavior(cls.ActivePseudoSelectorBehavior);
          // 4st behaviors
          this._addBehavior(cls.FontStyle4STBehavior);
          this._addBehavior(cls.FontSize4STBehavior);
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);

          // vm behaviors
          this._addBehavior(cls.ColorVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontWeightVMBehavior);
          this._addBehavior(cls.TextDecorationVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.TextActionVMBehavior);
          this._addBehavior(cls.ImageVMBehavior);
          this._addBehavior(cls.TitleVMBehavior);
          this._addBehavior(cls.WindowTypeVMBehavior);
          this._addBehavior(cls.VisibleMenuVMBehavior);
          this._addBehavior(cls.MenuEnabledVMBehavior);

          this._addBehavior(cls.WindowCloseUIBehavior);

          // 4ST styles
          this._addBehavior(cls.ActionPanelButtonTextAlign4STBehavior);
          this._addBehavior(cls.ActionPanelButtonTextHidden4STBehavior);
          this._addBehavior(cls.RingMenuPosition4STBehavior);

        },
        attachUI: function() {
          if (this._widget) {

            var chromeBar = this.isInChromeBar() ? this.getUINode().getWidget().getChromeBarWidget() : false;
            var isDialog = this.getAnchorNode()._vmStyles.indexOf("dialog") >= 0;

            if (chromeBar && !isDialog) {
              chromeBar.addMenu(this._widget);
            } else {
              this.getAnchorNode().getAncestor('Window').getController().getWidget().addMenu(this._widget);
            }

          }
        },

        _createWidget: function(type) {
          var widget = $super._createWidget.call(this, type);
          widget._windowWidget = this.getNodeBindings().parent.getController().getWidget();
          //this._nodeBindings.container = this.getNodeBindings().parent.getController();
          return widget;
        },

      };
    });
    cls.ControllerFactory.register("Menu", cls.MenuController);

  });
;
"use strict";

modulum('StartMenuCommandController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class StartMenuCommandController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.StartMenuCommandController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.StartMenuCommandController.prototype */ {
        __name: "StartMenuCommandController",
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.LayoutInfoVMBehavior);
          // END WARNING

          // 4st behaviors
          this._addBehavior(cls.FontStyle4STBehavior);
          this._addBehavior(cls.FontSize4STBehavior);
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);

          // vm behaviors
          this._addBehavior(cls.DisabledVMBehavior);
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.ColorVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontWeightVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.TextDecorationVMBehavior);
          this._addBehavior(cls.TextActionVMBehavior);
          this._addBehavior(cls.ImageVMBehavior);
          this._addBehavior(cls.TitleVMBehavior);
          this._addBehavior(cls.TextVMBehavior);
          // ui behaviors
          this._addBehavior(cls.OnClickStartMenuCommandUIBehavior);
        },
        _getWidgetType: function(kind) {
          var parent = this.getAnchorNode().getAncestor("StartMenu");
          var type = null;
          if (parent) {
            type = parent.getController()._getWidgetType(kind) + "Command";
          }
          return type;
        }
      };
    });
    cls.ControllerFactory.register("StartMenuCommand", cls.StartMenuCommandController);

  });
;
"use strict";

modulum('StartMenuController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class StartMenuController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.StartMenuController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.StartMenuController.prototype */ {
        __name: "StartMenuController",

        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.LayoutInfoVMBehavior);
          // END WARNING
          this._addBehavior(cls.TextVMBehavior);

          // 4st behaviors
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);

          // vm behaviors
          this._addBehavior(cls.BackgroundColorVMBehavior);
        },

        _getWidgetType: function(kind) {
          var type;
          if (!kind) {
            var windowNode = this.getAnchorNode().getApplication().getVMWindow();
            if (windowNode) {
              kind = windowNode.getStyleAttribute("startMenuPosition");
            }
          }
          switch (kind) {
            case "poptree":
              // poptree isn't implemented, using tree instead
              /* falls through */
            case "tree":
              type = 'StartMenu';
              break;
            case "menu":
              type = 'TopMenu';
              break;
          }
          return type;
        },

        attachUI: function() {
          var session = this.getAnchorNode().getApplication().getSession();
          var uiWidget = this.getAnchorNode().getAncestor('UserInterface').getController().getWidget();
          // _widgetKind is probably obsolete but is kept as a security
          if (this._widgetType === "StartMenu" || this._widgetKind === "poptree" || this._widgetKind === "tree") {
            session.manageStartMenu(this.getAnchorNode(), this.getWidget());
          } else if (this._widgetType === "TopMenu" || this._widgetKind === "menu") {
            uiWidget.addTopMenu(this.getWidget(), 0, uiWidget);
          }
        },

        _detachWidgetRecursive: function(node) {
          var children = node.getChildren();
          for (var c = 0; c < children.length; c++) {
            this._detachWidgetRecursive(children[c]);
          }
          node.getController()._detachWidget();
        },

        _attachWidgetRecursive: function(node) {
          node.getController()._attachWidget();
          var children = node.getChildren();
          for (var c = 0; c < children.length; c++) {
            this._attachWidgetRecursive(children[c]);
          }
        },

        _createWidgetRecursive: function(node, kind) {
          var currentController = node.getController();
          var type = currentController._getWidgetType(kind);
          currentController._widget = currentController._createWidget(type === "TopMenu" ? "StartMenuTopMenu" : type);
          var children = node.getChildren();
          for (var c = 0; c < children.length; c++) {
            this._createWidgetRecursive(children[c], kind);
          }
        },

        _detachUIRecursive: function(node) {
          var children = node.getChildren();
          for (var c = 0; c < children.length; c++) {
            this._detachUIRecursive(children[c]);
          }
          node.getController().detachUI();
        },

        _attachUIRecursive: function(node) {
          node.getController().attachUI();
          var children = node.getChildren();
          for (var c = 0; c < children.length; c++) {
            this._attachUIRecursive(children[c]);
          }
        },

        changeWidgetKind: function(kind) {
          if (kind !== this._widgetKind) {
            this._widgetKind = kind;
            this._widgetType = this._getWidgetType(kind);
            var anchor = this.getAnchorNode();
            this._detachWidgetRecursive(anchor);
            this._detachUIRecursive(anchor);
            this._createWidgetRecursive(anchor, kind);
            this._attachUIRecursive(anchor);
            this._attachWidgetRecursive(anchor);
            anchor.applyBehaviors(null, true, true);
            return true;
          }
          return false;
        }
      };
    });
    cls.ControllerFactory.register("StartMenu", cls.StartMenuController);

  });
;
"use strict";

modulum('StartMenuGroupController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class StartMenuGroupController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.StartMenuGroupController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.StartMenuGroupController.prototype */ {
        __name: "StartMenuGroupController",
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.LayoutInfoVMBehavior);
          // END WARNING

          // 4st behaviors
          this._addBehavior(cls.FontStyle4STBehavior);
          this._addBehavior(cls.FontSize4STBehavior);
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);

          // vm behaviors
          this._addBehavior(cls.DisabledVMBehavior);
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.ColorVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontWeightVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.TextDecorationVMBehavior);
          this._addBehavior(cls.TextVMBehavior);
          this._addBehavior(cls.ImageVMBehavior);
        },
        _getWidgetType: function(kind) {
          var parent = this.getAnchorNode().getAncestor("StartMenu");
          var type = null;
          if (parent) {
            type = parent.getController()._getWidgetType(kind) + "Group";
          }
          return type;
        }
      };
    });
    cls.ControllerFactory.register("StartMenuGroup", cls.StartMenuGroupController);

  });
;
"use strict";

modulum('StartMenuSeparatorController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class StartMenuSeparatorController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.StartMenuSeparatorController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.StartMenuSeparatorController.prototype */ {
        __name: "StartMenuSeparatorController",
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.LayoutInfoVMBehavior);
          // END WARNING

          // 4st behaviors
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);

          // vm behaviors
          this._addBehavior(cls.ColorVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
        },
        _getWidgetType: function(kind) {
          var type;
          switch (kind) {
            case "poptree":
              // poptree isn't implemented, using tree instead
              /* falls through */
            case "tree":
              type = 'StartMenuSeparator';
              break;
            case "menu":
              type = 'TopMenuSeparator';
              break;
          }
          return type;
        }
      };
    });
    cls.ControllerFactory.register("StartMenuSeparator", cls.StartMenuSeparatorController);

  });
;
"use strict";

modulum('ToolBarController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class ToolBarController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.ToolBarController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.ToolBarController.prototype */ {
        __name: "ToolBarController",
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.LayoutInfoVMBehavior);
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // 4st behaviors
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);

          // vm behaviors
          if (this.getAnchorNode().getParentNode().getTag() === 'Form') {
            this._addBehavior(cls.FormRelatedHiddenVMBehavior);
          }
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.ButtonTextHiddenVMBehavior);
        },

        /**
         * @inheritDoc
         */
        attachUI: function() {
          var parentNode = this.getAnchorNode().getParentNode();
          while (parentNode) {
            var controller = parentNode.getController();
            if (controller) {
              var widget = controller.getWidget();
              if (widget && widget.addToolBar) {
                var order = this.getAnchorNode().getParentNode().getTag() === 'Form' ? 1 : 0;

                var chromeBar = this.isInChromeBar() ? this.getUINode().getWidget().getChromeBarWidget() : false;

                // Ensure the form widget is correctly associated to the toolbar
                // This is done here, because when we set the toolbar allocated width, we need the parent form layout info
                // Those info are not available yet since the link between the toolbar and the form doesn't exist
                this.getWidget().setFormWidget(this.getAnchorNode().getParentNode().getWidget());

                if (!chromeBar) {
                  widget.addToolBar(this.getWidget(), order, widget);
                } else {
                  chromeBar.addToolBar(this.getWidget(), order);
                }

                break;
              }
            }
            parentNode = parentNode.getParentNode();
          }
        },

        detachUI: function() {
          var winNode = this.getAnchorNode().getAncestor('Window');
          if (!!winNode) {
            var winWidget = winNode.getController().getWidget();
            winWidget.removeToolBar(this.getWidget());
          }

          $super.detachUI.call(this);
        },

        destroy: function() {
          if (this._afterLayoutHandler) {
            this._afterLayoutHandler();
          }
          $super.destroy.call(this);
        }

      };
    });
    cls.ControllerFactory.register("ToolBar", cls.ToolBarController);
  });
;
"use strict";

modulum('ToolBarItemController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class ToolBarItemController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.ToolBarItemController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.ToolBarItemController.prototype */ {
        __name: "ToolBarItemController",
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.LayoutInfoVMBehavior);
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // 4st behaviors
          this._addBehavior(cls.FontStyle4STBehavior);
          this._addBehavior(cls.FontSize4STBehavior);
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.TextPosition4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);

          // vm behaviors
          this._addBehavior(cls.EnabledButtonVMBehavior);
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.ColorVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontWeightVMBehavior);
          this._addBehavior(cls.TextDecorationVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.ImageVMBehavior);
          this._addBehavior(cls.TitleVMBehavior);
          this._addBehavior(cls.TextActionVMBehavior);

          // ScaleIcon requires that the image is already present
          this._addBehavior(cls.ScaleIcon4STBehavior, true);

          // ui behaviors
          this._addBehavior(cls.OnClickUIBehavior);
          this._addBehavior(cls.InterruptUIBehavior);
        },

        _getWidgetType: function(kind, active) {
          var type;
          var chromeBarTheme = this.isInChromeBar();

          if (chromeBarTheme) {
            type = "ChromeBarItem";
          } else {
            type = $super._getWidgetType.call(this, kind, active);
          }
          return type;
        }
      };
    });
    cls.ControllerFactory.register("ToolBarItem", cls.ToolBarItemController);

  });
;
"use strict";

modulum('ToolBarSeparatorController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class ToolBarSeparatorController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.ToolBarSeparatorController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.ToolBarSeparatorController.prototype */ {
        __name: "ToolBarSeparatorController",
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.LayoutInfoVMBehavior);
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // 4st behaviors
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);

          // vm behaviors
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.ColorVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
        }
      };
    });
    cls.ControllerFactory.register("ToolBarSeparator", cls.ToolBarSeparatorController);

  });
;
"use strict";

modulum('TopMenuCommandController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class TopMenuCommandController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.TopMenuCommandController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.TopMenuCommandController.prototype */ {
        __name: "TopMenuCommandController",

        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.LayoutInfoVMBehavior);
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // 4st behaviors
          this._addBehavior(cls.FontStyle4STBehavior);
          this._addBehavior(cls.FontSize4STBehavior);
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);

          // vm behaviors
          this._addBehavior(cls.EnabledButtonVMBehavior);
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.FontWeightVMBehavior);
          this._addBehavior(cls.TextDecorationVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.TextActionVMBehavior);
          this._addBehavior(cls.ImageVMBehavior);
          this._addBehavior(cls.TitleVMBehavior);
          // ui behaviors
          this._addBehavior(cls.OnClickUIBehavior);
          this._addBehavior(cls.InterruptUIBehavior);
        }
      };
    });
    cls.ControllerFactory.register("TopMenuCommand", cls.TopMenuCommandController);

  });
;
"use strict";

modulum('TopMenuController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class TopMenuController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.TopMenuController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.TopMenuController.prototype */ {
        __name: "TopMenuController",
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.LayoutInfoVMBehavior);
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // 4st behaviors
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);

          // vm behaviors
          if (this.getAnchorNode().getParentNode().getTag() === 'Form') {
            this._addBehavior(cls.FormRelatedHiddenVMBehavior);
          }
          this._addBehavior(cls.BackgroundColorVMBehavior);

        },
        attachUI: function() {
          var parentNode = this.getAnchorNode().getParentNode();
          while (parentNode) {
            var controller = parentNode.getController();
            if (controller) {
              var widget = controller.getWidget();
              if (widget && widget.addTopMenu) {
                var containerWidget = widget;
                // only topmenu from modal is being added inside modal
                if (!parentNode.isModal || !parentNode.isModal()) { // if parent isn't a modal
                  containerWidget = this.getAnchorNode().getAncestor('UserInterface').getController().getWidget();
                }
                var isUnderForm = this.getAnchorNode().getParentNode().getTag() === 'Form';
                var order = isUnderForm ? 2 : 1;
                widget.addTopMenu(this.getWidget(), order, containerWidget);
                break;
              }
            }
            parentNode = parentNode.getParentNode();
          }
        },
        detachUI: function() {
          var winNode = this.getAnchorNode().getAncestor('Window');
          if (!!winNode) {
            var winWidget = winNode.getController().getWidget();
            winWidget.removeTopMenu(this.getWidget());
          }

          $super.detachUI.call(this);
        }
      };
    });
    cls.ControllerFactory.register("TopMenu", cls.TopMenuController);

  });
;
"use strict";

modulum('TopMenuGroupController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class TopMenuGroupController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.TopMenuGroupController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.TopMenuGroupController.prototype */ {
        __name: "TopMenuGroupController",
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.LayoutInfoVMBehavior);
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // 4st behaviors
          this._addBehavior(cls.FontStyle4STBehavior);
          this._addBehavior(cls.FontSize4STBehavior);
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);

          // vm behaviors
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.ColorVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontWeightVMBehavior);
          this._addBehavior(cls.TextDecorationVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.ImageVMBehavior);
          this._addBehavior(cls.TextActionVMBehavior);
        }
      };
    });
    cls.ControllerFactory.register("TopMenuGroup", cls.TopMenuGroupController);

  });
;
"use strict";

modulum('TopMenuSeparatorController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class TopMenuSeparatorController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.TopMenuSeparatorController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.TopMenuSeparatorController.prototype */ {
        __name: "TopMenuSeparatorController",
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.LayoutInfoVMBehavior);
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // 4st behaviors
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);

          // vm behaviors
          this._addBehavior(cls.HiddenVMBehavior);
        }
      };
    });
    cls.ControllerFactory.register("TopMenuSeparator", cls.TopMenuSeparatorController);

  });
;
"use strict";

modulum('ButtonController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class ButtonController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.ButtonController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.ButtonController.prototype */ {
        __name: "ButtonController",
        _imageReadyHandler: null,
        /**
         * @param {ControllerBindings} bindings
         */
        constructor: function(bindings) {
          this.scrollGridLineController = bindings.additionalBindings && bindings.additionalBindings.scrollGridLineController;

          $super.constructor.call(this, bindings);
        },

        destroy: function() {
          if (this._imageReadyHandler) {
            this._imageReadyHandler();
            this._imageReadyHandler = null;
          }
          $super.destroy.call(this);
        },

        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.LayoutInfoVMBehavior);
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // pseudo-selector behaviors
          this._addBehavior(cls.ActivePseudoSelectorBehavior);
          this._addBehavior(cls.FontStyle4STBehavior);
          this._addBehavior(cls.FontSize4STBehavior);
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.ButtonType4STBehavior);
          this._addBehavior(cls.DefaultTTFColor4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);

          this._addBehavior(cls.Alignment4STBehavior);
          this._addBehavior(cls.TextButtonVMBehavior);
          this._addBehavior(cls.ImageVMBehavior);

          // vm behaviors
          this._addBehavior(cls.EnabledButtonVMBehavior);
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.ColorVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontWeightVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.TextDecorationVMBehavior);

          this._addBehavior(cls.TitleVMBehavior);

          // ScaleIcon requires that the image is already present
          this._addBehavior(cls.ScaleIcon4STBehavior, false);

          // ui behaviors
          if (this.scrollGridLineController) {
            this._addBehavior(cls.ButtonRequestFocusUIBehavior);
          }
          this._addBehavior(cls.OnClickUIBehavior);
          this._addBehavior(cls.InterruptUIBehavior);
        },
        _createWidget: function(type) {
          if (this._imageReadyHandler) {
            this._imageReadyHandler();
            this._imageReadyHandler = null;
          }
          var button = $super._createWidget.call(this, type);
          this._imageReadyHandler = button.when(context.constants.widgetEvents.ready, this._imageLoaded.bind(this));
          return button;
        },
        _imageLoaded: function(event, src, hasMeasure) {
          if (!hasMeasure) {
            this.getWidget().getLayoutEngine().forceMeasurement();
            this.getAnchorNode().getApplication().getUI().getWidget().getLayoutInformation().invalidateMeasure();
          }
          this.getAnchorNode().getApplication().layout.refreshLayout();
        }
      };
    });
    cls.ControllerFactory.register("Button", cls.ButtonController);

  });
;
"use strict";

modulum('ButtonEditController', ['ValueContainerControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class ButtonEditController
     * @memberOf classes
     * @extends classes.ValueContainerControllerBase
     */
    cls.ButtonEditController = context.oo.Class(cls.ValueContainerControllerBase, function($super) {
      return /** @lends classes.ButtonEditController.prototype */ {
        __name: "ButtonEditController",
        _imageReadyHandler: null,

        /**
         * @constructs
         * @param {ControllerBindings} bindings
         */
        constructor: function(bindings) {
          $super.constructor.call(this, bindings);
          this._setCompleterBindings(bindings);
        },

        destroy: function() {
          if (this._imageReadyHandler) {
            this._imageReadyHandler();
            this._imageReadyHandler = null;
          }
          $super.destroy.call(this);
        },

        _setCompleterBindings: function(bindings) {
          if (this.isInMatrix() || this.isInTable()) {
            bindings.completer = bindings.container._children[0]._children[0];
          } else {
            bindings.completer = bindings.decorator._children[0];
          }
        },

        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.DialogTypeVMBehavior);
          if (this.isInTable()) {
            this._addBehavior(cls.TableSizeVMBehavior);
          }
          if (!this.isInTable() || this.isInFirstTableRow()) {
            this._addBehavior(cls.LayoutInfoVMBehavior);
          }
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // pseudo-selector behaviors
          this._addBehavior(cls.ActivePseudoSelectorBehavior);
          this._addBehavior(cls.DialogTypePseudoSelectorBehavior);
          if (this.isInMatrix()) {
            this._addBehavior(cls.MatrixCurrentRowVMBehavior);
          }
          this._addBehavior(cls.FontStyle4STBehavior);
          this._addBehavior(cls.FontSize4STBehavior);
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);

          // vm behaviors
          this._addBehavior(cls.EnabledVMBehavior);
          this._addBehavior(cls.FieldButtonEnabledVMBehavior);
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.ColorVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontWeightVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.TextAlignVMBehavior);
          this._addBehavior(cls.TextTransformVMBehavior);
          this._addBehavior(cls.TextDecorationVMBehavior);
          this._addBehavior(cls.DisplayFormatVMBehavior); // must be set before value
          this._addBehavior(cls.ValueVMBehavior);
          this._addBehavior(cls.IsPasswordVMBehavior);
          this._addBehavior(cls.MaxLengthVMBehavior);
          this._addBehavior(cls.ImageVMBehavior);
          this._addBehavior(cls.CursorsVMBehavior);
          this._addBehavior(cls.TitleVMBehavior);
          this._addBehavior(cls.CompleterVMBehavior);
          this._addBehavior(cls.PictureVMBehavior);
          this._addBehavior(cls.PlaceholderVMBehavior);
          this._addBehavior(cls.TextActionVMBehavior);
          //Field Validation
          this._addBehavior(cls.NotNullVMBehavior);
          this._addBehavior(cls.RequiredVMBehavior);
          this._addBehavior(cls.IncludeVMBehavior);

          // ScaleIcon requires that the image is already present
          this._addBehavior(cls.ScaleIcon4STBehavior, false);

          // ui behaviors
          this._addBehavior(cls.SendValueUIBehavior);
          this._addBehavior(cls.RequestFocusUIBehavior);
          this._addBehavior(cls.OnClickUIBehavior);

          if (this.isInTable()) {
            this._addBehavior(cls.TableImageVMBehavior);
            this._addBehavior(cls.RowSelectionUIBehavior);
            this._addBehavior(cls.TableItemCurrentRowVMBehavior);
          }
        },
        _getWidgetType: function(kind) {
          var type;
          if (kind === "Construct") {
            type = "DummyButtonEdit";
          } else {
            type = $super._getWidgetType.call(this, kind);
          }
          return type;
        },
        _createWidget: function(type) {
          if (this._imageReadyHandler) {
            this._imageReadyHandler();
            this._imageReadyHandler = null;
          }
          var buttonEdit = $super._createWidget.call(this, type);
          this._imageReadyHandler = buttonEdit.when(context.constants.widgetEvents.ready, this._imageLoaded.bind(this));
          return buttonEdit;
        },
        _imageLoaded: function(event, src, hasMeasure) {
          if (!hasMeasure) {
            this.getWidget().getLayoutEngine().forceMeasurement();
            this.getAnchorNode().getApplication().getUI().getWidget().getLayoutInformation().invalidateMeasure();
          }
          this.getAnchorNode().getApplication().layout.refreshLayout();
        }
      };
    });
    cls.ControllerFactory.register("ButtonEdit", cls.ButtonEditController);

  });
;
"use strict";

modulum('CheckBoxController', ['ValueContainerControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class CheckBoxController
     * @memberOf classes
     * @extends classes.ValueContainerControllerBase
     */
    cls.CheckBoxController = context.oo.Class(cls.ValueContainerControllerBase, function($super) {
      return /** @lends classes.CheckBoxController.prototype */ {
        __name: "CheckBoxController",
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.DialogTypeVMBehavior);
          if (this.isInTable()) {
            this._addBehavior(cls.TableSizeVMBehavior);
          }
          if (!this.isInTable() || this.isInFirstTableRow()) {
            this._addBehavior(cls.LayoutInfoVMBehavior);
          }
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // pseudo-selector behaviors
          this._addBehavior(cls.ActivePseudoSelectorBehavior);
          this._addBehavior(cls.DialogTypePseudoSelectorBehavior);
          if (this.isInMatrix()) {
            this._addBehavior(cls.MatrixCurrentRowVMBehavior);
          }
          this._addBehavior(cls.FontStyle4STBehavior);
          this._addBehavior(cls.FontSize4STBehavior);
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);

          // vm behaviors
          this._addBehavior(cls.EnabledVMBehavior);
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.ColorVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontWeightVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.TextDecorationVMBehavior);
          this._addBehavior(cls.TextVMBehavior);
          this._addBehavior(cls.ValueVMBehavior);
          this._addBehavior(cls.CheckBoxValuesVMBehavior);
          this._addBehavior(cls.TitleVMBehavior);
          //Field Validation
          this._addBehavior(cls.NotNullVMBehavior);
          this._addBehavior(cls.RequiredVMBehavior);
          this._addBehavior(cls.IncludeVMBehavior);
          // ui behaviors
          this._addBehavior(cls.SendValueUIBehavior);
          this._addBehavior(cls.RequestFocusUIBehavior);
          if (this.isInTable()) {
            this._addBehavior(cls.TableImageVMBehavior);
            this._addBehavior(cls.RowSelectionUIBehavior);
            this._addBehavior(cls.TableItemCurrentRowVMBehavior);
          }
        },
        _createWidget: function(type) {
          var checkBox = $super._createWidget.call(this, type);

          if (checkBox.setCheckedValue) {
            checkBox.setCheckedValue(this.getNodeBindings().decorator.attribute("valueChecked"));
          }
          if (checkBox.setUncheckedValue) {
            checkBox.setUncheckedValue(this.getNodeBindings().decorator.attribute("valueUnchecked"));
          }
          if (checkBox.setIndeterminateValue) {
            checkBox.setIndeterminateValue('');
          }
          return checkBox;
        }
      };
    });
    cls.ControllerFactory.register("CheckBox", cls.CheckBoxController);

  });
;
"use strict";

modulum('ComboBoxController', ['ValueContainerControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class ComboBoxController
     * @memberOf classes
     * @extends classes.ValueContainerControllerBase
     */
    cls.ComboBoxController = context.oo.Class(cls.ValueContainerControllerBase, function($super) {
      return /** @lends classes.ComboBoxController.prototype */ {
        __name: "ComboBoxController",
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.DialogTypeVMBehavior);
          if (this.isInTable()) {
            this._addBehavior(cls.TableSizeVMBehavior);
          }
          if (!this.isInTable() || this.isInFirstTableRow()) {
            this._addBehavior(cls.LayoutInfoVMBehavior);
          }
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // pseudo-selector behaviors
          this._addBehavior(cls.ActivePseudoSelectorBehavior);
          this._addBehavior(cls.DialogTypePseudoSelectorBehavior);
          if (this.isInMatrix()) {
            this._addBehavior(cls.MatrixCurrentRowVMBehavior);
          }
          // 4st behaviors
          this._addBehavior(cls.FontStyle4STBehavior);
          this._addBehavior(cls.FontSize4STBehavior);
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);
          // vm behaviors
          this._addBehavior(cls.EnabledVMBehavior);
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.ColorVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontWeightVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.TextTransformVMBehavior);
          this._addBehavior(cls.TextDecorationVMBehavior);
          // QueryEditableVMBehavior must be executed before ItemVMBehavior & ValueVMBehavior
          // in order to set value default value on proper widget
          this._addBehavior(cls.QueryEditableVMBehavior);
          this._addBehavior(cls.ItemVMBehavior);
          this._addBehavior(cls.ValueVMBehavior);
          this._addBehavior(cls.TitleVMBehavior);
          this._addBehavior(cls.PlaceholderVMBehavior);
          //Field Validation
          this._addBehavior(cls.NotNullVMBehavior);
          this._addBehavior(cls.RequiredVMBehavior);
          this._addBehavior(cls.IncludeVMBehavior);

          // ui behaviors
          this._addBehavior(cls.SendValueUIBehavior);
          this._addBehavior(cls.RequestFocusUIBehavior);
          if (this.isInTable()) {
            this._addBehavior(cls.TableImageVMBehavior);
            this._addBehavior(cls.RowSelectionUIBehavior);
            this._addBehavior(cls.TableItemCurrentRowVMBehavior);
          }
        }
      };
    });
    cls.ControllerFactory.register("ComboBox", cls.ComboBoxController);

  });
;
"use strict";

modulum('DateEditController', ['ValueContainerControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class DateEditController
     * @memberOf classes
     * @extends classes.ValueContainerControllerBase
     */
    cls.DateEditController = context.oo.Class(cls.ValueContainerControllerBase, function($super) {
      return /** @lends classes.DateEditController.prototype */ {
        __name: "DateEditController",
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.DialogTypeVMBehavior);
          if (this.isInTable()) {
            this._addBehavior(cls.TableSizeVMBehavior);
          }
          if (!this.isInTable() || this.isInFirstTableRow()) {
            this._addBehavior(cls.LayoutInfoVMBehavior);
          }
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // pseudo-selector behaviors
          this._addBehavior(cls.ActivePseudoSelectorBehavior);
          this._addBehavior(cls.DialogTypePseudoSelectorBehavior);
          if (this.isInMatrix()) {
            this._addBehavior(cls.MatrixCurrentRowVMBehavior);
          }
          // 4st behaviors
          this._addBehavior(cls.FontStyle4STBehavior);

          this._addBehavior(cls.FontSize4STBehavior);
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.FirstDayOfWeek4STBehavior);
          this._addBehavior(cls.DaysOff4STBehavior);
          this._addBehavior(cls.ShowWeekNumber4STBehavior);
          this._addBehavior(cls.CalendarType4STBehavior);
          this._addBehavior(cls.ButtonIcon4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);

          // vm behaviors
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.ColorVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontWeightVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.TextAlignVMBehavior);
          this._addBehavior(cls.TextTransformVMBehavior);
          this._addBehavior(cls.TextDecorationVMBehavior);
          this._addBehavior(cls.CursorsVMBehavior);
          this._addBehavior(cls.TitleVMBehavior);
          this._addBehavior(cls.MaxLengthVMBehavior);
          this._addBehavior(cls.PlaceholderVMBehavior);
          //Field Validation
          this._addBehavior(cls.NotNullVMBehavior);
          this._addBehavior(cls.RequiredVMBehavior);
          this._addBehavior(cls.IncludeVMBehavior);

          /* WARNING : Format & Picture have to be set before value */
          this._addBehavior(cls.FormatVMBehavior);
          this._addBehavior(cls.PictureVMBehavior);
          this._addBehavior(cls.ValueVMBehavior);
          this._addBehavior(cls.EnabledVMBehavior);

          // ui behaviors
          this._addBehavior(cls.SendValueUIBehavior);
          this._addBehavior(cls.RequestFocusUIBehavior);
          if (this.isInTable()) {
            this._addBehavior(cls.TableImageVMBehavior);
            this._addBehavior(cls.RowSelectionUIBehavior);
            this._addBehavior(cls.TableItemCurrentRowVMBehavior);
          }
        },
        _getWidgetType: function(kind) {
          var type;
          if (kind === "Construct") {
            type = "DummyDateEdit";
          } else if (this.isInTable() && (kind === "Display" || kind === "DisplayArray")) {
            type = "Label";
          } else {
            type = $super._getWidgetType.call(this, kind);
          }
          return type;
        }
      };
    });
    cls.ControllerFactory.register("DateEdit", cls.DateEditController);

  });
;
"use strict";

modulum('DateTimeEditController', ['ValueContainerControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class DateTimeEditController
     * @memberOf classes
     * @extends classes.ValueContainerControllerBase
     */
    cls.DateTimeEditController = context.oo.Class(cls.ValueContainerControllerBase, function($super) {
      return /** @lends classes.DateTimeEditController.prototype */ {
        __name: "DateTimeEditController",
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.DialogTypeVMBehavior);
          if (this.isInTable()) {
            this._addBehavior(cls.TableSizeVMBehavior);
          }
          if (!this.isInTable() || this.isInFirstTableRow()) {
            this._addBehavior(cls.LayoutInfoVMBehavior);
          }
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // pseudo-selector behaviors
          this._addBehavior(cls.ActivePseudoSelectorBehavior);
          this._addBehavior(cls.DialogTypePseudoSelectorBehavior);
          if (this.isInMatrix()) {
            this._addBehavior(cls.MatrixCurrentRowVMBehavior);
          }
          // 4st behaviors
          this._addBehavior(cls.FontStyle4STBehavior);
          this._addBehavior(cls.FontSize4STBehavior);
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.FirstDayOfWeek4STBehavior);
          this._addBehavior(cls.DaysOff4STBehavior);
          this._addBehavior(cls.ShowWeekNumber4STBehavior);
          this._addBehavior(cls.ButtonIcon4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);

          // vm behaviors

          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.ColorVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontWeightVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.TextAlignVMBehavior);
          this._addBehavior(cls.TextTransformVMBehavior);
          this._addBehavior(cls.TextDecorationVMBehavior);
          this._addBehavior(cls.DateTimeValueVMBehavior);
          this._addBehavior(cls.CursorsVMBehavior);
          this._addBehavior(cls.TitleVMBehavior);
          this._addBehavior(cls.MaxLengthVMBehavior);
          this._addBehavior(cls.EnabledVMBehavior);
          this._addBehavior(cls.PlaceholderVMBehavior);
          //Field Validation
          this._addBehavior(cls.NotNullVMBehavior);
          this._addBehavior(cls.RequiredVMBehavior);
          this._addBehavior(cls.IncludeVMBehavior);

          // ui behaviors
          this._addBehavior(cls.SendValueUIBehavior);
          this._addBehavior(cls.RequestFocusUIBehavior);
          if (this.isInTable()) {
            this._addBehavior(cls.TableImageVMBehavior);
            this._addBehavior(cls.RowSelectionUIBehavior);
            this._addBehavior(cls.TableItemCurrentRowVMBehavior);
          }
        },

        _getWidgetType: function(kind) {
          var type;
          if (kind === "Construct") {
            type = "DummyDateTimeEdit";
          } else if (this.isInTable() && (kind === "Display" || kind === "DisplayArray")) {
            type = "Label";
          } else {
            type = $super._getWidgetType.call(this, kind);
          }
          return type;
        },

        _isConstruct: function() {
          return this.getNodeBindings().container.attribute('dialogType') === "Construct";
        },

        /**
         * Strategy method which returns widget value in VM ready format
         * @returns {string}
         * @protected
         */
        _getWidgetValue: function() {
          var anchorNode = this.getAnchorNode();
          var decoratorNode = this.getNodeBindings().decorator;
          var widget = this.getWidget();
          var value = widget.getValue();

          if (value === null || value === undefined) {
            value = "";
          } else {
            if (!this._isConstruct() && widget.getFormat) {
              value = cls.DateTimeHelper.toISOFormat(value, widget.getFormat());
            } else {
              value = value.toString();
            }
          }
          var varType = anchorNode.attribute('varType');
          if (varType && varType.startsWith('DATETIME YEAR TO FRACTION(')) {
            var start = varType.lastIndexOf('(');
            var end = varType.lastIndexOf(')');
            if (start !== -1 && end !== -1) {
              var count = parseInt(varType.substring(start + 1, end));
              if (!isNaN(count)) {
                value += '.';
                for (var i = 0; i < count; i++) {
                  value += '0';
                }
              }
            }
          }
          value = this._shiftConversion(value, widget, decoratorNode);
          return value;
        },

        /**
         * Strategy method which returns AUI value in VM ready format
         * @returns {string}
         * @protected
         */
        _getAuiValue: function() {
          var valueNode = this.getNodeBindings().anchor;
          return valueNode.attribute("value").toString();
        }
      };
    });
    cls.ControllerFactory.register("DateTimeEdit", cls.DateTimeEditController);

  });
;
"use strict";

modulum('EditController', ['ValueContainerControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class EditController
     * @memberOf classes
     * @extends classes.ValueContainerControllerBase
     */
    cls.EditController = context.oo.Class(cls.ValueContainerControllerBase, function($super) {
      return /** @lends classes.EditController.prototype */ {
        __name: "EditController",

        /**
         * @param {ControllerBindings} bindings
         */
        constructor: function(bindings) {
          $super.constructor.call(this, bindings);
          this._setCompleterBindings(bindings);
        },

        _setCompleterBindings: function(bindings) {
          if (this.isInMatrix() || this.isInTable()) {
            bindings.completer = bindings.container._children[0]._children[0];
          } else {
            bindings.completer = bindings.decorator._children[0];
          }
        },

        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.DialogTypeVMBehavior);
          if (this.isInTable()) {
            this._addBehavior(cls.TableSizeVMBehavior);
          }
          if (!this.isInTable() || this.isInFirstTableRow()) {
            this._addBehavior(cls.LayoutInfoVMBehavior);
          }
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // pseudo-selector behaviors
          this._addBehavior(cls.ActivePseudoSelectorBehavior);
          this._addBehavior(cls.DialogTypePseudoSelectorBehavior);
          if (this.isInMatrix()) {
            this._addBehavior(cls.MatrixCurrentRowVMBehavior);
          }
          this._addBehavior(cls.FontStyle4STBehavior);
          this._addBehavior(cls.FontSize4STBehavior);
          if (!this.isInTable()) {
            this._addBehavior(cls.Border4STBehavior);
          }
          this._addBehavior(cls.Reverse4STBehavior);

          // vm behaviors
          this._addBehavior(cls.EnabledVMBehavior);
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.ColorVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontWeightVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.DisplayFormatVMBehavior); // must be set before value
          this._addBehavior(cls.TextAlignVMBehavior);
          this._addBehavior(cls.TextTransformVMBehavior);
          this._addBehavior(cls.TextDecorationVMBehavior);
          this._addBehavior(cls.ValueVMBehavior);
          this._addBehavior(cls.CursorsVMBehavior);
          this._addBehavior(cls.IsPasswordVMBehavior);
          this._addBehavior(cls.TitleVMBehavior);
          this._addBehavior(cls.MaxLengthVMBehavior);
          this._addBehavior(cls.KeyboardHintVMBehavior);
          this._addBehavior(cls.CompleterVMBehavior);
          this._addBehavior(cls.PictureVMBehavior);
          this._addBehavior(cls.PlaceholderVMBehavior);
          //Field Validation
          this._addBehavior(cls.NotNullVMBehavior);
          this._addBehavior(cls.RequiredVMBehavior);
          this._addBehavior(cls.IncludeVMBehavior);

          // ui behaviors
          this._addBehavior(cls.SendValueUIBehavior);
          this._addBehavior(cls.RequestFocusUIBehavior);
          if (this.isInTable()) {
            this._addBehavior(cls.TableImageVMBehavior);
            this._addBehavior(cls.RowSelectionUIBehavior);
            this._addBehavior(cls.TableItemCurrentRowVMBehavior);
          }
        },
        _getWidgetType: function(kind) {
          var type;
          if (kind === "Construct") {
            type = "DummyEdit";
          } else if (this.isInTable() && (kind === "Display" || kind === "DisplayArray") &&
            !(this.getNodeBindings().decorator.attribute("isPassword"))) {
            type = "Label";
          } else {
            type = $super._getWidgetType.call(this, kind);
          }
          return type;
        },
      };
    });
    cls.ControllerFactory.register("Edit", cls.EditController);
    cls.ControllerFactory.register("XEdit", cls.EditController);

  });
;
"use strict";

modulum('HLineController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class HLineController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.HLineController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.HLineController.prototype */ {
        __name: "HLineController",
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.LayoutInfoVMBehavior);
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // 4st behaviors
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);

          // vm behaviors
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.ColorVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
        }
      };
    });
    cls.ControllerFactory.register("HLine", cls.HLineController);

  });
;
"use strict";

modulum('ImageController', ['ValueContainerControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class ImageController
     * @memberOf classes
     * @extends classes.ValueContainerControllerBase
     */
    cls.ImageController = context.oo.Class(cls.ValueContainerControllerBase, function($super) {
      return /** @lends classes.ImageController.prototype */ {
        __name: "ImageController",
        _imageReadyHandler: null,
        _afterLayoutHandler: null,

        destroy: function() {
          if (this._imageReadyHandler) {
            this._imageReadyHandler();
            this._imageReadyHandler = null;
          }
          if (this._afterLayoutHandler) {
            this._afterLayoutHandler();
            this._afterLayoutHandler = null;
          }
          $super.destroy.call(this);
        },
        _initBehaviors: function() {
          $super._initBehaviors.call(this);
          var decorator = this.getNodeBindings().decorator;
          var container = this.getNodeBindings().container;

          var isStatic = !decorator && !container;

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          if (this.isInTable()) {
            this._addBehavior(cls.TableSizeVMBehavior);
          }
          if (!this.isInTable() || this.isInFirstTableRow()) {
            this._addBehavior(cls.LayoutInfoVMBehavior);
          }
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // pseudo-selector behaviors
          if (!isStatic) {
            this._addBehavior(cls.ActivePseudoSelectorBehavior);
            this._addBehavior(cls.DialogTypePseudoSelectorBehavior);
            if (this.isInMatrix()) {
              this._addBehavior(cls.MatrixCurrentRowVMBehavior);
            }
          }
          this._addBehavior(cls.FontStyle4STBehavior);
          this._addBehavior(cls.FontSize4STBehavior);
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.Alignment4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);

          // vm behaviors
          this._addBehavior(cls.EnabledVMBehavior);
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.ColorVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontWeightVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.TextDecorationVMBehavior);
          this._addBehavior(cls.TitleVMBehavior);
          this._addBehavior(cls.AutoScaleVMBehavior);

          this._addBehavior(cls.DefaultTTFColor4STBehavior);
          this._addBehavior(cls.ClickableImageVMBehavior);

          if (isStatic) {
            this._addBehavior(cls.ImageVMBehavior);
          } else {
            this._addBehavior(cls.RequestFocusUIBehavior);
            this._addBehavior(cls.ValueVMBehavior);
          }
          // ui behaviors
          this._addBehavior(cls.OnClickUIBehavior);
          if (this.isInTable()) {
            this._addBehavior(cls.TableImageVMBehavior);
            this._addBehavior(cls.RowSelectionUIBehavior);
            this._addBehavior(cls.TableItemCurrentRowVMBehavior);
          }
        },

        /**
         * @inheritDoc
         */
        _createWidget: function(type) {
          // TODO why dont' call super._createWidget ?
          var styleNode = this.getNodeBindings().decorator ? this.getNodeBindings().decorator : this.getAnchorNode();
          var imgWidget = cls.WidgetFactory.createWidget(type, {
            appHash: this.getAnchorNode().getApplication().applicationHash,
            appWidget: this.getAnchorNode().getApplication().getUI().getWidget(),
            auiTag: this.getAnchorNode().getId(),
            inTable: this.isInTable(),
            inFirstTableRow: this.isInFirstTableRow(),
            inMatrix: this.isInMatrix(),
            inScrollGrid: this.isInScrollGrid()
          }, styleNode);

          if (imgWidget.isInstanceOf(cls.ImageWidget)) {
            imgWidget.setStandaloneImage(!this.isInTable());
            if (this._imageReadyHandler) {
              this._imageReadyHandler();
              this._imageReadyHandler = null;
            }
            this._imageReadyHandler = imgWidget.when(context.constants.widgetEvents.ready, this._imageLoaded.bind(this));
            var application = this.getAnchorNode() && this.getAnchorNode().getApplication();
            if (application) {
              if (this._afterLayoutHandler) {
                this._afterLayoutHandler();
                this._afterLayoutHandler = null;
              }
              this._afterLayoutHandler = application.layout.afterLayout(imgWidget._whenLayouted.bind(imgWidget));
            }
          }
          return imgWidget;
        },
        _imageLoaded: function() {
          var application = this.getAnchorNode() && this.getAnchorNode().getApplication();
          if (application) {
            application.layout.refreshLayout();
          }
        },

        /**
         * @inheritDoc
         */
        sendWidgetValue: function(dirty) {
          // Images cannot send any value.
        }
      };
    });
    cls.ControllerFactory.register("Image", cls.ImageController);

  });
;
"use strict";

modulum('LabelController', ['ValueContainerControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class LabelController
     * @memberOf classes
     * @extends classes.ValueContainerControllerBase
     */
    cls.LabelController = context.oo.Class(cls.ValueContainerControllerBase, function($super) {
      return /** @lends classes.LabelController.prototype */ {
        __name: "LabelController",
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          var decorator = this.getNodeBindings().decorator;
          var container = this.getNodeBindings().container;
          var isStatic = !decorator && !container;

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          if (this.isInTable()) {
            this._addBehavior(cls.TableSizeVMBehavior);
          }
          if (!this.isInTable() || this.isInFirstTableRow()) {
            this._addBehavior(cls.LayoutInfoVMBehavior);
          }
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // pseudo-selector behaviors
          if (!isStatic) {
            this._addBehavior(cls.ActivePseudoSelectorBehavior);
            this._addBehavior(cls.DialogTypePseudoSelectorBehavior);
            if (this.isInMatrix()) {
              this._addBehavior(cls.MatrixCurrentRowVMBehavior);
            }
          }
          this._addBehavior(cls.FontStyle4STBehavior);
          this._addBehavior(cls.FontSize4STBehavior);
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);

          // vm behaviors
          this._addBehavior(cls.EnabledVMBehavior);
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.ColorVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontWeightVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.TextAlignVMBehavior);
          this._addBehavior(cls.TextDecorationVMBehavior);
          this._addBehavior(cls.TitleVMBehavior);
          this._addBehavior(cls.DisplayFormatVMBehavior); // must be set before value
          if (isStatic) {
            this._addBehavior(cls.TextLabelVMBehavior);
          } else {
            this._addBehavior(cls.ValueVMBehavior);
            this._addBehavior(cls.RequestFocusUIBehavior);
          }

          // ui behaviors
          if (this.isInTable()) {
            this._addBehavior(cls.TableImageVMBehavior);
            this._addBehavior(cls.RowSelectionUIBehavior);
            this._addBehavior(cls.TableItemCurrentRowVMBehavior);
          }

          //Put this 4st Behavior at the end since it's reformatting the value content
          this._addBehavior(cls.TextFormat4STBehavior);

        },

        /**
         * @inheritDoc
         */
        _createWidget: function(type) {
          // TODO why dont' call super._createWidget ?
          var styleNode = this.getNodeBindings().decorator ? this.getNodeBindings().decorator : this.getAnchorNode();
          return cls.WidgetFactory.createWidget(type, {
            appHash: this.getAnchorNode().getApplication().applicationHash,
            appWidget: this.getAnchorNode().getApplication().getUI().getWidget(),
            auiTag: this.getAnchorNode().getId(),
            inTable: this.isInTable(),
            inFirstTableRow: this.isInFirstTableRow(),
            inMatrix: this.isInMatrix(),
            inScrollGrid: this.isInScrollGrid()
          }, styleNode);
        }
      };
    });
    cls.ControllerFactory.register("Label", cls.LabelController);

  });
;
"use strict";

modulum('MessageController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class MessageController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.MessageController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.MessageController.prototype */ {
        __name: "MessageController",
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          this._addBehavior(cls.StyleVMBehavior);
          // 4st behaviors
          this._addBehavior(cls.FontStyle4STBehavior);
          this._addBehavior(cls.FontSize4STBehavior);
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);
          this._addBehavior(cls.TextFormat4STBehavior);
          // vm behaviors
          this._addBehavior(cls.ColorMessageVMBehavior);
          this._addBehavior(cls.BackgroundColorMessageVMBehavior);
          this._addBehavior(cls.FontWeightVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.TextDecorationVMBehavior);
          this._addBehavior(cls.MessageTextVMBehavior);
          this._addBehavior(cls.DisplayMessageVMBehavior);
          // ui behaviors
        },

        /**
         * Avoid destruction of the shared message widget
         */
        destroy: function() {
          var messageService = this.getAnchorNode().getApplication().message;
          messageService.removeMessage(this.getAnchorNode().attribute("count"));
          if (this._widget) {
            this._widget.setHidden(true);
            this._widget = null;
          }
          $super.destroy.call(this);
        },

        /**
         * Override default method to use the shared message widget
         */
        createWidget: function() {
          this._widget = this.getAnchorNode().getParentNode().getController().getWidget().getMessageWidget();

          var messageService = this.getAnchorNode().getApplication().message;
          messageService.addMessage(this.getAnchorNode().attribute("count"), this._widget);
        }

      };
    });
    cls.ControllerFactory.register("Message", cls.MessageController);

  });
;
"use strict";

modulum('ProgressBarController', ['ValueContainerControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class ProgressBarController
     * @memberOf classes
     * @extends classes.ValueContainerControllerBase
     */
    cls.ProgressBarController = context.oo.Class(cls.ValueContainerControllerBase, function($super) {
      return /** @lends classes.ProgressBarController.prototype */ {
        __name: "ProgressBarController",
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          if (this.isInTable()) {
            this._addBehavior(cls.TableSizeVMBehavior);
          }
          if (!this.isInTable() || this.isInFirstTableRow()) {
            this._addBehavior(cls.LayoutInfoVMBehavior);
          }
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // pseudo-selector behaviors
          this._addBehavior(cls.ActivePseudoSelectorBehavior);
          this._addBehavior(cls.DialogTypePseudoSelectorBehavior);
          if (this.isInMatrix()) {
            this._addBehavior(cls.MatrixCurrentRowVMBehavior);
          }
          this._addBehavior(cls.FontStyle4STBehavior);
          this._addBehavior(cls.FontSize4STBehavior);
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.Percentage4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);

          // vm behaviors
          this._addBehavior(cls.EnabledVMBehavior);
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.ColorVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontWeightVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.TextDecorationVMBehavior);
          this._addBehavior(cls.RangeVMBehavior); // range before value! to calculate percentage
          this._addBehavior(cls.ValueVMBehavior);
          this._addBehavior(cls.TitleVMBehavior);
          // ui behaviors
          this._addBehavior(cls.RequestFocusUIBehavior);
          if (this.isInTable()) {
            this._addBehavior(cls.TableImageVMBehavior);
            this._addBehavior(cls.RowSelectionUIBehavior);
            this._addBehavior(cls.TableItemCurrentRowVMBehavior);
          }
        },
        _createWidget: function(type) {
          var widget = $super._createWidget.call(this, type);
          if (widget.setRunning) {
            widget.setRunning(true);
          }
          return widget;

        }
      };
    });
    cls.ControllerFactory.register("ProgressBar", cls.ProgressBarController);

  });
;
"use strict";

modulum('RadioGroupController', ['ValueContainerControllerBase', 'ControllerFactory', 'WidgetFactory'],
  function(context, cls) {
    /**
     * @class RadioGroupController
     * @memberOf classes
     * @extends classes.ValueContainerControllerBase
     */
    cls.RadioGroupController = context.oo.Class(cls.ValueContainerControllerBase, function($super) {
      return /** @lends classes.RadioGroupController.prototype */ {
        __name: "RadioGroupController",
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.DialogTypeVMBehavior);
          if (this.isInTable()) {
            this._addBehavior(cls.TableSizeVMBehavior);
          }
          if (!this.isInTable() || this.isInFirstTableRow()) {
            this._addBehavior(cls.LayoutInfoVMBehavior);
          }
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // pseudo-selector behaviors
          this._addBehavior(cls.ActivePseudoSelectorBehavior);
          this._addBehavior(cls.DialogTypePseudoSelectorBehavior);
          if (this.isInMatrix()) {
            this._addBehavior(cls.MatrixCurrentRowVMBehavior);
          }
          this._addBehavior(cls.FontStyle4STBehavior);
          this._addBehavior(cls.FontSize4STBehavior);
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);

          // vm behaviors
          this._addBehavior(cls.EnabledVMBehavior);
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.ColorVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontWeightVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.TextDecorationVMBehavior);
          this._addBehavior(cls.ItemVMBehavior);
          this._addBehavior(cls.ValueVMBehavior);
          this._addBehavior(cls.OrientationVMBehavior);
          this._addBehavior(cls.TitleVMBehavior);
          //Field Validation
          this._addBehavior(cls.NotNullVMBehavior);
          this._addBehavior(cls.RequiredVMBehavior);
          this._addBehavior(cls.IncludeVMBehavior);

          // ui behaviors
          this._addBehavior(cls.SendValueUIBehavior);
          this._addBehavior(cls.RequestFocusUIBehavior);
          if (this.isInTable()) {
            this._addBehavior(cls.TableImageVMBehavior);
            this._addBehavior(cls.RowSelectionUIBehavior);
            this._addBehavior(cls.TableItemCurrentRowVMBehavior);
          }
        },
        _getWidgetType: function(kind) {
          var type;
          if (kind === "Construct") {
            type = "DummyRadioGroup";
          } else {
            type = $super._getWidgetType.call(this, kind);
          }
          return type;
        },
        _createWidget: function(type) {
          var radioGroup = $super._createWidget.call(this, type);

          var choices = this.getNodeBindings().decorator.getChildren().map(function(item) {
            return {
              value: item.attribute("name"),
              text: item.attribute("text")
            };
          });
          radioGroup.setChoices(choices);
          radioGroup.setOrientation(this.getNodeBindings().decorator.attribute('orientation'));
          return radioGroup;
        }
      };
    });
    cls.ControllerFactory.register("RadioGroup", cls.RadioGroupController);

  });
;
"use strict";

modulum('RipGraphicController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class RipGraphicController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.RipGraphicController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.RipGraphicController.prototype */ {
        __name: "RipGraphicController",
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          this._addBehavior(cls.LayoutInfoVMBehavior);
          this._addBehavior(cls.RipGraphicTypeVMBehavior);
          this._addBehavior(cls.Reverse4STBehavior);

        },
      };
    });
    cls.ControllerFactory.register("RipGraphic", cls.RipGraphicController);

  });
;
"use strict";

modulum('SliderController', ['ValueContainerControllerBase', 'ControllerFactory', 'WidgetFactory'],
  function(context, cls) {
    /**
     * @class SliderController
     * @memberOf classes
     * @extends classes.ValueContainerControllerBase
     */
    cls.SliderController = context.oo.Class(cls.ValueContainerControllerBase, function($super) {
      return /** @lends classes.SliderController.prototype */ {
        __name: "SliderController",
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          if (this.isInTable()) {
            this._addBehavior(cls.TableSizeVMBehavior);
          }
          if (!this.isInTable() || this.isInFirstTableRow()) {
            this._addBehavior(cls.LayoutInfoVMBehavior);
          }
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // pseudo-selector behaviors
          this._addBehavior(cls.ActivePseudoSelectorBehavior);
          this._addBehavior(cls.DialogTypePseudoSelectorBehavior);
          if (this.isInMatrix()) {
            this._addBehavior(cls.MatrixCurrentRowVMBehavior);
          }
          this._addBehavior(cls.FontStyle4STBehavior);
          this._addBehavior(cls.FontSize4STBehavior);
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);

          // vm behaviors
          this._addBehavior(cls.EnabledVMBehavior);
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.ColorVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontWeightVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.TextDecorationVMBehavior);
          this._addBehavior(cls.TitleVMBehavior);
          this._addBehavior(cls.OrientationVMBehavior);
          this._addBehavior(cls.RangeVMBehavior);
          this._addBehavior(cls.ValueVMBehavior);
          //Field Validation
          this._addBehavior(cls.NotNullVMBehavior);
          this._addBehavior(cls.RequiredVMBehavior);
          this._addBehavior(cls.IncludeVMBehavior);

          // ui behaviors
          this._addBehavior(cls.SendValueUIBehavior);
          this._addBehavior(cls.RequestFocusUIBehavior);
          if (this.isInTable()) {
            this._addBehavior(cls.TableImageVMBehavior);
            this._addBehavior(cls.RowSelectionUIBehavior);
            this._addBehavior(cls.TableItemCurrentRowVMBehavior);
          }
        }
      };
    });
    cls.ControllerFactory.register("Slider", cls.SliderController);

  });
;
"use strict";

modulum('SpinEditController', ['ValueContainerControllerBase', 'ControllerFactory', 'WidgetFactory'],
  function(context, cls) {
    /**
     * @class SpinEditController
     * @memberOf classes
     * @extends classes.ValueContainerControllerBase
     */
    cls.SpinEditController = context.oo.Class(cls.ValueContainerControllerBase, function($super) {
      return /** @lends classes.SpinEditController.prototype */ {
        __name: "SpinEditController",
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.DialogTypeVMBehavior);
          if (this.isInTable()) {
            this._addBehavior(cls.TableSizeVMBehavior);
          }
          if (!this.isInTable() || this.isInFirstTableRow()) {
            this._addBehavior(cls.LayoutInfoVMBehavior);
          }
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // pseudo-selector behaviors
          this._addBehavior(cls.ActivePseudoSelectorBehavior);
          this._addBehavior(cls.DialogTypePseudoSelectorBehavior);
          if (this.isInMatrix()) {
            this._addBehavior(cls.MatrixCurrentRowVMBehavior);
          }
          this._addBehavior(cls.FontStyle4STBehavior);
          this._addBehavior(cls.FontSize4STBehavior);
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);

          // vm behaviors
          this._addBehavior(cls.EnabledVMBehavior);
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.ColorVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontWeightVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.TextAlignVMBehavior);
          this._addBehavior(cls.TextDecorationVMBehavior);
          this._addBehavior(cls.ValueVMBehavior);
          this._addBehavior(cls.CursorsVMBehavior);
          this._addBehavior(cls.MaxLengthVMBehavior);
          this._addBehavior(cls.TitleVMBehavior);
          this._addBehavior(cls.RangeVMBehavior);
          this._addBehavior(cls.PlaceholderVMBehavior);
          //Field Validation
          this._addBehavior(cls.NotNullVMBehavior);
          this._addBehavior(cls.RequiredVMBehavior);
          this._addBehavior(cls.IncludeVMBehavior);

          // ui behaviors
          this._addBehavior(cls.SendValueUIBehavior);
          this._addBehavior(cls.RequestFocusUIBehavior);
          if (this.isInTable()) {
            this._addBehavior(cls.TableImageVMBehavior);
            this._addBehavior(cls.RowSelectionUIBehavior);
            this._addBehavior(cls.TableItemCurrentRowVMBehavior);
          }
        },
        _getWidgetType: function(kind) {
          var type;
          if (kind === "Construct") {
            type = "DummySpinEdit";
          } else if (this.isInTable() && (kind === "Display" || kind === "DisplayArray")) {
            type = "Label";
          } else {
            type = $super._getWidgetType.call(this, kind);
          }
          return type;
        }
      };
    });
    cls.ControllerFactory.register("SpinEdit", cls.SpinEditController);

  });
;
"use strict";

modulum('TextEditController', ['ValueContainerControllerBase', 'ControllerFactory', 'WidgetFactory'],
  function(context, cls) {
    /**
     * @class TextEditController
     * @memberOf classes
     * @extends classes.ValueContainerControllerBase
     */
    cls.TextEditController = context.oo.Class(cls.ValueContainerControllerBase, function($super) {
      return /** @lends classes.TextEditController.prototype */ {
        __name: "TextEditController",
        _isRichText: false,

        _initBehaviors: function() {
          $super._initBehaviors.call(this);
          //This has been place here to dynamicaly handle relayout when switching to RichText
          this._addBehavior(cls.TextFormat4STBehavior);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.DialogTypeVMBehavior);
          if (this.isInTable()) {
            this._addBehavior(cls.TableSizeVMBehavior);
          }

          if (!this.isInTable() || this.isInFirstTableRow()) {
            this._addBehavior(cls.LayoutInfoVMBehavior);
          }
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // pseudo-selector behaviors
          this._addBehavior(cls.ActivePseudoSelectorBehavior);
          this._addBehavior(cls.DialogTypePseudoSelectorBehavior);
          if (this.isInMatrix()) {
            this._addBehavior(cls.MatrixCurrentRowVMBehavior);
          }
          this._addBehavior(cls.FontStyle4STBehavior);
          this._addBehavior(cls.FontSize4STBehavior);
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.WrapPolicy4STBehavior);
          this._addBehavior(cls.ShowEditToolBox4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);

          // vm behaviors
          this._addBehavior(cls.TextEditRowsVMBehavior);
          this._addBehavior(cls.EnabledVMBehavior);
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.ColorVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontWeightVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.TextAlignVMBehavior);
          this._addBehavior(cls.TextTransformVMBehavior);
          this._addBehavior(cls.TextDecorationVMBehavior);
          this._addBehavior(cls.ValueVMBehavior);
          this._addBehavior(cls.MaxLengthVMBehavior);
          this._addBehavior(cls.CursorsVMBehavior);
          this._addBehavior(cls.TitleVMBehavior);
          this._addBehavior(cls.PlaceholderVMBehavior);
          this._addBehavior(cls.WantTabsVMBehavior);
          this._addBehavior(cls.WantReturnsVMBehavior);
          this._addBehavior(cls.ScrollBarsVMBehavior);
          //Field Validation
          this._addBehavior(cls.NotNullVMBehavior);
          this._addBehavior(cls.RequiredVMBehavior);
          this._addBehavior(cls.IncludeVMBehavior);

          //related to richtext
          this._addBehavior(cls.OnDataUIBehavior);
          this._addBehavior(cls.OnActionUIBehavior);
          this._addBehavior(cls.WebComponentStateChangedVMBehavior);
          this._addBehavior(cls.WebComponentKeyboardUIBehavior);

          // ui behaviors
          this._addBehavior(cls.SendValueUIBehavior);
          this._addBehavior(cls.RequestFocusUIBehavior);
          if (this.isInTable()) {
            this._addBehavior(cls.TableImageVMBehavior);
            this._addBehavior(cls.RowSelectionUIBehavior);
            this._addBehavior(cls.TableItemCurrentRowVMBehavior);
          }
          this._addBehavior(cls.HasWebComponentUIBehavior);

        },
        _getWidgetType: function(kind) {
          var type;
          if (kind === "Construct") {
            type = "DummyTextEdit";
          } else {
            type = $super._getWidgetType.call(this, kind);
          }
          if (this._isRichText) {
            type = "RichText";
          }

          return type;
        },

        setAsRichText: function(isRichText) {
          this._isRichText = isRichText;
        }

      };
    });
    cls.ControllerFactory.register("TextEdit", cls.TextEditController);

  });
;
"use strict";

modulum('TimeEditController', ['ValueContainerControllerBase', 'ControllerFactory', 'WidgetFactory'],
  function(context, cls) {
    /**
     * @class TimeEditController
     * @memberOf classes
     * @extends classes.ValueContainerControllerBase
     */
    cls.TimeEditController = context.oo.Class(cls.ValueContainerControllerBase, function($super) {
      return /** @lends classes.TimeEditController.prototype */ {
        __name: "TimeEditController",
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.DialogTypeVMBehavior);
          if (this.isInTable()) {
            this._addBehavior(cls.TableSizeVMBehavior);
          }
          if (!this.isInTable() || this.isInFirstTableRow()) {
            this._addBehavior(cls.LayoutInfoVMBehavior);
          }
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // pseudo-selector behaviors
          this._addBehavior(cls.ActivePseudoSelectorBehavior);
          this._addBehavior(cls.DialogTypePseudoSelectorBehavior);
          if (this.isInMatrix()) {
            this._addBehavior(cls.MatrixCurrentRowVMBehavior);
          }
          this._addBehavior(cls.FontStyle4STBehavior);
          this._addBehavior(cls.FontSize4STBehavior);
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);

          // vm behaviors
          this._addBehavior(cls.EnabledVMBehavior);
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.ColorVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontWeightVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.TextAlignVMBehavior);
          this._addBehavior(cls.TextDecorationVMBehavior);
          this._addBehavior(cls.DisplayFormatVMBehavior); // must be set before value
          this._addBehavior(cls.ValueVMBehavior);
          this._addBehavior(cls.MaxLengthVMBehavior);
          this._addBehavior(cls.CursorsVMBehavior);
          this._addBehavior(cls.PlaceholderVMBehavior);
          //Field Validation
          this._addBehavior(cls.NotNullVMBehavior);
          this._addBehavior(cls.RequiredVMBehavior);
          this._addBehavior(cls.IncludeVMBehavior);

          // ui behaviors
          this._addBehavior(cls.SendValueUIBehavior);
          this._addBehavior(cls.RequestFocusUIBehavior);
          if (this.isInTable()) {
            this._addBehavior(cls.TableImageVMBehavior);
            this._addBehavior(cls.RowSelectionUIBehavior);
            this._addBehavior(cls.TableItemCurrentRowVMBehavior);
          }
        },

        _getWidgetType: function(kind) {
          var type;
          if (kind === "Construct") {
            type = "DummyTimeEdit";
          } else if (this.isInTable() && (kind === "Display" || kind === "DisplayArray")) {
            type = "Label";
          } else {
            type = $super._getWidgetType.call(this, kind);
          }
          return type;
        },

        _isConstruct: function() {
          return this.getNodeBindings().container.attribute('dialogType') === "Construct";
        }
      };
    });
    cls.ControllerFactory.register("TimeEdit", cls.TimeEditController);

  });
;
"use strict";

modulum('WebComponentController', ['ValueContainerControllerBase', 'ControllerFactory', 'WidgetFactory'],
  function(context, cls) {
    /**
     * @class WebComponentController
     * @memberOf classes
     * @extends classes.ValueContainerControllerBase
     */
    cls.WebComponentController = context.oo.Class(cls.ValueContainerControllerBase, function($super) {
      return /** @lends classes.WebComponentController.prototype */ {
        __name: 'WebComponentController',

        /**
         * Initialize behaviors of the controller
         * @private
         */
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          if (this.isInTable()) {
            this._addBehavior(cls.TableSizeVMBehavior);
          }
          if (!this.isInTable() || this.isInFirstTableRow()) {
            this._addBehavior(cls.LayoutInfoVMBehavior);
          }
          if (this.isInStack()) {
            this._addBehavior(cls.WebComponentLayoutInfoVMBehavior);
          }
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // pseudo-selector behaviors
          this._addBehavior(cls.ActivePseudoSelectorBehavior);
          this._addBehavior(cls.DialogTypePseudoSelectorBehavior);
          if (this.isInMatrix()) {
            this._addBehavior(cls.MatrixCurrentRowVMBehavior);
          }
          this._addBehavior(cls.FontStyle4STBehavior);
          this._addBehavior(cls.FontSize4STBehavior);
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);

          // vm behaviors
          this._addBehavior(cls.PropertyVMBehavior);
          this._addBehavior(cls.ComponentTypeVMBehavior);
          this._addBehavior(cls.ValueVMBehavior);
          this._addBehavior(cls.EnabledVMBehavior);
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.ColorVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontWeightVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.TextDecorationVMBehavior);
          this._addBehavior(cls.TitleVMBehavior);
          this._addBehavior(cls.WebComponentStateChangedVMBehavior);
          this._addBehavior(cls.WebComponentCursorsVMBehavior);

          // ui behaviors
          this._addBehavior(cls.SendValueUIBehavior);
          this._addBehavior(cls.RequestFocusUIBehavior);
          this._addBehavior(cls.OnActionUIBehavior);
          this._addBehavior(cls.OnDataUIBehavior);
          this._addBehavior(cls.HasWebComponentUIBehavior);
          this._addBehavior(cls.WebComponentKeyboardUIBehavior);
        }
      };
    });
    cls.ControllerFactory.register('WebComponent', cls.WebComponentController);
  });
;
"use strict";

modulum('ValueContainerControllerBase', ['ControllerBase'],
  function(context, cls) {
    /**
     * Base controller for an AUI node.
     * Manages client side life cycle representation of the node.
     * @class ValueContainerControllerBase
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.ValueContainerControllerBase = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.ValueContainerControllerBase.prototype */ {
        __name: "ValueContainerControllerBase",

        /**
         * @inheritDoc
         */
        _initBehaviors: function() {
          $super._initBehaviors.call(this);
          if (this.isInStack() && !(this.isInMatrix() || this.isInTable())) {
            this._addBehavior(cls.StackLabelVMBehavior);
          }
        },

        /**
         * Creates a new widget depending on the dialog type
         * @returns {classes.WidgetBase} the widget
         */
        createWidget: function() {
          if (!this._widget && this.autoCreateWidget()) {
            var dialogType = null;

            // Determine the widget kind of a valueNode
            if (this.getAnchorNode()) {
              dialogType = this.getAnchorNode().attribute('dialogType');
            }
            if (!dialogType && this.getNodeBindings().decorator) {
              dialogType = this.getNodeBindings().decorator.attribute('dialogType');
            }
            if (!dialogType && this.getNodeBindings().container) {
              dialogType = this.getNodeBindings().container.attribute('dialogType');
            }

            var type = this._getWidgetType(dialogType);
            this._widgetKind = dialogType;
            this._widgetType = type;

            this._widget = this._createWidget(type);
          }
          return this._widget;
        },

        /**
         *
         * @inheritDoc
         * @protected
         * @virtual
         */
        _createWidget: function(type) {
          return cls.WidgetFactory.createWidget(type, {
            appHash: this.getAnchorNode().getApplication().applicationHash,
            appWidget: this.getAnchorNode().getApplication().getUI().getWidget(),
            auiTag: this.getAnchorNode().getId(),
            inTable: this.isInTable(),
            inFirstTableRow: this.isInFirstTableRow(),
            inMatrix: this.isInMatrix(),
            inScrollGrid: this.isInScrollGrid()
          }, this.getNodeBindings().decorator);
        },

        /**
         * @inheritDoc
         */
        autoCreateWidget: function() {

          if (this.isInTable() && this._autoCreateWidget) {
            // In table if the value index is greater than table size, it's not necessary to create a widget (optim)
            var tableNode = this.getNodeBindings().container.getParentNode();
            if (tableNode.attribute("offset") > 0) {
              return true;
            }

            var tableSize = tableNode.attribute("size");
            var valueIndex = this.getAnchorNode().getParentNode().getChildren().indexOf(this.getAnchorNode());

            if (valueIndex >= tableSize) {
              var autoCreate = (tableSize === 0 && valueIndex === 0);
              this._useAUIPositionToAttachUI = !autoCreate;
              return autoCreate;
            }
          }

          return $super.autoCreateWidget.call(this);
        },

        /**
         * Strategy method which returns widget value in VM ready format
         * @returns {string} the widget value
         * @protected
         */
        _getWidgetValue: function() {
          var decoratorNode = this.getNodeBindings().decorator;
          var widget = this.getWidget();
          var value = widget.getValue();

          if (value === null || value === undefined) {
            value = "";
          } else {
            value = value.toString();
          }
          value = this._shiftConversion(value, widget, decoratorNode);

          // Validate value, if not valid, rollback to old VM's value!
          if (widget instanceof cls.FieldWidgetBase && !widget.validateValue()) {
            value = widget._oldValue;
            widget.setValue(value);
          }
          return value;
        },

        /**
         * Strategy method which returns AUI value in VM ready format
         * @returns {string} the AUI value
         * @protected
         */
        _getAuiValue: function() {
          var valueNode = this.getNodeBindings().anchor;
          return valueNode.attribute("value").toString();
        },

        /**
         * Get the value depending of the shift attribute
         * @param {string} value - value to process
         * @param {classes.WidgetBase} widget - concerned widget
         * @param {classes.NodeBase} decoratorNode - concerned Node
         * @return {string} - the updated value
         * @private
         */
        _shiftConversion: function(value, widget, decoratorNode) {
          // manage upshift & downshift case
          if (decoratorNode && decoratorNode.isAttributeSetByVM('shift')) {
            var shiftAttr = decoratorNode.attribute('shift');
            if (this.getWidget() && this.getWidget().getTextTransform) {
              shiftAttr = this.getWidget().getTextTransform();
            }
            if (shiftAttr !== "none" && (widget.isEditing && widget.isEditing())) {
              switch (shiftAttr) {
                case 'up':
                  value = value.toUpperCase();
                  break;
                case 'down':
                  value = value.toLowerCase();
                  break;
              }
            }
          }
          return value;
        },

        /**
         * @inheritDoc
         */
        sendWidgetValue: function(dirty) {
          var anchorNode = this.getAnchorNode();
          var widget = this.getWidget();
          var widgetValue = this._getWidgetValue();
          var auiValue = anchorNode.attribute('value');

          // We send value:
          // - dirty==false --> always send value
          // - dirty==true  --> send value only if widget has been edited or if widget value is different from aui value
          if (!dirty || (widget && widget instanceof cls.FieldWidgetBase && widget.isEditing()) || (auiValue !== widgetValue)) {
            anchorNode.getApplication().typeahead.value(anchorNode, widgetValue);
          }
        },

        /**
         * @inheritDoc
         */
        sendWidgetCursors: function(dirty) {
          var widget = this.getWidget();
          if (!widget || !widget.hasCursors()) {
            return;
          }
          if (!dirty || widget.isEditing()) {
            var cursors = widget.getCursors();
            var anchorNode = this.getAnchorNode();
            anchorNode.getApplication().typeahead.cursors(anchorNode, cursors.start, cursors.end);
          }
        }
      };
    });
  });
;
"use strict";

modulum('ColoredWidgetBase', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Base class for all widgets handling colors (background and fore)
     * @class ColoredWidgetBase
     * @memberOf classes
     * @extends classes.WidgetBase
     * @publicdoc Widgets
     */
    cls.ColoredWidgetBase = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.ColoredWidgetBase.prototype */ {
        __name: "ColoredWidgetBase",
        __virtual: true,
        /**
         * true to ignore background color
         * @type {boolean}
         * @protected
         */
        _ignoreBackgroundColor: false,
        /**
         * the widget's main color
         * @type {?string}
         * @protected
         */
        _color: null,
        /**
         * the widget's main background color
         * @type {?string}
         * @protected
         */
        _backgroundColor: null,

        /**
         * @inheritDoc
         */
        _afterInitElement: function() {
          this.getElement().toggleClass("gbc_WidgetBase_standalone", !this._inTable);
          this.getElement().toggleClass("gbc_WidgetBase_in_array", this._inTable);
        },

        /**
         * Set the fore color
         * @see {@link http://www.w3.org/wiki/CSS/Properties/color}
         * @param {string} color a CSS color definition. Can be a color name ('red', 'blue'),
         *                 an hex code ('#f5d48a') or a color function ('rgb(128, 255, 0)').
         *                 null restores the default value.
         * @publicdoc
         */
        setColor: function(color) {
          if (this._color !== color) {
            this._color = color;
            this.setStyle({
              selector: ".gbc_WidgetBase_standalone",
              appliesOnRoot: true
            }, {
              "color": !!color ? color + " !important" : null,
              "fill": !!color ? color + " !important" : null
            });
            this.setStyle({
              preSelector: ".nohighlight ",
              selector: ".gbc_WidgetBase_in_array",
              appliesOnRoot: true
            }, {
              "color": !!color ? color + " !important" : null,
              "fill": !!color ? color + " !important" : null
            });
            this.setStyle({
              preSelector: ".highlight ",
              selector: ".gbc_WidgetBase_in_array:not(.currentRow)",
              appliesOnRoot: true
            }, {
              "color": !!color ? color + " !important" : null,
              "fill": !!color ? color + " !important" : null
            });
          }
        },

        /**
         * Returns the fore color
         * @see {@link http://www.w3.org/wiki/CSS/Properties/color}
         * @returns {?string} a color definition as an RGB function ('rgb(128, 255, 0)')
         * @publicdoc
         */
        getColor: function() {
          return this._color;
        },

        /**
         * Returns the fore color (directly from style css)
         * @see {@link http://www.w3.org/wiki/CSS/Properties/color}
         * @returns {string} a color definition as an RGB function ('rgb(128, 255, 0)')
         * @publicdoc
         */
        getColorFromStyle: function() {
          return this.getStyle(".gbc_WidgetBase_standalone", "color", true);
        },

        /**
         * Sets the background color
         * @see {@link http://www.w3.org/wiki/CSS/Properties/background-color}
         * @param {string} color a CSS color definition. Can be a color name ('red', 'blue'),
         *                 an hex code ('#f5d48a') or a color function ('rgb(128, 255, 0)')
         *                 null restores the default value.
         * @publicdoc
         */
        setBackgroundColor: function(color) {
          if (this._backgroundColor !== color) {
            this._backgroundColor = color;
            this.setStyle({
              selector: ".gbc_WidgetBase_standalone",
              appliesOnRoot: true
            }, {
              "background-color": !!color && !this._ignoreBackgroundColor ? color + " !important" : null
            });
            this.setStyle({
              preSelector: ".nohighlight ",
              selector: ".gbc_WidgetBase_in_array",
              appliesOnRoot: true
            }, {
              "background-color": !!color && !this._ignoreBackgroundColor ? color + " !important" : null
            });
            this.setStyle({
              preSelector: ".highlight ",
              selector: ".gbc_WidgetBase_in_array:not(.currentRow)",
              appliesOnRoot: true
            }, {
              "background-color": !!color && !this._ignoreBackgroundColor ? color + " !important" : null
            });
          }
        },
        /**
         * Set whether or not to ignore bckground color
         * @param {boolean} ignore true to ignore
         * @protected
         */
        setIgnoreBackgroundColor: function(ignore) {
          this._ignoreBackgroundColor = ignore;
          this.setBackgroundColor(this._backgroundColor);
        },

        /**
         * Returns the background color
         * @see {@link http://www.w3.org/wiki/CSS/Properties/background-color}
         * @returns {?string} a color definition as an RGB function ('rgb(128, 255, 0)')
         * @publicdoc
         */
        getBackgroundColor: function() {
          return this._backgroundColor;
        }
      };
    });
  });
;
"use strict";

modulum('TextWidgetBase', ['ColoredWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Base class for all widgets handling text attributes
     * @class TextWidgetBase
     * @memberOf classes
     * @publicdoc Widgets
     * @extends classes.ColoredWidgetBase
     */
    cls.TextWidgetBase = context.oo.Class(cls.ColoredWidgetBase, function($super) {
      return /** @lends classes.TextWidgetBase.prototype */ {
        __name: "TextWidgetBase",
        /**
         * Flag for augmentedFace
         * @type {boolean}
         */
        __virtual: true,
        /**
         * Current font family used
         * @type {string}
         */
        _fontFamily: "",
        /**
         * Current font weight used
         * @type {string}
         */
        _fontWeight: "",
        /**
         * Current font style used
         * @type {string}
         */
        _fontStyle: "",
        /**
         * Current font size used
         * @type {string}
         */
        _fontSize: "",
        /**
         * Current text aligned used
         * @type {string}
         */
        _textAlign: "",
        /**
         * Current text transform used
         * @type {string}
         */
        _textTransform: "none",
        /**
         * Current text decoration used
         * @type {string}
         */
        _textDecoration: "",

        /**
         * @inheritDoc
         */
        destroy: function() {
          $super.destroy.call(this);
        },

        /**
         * Set the font-family used for this widget
         * @see {@link http://www.w3.org/wiki/CSS/Properties/font-family}
         * @param {string} fontFamily the font family to use. null restores the default value.
         * @publicdoc
         */
        setFontFamily: function(fontFamily) {
          if (this._fontFamily !== fontFamily) {
            this._fontFamily = fontFamily;
            this.setStyle({
              "font-family": fontFamily
            });
          }
        },

        /**
         * Get the font-family used by this widget
         * @see {@link http://www.w3.org/wiki/CSS/Properties/font-family}
         * @returns {string} the used font family
         * @publicdoc
         */
        getFontFamily: function() {
          return this.getStyle("font-family"); // TODO must return this._fontFamily
        },

        /**
         * Set the font weight used for this widget
         * @see {@link http://www.w3org/wiki/CSS/Properties/font-weight}
         * @param weight {string} a CSS font weight value. null restores the default value.
         * @publicdoc
         */
        setFontWeight: function(weight) {
          if (this._fontWeight !== weight) {
            this._fontWeight = weight;
            this.setStyle({
              "font-weight": weight
            });
          }
        },

        /**
         * Get the font-family used by this widget
         * @see {@link http://www.w3org/wiki/CSS/Properties/font-weight}
         * @returns {string} a CSS font weight value
         * @publicdoc
         */
        getFontWeight: function() {
          return this._fontWeight;
        },

        /**
         * Set the font-style used for this widget
         * @see {@link http://www.w3.org/wiki/CSS/Properties/font-style}
         * @example setFontStyle("italic")
         * @param style {string} a CSS font style value. null restores the default value.
         * @publicdoc
         */
        setFontStyle: function(style) {
          if (this._fontStyle !== style) {
            this._fontStyle = style;
            this.setStyle({
              "font-style": style
            });
          }
        },

        /**
         * Get the font-style used by this widget
         * @see {@link http://www.w3org/wiki/CSS/Properties/font-style}
         * @returns {string} a CSS font style value
         * @publicdoc
         */
        getFontStyle: function() {
          return this._fontStyle;
        },

        /**
         * Set the font-size used for this widget
         * @see {@link http://www.w3.org/wiki/CSS/Properties/font-size}
         * @param size {string} a CSS font size value. null restores the default value.
         * @example setFontSize("12px")
         * @publicdoc
         */
        setFontSize: function(size) {
          if (this._fontSize !== size) {
            this._fontSize = size;
            this.setStyle({
              "font-size": size
            });
          }
        },

        /**
         * Get the font-size used by this widget
         * @see {@link http://www.w3org/wiki/CSS/Properties/font-size}
         * @returns {string} a CSS font size value
         * @publicdoc
         */
        getFontSize: function() {
          return this.getStyle("font-size"); // TODO must return this._fontSize
        },

        /**
         * Set the text-align used for this widget
         * @see {@link http://www.w3.org/wiki/CSS/Properties/text-align}
         * @param align {string} a CSS text alignment. null restores the default value.
         * @example setTextAlign("right")
         * @publicdoc
         */
        setTextAlign: function(align) {
          if (this._textAlign !== align) {
            this._textAlign = align;
            this.setStyle({
              "text-align": align
            });
          }
        },

        /**
         * Get the text-align used by this widget
         * @see {@link http://www.w3.org/wiki/CSS/Properties/text-align}
         * @returns {string} a text alignment
         * @publicdoc
         */
        getTextAlign: function() {
          return this._textAlign;
        },

        /**
         * Set the text-transform used for this widget
         * @see {@link http://www.w3.org/wiki/CSS/Properties/text-transform}
         * @param transform {string} a CSS text transform. null restores the default value.
         * @example setTextTransform("upper")
         * @publicdoc
         */
        setTextTransform: function(transform) {
          if (this._textTransform !== transform) {
            this._textTransform = transform;
            this.addClass(transform + "shift");
          }
        },

        /**
         * Remove both class which cause text-transform
         * @publicdoc
         */
        removeTextTransform: function() {
          this.removeClass("upshift");
          this.removeClass("downshift");
          this._textTransform = "none";
        },

        /**
         * Get the text-transform used by this widget
         * @see {@link http://www.w3.org/wiki/CSS/Properties/text-transform}
         * @returns {string} a CSS text transform
         * @publicdoc
         */
        getTextTransform: function() {
          return this._textTransform;
        },

        /**
         * Get the text-decoration used by this widget
         * @see {@link http://www.w3.org/wiki/CSS/Properties/text-decoration}
         * @return {string} a CSS text decoration
         * @publicdoc
         */
        getTextDecoration: function() {
          return this._textDecoration;
        },

        /**
         * Set the text-decoration used for this widget
         * @see {@link http://www.w3.org/wiki/CSS/Properties/text-decoration}
         * @publicdoc
         */
        setTextDecoration: function(decoration) {
          if (this._textDecoration !== decoration) {
            this._textDecoration = decoration;
            this.setStyle({
              "text-decoration": decoration
            });
          }
        }
      };
    });
  });
;
"use strict";

modulum('WidgetBase', ['EventListener'],
  function(context, cls) {
    var SPACES_RE = /\s+/;

    /**
     * Base class for widgets.
     * @class WidgetBase
     * @memberOf classes
     * @tutorial widgets
     * @extends classes.EventListener
     * @publicdoc Widgets
     */
    cls.WidgetBase = context.oo.Class({
      base: cls.EventListener
    }, function($super) {

      var __charMeasurer = document.createElement('char-measurer');
      __charMeasurer.className = "g_layout_charMeasurer";
      var __charMeasurer1 = document.createElement('char-measurer-item');
      __charMeasurer1.className = "g_layout_charMeasurer1";
      __charMeasurer1.textContent = "MMMMMMMMMM\nM\nM\nM\nM\nM\nM\nM\nM\nM";
      var __charMeasurer2 = document.createElement('char-measurer-item');
      __charMeasurer2.className = "g_layout_charMeasurer2";
      __charMeasurer2.textContent = "0000000000";
      __charMeasurer.appendChild(__charMeasurer1);
      __charMeasurer.appendChild(__charMeasurer2);
      __charMeasurer.setAttribute("aria-hidden", "true");

      return /** @lends classes.WidgetBase.prototype */ {
        $static: /** @lends classes.WidgetBase */ {
          /** Generic click events handler */
          // TODO is it still necessary to have these methods static ?
          /** Generic focus events handler */
          _onFocus: function(event) {
            this.emit(context.constants.widgetEvents.focus, event);
          },
          /**
           * Need to listen mouseup event on body to be able to focus an input field if selection ends outside of the field.
           * If selection ends inside the field, click event will be raised
           * @protected
           */
          _onSelect: function() {
            document.body.on('mouseup.DetectTextSelection', function(event) {
              document.body.off('mouseup.DetectTextSelection');
              this._element.off('mouseleave.DetectTextSelection');
            }.bind(this));
            this._element.on('mouseleave.DetectTextSelection', function(event) {
              document.body.off('mouseup.DetectTextSelection');
              this._element.off('mouseleave.DetectTextSelection');
              this._onRequestFocus(event); // request focus
            }.bind(this));
          },
          selfDataContent: {}
        },
        __name: "WidgetBase",
        __templateName: null,
        __charMeasurer: null,
        __dataContentPlaceholderSelector: null,
        /**
         * Current widget's unique ID (GBC system wide)
         * @type {?string}
         */
        _uuid: null,

        /**
         * Incremental ID for widgets that are linked to the AUI, 0 otherwise
         * @type {number}
         */
        _nUuid: 0,

        /**
         * Widget root class name (based on widget's unique ID)
         * @type {?string}
         */
        _rootClassName: null,
        _auiTag: null,
        _auiName: null,
        /**
         * the parent widget
         * @type {HTMLElement}
         * @protected
         */
        _element: null,
        /**
         * the parent widget
         * @type {classes.WidgetGroupBase}
         * @protected
         */
        _parentWidget: null,
        /**
         * Current instance stylesheet
         * @type {Object}
         */
        _stylesheet: null,
        /**
         * stylesheet context ('global', 'window')
         * @type {string}
         */
        _stylingContext: "global",
        /**
         * the layout engine
         * @type {classes.LayoutEngineBase}
         * @protected
         */
        _layoutEngine: null,
        /**
         * the layout information
         * @type {classes.LayoutInformation}
         * @protected
         */
        _layoutInformation: null,
        /**
         * the user interface widget
         * @type {classes.UserInterfaceWidget}
         * @protected
         */
        _uiWidget: null,
        /**
         * Application widget
         * @type {classes.ApplicationWidget}
         * @protected
         */
        _appWidget: null,
        _appHash: null,
        _windowWidget: null,
        _formWidget: null,
        _tableWidgetBase: null,

        _i18NList: null,
        _i18nTranslateListener: null,

        /**
         * Dialog type of the widget (Input, Input Array, Display, Display Array, Construct)
         * @type {string}
         * @protected
         */
        _dialogType: false,
        _enabled: true,
        _noBorder: false,
        _hidden: false,
        _focusable: false,

        /**
         * If alwaysSend, any action will send an event to VM without without checking if the value has changed.
         * @public
         * @type {boolean}
         * @default false
         */
        //_alwaysSend: false,
        _startKey: null,
        _endKey: null,

        _inMatrix: false,
        _inTable: false,
        _inFirstTableRow: false,
        _ignoreLayout: false,

        // arabic mode
        _isReversed: false,

        /**
         * @type {?string}
         */
        _rawStyles: null,

        /**
         * @type {Array<string>}
         */
        _applicationStyles: null,

        /**
         * An interruptible widget is active when the VM is processing
         * @type {boolean}
         */
        _interruptable: false,
        _hasWebcomp: false,

        /**
         * @inheritDoc
         * @constructs
         * @param {Object} opts instantiation options
         * @param {number} opts.appHash internal app hash
         * @param {classes.ApplicationWidget} opts.appWidget early ApplicationWidget link
         * @param {number} opts.auiTag internal aui tag id
         * @param {boolean} opts.inTable internal is in table
         * @param {boolean} opts.inMatrix internal is in matrix
         * @param {boolean} opts.inFirstTableRow internal
         * @param {boolean} opts.inScrollGrid internal is in a scroll grid
         * @param {boolean} opts.ignoreLayout ignore layout char measurer
         */
        constructor: function(opts) {
          opts = (opts || {});
          this._appHash = opts.appHash;
          this._appWidget = opts.appWidget;
          this._auiTag = opts.auiTag;
          this._inTable = (opts.inTable === true);
          this._inFirstTableRow = (opts.inFirstTableRow === true);
          this._inMatrix = (opts.inMatrix === true);
          this._inScrollGrid = (opts.inScrollGrid === true);
          this._ignoreLayout = (this._inTable && !this._inFirstTableRow) || opts.ignoreLayout;

          this._uuid = context.InitService.uniqueIdAsString();
          this._nUuid = this._auiTag ? context.InitService.uniqueId() : 0;
          $super.constructor.call(this, opts);
          this._rootClassName = "w_" + this._uuid;
          this._initElement();
          this._afterInitElement();
          this._initLayout();
          this._initTranslation();
          if (this._auiTag) {
            this._element.addClass("aui__" + this._auiTag);
            this._element.setAttribute("data-aui-id", this._auiTag);
          }
          context.WidgetService._emit(context.constants.widgetEvents.created, this);
          context.WidgetService.registerWidget(this);
        },

        /**
         * Returns build parameters
         * @returns {{appHash: (null|*), auiTag: (null|*), inTable: (boolean|*), inFirstTableRow: (boolean|*), inMatrix: (boolean|*), inScrollGrid: *, ignoreLayout: (boolean|*)}} build parameters
         * @publicdoc
         */
        getBuildParameters: function() {
          var opts = {
            appHash: this._appHash,
            appWidget: this._appWidget,
            auiTag: this._auiTag,
            inTable: this._inTable,
            inFirstTableRow: this._inFirstTableRow,
            inMatrix: this._inMatrix,
            inScrollGrid: this._inScrollGrid,
            ignoreLayout: this._ignoreLayout
          };
          return opts;
        },

        /**
         * Destroy style sheet related to widget
         * @private
         */
        _destroyStyle: function() {
          if (this._stylingContext === "widget") {
            context.styler.removeStyleSheet(this.getUniqueIdentifier());
          } else if (this._stylingContext === "window") {
            var win = this.getWindowWidget();
            var sheetId = win && win.getUniqueIdentifier() || this._appHash || "_";
            context.styler.appendStyleSheet({}, this.getRootClassName(), true, sheetId);
          } else {
            context.styler.appendStyleSheet({}, this.getRootClassName(), true, this._appHash || "_");
          }
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._destroyStyle();

          this.emit(context.constants.widgetEvents.destroyed, this);
          context.WidgetService._emit(context.constants.widgetEvents.destroyed, this);
          if (this._layoutEngine) {
            this._layoutEngine.destroy();
            this._layoutEngine = null;
          }
          if (this._parentWidget && this._parentWidget.removeChildWidget) {
            this._parentWidget.removeChildWidget(this);
          }
          if (this._layoutInformation) {
            this._layoutInformation.destroy();
            this._layoutInformation = null;
          }
          document.body.off('mouseup.DetectTextSelection');
          if (this._element) {
            this._element.remove();
          }
          this.__charMeasurer1 = null;
          this.__charMeasurer2 = null;
          this.__charMeasurer = null;
          this._stylesheet = null;

          this._uiWidget = null;
          this._appWidget = null;
          this._windowWidget = null;
          this._formWidget = null;
          this._tableWidgetBase = null;
          this._element = null;

          if (this._i18nTranslateListener) {
            this._i18nTranslateListener();
            this._i18nTranslateListener = null;
          }
          this._i18NList = null;

          $super.destroy.call(this);

          context.WidgetService.unregisterWidget(this);
        },

        /**
         * Method called after the element is initialized
         * Override in inherited widgets if necessary
         * @private
         */
        _afterInitElement: function() {},

        /**
         * Create all instances for layout management
         * @protected
         */
        _initLayout: function() {
          this._layoutInformation = new cls.LayoutInformation(this);
          this._layoutEngine = new cls.NoLayoutEngine(this);
        },

        /**
         * function to be called by widget's layout engine when resetting the layout if needed
         */
        resetLayout: function() {},

        /**
         * Get the widget's layout information
         * @returns {classes.LayoutInformation} the widget's layout information
         * @publicdoc
         */
        getLayoutInformation: function() {
          return this._layoutInformation;
        },

        /**
         * Get the widget's layout engine
         * @returns {classes.LayoutEngineBase} the widget's layout engine
         * @publicdoc
         */
        getLayoutEngine: function() {
          return this._layoutEngine;
        },

        /**
         * Get the styling context of widget style sheet (global, window or widget);
         * @returns {string} widget styling context used in its style sheet
         */
        getStylingContext: function() {
          return this._stylingContext;
        },

        /**
         * Setups the DOM element
         * @protected
         */
        _initElement: function() {
          this._element = context.TemplateService.renderDOM(this.__templateName || this.__name, this.__ascendance);
          var id = this.getRootClassName();
          this._element.id = id;

          this._element.className += ["", this.__ascendanceClasses, id, "g_measureable"].join(" ");
          // TODO we add class g_measureable in all cases, we should probably just add this class if ignoreLayout=false
          if (!this._ignoreLayout) {
            this._initCharMeasurer();
          }
        },

        /**
         * Init the char Measurer for proper layout management
         * @private
         */
        _initCharMeasurer: function() {
          this.__charMeasurer = __charMeasurer.cloneNode(true);
          this.__charMeasurer1 = this.__charMeasurer.children[0];
          this.__charMeasurer2 = this.__charMeasurer.children[1];
          this._element.appendChild(this.__charMeasurer);
        },

        /**
         * Handle request Focus
         * @param {UIEvent} event - dom event
         */
        _onRequestFocus: function(event) {
          if (this.isInTable()) {
            this.getTableWidgetBase().requestFocusFromWidget(this, event);
            // TODO check if test isInMatrix is still necessary with bellow check Display Array
          } else if (this.isInMatrix() ||
            this._inScrollGrid ||
            (this.isFocusable() &&
              (this.isEnabled() || this.getDialogType() === "DisplayArray"))) {
            this.emit(context.constants.widgetEvents.requestFocus, event);
          }
        },

        /**
         * Returns id widget should show application contextmenu
         * @returns {boolean} true if application contextmenu should be displayed
         */
        shouldShowApplicationContextMenu: function() {
          return true;
        },

        /**
         * Build/add extra actions to app contextmenu
         * Must be redefine by widget which must add extra actions
         * @param {classes.ContextMenuWidget} contextMenu - widget
         */
        buildExtraContextMenuActions: function(contextMenu) {

          // prepare copy action
          var copyFunction = null;
          var clipboardValue = this.getClipboardValue();
          if (clipboardValue !== null) {
            copyFunction = function(contextMenu) {
              contextMenu.hide();
              cls.ClipboardHelper.copyTo(this.getClipboardValue(), this._element);
            };
          }

          // if copyfunction exists add it to contextmenu
          if (!!copyFunction) {
            // in table display "Copy cell" instead of "Copy"
            var copyTranslation = this.isInTable() ? i18next.t("gwc.contextMenu.copyCell") : i18next.t("gwc.clipboard.copy");
            contextMenu.addAction("copy", copyTranslation, null, null, {
              clickCallback: copyFunction.bind(this, contextMenu)
            }, true);
          }

          if (this.isInTable()) {
            // build table contextmenu
            this.getTableWidgetBase().buildExtraContextMenuActions(contextMenu);
          }
        },

        /**
         * Defines if the widget is focusable
         * @param {boolean} focusable - State of focusable
         * @publicdoc
         */
        setFocusable: function(focusable) {
          this._focusable = focusable;
          this._setElementAttribute('tabindex', focusable ? '0' : null);
        },

        /**
         * Returns if the widget is focusable
         * @return {boolean} State of focusable
         * @publicdoc
         */
        isFocusable: function() {
          return this._focusable;
        },

        /**
         * Tests if the widget has really the DOM focus (check document.activeElement)
         * @returns {boolean} true if the widget has the DOM focus
         */
        hasDOMFocus: function() {
          return this._element === document.activeElement;
        },

        /**
         * Initialization of internationalization engine
         * @private
         */
        _initTranslation: function() {
          // Will ask the translation once ready
          this._i18NList = this._element.querySelectorAll("[data-i18n]");
          this._i18nTranslateListener = context.I18NService.translate(this);
        },

        /**
         * Translate the widget
         * @publicdoc
         */
        translate: function() {
          var allSelectors = this._i18NList;
          for (var i = 0; i < allSelectors.length; i++) {
            allSelectors[i].innerHTML = i18next.t(allSelectors[i].getAttribute("data-i18n"));
          }
        },

        /**
         * Get the unique identifier of the widget
         * @returns {string} the unique identifier of the widget
         * @publicdoc
         */
        getUniqueIdentifier: function() {
          return this._uuid;
        },

        /**
         * Get the increment identifier of the widget if linked to AUI, 0 otherwise
         * @returns {number} the increment identifier of the widget if linked to AUI, 0 otherwise
         */
        getAuiLinkedUniqueIdentifier: function() {
          return this._nUuid;
        },

        /**
         * Get the unique identifier of the application
         * @returns {string} the unique identifier of the application
         * @publicdoc
         */
        getApplicationIdentifier: function() {
          return this._appHash !== undefined ? this._appHash : null;
        },

        /**
         * Get the root element of the widget
         * @returns {HTMLElement} the root element of the widget
         * @publicdoc
         */
        getElement: function() {
          return this._element;
        },

        /**
         * Get the main class name of the widget
         * @return {string} the main class name
         * @publicdoc
         */
        getClassName: function() {
          return "gbc_" + this.__name;
        },

        /**
         * Get the name of the widget class
         * @return {string} the widget class name
         * @publicdoc
         */
        getName: function() {
          return this.__name;
        },

        /**
         * Get the Aui Tree Tag
         * @return {string} html class ready name
         * @private
         */
        _getAuiTagClass: function() {
          return ".aui__" + this._auiTag;
        },

        /**
         * Get the unique class name identifying a widget instance
         * @returns {*|string} the unique class name identifying a widget instance
         */
        getRootClassName: function() {
          return this._rootClassName;
        },

        /**
         * Get the CSS id selector of the widget
         * @param {string=} [subSelector] selector targeting an element below the widget's root node
         * @param {boolean=} [appliesOnRoot] true if the returned selector should match the root too.
         * @param {string} [preSelector] pre selector rule, if any
         * @returns {string} the CSS selector corresponding to the requested DOM element
         * @public
         */
        _getCssSelector: function(subSelector, appliesOnRoot, preSelector) {
          return (preSelector || "") + "#" + this.getRootClassName() +
            (appliesOnRoot ? "" : " ") +
            (subSelector || "");
        },

        /**
         * Get widget style property value
         * @param {?string} [selector] additional sub selector
         * @param {string} property property name
         * @param {boolean=} appliesOnRoot - true if the returned selector should match the root too.
         * @returns {*} property value if set, undefined otherwise
         * @publicdoc
         */
        getStyle: function(selector, property, appliesOnRoot) {
          if (!property) {
            property = selector;
            selector = null;
          }
          var cssSelector = this._getCssSelector(selector, appliesOnRoot);
          return this._stylesheet && this._stylesheet[cssSelector] && this._stylesheet[cssSelector][property];
        },

        /**
         * Updates widget style with new rules
         * @param {?string|{selector:String, preSelector:String, appliesOnRoot:boolean=}} [selector] additional sub selector
         * @param {Object.<string, *>} style style properties to set
         * @publicdoc
         */
        setStyle: function(selector, style) {
          if (!style) {
            style = selector;
            selector = null;
          }
          var subSelector = selector,
            preSelector = null,
            appliesOnRoot = null;
          if (!!selector && (selector.selector || selector.preSelector)) {
            subSelector = selector.selector;
            preSelector = selector.preSelector;
            appliesOnRoot = selector.appliesOnRoot;
          }
          var cssSelector = this._getCssSelector(subSelector, appliesOnRoot, preSelector);
          if (!this._stylesheet) {
            this._stylesheet = {};
          }
          var localStyle = this._stylesheet[cssSelector];
          if (!localStyle) {
            localStyle = this._stylesheet[cssSelector] = {};
          }
          var keys = Object.keys(style);
          for (var k = 0; k < keys.length; k++) {
            if (style[keys[k]] === null) {
              delete localStyle[keys[k]];
            } else {
              localStyle[keys[k]] = style[keys[k]];
            }
          }
          var win = this.getWindowWidget(),
            contextChanged = (this._stylingContext === "global" && win) || (this._stylingContext === "window" && !win);

          context.styler.appendStyleSheet(this._stylesheet,
            this.getRootClassName(), true, this._stylingContext === "widget" ? this.getUniqueIdentifier() : this.getStyleSheetId()
          );

          if (contextChanged) {
            this._stylingContext = win ? "window" : "global";
            if (win) {
              context.styler.appendStyleSheet({}, this.getRootClassName(), true, this._appHash || "_");
            }
          }
        },

        getStyleSheetId: function() {
          var windowWidget = this.getWindowWidget(),
            windowWidgetId = windowWidget && windowWidget.getUniqueIdentifier();
          return windowWidgetId || this._appHash || "_";
        },

        /**
         * Get the raw styles from VM
         * @returns {?string} the raw styles from VM
         */
        getRawStyles: function() {
          return this._rawStyles;
        },
        setApplicationStyles: function(styles) {
          this._rawStyles = styles;
          var i, oldClasses = this._applicationStyles,
            oldlen = oldClasses ? oldClasses.length : 0,
            newClasses = styles && styles.split(SPACES_RE),
            newlen = newClasses ? newClasses.length : 0;
          for (i = 0; i < oldlen; i++) {
            if (!newClasses || newClasses.indexOf(oldClasses[i]) < 0) {
              this.removeClass("gbc_style_" + oldClasses[i]);
            }
          }
          for (i = 0; i < newlen; i++) {
            if (!oldClasses || oldClasses.indexOf(newClasses[i]) < 0) {
              this.addClass("gbc_style_" + newClasses[i]);
            }
          }
          this._applicationStyles = newClasses;
        },

        /**
         * Defines the parent widget
         * @param {classes.WidgetGroupBase} widget - the widget to use as parent
         * @param {Object=} options - possible options
         * @param {boolean=} options.noLayoutInvalidation - won't affect parent layout
         * @publicdoc
         */
        setParentWidget: function(widget, options) {
          options = options || {};
          this._parentWidget = widget;
          if (!!this._layoutEngine && !options.noLayoutInvalidation) {
            this._layoutEngine.invalidateMeasure();
          }
        },

        /**
         * Get the parent widget
         * @returns {classes.WidgetGroupBase} the parent widget
         * @publicdoc
         */
        getParentWidget: function() {
          return this._parentWidget;
        },

        /**
         * Get the UI widget related to the widget
         * @returns {classes.UserInterfaceWidget} UserInterfaceWidget
         * @publicdoc
         */
        getUserInterfaceWidget: function() {
          if (this._uiWidget === null) {
            var result = this;
            while (result && !(result.isInstanceOf(gbc.classes.UserInterfaceWidget))) {
              result = result.getParentWidget();
            }
            this._uiWidget = result;
          }
          return this._uiWidget;
        },

        /**
         * Get Application Widget related to the widget
         * @returns {classes.ApplicationWidget} ApplicationWidget
         * @publicdoc
         */
        getApplicationWidget: function() {
          if (this._appWidget === null) {
            var result = this;
            while (result && !(result.isInstanceOf(gbc.classes.ApplicationWidget))) {
              result = result.getParentWidget();
            }
            this._appWidget = result;
          }
          return this._appWidget;
        },

        /**
         * Get the Window Widget related to the widget
         * @returns {classes.WindowWidget} WindowWidget
         * @publicdoc
         */
        getWindowWidget: function() {
          if (this._windowWidget === null) {
            var result = this;
            while (result && !(result.isInstanceOf(gbc.classes.WindowWidget))) {
              result = result.getParentWidget();
            }
            this._windowWidget = result;
          }
          return this._windowWidget;
        },

        /**
         * Get the Form Widget related to the widget
         * @returns {classes.FormWidget} FormWidget
         * @publicdoc
         */
        getFormWidget: function() {
          if (this._formWidget === null) {
            var result = this;
            while (result && !(result.isInstanceOf(gbc.classes.FormWidget))) {
              result = result.getParentWidget();
            }
            this._formWidget = result;
          }
          return this._formWidget;
        },

        /**
         * Get the table Widget base class related to the widget
         * @returns {classes.TableWidgetBase} TableWidgetBase
         * @publicdoc
         */
        getTableWidgetBase: function() {
          if (this._tableWidgetBase === null) {
            var result = this;
            while (result && !(result.isInstanceOf(gbc.classes.TableWidgetBase))) {
              result = result.getParentWidget();
            }
            this._tableWidgetBase = result;
          }
          return this._tableWidgetBase;
        },

        /**
         * Check if this widget is a child of a given one
         * @param {classes.WidgetBase} parent the reference parent widget
         * @return {boolean} true if is a child, false otherwise
         * @publicdoc
         */
        isChildOf: function(parent) {
          var result = this.getParentWidget();
          while (result && result !== parent) {
            result = result.getParentWidget();
          }
          return !!result;
        },

        /**
         * Replace the current widget with a given one
         * @param {classes.WidgetBase} widget the new widget
         * @publicdoc
         */
        replaceWith: function(widget) {
          if (this._parentWidget) {
            this._parentWidget.replaceChildWidget(this, widget);
          }
        },

        /**
         * Detach the widget from the dom
         * @publicdoc
         */
        detach: function() {
          if (this._element && this._element.parentNode) {
            this._element.parentNode.removeChild(this._element);
          } else {
            context.LogService.warn("Trying to detach a widget which is already outside of DOM " + this.__name);
          }
        },

        /**
         * Set widget current dialog type.
         * Can be Input, Input Array, Display, Display Array or Construct
         * @param {string} dialogType Dialog type
         * @publicdoc
         */
        setDialogType: function(dialogType) {
          this._dialogType = dialogType;
        },

        /**
         * return widget current dialog type
         * @returns {string} values can be : Input, InputArray, Display, DisplayArray or Construct
         * @publicdoc
         */
        getDialogType: function() {
          return this._dialogType;
        },

        /**
         * Defines the enabled status of the widget
         * @param {boolean} enabled true if the widget allows user interaction, false otherwise.
         * @publicdoc
         */
        setEnabled: function(enabled) {
          if (this._enabled !== enabled) {
            this._enabled = !!enabled;
            if (this._enabled) {
              this.removeClass("disabled");
            } else {
              this.addClass("disabled");
            }
          }
        },

        /**
         * Check if widget is enabled
         * @returns {boolean} true if the widget allows user interaction, false otherwise.
         * @publicdoc
         */
        isEnabled: function() {
          return this._enabled;
        },

        /**
         * Defines if the widget should be hidden or not
         * @param {boolean} hidden true if the widget is hidden, false otherwise
         * @publicdoc
         */
        setHidden: function(hidden) {
          if (this._hidden !== hidden) {
            this._hidden = !!hidden;
            if (this._element) {
              if (this._hidden) {
                this.addClass("hidden");
              } else {
                this.removeClass("hidden");
              }
            }
            if (this._layoutEngine) {
              this._layoutEngine.changeHidden(hidden);
            }
            this.emit(context.constants.widgetEvents.visibilityChange);
          }
        },

        /**
         * Check if the widget is hidden
         * @returns {boolean} true if the widget is hidden, false otherwise
         * @publicdoc
         */
        isHidden: function() {
          return this._hidden;
        },

        /**
         * Check if the widget is part of layout computing
         * @param {boolean} [deep] true to test against parent widgets as well
         * @returns {boolean} true if the widget is part of layout computing
         */
        isLayoutMeasureable: function(deep) {
          if (!deep) {
            return !this.isHidden();
          } else {
            if (this.isHidden()) {
              return false;
            } else {
              var parent = this;
              while (!!parent) {
                if (!parent.isLayoutMeasureable()) {
                  return false;
                }
                if (parent.isLayoutTerminator() && parent.isLayoutMeasureable()) {
                  return true;
                }
                parent = parent.getParentWidget();
              }
              return true;
            }
          }
        },

        /**
         * Check if the widget is visible
         * @return {boolean} true if visible, false otherwise
         * @publicdoc
         */
        isVisible: function() {
          return !this.isHidden();
        },

        /**
         * Check if widget or one of its parent is hidden
         * @return {boolean} true if hidden, false otherwise
         */
        isHiddenRecursively: function() {
          var parent = this;
          while (!!parent) {
            if (parent.isHidden()) {
              return true;
            }
            parent = parent.getParentWidget();
          }
          return false;
        },

        /**
         * Check if widget and all of its parent are visible
         * @return {boolean} true if visible, false otherwise
         */
        isVisibleRecursively: function() {
          var parent = this;
          while (!!parent) {
            if (!parent.isVisible()) {
              return false;
            }
            parent = parent.getParentWidget();
          }
          return true;
        },

        isLayoutTerminator: function() {
          return false;
        },

        /**
         * Remove or add borders to the widget
         * @param {boolean} noBorder - true if the widget has no border class, false otherwise
         * @publicdoc
         */
        setNoBorder: function(noBorder) {
          if (this._noBorder !== noBorder) {
            this._noBorder = !!noBorder;
            if (this._noBorder) {
              this.addClass("gbc_NoBorder");
            } else {
              this.removeClass("gbc_NoBorder");
            }
          }
        },

        /**
         * Check if the widget is displayed without border
         * @returns {boolean} true if the widget has no border class, false otherwise
         * @publicdoc
         */
        isNoBorder: function() {
          return this._noBorder;
        },

        /**
         * Set the title of the widget
         * @param {string} title - the tooltip text
         * @publicdoc
         */
        setTitle: function(title) {
          if (title === "") {
            this._setElementAttribute("title", null);
            this.setAriaAttribute("label", null);
          } else {
            this._setElementAttribute("title", title);
            this.setAriaAttribute("label", title);
          }
        },

        /**
         * Get the title of the widget
         * @returns {string} the tooltip text
         * @publicdoc
         */
        getTitle: function() {
          return this._element.getAttribute("title");
        },

        /**
         * Called when widget obtains the focus
         * @param {boolean} [fromMouse] - true if focus comes from mouse event
         * @publicdoc
         */
        setFocus: function(fromMouse) {
          var userInterfaceWidget = this.getUserInterfaceWidget();
          if (userInterfaceWidget) {
            userInterfaceWidget.setFocusedWidget(this);
            // emit current view change (used for hbox splitview)
            userInterfaceWidget.emit(context.constants.widgetEvents.splitViewChange);
            this.setAriaSelection();
          }

          // rare case when we are going to focus an hidden widget. To avoid fallback focus to body, we focus userinterface widget instead.
          if (this.isHidden()) {
            var uiWidget = this.getUserInterfaceWidget();
            if (uiWidget) {
              uiWidget.getElement().domFocus();
            }
          }
        },

        /**
         * Called before setting VM focus to notify previous VM focused widget
         * @publicdoc
         */
        loseVMFocus: function() {},

        /**
         * Called before setFocus to notify previous focused widget
         * @publicdoc
         */
        loseFocus: function() {},

        /**
         * Check if widget node has VM focus
         * @returns {boolean} true if widget node has VM focus
         * @publicdoc
         */
        hasVMFocus: function() {
          var ui = this.getUserInterfaceWidget();
          return !ui || (this === ui.getVMFocusedWidget());
        },

        /**
         * Check if widget node has focus (class gbc_Focus)
         * @returns {boolean} true if widget node has focus
         * @publicdoc
         */
        hasFocus: function() {
          var ui = this.getUserInterfaceWidget();
          return !ui || (this === ui.getFocusedWidget());
        },

        /**
         * Checks if the widget element has the given class
         * @param {string} className - class to check
         * @publicdoc
         */
        hasClass: function(className) {
          return this._element.hasClass(className);
        },

        /**
         * Add the given class to element
         * @param {string} className - class to add
         * @publicdoc
         */
        addClass: function(className) {
          this._element.addClass(className);
        },

        /**
         * Remove the given class from element
         * @param {string} className - class to delete
         * @publicdoc
         */
        removeClass: function(className) {
          this._element.removeClass(className);
        },

        /**
         * Toggle the given class to element
         * @param {string} className - class to toggle
         * @param {boolean=} switcher forced new state
         * @publicdoc
         */
        toggleClass: function(className, switcher) {
          this._element.toggleClass(className, switcher);
        },

        /**
         * Add QA informations to the widget
         * @param {string} name - AUI tree name
         * @param {string} value - AUI tree value
         */
        setQAInfo: function(name, value) {
          if (!!this._element) {
            this._setElementAttribute("data-gqa-" + name, value);
          }
        },

        /**
         * Defines the AUI tree name of the widget
         * @param {string} name the name
         */
        setAuiName: function(name) {
          if (!!this._element && (name !== this._auiName)) {
            this._auiName = name;
            this._setElementAttribute("data-aui-name", name);
          }
        },

        /**
         * Check if the widget is in a table
         * @returns {boolean} true if the widget is in a table, false otherwise.
         * @publicdoc
         */
        isInTable: function() {
          return this._inTable;
        },

        /**
         * Check if the widget is in a matrix
         * @returns {boolean} true if the widget is in a matrix, false otherwise.
         * @publicdoc
         */
        isInMatrix: function() {
          return this._inMatrix;
        },

        /**
         * Does the widget ignore layouting
         * @returns {boolean} true if the widget ignore all layout.
         * @publicdoc
         */
        ignoreLayout: function() {
          return this._ignoreLayout;
        },

        /**
         * Set Arabic mode
         * @param {boolean} rtl - true if widget is right to left
         * @publicdoc
         */
        setReverse: function(rtl) {
          if (this._isReversed !== rtl) {
            this._isReversed = rtl;
            if (rtl) {
              this.addClass("reverse");
            } else {
              this.removeClass("reverse");
            }
          }
        },

        /**
         * Check if arabic mode is enabled
         * @return {boolean} true if enabled
         * @publicdoc
         */
        isReversed: function() {
          return this._isReversed;
        },

        /**
         * Get start (for reversed mode)
         * @return {string} start keyword for rtl
         * @publicdoc
         */
        getStart: function() {
          return this.isReversed() ? "right" : "left";
        },

        /**
         * Get end (for reversed mode)
         * @return {string} end keyword for rtl
         * @publicdoc
         */
        getEnd: function() {
          return this.isReversed() ? "left" : "right";
        },

        /**
         * Method called when the widget is attached/detached from the DOM
         * Override this in inherited widget if necessary
         */
        _setDOMAttachedOrDetached: function() {

        },

        /**
         * Returns if element is in the DOM
         * @return {boolean} true if element in the DOM
         */
        isElementInDOM: function() {
          return !!this._element && this._element.isInDOM();
        },

        /**
         * Could the widget get interrupt?
         * @param {boolean} interruptable - true if interruptable, false otherwise
         */
        setInterruptable: function(interruptable) {
          this._interruptable = interruptable;
          if (this._element) {
            this._setElementAttribute("interruptable", interruptable ? "interruptable" : null);
          }
        },
        /**
         * returns true if widget acts as an interruptable
         * @return {boolean} true if widget acts as an interruptable
         */
        isInterruptable: function() {
          return this._interruptable;
        },

        /**
         * Updates widget interruptable active
         * @param isActive is interruptable active?
         */
        setInterruptableActive: function(isActive) {
          if (this._element) {
            this._setElementAttribute("interruptable-active", isActive ? "interruptable-active" : null);
          }
        },

        /**
         * Make the widget flash (basically when some action are forbidden)
         */
        flash: function() {
          if (this.isEnabled()) {
            this.addClass("disabled");
            this._registerTimeout(function() {
              this.removeClass("disabled");
            }.bind(this), 50);
          }
        },

        /**
         * Returns if widget has cursors
         * @return {boolean} true if widget has cursors
         */
        hasCursors: function() {
          // if widget has setCursors & getCursors functions defined -> it supports cursors
          return this.setCursors && this.getCursors;
        },

        /**
         * Manage key
         * @param {string} keyString - key string representation
         * @param {Object} domKeyEvent - key event from DOM
         * @param {boolean} repeat - true if key is being pressed
         * @returns {boolean} returns if the domKeyEvent has been processed by the widget
         */
        manageKeyDown: function(keyString, domKeyEvent, repeat) {
          if (this.isInTable()) {
            return this.getTableWidgetBase().manageKeyDown(keyString, domKeyEvent, repeat);
          }
          return false;
        },

        /**
         * Manage key before any action
         * @param {string} keyString - key string representation
         * @param {Object} domKeyEvent - key event from DOM
         * @param {boolean} repeat - true if key is being pressed
         * @returns {boolean} returns if the domKeyEvent has been processed by the widget
         */
        managePriorityKeyDown: function(keyString, domKeyEvent, repeat) {
          if (this.isInTable()) {
            return this.getTableWidgetBase().managePriorityKeyDown(keyString, domKeyEvent, repeat);
          }
          return false;
        },

        /**
         * Manage key once released (on key up).
         * @param {string} keyString - keys string representation (can be a combinaison eg: shift+a)
         * @param {Object} domKeyEvent - key event from DOM
         */
        manageKeyUp: function(keyString, domKeyEvent) {
          if (this.isInTable()) {
            this.getTableWidgetBase().manageKeyUp(keyString, domKeyEvent);
          }
        },

        /**
         * Manage mouse click
         * @param {*} domEvent - mouse click event from DOM
         * @returns {boolean} returns if event must be bubbled to parent DOM widget
         */
        manageMouseClick: function(domEvent) {
          return true;
        },

        /**
         * Manage mouse double click
         * @param {*} domEvent - mouse dblclick event from DOM
         * @returns {boolean} returns if event must be bubbled to parent DOM widget
         */
        manageMouseDblClick: function(domEvent) {
          return true;
        },

        /**
         * Manage mouse right click
         * @param {*} domEvent - mouse click event from DOM
         * @returns {boolean} returns if event must be bubbled to parent DOM widget
         */
        manageMouseRightClick: function(domEvent) {

          if (domEvent.shiftKey) {
            return false; // don't show context menu if shift key is pressed
          }

          if (context.DebugService.isActive() && domEvent.ctrlKey) {
            domEvent.preventCancelableDefault();
            return false; // right click + CTRL is used to show debugTree
          }

          this._onRequestFocus(domEvent); // request focus

          if (this.shouldShowApplicationContextMenu()) {
            var appWidget = this.getApplicationWidget();
            if (appWidget && context.ThemeService.getValue("theme-disable-context-menu") === false) {
              if (!domEvent.target.elementOrParent("gbc_ContextMenuWidget")) { // if right-click is not on a contextmenu
                appWidget.showContextMenu(domEvent.data ? domEvent.data[0] : domEvent, this);
              } else {
                // If right-click on context menu item: use a regular click instead
                domEvent.preventCancelableDefault();
                this.manageMouseClick(domEvent);
              }
              return false; // if contextmenu is managed by this widget don't bubble
            }
          }
          return false;
        },

        /**
         * Define the aria role of this widget,
         * Mostly already defined in template
         * @param {string} roleName - aria role name to set
         */
        setAriaRole: function(roleName) {
          if (roleName && this._element) {
            this._setElementAttribute("role", roleName);
          }
        },

        /**
         * Set the aria attribute of this widget,
         * @param {string} attrName - aria attribute Name to set
         * @param {*} attrVal - aria attribute value to set
         */
        setAriaAttribute: function(attrName, attrVal) {
          if (this._element && attrName) {
            this._setElementAttribute("aria-" + attrName, attrVal);
          }
        },

        /**
         * Get the aria attribute of this widget,
         * @param {string} attrName - aria attribute Name to get
         * @return {*} aria attribute value
         */
        getAriaAttribute: function(attrName) {
          if (this._element && attrName) {
            return this._element.getAttribute("aria-" + attrName);
          }
        },

        /**
         * Set the aria-selected attribute to help screen-reader to know wich widget is the current one
         */
        setAriaSelection: function() {
          this.domAttributesMutator(function() {
            var currentSelected = document.querySelector('[aria-selected="true"]');
            if (currentSelected) {
              currentSelected.removeAttribute('aria-selected');
            }
          });
          this.setAriaAttribute('selected', "true");
        },

        /**
         * Set the widget has "expanded" for better accessibility
         * @param {Boolean} expanded - true if widget is expanded, false otherwise
         */
        setAriaExpanded: function(expanded) {
          this.setAriaAttribute("expanded", expanded);
        },

        /**
         * Get the value to put in the clipboard when copying
         * @return {?string|number}
         */
        getClipboardValue: function() {
          return null;
        },

        /**
         * Helper method to update attirbutes in DOM using buffering system
         * @param {string} attr the attribute name
         * @param {*} val the attribute new value
         * @param {string|Function} [elementSelector] a string identifier of this class member or a method returning the element to set the attributes value
         * @protected
         */
        _setElementAttribute: function(attr, val, elementSelector) {
          this.domAttributesMutator(function(attr, val, elementSelector) {
            var target = null;
            if (elementSelector) {
              if (typeof elementSelector === "string") {
                target = this[elementSelector];
              } else if (typeof elementSelector === "function") {
                target = elementSelector(this);
              }
            } else {
              target = this._element;
            }
            if (target) {
              if (val === null || val === "" || typeof(val) === "undefined") {
                target.removeAttribute(attr);
              } else {
                target.setAttribute(attr, val.toString());
              }
            }
          }.bind(this, attr, val, elementSelector));
        },

        /**
         * Helper method to update textContent in DOM using buffering system
         * @param {string} text the new text
         * @param {string|function} [elementSelector] a string identifier of this class member or a method returning the element to set the textContent
         * @protected
         */
        _setTextContent: function(text, elementSelector) {
          this.domAttributesMutator(function(text, elementSelector) {
            var target = null;
            if (elementSelector) {
              if (typeof elementSelector === "string") {
                target = this[elementSelector];
              } else if (typeof elementSelector === "function") {
                target = elementSelector(this);
              }
            } else {
              target = this._element;
            }
            if (target) {
              target.textContent = text;
            }
          }.bind(this, text, elementSelector));
        },

        /**
         * Use this to update attributes of dom nodes using a buffering system
         * @param fn the function to bufferize - don't forget to bind to context
         */
        domAttributesMutator: function(fn) {
          var appWidget = this.getApplicationWidget();
          if (!appWidget || !appWidget.domAttributesMutationBuffer(fn, this)) {
            fn();
          }
        },

        /**
         * @param fn the function to bufferize - don't forget to bind to context
         */
        afterDomMutator: function(fn) {
          var appWidget = this.getApplicationWidget();
          if (!appWidget || !appWidget.afterDomMutationBuffer(fn, this)) {
            this._registerAnimationFrame(fn);
          }
        }
      };
    });
  });
;
"use strict";

/**
 * @readonly
 * @enum {string};
 */
gbc.constants.widgetEvents = {
  activate: 'g_activate',
  afterLayout: 'g_afterLayout',
  afterLayoutComplete: 'g_afterLayoutComplete',
  afterLayoutFocusRestored: 'g_afterLayoutFocusRestored',
  blur: 'g_blur',
  change: 'g_change',
  click: 'g_click',
  close: 'g_close',
  copy: 'g_copy',
  contextMenu: 'g_contextMenu',
  created: 'g_created',
  disable: 'g_disable',
  displayChanged: "g_displayChanged",
  destroyed: 'g_destroyed',
  doubleClick: 'g_doubleClick',
  enter: 'g_enter',
  esc: 'g_esc',
  focus: 'g_focus',
  focusRestored: 'g_focusRestored',
  frozen: "g_frozen",
  gridInfoChanged: 'g_gridInfoChanged',
  keyDown: 'g_keyDown',
  keyUp: 'g_keyUp',
  keyArrowDown: 'g_keyArrowDown',
  keyArrowLeft: 'g_keyArrowLeft',
  keyArrowRight: 'g_keyArrowRight',
  keyArrowUp: 'g_keyArrowUp',
  keyEnd: 'g_keyEnd',
  keyHome: 'g_keyHome',
  keyPageUp: 'g_keyPageUp',
  keyPageDown: 'g_keyPageDown',
  keySpace: 'g_keySpace',
  layout: 'g_layout',
  layoutApplied: 'g_layoutApplied',
  layoutInformationChanged: 'g_layoutInformationChanged',
  layoutRequest: 'g_layoutRequest',
  logStepDone: 'g_logStepDone',
  logForwardDone: 'g_logForwardDone',
  modalOut: 'g_modalOut',
  modalResize: "g_modalResize",
  mousewheel: 'g_mouseWheel',
  offset: 'g_offset',
  onBeforeUnload: "g_onbeforeunload",
  onBlur: "g_onBlur",
  onUnload: "g_onunload",
  pageSize: 'g_pageSize',
  pageVisibility: 'g_pageVisibility',
  ready: 'g_ready',
  requestFocus: 'g_requestFocus',
  restart: "g_restart",
  rightClick: 'g_rightClick',
  rowAction: 'g_rowAction',
  scroll: 'g_scroll',
  select: 'g_select',
  selectAll: 'g_selectAll',
  space: 'g_space',
  splitter: 'g_splitter',
  splitterStart: 'g_splitterStart',
  splitterEnd: 'g_splitterEnd',
  splitViewChange: 'g_splitViewChange',
  tableColumnAfterLastItemClick: 'g_tableColumnAfterLastItemClick',
  tableDragEnter: 'g_tableDragEnter',
  tableDragEnd: 'g_tableDragEnd',
  tableDragLeave: 'g_tableDragLeave',
  tableDragStart: 'g_tableDragStart',
  tableDrop: 'g_tableDrop',
  tableDragOver: 'g_tableDragOver',
  tableHeaderClick: 'g_tableHeaderClick',
  tableHeaderOrder: 'g_tableHeaderOrder',
  tableLeftFrozen: 'g_tableTableLeftFrozen',
  tableOrderColumn: 'g_tableOrderColumn',
  tableResetToDefault: 'g_tableResetToDefault',
  tableResizeCol: 'g_tableResizeCol',
  tableRightFrozen: 'g_tableTableRightFrozen',
  tableShowHideCol: 'g_tableShowHideCol',
  tableClick: 'g_tableClick',
  themeChange: 'g_themeChange',
  toggleClick: "g_toggleClick",
  touchEnd: "g_touchEnd",
  touchMove: "g_touchMove",
  touchStart: "g_touchStart",
  unfrozen: "g_unfrozen",
  visibilityChange: "g_visibilityChange",
  webcomponentKeyDown: "g_webcomponentKeyDown"
};
;
"use strict";

modulum('WidgetFactory', ['Factory', 'LogService'],

  /**
   * @typedef {Object} WidgetFactoryId
   * @property {?string} parentIdentifier
   * @property {?string} parentStyle
   * @property {Object|?string} parentAttributes
   * @property {?string} identifier
   * @property {?string} style
   * @property {Object|?string} attributes
   * @property {number} weight
   * @property {number} attributesWeight
   * @property {number} parentAttributesWeight
   * @property {number} weight
   * @property {number} timestamp
   * @property {?Function} builder
   */

  function(context, cls) {
    /**
     * @namespace classes.WidgetFactory
     */
    cls.WidgetFactory = context.oo.StaticClass(function() {
      return /** @lends classes.WidgetFactory */ {

        /**
         * @const
         * @private
         */
        _selectorRegExp: /^\s*(?:([a-zA-Z]+)(?:\.([a-zA-Z0-9_-]+))?((?:\[[a-zA-Z0-9_-]+=[a-zA-Z0-9_\s-]+])+)?\s+)?([a-zA-Z]+)(?:\.([a-zA-Z0-9_-]+))?((?:\[[a-zA-Z0-9_-]+=[a-zA-Z0-9_\s-]+])+)?\s*$/,
        _selectorAttributesRegExp: /(?:\[([a-zA-Z0-9_-]+)=([a-zA-Z0-9_\s-]+)])/g,

        /**
         * @type {Object.<string, WidgetFactoryId>}
         * @private
         */
        _fabrics: {},

        /**
         * @type {Object.<string, WidgetFactoryId>}
         * @private
         */
        _themeFabrics: {},

        /**
         *
         * @param {string} selector Selector matcher as "[parentNode[.parentStyle]] id[.style]"
         * @param {Function} constructor constructor of the widget
         */
        registerBuilder: function(selector, constructor) {
          this._register(this._sanitizeId(selector), constructor);
        },

        /**
         * parse the fabric selector
         * @param {string} selector the selector
         * @private
         * @returns {WidgetFactoryId} the parsed id
         */
        _sanitizeId: function(selector) {
          var result = {
            parentIdentifier: "",
            parentStyle: "",
            parentAttributes: "",
            identifier: "",
            style: "",
            attributes: "",
            weight: 0,
            attributesWeight: 0,
            parentAttributesWeight: 0,
            timestamp: Date.now(),
            builder: null
          };
          var exec = this._selectorRegExp.exec(selector);
          if (exec) {
            var _attrs, curr, i = 0;
            result.parentIdentifier = exec[1] || "";
            result.parentStyle = exec[2] || "";
            result.parentAttributes = exec[3] || "";
            if (result.parentAttributes) {
              i = 0;
              _attrs = result.parentAttributes;
              result.parentAttributes = {};
              /*jshint -W084 */
              while (curr = this._selectorAttributesRegExp.exec(_attrs)) {
                result.parentAttributes[curr[1]] = curr[2];
                i++;
              }
            }
            result.parentAttributesWeight = i;
            result.identifier = exec[4];
            result.style = exec[5] || "";
            result.attributes = exec[6] || "";
            if (result.attributes) {
              i = 0;
              _attrs = result.attributes;
              result.attributes = {};
              while (curr = this._selectorAttributesRegExp.exec(_attrs)) {
                result.attributes[curr[1]] = curr[2];
                i++;
              }
            }
            result.attributesWeight = i;
            result.weight = (result.parentIdentifier ? 4 : 0) + (result.parentStyle ? 2 : 0) + (result.style ? 1 : 0);
          } else {
            context.LogService.warn("WidgetFactory - Trying to register widget with wrong selector: '" + selector + "'");
          }
          return result;
        },

        /**
         * register a widget fabric
         * @private
         * @param {WidgetFactoryId} id the fabric id
         * @param {Function?} constructor constructor of the widget
         * @param {boolean} [_fromTheme] internal param - true if register comes from a theme
         */
        _register: function(id, constructor, _fromTheme) {
          var fabrics = this._fabrics;
          if (_fromTheme) {
            fabrics = this._themeFabrics;
          }
          if (id.identifier) {
            id.builder = constructor;
            var store = (fabrics[id.identifier] = fabrics[id.identifier] || []);
            store.push(id);
            store.sort(this._compareFabrics);
          }
        },

        _compareFabrics: function(a, b) {
          return (b.weight - a.weight) ||
            (b.parentAttributesWeight - a.parentAttributesWeight) ||
            (b.attributesWeight - a.attributesWeight) ||
            (b.timestamp - a.timestamp);
        },

        /**
         * @deprecated
         * @param {string} id
         * @param {string|?Function} style style of the widget
         * @param {?Function} constructor constructor of the widget
         */
        register: function(id, style, constructor) {
          if (!constructor) {
            constructor = style;
            style = "";
          }
          this.registerBuilder(id + (style ? ("." + style) : ""), constructor);
        },

        /**
         *
         * @deprecated
         * @param {string} id
         * @param {string} [styles]
         * @returns {classes.WidgetBase}
         */
        create: function(id, styles, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) {
          var result = null;
          if (this._fabrics[id]) {
            if (!styles) {
              result = this._fabrics[id].filter(function(f) {
                return !f.weight && !f.attributesWeight && !f.parentAttributesWeight;
              })[0];
            } else {
              var pos = 0,
                fabrics = this._fabrics[id].filter(function(f) {
                  return f.weight <= 1 && !f.attributesWeight && !f.parentAttributesWeight;
                });
              while (!result && (pos < fabrics.length)) {
                var fabric = fabrics[pos];
                if (!fabric.style || styles.trim().split(cls.NodeBase.stylesSeparatorRegExp).indexOf(fabric.style)) {
                  result = fabric;
                }
                pos++;
              }
            }
          }
          if (result && result.builder) {
            var Fabric = result.builder;
            result = new Fabric(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
          }
          return result;
        },
        /**
         *
         * @param {string} id
         * @param {?*} [builderParameters]
         * @param {classes.NodeBase|classes.WidgetBase} [contextInstance]
         * @return {?classes.WidgetBase}
         */
        createWidget: function(id, builderParameters, contextInstance) {
          var result = null;
          var Fabric = this._findFabric(id, builderParameters, contextInstance);
          var ThemeFabric = this._findFabric(id, builderParameters, contextInstance, true);
          if (ThemeFabric && (!Fabric || this._compareFabrics(Fabric, ThemeFabric) >= 0)) {
            Fabric = ThemeFabric;
          }
          if (Fabric) {
            Fabric = Fabric.builder;
            result = new Fabric(builderParameters);
          }
          return result;
        },
        /**
         *
         * @param {string} id
         * @param {?*} [builderParameters]
         * @param {classes.NodeBase|classes.WidgetBase} [contextInstance]
         * @param {Boolean} [_fromTheme]
         * @return {?WidgetFactoryId}
         * @private
         */
        _findFabric: function(id, builderParameters, contextInstance, _fromTheme) {
          var fabrics = this._fabrics;
          if (_fromTheme) {
            fabrics = this._themeFabrics;
          }
          var result = null;
          if (fabrics[id]) {
            if (!contextInstance) {
              result = fabrics[id].filter(function(f) {
                return !f.weight && !f.attributesWeight && !f.parentAttributesWeight;
              })[0];
            } else {
              var pos = 0;
              while (!result && (pos < fabrics[id].length)) {
                if (this._matchFabric(fabrics[id][pos], builderParameters, contextInstance)) {
                  result = fabrics[id][pos];
                }
                pos++;
              }
            }
          }
          return result;
        },
        /**
         *
         * @param {WidgetFactoryId} fabric
         * @param {?*} [builderParameters]
         * @param {classes.NodeBase|classes.WidgetBase} [contextInstance]
         * @returns {boolean}
         * @private
         */
        _matchFabric: function(fabric, builderParameters, contextInstance) {
          var result = !fabric.parentIdentifier,
            contextInstanceLocal = contextInstance;
          if (fabric.parentIdentifier) {
            if (contextInstance && contextInstance.isInstanceOf && contextInstance.isInstanceOf(cls.NodeBase)) {
              result = contextInstance.getAncestorWithStyle(fabric.parentIdentifier, fabric.parentStyle);
            } else if (builderParameters &&
              typeof builderParameters.appHash === "number" &&
              typeof builderParameters.auiTag === "number") {
              var app = context.SessionService.getCurrent().getApplicationByHash(builderParameters.appHash);
              result = app && app.model.getNode(builderParameters.auiTag);
              contextInstanceLocal = result;
              result = result.getAncestorWithStyle(fabric.parentIdentifier, fabric.parentStyle);
            }
          }
          result = result && (!fabric.parentAttributesWeight || (result !== true && this._matchAttributes(fabric.parentAttributes,
            result._initialStyleAttributes)));
          result = result && (!fabric.style || (contextInstanceLocal._vmStyles.indexOf(fabric.style) >= 0));
          result = result && (!fabric.attributesWeight || this._matchAttributes(fabric.attributes, contextInstanceLocal
            ._initialStyleAttributes));
          return result;
        },

        _matchAttributes: function(neededAttributes, nodeAttributes) {
          var result = true,
            keys = Object.keys(neededAttributes),
            i = 0,
            len = keys.length;

          while (result && i < len) {
            result = neededAttributes[keys[i]] === nodeAttributes[keys[i]];
            i++;
          }
          return result;
        },

        /**
         * set theme overrides
         * @param {Object<string, string>} overrides theme overrides definitions
         */
        registerThemeOverrides: function(overrides) {
          this._themeFabrics = {};
          var i = 0,
            keys = overrides && Object.keys(overrides) || [],
            len = keys.length;
          for (; i < len; i++) {
            var selector = keys[i],
              constructor = null;
            if (/^cls\./.test(overrides[selector])) {
              constructor = context.classes[overrides[selector].replace(/^cls\./, "")];
            }
            this._register(this._sanitizeId(selector), constructor);
          }
        }
      };
    });
  });
;
"use strict";

modulum('WidgetGridLayoutBase', ['WidgetGroupBase'],
  function(context, cls) {

    /**
     * Base class for widget group.
     * @class WidgetGridLayoutBase
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     */
    cls.WidgetGridLayoutBase = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.WidgetGridLayoutBase.prototype */ {
        __name: "WidgetGridLayoutBase",
        /**
         * Whether or not is GridChildrenInParent
         * @type {!boolean}
         */
        _isGridChildrenInParent: null,
        _rerouteChildren: false,
        _owned: null,
        _scrolling: false,
        _wheelHandling: false,
        _wheelThrottleHandler: null,
        _wheelThrottleTimeout: null,

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          this._wheelThrottleTimeout = cls.ScrollUIBehavior._throttleTimeout * 4;
          this._owned = [];
          this._element.addClass("g_Grid");
          this._containerElement.addClass("g_GridLayoutEngine");
        },

        /**
         * @inheritDoc
         */
        _initLayout: function(noLayoutEngine) {
          $super._initLayout.call(this);
          if (!noLayoutEngine) {
            this._layoutEngine = new cls.GridLayoutEngine(this);
          }
        },

        /**
         * @inheritDoc
         */
        _addChildWidgetToDom: function(widget, position) {
          this.getLayoutEngine().registerChild(widget);
          var widgetGridHost = document.createElement('div');
          widgetGridHost.addClass('g_GridElement');
          var info = widget.getLayoutInformation();
          if (info) {
            info.setHostElement(widgetGridHost);
          }
          if (widget instanceof cls.ScrollAreaWidget) {
            if (!this._wheelHandling) {
              this._wheelHandling = true;
              this._element.addEventListener("wheel", this._handleWheel.bind(this));
            }
            widgetGridHost.addClass('g_GridElement_scrollzone');
          } else {
            widgetGridHost.addClass('g_GridElement_scrollignore');
          }
          widgetGridHost.appendChild(widget._element);
          widgetGridHost.insertAt(position, this._containerElement);
        },

        /**
         * Manage mousewheel event
         * @param {MouseEvent} event the event
         * @private
         */
        _handleWheel: function(event) {
          if (this._wheelHandling) {
            if (this._wheelThrottleHandler) {
              this._clearTimeout(this._wheelThrottleHandler);
            }
            if (!this._scrolling) {
              this._scrolling = true;
              this._element.addClass("g_scrolling");
            }
            this._wheelThrottleHandler = this._registerTimeout(function() {
              this._scrolling = false;
              this._wheelThrottleHandler = null;
              this._element.removeClass("g_scrolling");
            }.bind(this), this._wheelThrottleTimeout);
          }
        },

        /**
         * @inheritDoc
         */
        _removeChildWidgetFromDom: function(widget) {
          this.getLayoutEngine().unregisterChild(widget);
          var info = widget.getLayoutInformation(),
            host = info && info.getHostElement();
          if (host && host.parentNode === this._containerElement) {
            widget._element.remove();
            host.remove();
            host = null;
          }
        },
        /**
         * Is it GridChildrenInParent ?
         * @return {boolean} true if it is GridChildrenInParent
         */
        isGridChildrenInParent: function() {
          return this._isGridChildrenInParent;
        },
        /**
         * Set GridChildrenInParent state
         * @param {boolean} isGridChildrenInParent the wanted state
         */
        setGridChildrenInParent: function(isGridChildrenInParent) {
          if (this._isGridChildrenInParent !== isGridChildrenInParent) {
            this._isGridChildrenInParent = isGridChildrenInParent;
            if (this._isGridChildrenInParent) {
              this._moveOwnChildrenToParent();
            } else {
              this._moveOwnChildrenToSelf();
            }
          }
        },

        /**
         * @inheritDoc
         */
        addChildWidget: function(widget, options) {
          if (this._rerouteChildren) {
            this._owned.push(widget);
            var layoutInfo = widget.getLayoutInformation();
            if (layoutInfo) {
              layoutInfo.setOwningGrid(this);
            }
            this.getParentWidget().addChildWidget(widget, options);
          } else {
            $super.addChildWidget.call(this, widget, options);
          }
        },

        /**
         * @inheritDoc
         */
        removeChildWidget: function(widget, options) {
          if (this._rerouteChildren) {
            this.getParentWidget().removeChildWidget(widget, options);
            var layoutInfo = widget.getLayoutInformation();
            if (layoutInfo) {
              layoutInfo.setOwningGrid(null);
            }
          } else {
            $super.removeChildWidget.call(this, widget, options);
          }
        },

        /**
         * Get a copy of children list
         * @return {Array.<classes.WidgetBase>} a copy list of children
         * @private
         */
        _listChildrenToMoveWhenGridChildrenInParent: function() {
          return this._children.slice();
        },

        /**
         * Move self children to parent on GridChildrenInParent
         * @private
         */
        _moveOwnChildrenToParent: function() {
          var children = [];
          var childrenToMove = this._listChildrenToMoveWhenGridChildrenInParent();
          while (childrenToMove.length) {
            var child = childrenToMove.shift();
            this.removeChildWidget(child);
            children.push(child);
          }
          this._rerouteChildren = true;
          while (children.length) {
            this.addChildWidget(children.shift());
          }
        },
        /**
         * Move self children to itself on GridChildrenInParent
         * @private
         */
        _moveOwnChildrenToSelf: function() {
          var children = [];
          while (this._owned.length) {
            var child = this._owned[0];
            this.removeChildWidget(child);
            children.push(child);
          }
          this._rerouteChildren = false;
          while (children.length) {
            this.addChildWidget(children.shift());
          }
        }
      };
    });
  });
;
"use strict";

modulum('WidgetGroupBase', ['TextWidgetBase'],
  function(context, cls) {

    /**
     * Base class for widget group.
     * @class WidgetGroupBase
     * @memberOf classes
     * @extends classes.TextWidgetBase
     * @publicdoc Widgets
     */
    cls.WidgetGroupBase = context.oo.Class(cls.TextWidgetBase, function($super) {
      return /** @lends classes.WidgetGroupBase.prototype */ {
        __name: "WidgetGroupBase",
        __virtual: true,
        /**
         * the container element
         * @type HTMLElement
         * @protected
         */
        _containerElement: null,
        /**
         * the children widget
         * @type {classes.WidgetBase[]}
         * @protected
         */
        _children: null,
        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          this._children = [];
          $super.constructor.call(this, opts);
        },
        /**
         * @inheritDoc
         */
        _afterInitElement: function() {
          $super._afterInitElement.call(this);
          this._initContainerElement();
        },

        /**
         * init the container element
         * @protected
         */
        _initContainerElement: function() {
          var elt = this._element;
          this._containerElement = elt.hasClass("containerElement") ? elt : elt.getElementsByClassName("containerElement")[0];
          if (!this._containerElement) {
            throw "Widgets inheriting WidgetGroupBase must have one container with class containerElement in its template";
          }
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._containerElement = null;
          if (this._children.length > 0) {
            gbc.error(this.__name + "(uuid: " + this.getUniqueIdentifier() + ") has been destroyed whereas it still has children");
          }
          $super.destroy.call(this);
        },

        /**
         * Destroy all children widgets
         */
        destroyChildren: function() {
          var children = this.getChildren();
          if (children) {
            for (var i = children.length - 1; i > -1; i--) {
              var currentChildren = children[i];
              currentChildren.destroy();
              currentChildren = null;
            }
          }
          this._children.length = 0;
        },

        /**
         * Get the container Element
         * @return {HTMLElement} the element
         * @publicdoc
         */
        getContainerElement: function() {
          return this._containerElement;
        },

        /**
         * Add a child widget to the widget
         * @param {classes.WidgetBase} widget the widget to add
         * @param {Object=} options - possible options
         * @param {boolean=} options.noDOMInsert - won't add child to DOM
         * @param {number=} options.position - insert position
         * @param {string=} options.tag - context tag
         * @param {string=} options.mode - context mode : null|"replace"
         * @publicdoc
         */
        addChildWidget: function(widget, options) {
          options = options || {};

          if (!!widget._parentWidget && widget._parentWidget !== this) {
            gbc.error(this.__name + "(uuid: " + this.getUniqueIdentifier() +
              ") addChildWidget cannot be executed if child has already a parent");
          }

          var position = Object.isNumber(options.position) ? options.position : (this._children.length);
          if (options.ordered) {
            if (this._children.length > 0) {
              for (var i = this._children.length; i > 0; i--) {
                if (widget.getAuiLinkedUniqueIdentifier() < this._children[i - 1].getAuiLinkedUniqueIdentifier()) {
                  position = i - 1;
                }
              }
            }
          }

          widget.setParentWidget(this, {
            noLayoutInvalidation: !!options.noDOMInsert
          });
          if (!options.noDOMInsert) {
            this._addChildWidgetToDom(widget, position);
            widget._setDOMAttachedOrDetached();
          }
          this._children.splice(position, 0, widget);
        },

        /**
         * Add a child widget which has already a parent to the widget
         * @param {classes.WidgetBase} widget the widget to add
         * @param {Object=} options - possible options
         * @param {boolean=} options.noDOMInsert - won't add child to DOM
         * @param {number=} options.position - insert position
         * @param {string=} options.ordered - auto order item by unique auiID
         * @param {string=} options.tag - context tag
         * @param {string=} options.mode - context mode : null|"replace"
         * @publicdoc
         */
        adoptChildWidget: function(widget, options) {
          options = options || {};

          if (widget.getParentWidget()) {
            var children = widget.getParentWidget().getChildren();
            if (children) {
              children.remove(widget);
            }
          }

          var position = Object.isNumber(options.position) ? options.position : (this._children.length);

          if (options.ordered) {
            if (this._children.length > 0) {
              for (var i = this._children.length; i > 0; i--) {
                if (widget.getAuiLinkedUniqueIdentifier() < this._children[i - 1].getAuiLinkedUniqueIdentifier()) {
                  position = i - 1;
                }
              }
            }
          }
          if (!options.noDOMInsert) { // move DOM element
            this._addChildWidgetToDom(widget, position);
          } else { // just remove DOM element from previous location
            this._removeChildWidgetFromDom(widget);
          }
          widget.setParentWidget(this, {
            noLayoutInvalidation: !!options.noDOMInsert
          });
          this._children.splice(position, 0, widget);

          widget._setDOMAttachedOrDetached();
        },

        /**
         * add child widget to dom
         * @param {classes.WidgetBase} widget the widget to add
         * @param {number} position where to add the widget
         * @protected
         */
        _addChildWidgetToDom: function(widget, position) {
          widget._element.insertAt(position, this._containerElement);
        },

        /**
         * Remove a child widget from this widget
         * @param {classes.WidgetBase} widget the widget to remove
         * @publicdoc
         */
        removeChildWidget: function(widget) {
          this._removeChildWidgetFromDom(widget);
          widget.setParentWidget(null);
          if (this._children) {
            this._children.remove(widget);
          }
          widget._setDOMAttachedOrDetached();
        },
        /**
         * remove child widget from dom
         * @param {classes.WidgetBase} widget the widget to remove
         * @protected
         */
        _removeChildWidgetFromDom: function(widget) {
          if (widget._element.parentNode === this._containerElement) {
            widget._element.remove();
          }
        },

        /**
         * Remove a child widget to use another widget instead
         * @param {classes.WidgetBase} oldWidget the widget to replace
         * @param {classes.WidgetBase} newWidget the widget to add
         * @publicdoc
         */
        replaceChildWidget: function(oldWidget, newWidget) {
          var index = this.getIndexOfChild(oldWidget);
          var layoutInfo = newWidget.getLayoutInformation();
          if (layoutInfo) {
            layoutInfo.setOwningGrid(oldWidget.getLayoutInformation() && oldWidget.getLayoutInformation().getOwningGrid());
          }
          this.removeChildWidget(oldWidget);
          this.addChildWidget(newWidget, {
            position: index,
            mode: "replace"
          });
        },

        /**
         * Remove all children
         * @publicdoc
         */
        empty: function() {
          var remove = this._children.slice();
          for (var i = 0; i < remove.length; i++) {
            this.removeChildWidget(remove[i]);
          }
        },

        /**
         * Get the child widget position
         * @param {classes.WidgetBase} widget the widget
         * @returns {number} widget position
         * @publicdoc
         */
        getIndexOfChild: function(widget) {
          return this._children.indexOf(widget);
        },

        /**
         * Get all children of this widget
         * @returns {classes.WidgetBase[]} the list of children of this widget group
         * @publicdoc
         */
        getChildren: function() {
          return this._children;
        },

        /**
         * Returns current widget (flagged with 'current' class)
         * @returns {?classes.WidgetBase} The current child
         * @publicdoc
         */
        getCurrentChildren: function() {
          for (var i = 0; i < this._children.length; i++) {
            var child = this._children[i];
            if (child.getElement().hasClass("current")) {
              return child;
            }
          }
          return null;
        },

        /**
         * returns true if a WebComponent is contained in any sublevel child
         * @publicdoc
         * @returns {boolean} true if the widget has webcomponent, false otherwise
         */
        hasChildWebComponent: function() {
          return this._hasWebcomp; // Tell window that it has a webcomp
        },

        /**
         * Flag/unflag having child with WebComponent
         * @param {boolean} has - flag the widget as having a webcomponent
         */
        setHasChildWebComponent: function(has) {
          this._hasWebcomp = has;
        },

      };
    });
  });
;
"use strict";

modulum('MenuWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Menu widget.
     * @class MenuWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     */
    cls.MenuWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.MenuWidget.prototype */ {
        __name: 'MenuWidget',

        /**
         * Element that hold the text
         * @protected
         * @type HTMLElement
         */
        _textElement: null,

        /** @type {?string} */
        _text: null,

        /**
         * Image of the menu
         * @protected
         * @type {classes.ImageWidget}
         */
        _image: null,

        /**
         * If menu is set as modal, it's stored here
         * @protected
         * @type {classes.ModalWidget}
         */
        _modalWidget: null,

        /**
         * Type of the menu
         * @protected
         * @type {?string}
         */
        _menuType: null,

        /**
         * last known menu panel position
         * @type {!string}
         */
        _menuPanelPosition: null,

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          this._textElement = this._element.getElementsByClassName('gbc_MenuWidgetText')[0];

          // default orientation is vertical
          this._element.removeClass('gbc_MenuWidget_horizontal').addClass('gbc_MenuWidget_vertical');
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          this._layoutInformation = new cls.LayoutInformation(this);
          this._layoutEngine = new cls.MenuLayoutEngine(this);
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._modalWidget) {
            this._modalWidget.hide();
            this._modalWidget.destroy();
            this._modalWidget = null;
          }

          if (this._image) {
            this._image.destroy();
            this._image = null;
          }

          this._textElement = null;

          $super.destroy.call(this);
        },

        /**
         * Set the text of the menu
         * @param {string} text - text to set
         */
        setText: function(text) {
          if (!this._chromeBar) {
            this._text = text;
            this._setTextContent(text, "_textElement");
            this.setAriaAttribute('label', this.getText());
          }
        },

        /**
         * Get the text of the menu
         * @return {string}
         */
        getText: function() {
          return this._text;
        },

        /**
         * Define the image of the menu
         * @param {classes.ImageWidget} image - img widget
         */
        setImage: function(image) {
          if (!this._image) {
            if (!image) {
              return;
            }
            this._image = cls.WidgetFactory.createWidget('ImageWidget', this.getBuildParameters());
            this._element.getElementsByClassName('gbc_MenuWidgetTitle')[0].prependChild(this._image.getElement());
          }
          this._image.setSrc(image);
        },

        /**
         * Get image of the menu
         * @return {?string} - source of the image, null if not set
         */
        getImage: function() {
          if (this._image) {
            return this._image.getSrc();
          }
          return null;
        },

        /**
         * Set the tooltip of the menu
         * @param {string} title the tooltip text
         */
        setTitle: function(title) {
          this._element.setAttribute('title', title);
        },

        /**
         * Get the title of the menu
         * @returns {string} the tooltip text
         */
        getTitle: function() {
          return this._element.getAttribute('title');
        },

        /**
         * @inheritDoc
         */
        setBackgroundColor: function(color) {
          $super.setBackgroundColor.call(this, color);
          if (this._modalWidget) {
            this._modalWidget.setBackgroundColor(color);
          }
        },

        /**
         * Set the menu state
         * @param {boolean} enabled - true if the widget allows user interaction, false otherwise.
         */
        setEnabled: function(enabled) {
          $super.setEnabled.call(this, enabled);
          // if a menu get active and was previously hidden, it has to be displayed
          if (enabled && this.isHidden()) {
            this.setHidden(false);
          }
          // a modal or popup which gets disabled has to be hidden
          if (!enabled && this._modalWidget && this._modalWidget.isVisible() && (this.isModal() || this.isPopup())) {
            this._modalWidget.hide();
          }
        },

        /**
         * Change the orientation of the menu
         * @param {string} orientation  - layout orientation. 'vertical' or 'horizontal'.
         */
        setOrientation: function(orientation) {
          if (this.getOrientation() !== orientation) {
            this._element.toggleClass('gbc_MenuWidget_horizontal', orientation !== 'vertical');
            this._element.toggleClass('gbc_MenuWidget_vertical', orientation === 'vertical');
          }
        },

        /**
         * Get the orientation of the menu
         * @returns {string} 'vertical' or 'horizontal'.
         */
        getOrientation: function() {
          if (this._element.hasClass('gbc_MenuWidget_vertical')) {
            return 'vertical';
          }
          return 'horizontal';
        },

        /**
         * Set menu visibility
         * @param {boolean} hidden - hide the menu if set to true
         */
        setHidden: function(hidden) {
          if (this._hidden !== hidden) {
            this._hidden = !!hidden;
            $super.setHidden.call(this, hidden);
            if (this._modalWidget) {
              if (this._hidden) {
                this._modalWidget.hide();
              } else {
                this._modalWidget.show();
              }
            }
          }
          if (this._chromeBar) {
            this._chromeBar.setMenuItemsHidden(hidden);
          }
        },

        /**
         * Know if menu is displayed as popup
         * @return {boolean}
         */
        isPopup: function() {
          return this._menuType === 'popup';
        },

        /**
         * Know if menu is displayed as a modal
         * @return {boolean}
         */
        isModal: function() {
          return this._menuType === 'dialog' || this._menuType === 'winmsg'; // winmsg = fgldialog
        },

        /**
         * @inheritDoc
         */
        managePriorityKeyDown: function(keyString, domKeyEvent, repeat) {
          var keyProcessed = false;

          if (this.isPopup() && this._modalWidget && this._modalWidget.isVisible()) {
            switch (keyString) {
              case "space":
              case "enter":
              case "return":
                this._modalWidget.getCurrentChildren().emit(context.constants.widgetEvents.click, null);
                keyProcessed = true;
                break;
            }

            if (!keyProcessed) {
              keyProcessed = this._modalWidget.managePriorityKeyDown(keyString, domKeyEvent, repeat);
            }
          }
          return keyProcessed;
        },

        /**
         * Defines the menu to be displayed as a modal one
         * @param {string} modalType - could be 'popup', 'dialog' or 'winmsg'
         */
        setAsModal: function(modalType) {
          this._menuType = modalType;
          var tabbedMode = context.SessionService.getCurrent().isInTabbedContainerMode();
          var tabContainer = context.SessionService.getCurrent().getTabbedContainerModeHostApplication();
          // DROPDOWN MENU
          if (this.isPopup()) {
            this._modalWidget = cls.WidgetFactory.createWidget('ChoiceDropDown', this.getBuildParameters());
            this._modalWidget.setParentWidget(this, {
              noLayoutInvalidation: true
            });
            this._modalWidget.getElement().addClass('menu');

            while (this.getChildren().length) {
              this._modalWidget.adoptChildWidget(this.getChildren().shift());
            }
            //Place it at the middle center of the screen if menu opens automatically
            this._modalWidget.x = context.WidgetService.cursorX || 'CENTER';
            this._modalWidget.y = context.WidgetService.cursorY || 'CENTER';

            this._modalWidget.when(cls.DropDownWidget.widgetEvents.dropDownClose, this._onClose.bind(this));

            this._onRequestFocus(); // request focus

            // display dropdown in animation frame because we need dropdown items (menuaction) to be measured before dropdown
            this.afterDomMutator(function() {
              this._modalWidget.show();
            }.bind(this));

            // MODAL MENU
          } else if (this.isModal()) {
            var parentWidget = tabbedMode ? this.getApplicationWidget() : this.getWindowWidget();

            if (!this._modalWidget) {
              this._modalWidget = cls.WidgetFactory.createWidget('Modal', this.getBuildParameters());
              var parentNode = parentWidget.getElement();
              if (parentWidget.isModal) {
                parentNode = parentWidget.getModal().getElement().parentNode;
              }
              parentNode.appendChild(this._modalWidget.getElement());
            }

            if (!parentWidget || !parentWidget.getText || parentWidget.getText() !== this.getText()) {
              this._modalWidget.setHeader(this.getText());
            } else { // menu dialog with parent window of type popup : no title to add and hide window close button
              if (parentWidget.getModal) {
                var parentModal = parentWidget.getModal();
                if (parentModal) {
                  parentModal.setClosable(false);
                }
              }
            }
            this._modalWidget.setImage(this.getImage());
            this._modalWidget.setClosable(false);
            this._modalWidget.setContent(this.getTitle());
            this._modalWidget.setFooter(this.getElement());
            this._modalWidget.addClass('gbc_ModalMenuDialog');
            if (tabbedMode) {
              this._modalWidget.addClass('tabbedContainer_Modal');
            }
            this.setOrientation('horizontal');
            this._element.addClass('gbc_ModalMenu');
            this._modalWidget.setStyle('.mt-dialog-content', {
              'white-space': 'pre'
            });
            this._modalWidget.setBackgroundColor(this._backgroundColor);

            this._modalWidget.show();
          }
        },

        /**
         * Will update the position if menu is in a modal
         * @private
         */
        _updateModalPosition: function() {
          if (this._modalWidget && this._modalWidget.resizeHandler) {
            this._modalWidget.resizeHandler();
          }
        },

        /**
         * Define this menu as a chromebar
         * @param chromeBar
         */
        setAsChromeBar: function(chromeBar) {
          this._chromeBar = chromeBar;
        },

        /**
         * Check if this menu is a chromebar
         * @return {boolean}
         */
        isChromeBar: function() {
          return !!this._chromeBar;
        },

        /**
         * @inheritDoc
         */
        _onClose: function() {
          this.emit(context.constants.widgetEvents.close);
        },

        /**
         * Manage actionPanel position
         * actionPanelPosition (Dialog) + ringMenuPosition (Menu) 4ST attribute
         * @param position
         */
        setActionPanelPosition: function(position) {
          if (!this._menuType) {
            var windowMenuContainer = this.getWindowWidget().getMenuContainer(position);
            if (windowMenuContainer) {
              if (windowMenuContainer.firstChild !== this._element) {
                if (windowMenuContainer.firstChild) {
                  windowMenuContainer.removeChild(windowMenuContainer.firstChild);
                }
                windowMenuContainer.appendChild(this._element);
              }
              this.domAttributesMutator(function(windowMenuContainer) {
                windowMenuContainer.removeClass('hidden');
              }.bind(this, windowMenuContainer));
            } else if (position !== "chrome") {
              this.setHidden(true);
            }
            if (position !== this._menuPanelPosition) {
              this.getWindowWidget().getLayoutEngine().invalidateAllocatedSpace();
              this._menuPanelPosition = position;
            }
          }
        },

        /**
         * @inheritDoc
         */
        hasFocus: function() {
          return true;
        }

      };
    });
    cls.WidgetFactory.registerBuilder('Menu', cls.MenuWidget);
    cls.WidgetFactory.registerBuilder('Dialog', cls.MenuWidget);
  });
;
"use strict";

modulum('StartMenuCommandWidget', ['TextWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * StartMenuCommand widget.
     * @class StartMenuCommandWidget
     * @memberOf classes
     * @extends classes.TextWidgetBase
     */
    cls.StartMenuCommandWidget = context.oo.Class(cls.TextWidgetBase, function($super) {
      return /** @lends classes.StartMenuCommandWidget.prototype */ {
        __name: 'StartMenuCommandWidget',

        /**
         * Image of the startMenu command
         * @protected
         * @type {classes.ImageWidget}
         */
        _image: null,

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          this.emit(context.constants.widgetEvents.click);
          return false;
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._image) {
            this._image.destroy();
            this._image = null;

          }
          $super.destroy.call(this);
        },

        /**
         * Set the text of the command
         * @param {string} text
         */
        setText: function(text) {
          this._setTextContent(text, function() {
            return this._element.getElementsByClassName('gbc_startMenuCommandText')[0];
          }.bind(this));
        },

        /**
         * Get the text of the command
         * @return {string}
         */
        getText: function() {
          return this._element.getElementsByClassName('gbc_startMenuCommandText')[0].textContent;
        },

        /**
         * Set the title to appear as tooltip
         * @param {string} title
         */
        setTitle: function(title) {
          this._element.setAttribute('title', title);
        },

        /**
         * Get the title to appear as tooltip
         * @return {string}
         */
        getTitle: function() {
          return this._element.getAttribute('title');
        },

        /**
         * Define the command image
         * @param {string} image
         */
        setImage: function(image) {
          if (image.length !== 0) {
            if (!this._image) {
              this._image = cls.WidgetFactory.createWidget('ImageWidget', this.getBuildParameters());
              this._element.prependChild(this._image.getElement());
            }
            this._image.setSrc(image);
          }
        },

        /**
         * Get image of the command
         * @return {?string} - source of the image, null if not set
         */
        getImage: function() {
          if (this._image) {
            return this._image.getSrc();
          }
          return null;
        }
      };
    });
    cls.WidgetFactory.registerBuilder('StartMenuCommand', cls.StartMenuCommandWidget);
  });
;
"use strict";

modulum('StartMenuGroupWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * StartMenuGroup widget.
     * @class StartMenuGroupWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     */
    cls.StartMenuGroupWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.StartMenuGroupWidget.prototype */ {
        __name: 'StartMenuGroupWidget',

        /**
         * Image of the startMenu command
         * @protected
         * @type {classes.ImageWidget}
         */
        _image: null,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._image) {
            this._image.destroy();
            this._image = null;

          }
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          if (domEvent.target.elementOrParent("gbc_startMenuGroupTitle")) { // only click on group title are managed
            this._element.classList.toggle('gbc_open');
            if (this.getElement().parent("gbc_startMenuContainer")) {
              context.SessionService.getCurrent().getCurrentApplication().layout.refreshLayout({
                resize: true
              });
            }
          }
          return false;
        },

        /**
         * Set the text of the group
         * @param {string} text
         */
        setText: function(text) {
          this._setTextContent(text, function() {
            return this._element.getElementsByClassName('gbc_startMenuGroupTitleText')[0];
          }.bind(this));
        },

        /**
         * Get the text of the group
         * @return {string}
         */
        getText: function() {
          return this._element.getElementsByClassName('gbc_startMenuGroupTitleText')[0].textContent;
        },

        /**
         * Define the command image
         * @param {string} image
         */
        setImage: function(image) {
          if (image.length !== 0) {
            if (!this._image) {
              this._image = cls.WidgetFactory.createWidget('ImageWidget', this.getBuildParameters());
              this._element.child('gbc_startMenuGroupTitle').prependChild(this._image.getElement());
            }
            this._image.setSrc(image);
          }
        },

        /**
         * Get image of the command
         * @return {?string} - source of the image, null if not set
         */
        getImage: function() {
          if (this._image) {
            return this._image.getSrc();
          }
          return null;
        }
      };
    });
    cls.WidgetFactory.registerBuilder('StartMenuGroup', cls.StartMenuGroupWidget);
  });
;
"use strict";

modulum('StartMenuSeparatorWidget', ['ColoredWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * StartMenuSeparator widget.
     * @class StartMenuSeparatorWidget
     * @memberOf classes
     * @extends classes.ColoredWidgetBase
     */
    cls.StartMenuSeparatorWidget = context.oo.Class(cls.ColoredWidgetBase, function($super) {
      return /** @lends classes.StartMenuSeparatorWidget.prototype */ {
        __name: 'StartMenuSeparatorWidget'
      };
    });
    cls.WidgetFactory.registerBuilder('StartMenuSeparator', cls.StartMenuSeparatorWidget);
  });
;
"use strict";

modulum('StartMenuTopMenuWidget', ['TopMenuWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * StartMenuTopMenu widget.
     * @class StartMenuTopMenuWidget
     * @memberOf classes
     * @extends classes.TopMenuWidget
     */
    cls.StartMenuTopMenuWidget = context.oo.Class(cls.TopMenuWidget, function($super) {
      return /** @lends classes.StartMenuTopMenuWidget.prototype */ {
        __name: 'StartMenuTopMenuWidget',
        __templateName: 'TopMenuWidget'
      };
    });
    cls.WidgetFactory.registerBuilder('StartMenuTopMenu', cls.StartMenuTopMenuWidget);
  });
;
"use strict";

modulum('StartMenuWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * StartMenu widget.
     * @class StartMenuWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     */
    cls.StartMenuWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.StartMenuWidget.prototype */ {
        __name: 'StartMenuWidget',
        /**
         * Element that hold the text
         * @type Element
         */
        _textElement: null,

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          this._textElement = this._element.getElementsByClassName('gbc_StartMenuText')[0];
        },

        /**
         * Set the text of the group
         * @param {string} text
         */
        setText: function(text) {
          this._setElementAttribute('title', text, "_textElement");
          this._setTextContent(text, "_textElement");
        },

        /**
         * Get the text of the group
         * @return {string}
         */
        getText: function() {
          return this._textElement.textContent;
        },
        setProcessing: function(isProcessing) {
          if (this.getElement()) {
            if (isProcessing) {
              this.getElement().setAttribute("processing", "processing");
            } else {
              this.getElement().removeAttribute("processing");
            }
          }
        }
      };
    });
    cls.WidgetFactory.registerBuilder('StartMenu', cls.StartMenuWidget);
  });
;
"use strict";

modulum('ToolBarItemWidget', ['TextWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * ToolBarItem widget.
     * @class ToolBarItemWidget
     * @memberOf classes
     * @extends classes.TextWidgetBase
     * @publicdoc
     */
    cls.ToolBarItemWidget = context.oo.Class(cls.TextWidgetBase, function($super) {
      return /** @lends classes.ToolBarItemWidget.prototype */ {
        __name: 'ToolBarItemWidget',

        /** @type {HTMLElement} */
        _textElement: null,
        /** @type {classes.ImageWidget} */
        _image: null,
        /** @type {HTMLElement} */
        _imageContainer: null,
        /** @type {boolean} */
        _autoScale: false,

        /**
         * @inheritDoc
         */
        _initElement: function(initialInformation) {
          $super._initElement.call(this, initialInformation);
          this._textElement = this._element.getElementsByTagName('span')[0];
          this._imageContainer = this._element.getElementsByClassName('gbc_imageContainer')[0];
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          this._layoutInformation = new cls.LayoutInformation(this);
          this._layoutEngine = new cls.FlowItemLayoutEngine(this);
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._image) {
            this._image.destroy();
            this._image = null;
          }
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          this.emit(context.constants.widgetEvents.click);
          return true;
        },

        /**
         * Set the text of the toolbar item
         * @param {string} text the text
         * @publicdoc
         */
        setText: function(text) {
          this._setTextContent(text, "_textElement");
        },

        /**
         * Get the text of the toolbar item
         * @return {string} the text of the item
         * @publicdoc
         */
        getText: function() {
          return this._textElement.textContent;
        },

        /**
         * Define the toolbar item image
         * @param {string} image - image url to use
         * @publicdoc
         */
        setImage: function(image) {
          if (image.length !== 0) {
            if (!this._image) {
              this._image = cls.WidgetFactory.createWidget('ImageWidget', this.getBuildParameters());
              this._imageContainer.appendChild(this._image.getElement());
              this.setAutoScale(this._autoScale);
            }
            this._image.setSrc(image);
          } else if (this._image) {
            this._image.getElement().remove();
            this._image.destroy();
            this._image = null;
          }
        },

        /**
         * Get image of the toolbar item
         * @return {?string} - source of the image, null if not set
         * @publicdoc
         */
        getImage: function() {
          if (this._image) {
            return this._image.getSrc();
          }
          return null;
        },

        /**
         * Define autoScale or not for this item
         * @param {boolean} enabled autoscale state
         * @publicdoc
         */
        setAutoScale: function(enabled) {
          this._autoScale = enabled;
          if (this._image) {
            this._image.setAutoScale(this._autoScale);
          }
          this._imageContainer.toggleClass('gbc_autoScale', this._autoScale);
        },

        /**
         * Set the title to appear as tooltip
         * @param {string} title - tooltip text
         * @publicdoc
         */
        setTitle: function(title) {
          this._element.setAttribute('title', title);
        },

        /**
         * Get the title to appear as tooltip
         * @return {string} the title
         * @publicdoc
         */
        getTitle: function() {
          return this._element.getAttribute('title');
        }

      };
    });
    cls.WidgetFactory.registerBuilder('ToolBarItem', cls.ToolBarItemWidget);
  });
;
"use strict";

modulum('ToolBarSeparatorWidget', ['ColoredWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * ToolBarSeparator widget.
     * @class ToolBarSeparatorWidget
     * @memberOf classes
     * @extends classes.ColoredWidgetBase
     * @publicdoc
     */
    cls.ToolBarSeparatorWidget = context.oo.Class(cls.ColoredWidgetBase, function($super) {
      return /** @lends classes.ToolBarSeparatorWidget.prototype */ {
        __name: 'ToolBarSeparatorWidget'
      };
    });
    cls.WidgetFactory.registerBuilder('ToolBarSeparator', cls.ToolBarSeparatorWidget);
  });
;
"use strict";

modulum('ToolBarWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * ToolBar widget.
     * @class ToolBarWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     * @publicdoc Widgets
     */
    cls.ToolBarWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.ToolBarWidget.prototype */ {
        __name: 'ToolBarWidget',

        /**
         * Widget to use to scroll on toolbar
         * @type {classes.FlowDecoratorWidget}
         */
        _flowDecoratorWidget: null,

        /** @type {Element} **/
        _flowDecoratorContainer: null,

        /** @type {classes.ChromeBarWidget} **/
        _chromeBar: null,

        _resizeHandler: null,

        /** @type {classes.FormWidget} **/
        _formWidget: null,

        /**
         * @inheritDoc
         */
        _initContainerElement: function() {
          $super._initContainerElement.call(this);
          this._flowDecoratorWidget = cls.WidgetFactory.createWidget("FlowDecorator", this.getBuildParameters());
          this._flowDecoratorWidget.setParentWidget(this);
          this._flowDecoratorWidget.setOrientation("vertical");
          this._flowDecoratorWidget.setRendering("list");
          this._flowDecoratorContainer = this.getElement().querySelector(".mt-tab-flow");
          this._flowDecoratorContainer.appendChild(this._flowDecoratorWidget.getElement());
          this._resizeHandler = context.HostService.onScreenResize(this._onResize.bind(this));
          this.addChildWidget(this._flowDecoratorWidget, {
            noDOMInsert: true
          });
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          this._layoutInformation = new cls.LayoutInformation(this);
          this._layoutEngine = new cls.FlowLayoutEngine(this);
          this._layoutEngine.setFlowDecoratorWidget(this._flowDecoratorWidget);

        },

        /**
         * Handler called when screen is resized
         * @private
         */
        _onResize: function() {
          this._layoutEngine.forceMeasurement();
          this._layoutEngine.invalidateMeasure();
        },

        /**
         * Set Priority of this toolbar
         * @param {number} order the priority of this toolbar
         * @publicdoc
         */
        setOrder: function(order) {
          this.setStyle({
            order: order
          });
        },

        /**
         * Get Priority of this toolbar
         * @returns {number} priority of this toolbar
         * @publicdoc
         */
        getOrder: function() {
          return this.getStyle('order');
        },

        /**
         * Show/hide the text of the toolbar items
         * @param {boolean} state - true to display text under image, false to hide it
         * @publicdoc
         */
        setButtonTextHidden: function(state) {
          if (state) {
            this.getElement().addClass('buttonTextHidden');
          } else {
            this.getElement().removeClass('buttonTextHidden');
          }
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._flowDecoratorWidget) {
            this._flowDecoratorWidget.destroy();
            this._flowDecoratorWidget = null;
          }
          if (this._resizeHandler) {
            this._resizeHandler();
            this._resizeHandler = null;
          }
          if (this.isChromeBar()) {
            //this._chromeBar.removeToolBar(this);
            this._chromeBar = null;
          }

          $super.destroy.call(this);
        },

        /**
         * Define this Toolbar as a ChromeBar part
         * @param {classes.ChromeBarWidget} chromeBar - widget to set
         */
        setAsChromeBar: function(chromeBar) {
          this._chromeBar = chromeBar;
        },

        /**
         * Check if this toolbar is a chromeBar part
         * @return {boolean} - true if widget is a chromebar, false otherwise
         */
        isChromeBar: function() {
          return !!this._chromeBar;
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          if (!domEvent.target.hasClass("gbc_FlowDecoratorWidget")) {
            this._flowDecoratorWidget.closeDropDown();
          }

          return true;
        },

        /**
         * Get the 3 dots real width
         * @return {number} width in px
         */
        getDecoratorWidth: function() {
          return this._flowDecoratorWidget.getLayoutInformation().getRawMeasure().getWidth();
        },

        /**
         *
         * @return {classes.FlowDecoratorWidget}
         */
        getFlowDecoratorWidget: function() {
          return this._flowDecoratorWidget;
        },

        /**
         * Define the form linked to this toolbar
         * Mainly used for layout calculation in modal window
         * @param {classes.FormWidget} widget - the form widget to link
         */
        setFormWidget: function(widget) {
          this._formWidget = widget;
        }

      };
    });
    cls.WidgetFactory.registerBuilder('ToolBar', cls.ToolBarWidget);
  });
;
"use strict";

modulum('TopMenuCommandWidget', ['TextWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * TopMenuCommand widget.
     * @class TopMenuCommandWidget
     * @memberOf classes
     * @extends classes.TextWidgetBase
     * @publicdoc Widgets
     */
    cls.TopMenuCommandWidget = context.oo.Class(cls.TextWidgetBase, function($super) {
      return /** @lends classes.TopMenuCommandWidget.prototype */ {
        __name: 'TopMenuCommandWidget',
        /** @type {classes.ImageWidget} */
        _image: null,
        /** @type {HTMLElement} */
        _anchorElement: null,
        /** @type {HTMLElement} */
        _commentContainer: null,

        /**
         * @inheritDoc
         */
        _initElement: function(initialInformation) {
          $super._initElement.call(this, initialInformation);

          this._image = cls.WidgetFactory.createWidget('ImageWidget', this.getBuildParameters());
          this._image.setAutoScale(true);
          this._element.prependChild(this._image.getElement());

          this._anchorElement = this._element.querySelector('span.anchor');
          this._commentContainer = this._element.querySelector('span.gbc-label-comment-container');

          this._element.on('mouseover.TopMenuCommandWidget', this._onMouseover.bind(this));
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._element) {
            this._element.off('mouseover.TopMenuCommandWidget');
          }
          if (this._image) {
            this._image.destroy();
            this._image = null;
          }
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          if (this.isEnabled() || this.isInterruptable()) {
            this.emit(context.constants.widgetEvents.click, domEvent);
          }
          return true;
        },

        /**
         * Hide previous sub menu displayed from a same level topmenugroup
         * @param event
         * @private
         */
        _onMouseover: function(event) {
          if (cls.DropDownWidget.hasAnyVisible()) {
            var lastDropDown = cls.DropDownWidget.getActiveDropDown();

            if (!lastDropDown.getElement().contains(event.target)) {
              lastDropDown.remove();
            }
          }
        },

        /**
         * Set the text of the command item
         * @param {string} text - text to display
         * @publicdoc
         */
        setText: function(text) {
          this._setTextContent(text, "_anchorElement");
        },

        /**
         * Set a comment for the Command item
         * @param {string} comment - accelerator name
         * @publicdoc
         */
        setComment: function(comment) {
          var regex = /([^A-Za-z]*\+|\-)([A-Za-z])/g;
          if (window.browserInfo.isSafari) {
            comment = comment.replace(/control/ig, "")
              .replace(regex, function(match) {
                return match.toUpperCase();
              })
              .replace("-", " ");
          } else {
            comment = comment.replace("-", "+")
              .replace(/control/ig, "Ctrl")
              .replace(regex, function(match) {
                return match.toUpperCase();
              });
          }
          this._commentContainer.textContent = comment;
        },

        /**
         * Get the text of the command item
         * @return {string} - text of the command item
         * @publicdoc
         */
        getText: function() {
          return this._anchorElement.textContent;
        },

        /**
         * Define the topmenu command image
         * @param {string} image - url source of the image
         * @publicdoc
         */
        setImage: function(image) {
          this._image.setSrc(image);
        },

        /**
         * Get image of the topmenu command
         * @return {?string} - source of the image, null if not set
         * @publicdoc
         */
        getImage: function() {
          if (this._image) {
            return this._image.getSrc();
          }
          return null;
        }
      };
    });
    cls.WidgetFactory.registerBuilder('TopMenuCommand', cls.TopMenuCommandWidget);
  });
;
"use strict";

modulum('TopMenuGroupWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * TopMenuGroup widget.
     * @class TopMenuGroupWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     * @publicdoc Widgets
     */
    cls.TopMenuGroupWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.TopMenuGroupWidget.prototype */ {
        __name: 'TopMenuGroupWidget',

        /** @type {classes.ImageWidget} */
        _image: null,
        /** @type {classes.DropDownWidget} */
        _dropDown: null,
        /** @type {HTMLElement} */
        _textElement: null,
        /**
         * Top div element used as main container to disable pointer events on topmenu opening
         * @type {HTMLElement}
         */
        _mainContainerWidget: null,
        /**
         * Indicates if topmenugroup is a sub menu (child of another topmenugroup) or not
         * @type {?boolean}
         */
        _isSubMenu: null,

        /**
         * @inheritDoc
         */
        _initContainerElement: function() {
          $super._initContainerElement.call(this);

          this._mainContainerWidget = window.document.getElementsByClassName("gbc_MainContainerWidget")[0];

          this._textElement = this._element.getElementsByTagName('span')[0];

          this._image = cls.WidgetFactory.createWidget('ImageWidget', this.getBuildParameters());
          this._image.setAutoScale(true);
          this._element.prependChild(this._image.getElement());

          this._dropDown = cls.WidgetFactory.createWidget('ChoiceDropDown', this.getBuildParameters());
          this._dropDown.setParentWidget(this);
          this._dropDown.setBackgroundColor(this.getBackgroundColor());

          // on dropdown opening we set 'current' class for top level topmenugroup item
          this._dropDown.onOpen(function() {
            if (!this.isSubMenu()) {
              this.addClass("current");
              this.getParentWidget().addClass("open");
            }
          }.bind(this));
          // on dropdown close we remove 'current' class for top level topmenugroup item
          this._dropDown.onClose(function() {
            if (!this.isSubMenu()) {
              if (this.getElement()) {
                this.removeClass("current");
              }
              if (this.getParentWidget()) {
                this.getParentWidget().removeClass("open");
              }
            }
          }.bind(this));

          if (!window.isMobile()) {
            this._element.on('mouseover.TopMenuGroupWidget', this._displayTopMenuDropDown.bind(this));
          } else { // for mobile, topmenus are being displayed on touch
            // when a topmenu dropdown is displayed and we press on another sibling topmenugroup, we need to cancel close of current menu to be able to display other one right after press
            this._dropDown.shouldClose = function(targetElement) {
              return !targetElement.isElementOrChildOf(this.getParentWidget().getElement());
            }.bind(this);
          }
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (!window.isMobile()) {
            this._element.off('mouseover.TopMenuGroupWidget');
          }
          if (this._image) {
            this._image.destroy();
            this._image = null;
          }
          $super.destroy.call(this);
          this._dropDown.destroy();
          this._dropDown = null;
        },

        /**
         * @inheritDoc
         */
        managePriorityKeyDown: function(keyString, domKeyEvent, repeat) {
          var keyProcessed = false;

          if (this.isVisible()) {
            var currentChild = this._dropDown.getCurrentChildren();
            var parent = this.getParentWidget();
            keyProcessed = true;
            switch (keyString) {
              case "esc":
                this._dropDown.hide();
                break;
              case this.getStart():
                if (!this.isSubMenu()) { // navigate between topmenu groups
                  var previousMenu = parent.getPreviousMenu(this);
                  if (previousMenu) {
                    this.removeClass("current");
                    if (previousMenu.getName().endsWith("TopMenuGroupWidget")) {
                      previousMenu._displayTopMenuDropDown(null);
                    }
                  }
                } else { // hide sub menu
                  this._dropDown.remove();
                }
                break;
              case this.getEnd():
                if (currentChild && currentChild.getName().endsWith("TopMenuGroupWidget")) {
                  // display sub menu
                  currentChild._displayTopMenuDropDown(null);
                } else {
                  if (!this.isSubMenu()) { // navigate between topmenu groups
                    var nextMenu = parent.getNextMenu(this);
                    if (nextMenu) {
                      this.removeClass("current");
                      if (nextMenu.getName().endsWith("TopMenuGroupWidget")) {
                        nextMenu._displayTopMenuDropDown(null);
                      }
                    }
                  }
                }
                break;
              case "enter":
              case "return":
                if (currentChild) {
                  if (currentChild.getName().endsWith("TopMenuGroupWidget")) {
                    // display sub menu
                    currentChild._displayTopMenuDropDown(null);
                  } else if (currentChild.getName().endsWith("TopMenuCommandWidget")) {
                    currentChild.emit(context.constants.widgetEvents.click);
                  }
                }
                break;
              default:
                keyProcessed = false;
            }
          }
          if (keyProcessed) {
            return true;
          } else {
            return this._dropDown.managePriorityKeyDown(keyString, domKeyEvent, repeat);
          }
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          if (!this.isSubMenu()) {
            this._dropDown.toggle();
            return false;
          } else if (window.isMobile()) { // for mobile, execute mouseover logic on click
            this._displayTopMenuDropDown();
          }
          return true;
        },

        /**
         * Display topmenu or submenus dropdown (only if it was initially displayed using a click)
         * @param {?object} [event] - source event handler. If null we take current topmenu element as target element
         * @protected
         */
        _displayTopMenuDropDown: function(event) {
          if (cls.DropDownWidget.hasAnyVisible()) {
            // 1. eventually hide previous sub menu
            var element = event ? event.target : this.getElement();
            var lastDropDown = cls.DropDownWidget.getActiveDropDown();

            // don't re display if same dropdown
            if (lastDropDown.getParentWidget() !== this) {

              if (!lastDropDown.getElement().contains(element)) {
                lastDropDown.remove();
              }

              // 2. display new sub menu
              if (this.isSubMenu()) {
                var parentRect = this.getElement().getBoundingClientRect();
                this._dropDown.x = parentRect.right;
                this._dropDown.y = parentRect.top;
              }
              this._dropDown.show(this.isSubMenu());
            }
          }
        },

        /**
         * Check if current topmenugroup is a child of another topmenugroup
         * @returns {boolean} true if current topmenugroup is a child of another topmenugroup
         */
        isSubMenu: function() {
          if (this._isSubMenu === null && this.getParentWidget()) {
            // usage of endsWidth to manage startmenu names
            this._isSubMenu = !this.getParentWidget().getName().endsWith("TopMenuWidget");
          }
          return this._isSubMenu;
        },

        /**
         * @inheritDoc
         */
        addChildWidget: function(widget) {
          this._dropDown.adoptChildWidget(widget);
        },
        /**
         * @inheritDoc
         */
        removeChildWidget: function(widget) {
          this._dropDown.removeChildWidget(widget);
        },

        /**
         * Get all children of TopMenuGroup DropDown
         * @returns {classes.WidgetBase[]} the list of children being added in dropDown
         * @publicdoc
         */
        getChildren: function() {
          return this._dropDown.getChildren();
        },

        /**
         * Set the text of the group item
         * @param {string} text - Text to display
         * @publicdoc
         */
        setText: function(text) {
          this._setTextContent(text, "_textElement");
        },

        /**
         * Get the text of the group item
         * @return {string} - Text displayed
         * @publicdoc
         */
        getText: function() {
          return this._textElement.textContent;
        },

        /**
         * Define the group item image
         * @param {string} image - image source url
         * @publicdoc
         */
        setImage: function(image) {
          this._image.setSrc(image);
          this._image.toggleClass("hidden", !this.isSubMenu() && !image);
        },

        /**
         * Get image of the group item
         * @return {?string} - source of the image, null if not set
         * @publicdoc
         */
        getImage: function() {
          if (this._image) {
            return this._image.getSrc();
          }
          return null;
        },

        /**
         * @inheritDoc
         */
        setBackgroundColor: function(color) {
          if (this._dropDown) {
            this._dropDown.setBackgroundColor(color);
          }
        },

        /**
         * @inheritDoc
         */
        setColor: function(color) {
          $super.setColor.call(this, color);
          if (this._dropDown) {
            this._dropDown.setColor(color);
          }
        },

        /**
         * Always true to be able to have dropdown associated with topmenugroup
         * @return {boolean} - always true
         */
        hasFocus: function() {
          return true;
        }
      };
    });
    cls.WidgetFactory.registerBuilder('TopMenuGroup', cls.TopMenuGroupWidget);
  });
;
"use strict";

modulum('TopMenuSeparatorWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * TopMenuSeparator widget.
     * @class TopMenuSeparatorWidget
     * @memberOf classes
     * @extends classes.WidgetBase
     * @publicdoc Widgets
     */
    cls.TopMenuSeparatorWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.TopMenuSeparatorWidget.prototype */ {
        __name: 'TopMenuSeparatorWidget',

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._parentWidget && this._parentWidget.isInstanceOf(cls.DropDownWidget)) {
            this._parentWidget.getParentWidget().removeChildWidget(this);
          }
          $super.destroy.call(this);
        },

        isEnabled: function() {
          return false;
        }
      };
    });
    cls.WidgetFactory.registerBuilder('TopMenuSeparator', cls.TopMenuSeparatorWidget);
  });
;
"use strict";

modulum('TopMenuWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * TopMenu widget.
     * @class TopMenuWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     * @publicdoc Widgets
     */
    cls.TopMenuWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.TopMenuWidget.prototype */ {
        __name: 'TopMenuWidget',

        /**
         * Priority of this menu
         * @param {number} order the priority of this menu
         * @publicdoc
         */
        setOrder: function(order) {
          this.setStyle({
            order: order
          });
        },

        /**
         * Get priority of this menu
         * @returns {number} priority of this menu
         * @publicdoc
         */
        getOrder: function() {
          return this.getStyle('order');
        },

        /**
         * Get previous topmenugroup located at same level that refMenu
         * @param {classes.TopMenuGroupWidget} refMenu - topmenugroup used as search criteria
         * @returns {classes.TopMenuGroupWidget} returns previous topmenugroup
         * @publicdoc
         */
        getPreviousMenu: function(refMenu) {
          return this.getChildren()[this.getIndexOfChild(refMenu) - 1];
        },

        /**
         * Get next topmenugroup located at same level that refMenu
         * @param {classes.TopMenuGroupWidget} refMenu - topmenugroup used as search criteria
         * @returns {classes.TopMenuGroupWidget} returns next topmenugroup
         * @publicdoc
         */
        getNextMenu: function(refMenu) {
          return this.getChildren()[this.getIndexOfChild(refMenu) + 1];
        }
      };
    });
    cls.WidgetFactory.registerBuilder('TopMenu', cls.TopMenuWidget);
  });
;
"use strict";

modulum('ApplicationWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Main container widget for an application
     * @class ApplicationWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     * @publicdoc Widgets
     */
    cls.ApplicationWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.ApplicationWidget.prototype */ {
        __name: "ApplicationWidget",
        _waiter: null,
        /**
         * @type {classes.SessionSidebarApplicationItemWidget}
         */
        _sidebarWidget: null,
        /**
         * the contextmenu widget
         * @type {classes.ContextMenuWidget}
         */
        _contextMenu: null,
        _handlers: null,
        _uiWidget: null,

        /** @type {Array} */
        _domAttributesMutationBuffer: null,

        /** @type {Array} */
        _afterDomMutationBuffer: null,

        /** @type {boolean} */
        _isBuffering: false,

        /** @type {boolean} */
        _isDomMutating: false,

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          opts.appWidget = this;
          $super.constructor.call(this, opts);
          this._domAttributesMutationBuffer = [];
          this._afterDomMutationBuffer = [];
          this._handlers = [];
          this._sidebarWidget = cls.WidgetFactory.createWidget("SessionSidebarApplicationItem", this.getBuildParameters());
          this._sidebarWidget.setApplicationWidget(this);
        },
        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._handlers) {
            for (var i = 0; i < this._handlers.length; i++) {
              this._handlers[i]();
            }
            this._handlers.length = 0;
          }
          this._sidebarWidget.destroy();
          this._sidebarWidget = null;
          if (this._waiter) {
            this._waiter.destroy();
            this._waiter = null;
          }
          context.styler.removeStyleSheet(this._appHash);

          if (this._contextMenu) {
            this._contextMenu.destroy();
            this._contextMenu = null;
          }

          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          this._ignoreLayout = true;
          $super._initElement.call(this);
          this._waiter = cls.WidgetFactory.createWidget("Waiting", this.getBuildParameters());
          this._element.appendChild(this._waiter.getElement());

          this._contextMenu = cls.WidgetFactory.createWidget("ContextMenu", this.getBuildParameters());
          this._contextMenu.setParentWidget(this);
        },

        /**
         * @inheritDoc
         */
        managePriorityKeyDown: function(keyString, domKeyEvent, repeat) {
          var keyProcessed = false;
          if (this.getContextMenu() && this.getContextMenu().isVisible()) {
            keyProcessed = this.getContextMenu().managePriorityKeyDown(keyString, domKeyEvent, repeat);
          }
          return keyProcessed;
        },

        /**
         * Show context menu and show it
         * @param evt
         * @param widget
         */
        showContextMenu: function(evt, widget) {

          var vmFocusWidget = this._uiWidget ? this._uiWidget.getVMFocusedWidget() : null;

          this._contextMenu.setColor(this.getColor());
          this._contextMenu.setBackgroundColor(this.getBackgroundColor());

          evt.preventCancelableDefault();
          evt.stopImmediatePropagation();
          evt.stopPropagation();

          this._contextMenu.x = evt.clientX;
          this._contextMenu.y = evt.clientY;

          if (this._contextMenu.isVisible()) {
            this._contextMenu.hide(); // hide it before display it, to be sure it is in the correct position
          }

          // if widget is not focusable or focused widget and widget from where contextmenu is called is the same we can directly show contextMenu
          if (!widget.isFocusable() || !widget.isEnabled() || vmFocusWidget === widget || vmFocusWidget === widget
            .getParentWidget()) {
            // Extra actions defines by widgets in buildExtraContextMenuActions function
            this._contextMenu.removeAndDestroyActions(true);
            widget.buildExtraContextMenuActions(this._contextMenu);
            // if the contextMenu has visible action, try to show it
            if (this._contextMenu.hasVisibleAction()) {
              this._contextMenu.show();
            }
          } else {
            // once VM gave focus to widget, show the contextMenu
            context.SessionService.getCurrent().getCurrentApplication().focus.when(context.constants.widgetEvents.focusRestored,
              function() {
                // Extra actions defines by widgets in buildExtraContextMenuActions function
                this._contextMenu.removeAndDestroyActions(true);
                var newVmFocusWidget = this._uiWidget ? this._uiWidget.getVMFocusedWidget() : null;
                if (newVmFocusWidget === widget) {
                  newVmFocusWidget.buildExtraContextMenuActions(this._contextMenu);
                }
                if (this._contextMenu.hasVisibleAction()) {
                  this._contextMenu.show();
                }
              }.bind(this), true); // true : execute only once
          }
        },

        /**
         * Returns contextMenu widget
         * @returns {classes.ContextMenuWidget} contextMenu widget
         */
        getContextMenu: function() {
          return this._contextMenu;
        },

        /**
         *
         * @param {classes.WidgetBase} widget
         * @param {Object=} options - possible options
         * @param {boolean=} options.noDOMInsert - won't add child to DOM
         * @param {number=} options.position - insert position
         * @param {string=} options.tag - context tag
         * @param {string=} options.mode - context mode : null|"replace"
         */
        addChildWidget: function(widget, options) {
          this._uiWidget = widget;
          $super.addChildWidget.call(this, widget, options);
        },
        /**
         * Set application hash
         * @param {string} applicationHash
         */
        setApplicationHash: function(applicationHash) {
          this._appHash = applicationHash;
        },
        /**
         * Hide waiter
         */
        hideWaiter: function() {
          this._waiter.getElement().remove();
        },
        /**
         * Return sidebar widget
         * @returns {classes.SessionSidebarApplicationItemWidget}
         */
        getSidebarWidget: function() {
          return this._sidebarWidget;
        },
        /**
         * Activate application
         */
        activate: function() {
          this.emit(context.constants.widgetEvents.activate);
          if (this._uiWidget) {
            this._uiWidget.emit(context.constants.widgetEvents.activate);
          }
        },
        /**
         * Bind an handler executed when application is activated
         * @param {Hook} hook
         * @returns {HandleRegistration} return handler reference
         */
        onActivate: function(hook) {
          this._handlers.push(this.when(context.constants.widgetEvents.activate, hook));
          return this._handlers[this._handlers.length - 1];
        },
        /**
         * Disable application
         */
        disable: function() {
          this.emit(context.constants.widgetEvents.disable);
          if (this._uiWidget) {
            this._uiWidget.emit(context.constants.widgetEvents.disable);
          }
        },
        /**
         * Emit a request to relayout application
         */
        layoutRequest: function() {
          this.emit(context.constants.widgetEvents.layoutRequest);
        },
        /**
         * Bind an handler executed when layout is requested
         * @param hook
         * @returns {Function} return handler reference
         */
        onLayoutRequest: function(hook) {
          this._handlers.push(this.when(context.constants.widgetEvents.layoutRequest, hook));
          return this._handlers[this._handlers.length - 1];
        },

        /**
         * @inheritDoc
         */
        flash: function() {
          this.addClass("flash");
          this._registerTimeout(function() {
            this.removeClass("flash");
          }.bind(this), 50);
        },

        /**
         * register function to run when not buffering. Executed directly if not buffering.
         * @param {Function} fn function to run when not buffering
         * @param {classes.WidgetBase} context a widget context - used to check is this context is destroyed or not when executing
         * @returns {boolean} whether or not the function zas buffered
         */
        domAttributesMutationBuffer: function(fn, context) {
          if (this._isBuffering) {
            this._domAttributesMutationBuffer.push([fn, context]);
            return true;
          }
          return false;
        },

        /**
         * register function to run when not buffering. Executed directly if not buffering.
         * @param {Function} fn function to run when not buffering
         * @param {classes.WidgetBase} context a widget context - used to check is this context is destroyed or not when executing
         * @returns {boolean} whether or not the function zas buffered
         */
        afterDomMutationBuffer: function(fn, context) {
          if (this._isBuffering || this._isDomMutating) {
            this._afterDomMutationBuffer.push([fn, context]);
            return true;
          }
          return false;
        },

        /**
         * Set buffering state
         * @param {boolean} buffering the new buffering state
         */
        bufferizeDom: function(buffering) {
          if (buffering) {
            this._isBuffering = true;
          } else {
            this._isDomMutating = true;
            this._isBuffering = false;
            var domAttributesMutationBuffer = this._domAttributesMutationBuffer;
            this._domAttributesMutationBuffer = [];
            var afterDomMutationBuffer = this._afterDomMutationBuffer;
            this._afterDomMutationBuffer = [];
            domAttributesMutationBuffer.forEach(function(item) {
              if (!item[1] || !item[1].isDestroyed()) {
                item[0]();
              }
            });
            this._registerAnimationFrame(function(afterDomMutationBuffer) {
              afterDomMutationBuffer.forEach(function(item) {
                if (!item[1] || !item[1].isDestroyed()) {
                  item[0]();
                }
              });
            }.bind(this, afterDomMutationBuffer));
            this._isDomMutating = false;
          }
        },

        /**
         * @inheritDoc
         */
        hasChildWebComponent: function() {
          return (!!this._uiWidget && this._uiWidget.hasChildWebComponent()) || $super.hasChildWebComponent.call(this);
        }
      };
    });
    cls.WidgetFactory.registerBuilder('Application', cls.ApplicationWidget);
  });
;
"use strict";

modulum('SessionEndRedirectWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Widget displayed at the end of a session
     * @class SessionEndRedirectWidget
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.SessionEndRedirectWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.SessionEndRedirectWidget.prototype */ {
        __name: "SessionEndRedirectWidget",

        _initLayout: function() {
          // no layout
        }
      };
    });
    cls.WidgetFactory.registerBuilder('SessionEndRedirect', cls.SessionEndRedirectWidget);
  });
;
"use strict";

modulum('SessionEndWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Widget displayed at the end of a session
     * @class SessionEndWidget
     * @memberOf classes
     * @extends classes.WidgetBase
     * @publicdoc Widgets
     */
    cls.SessionEndWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.SessionEndWidget.prototype */ {
        __name: "SessionEndWidget",
        _closeApplicationEnd: null,
        _restartApp: null,
        /** @type {HTMLElement} */
        _getGbcLog: null,

        /** @type {classes.ChromeBarWidget} **/
        _chromeBar: null,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          this._ignoreLayout = true;
          $super._initElement.call(this);
          this._closeApplicationEnd = this._element.getElementsByClassName("closeApplicationEnd")[0];
          this._restartApp = this._element.getElementsByClassName("restartApp")[0];
          this._getGbcLog = this._element.querySelector(".gbcLogLink");
          if (!gbc.ThemeService.getValue("theme-legacy-topbar")) {
            var chromeBarOpt = this.getBuildParameters();
            chromeBarOpt.lightmode = true;
            this._chromeBar = cls.WidgetFactory.createWidget("ChromeBar", chromeBarOpt);
            this._element.prependChild(this._chromeBar.getElement());
            this._chromeBar.setLightMode(true);
          }
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          // no layout
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._closeApplicationEnd = null;
          this._restartApp = null;
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          var target = domEvent.target;
          if (target.isElementOrChildOf(this._closeApplicationEnd)) {
            this.emit(context.constants.widgetEvents.close);
          } else if (target.isElementOrChildOf(this._restartApp)) {
            this.emit(context.constants.widgetEvents.restart);
          } else if (target.isElementOrChildOf(this._getGbcLog)) {
            gbc.LogService.download();
          }
          return true;
        },

        /**
         * Show all session actions
         * VM logs, Proxy logs
         * @publicdoc
         */
        showSessionActions: function() {
          var elements = this._element.getElementsByClassName('from-session') || [];
          for (var i = 0; i < elements.length; i++) {
            elements[i].removeClass('hidden');
          }
          if (gbc.LogService.isRecordingEnabled()) {
            this._getGbcLog.removeClass('hidden');
          }
        },

        /**
         * Show user actions
         * restart, quit ...
         * @publicdoc
         */
        showUAActions: function() {
          this._element.getElementsByClassName('from-ua')[0].removeClass('hidden');
        },

        /**
         * Defines header message
         * @param {string} header the header content
         * @publicdoc
         */
        setHeader: function(header) {
          this._element.getElementsByClassName('mt-card-header-text')[0].innerHTML = header;
        },

        /**
         * Defines message to display at the end of the session
         * @param {string} message - text to display
         * @publicdoc
         */
        setMessage: function(message) {
          var messageElt = this._element.getElementsByClassName('message')[0];
          messageElt.removeClass('hidden');
          messageElt.innerHTML = message;
        },

        /**
         * Set the session id
         * @param {number} id - identifier of the session
         * @publicdoc
         */
        setSessionID: function(id) {
          this._element.getElementsByClassName('session')[0].removeClass('hidden');
          this._element.getElementsByClassName('sessionID')[0].textContent = id;
        },

        /**
         * Set the links of the session
         * @param {string} base - url base (hostname)
         * @param {string|number} session - identifier for this session
         * @publicdoc
         */
        setSessionLinks: function(base, session) {
          this._element.querySelector('.uaLink>a').setAttribute('href', base + '/monitor/log/uaproxy-' + session);
          this._element.querySelector('.vmLink>a').setAttribute('href', base + '/monitor/log/vm-' + session);
          if (!context.DebugService.isActive()) {
            this._element.querySelector('.uaLink').style.display = 'none';
            this._element.querySelector('.vmLink').style.display = 'none';
          }
        },

        /**
         * Defines the aui log url
         * @param {string|number} session - identifier for this session
         * @param file
         */
        setAuiLogUrl: function(session, file) {
          this._element.querySelector('.auiLink>a').setAttribute('download', 'auiLog-' + session + '.log');
          this._element.querySelector('.auiLink>a').setAttribute('href', 'file');
        }
      };
    });
    cls.WidgetFactory.registerBuilder('SessionEnd', cls.SessionEndWidget);
  });
;
"use strict";

modulum('SessionLogPromptWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class SessionLogPromptWidget
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.SessionLogPromptWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.SessionLogPromptWidget.prototype */ {
        __name: "SessionLogPromptWidget",

        /** @type Element */
        _button: null,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          this._button = this._element.getElementsByClassName("mt-button")[0];
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._button = null;
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          if (domEvent.target === this._button || domEvent.target.parent("mt-button") === this._button) {
            this.emit(context.constants.widgetEvents.click);
          }
          return true;
        }
      };
    });
    cls.WidgetFactory.registerBuilder('SessionLogPrompt', cls.SessionLogPromptWidget);
  });
;
"use strict";

modulum('SessionWaitingEndWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class SessionWaitingEndWidget
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.SessionWaitingEndWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.SessionWaitingEndWidget.prototype */ {
        __name: "SessionWaitingEndWidget",

        _initElement: function() {
          this._ignoreLayout = true;
          $super._initElement.call(this);
          this._element.querySelector(".mt-card-header-pic img").src = context.ThemeService.getResource("img/wheel.gif");
        },

        _initLayout: function() {
          // no layout
        },

        setHeader: function(message) {
          this._element.getElementsByClassName("mt-card-header-text")[0].innerHTML = message;
        },
        setMessage: function(message) {
          var messageElt = this._element.getElementsByClassName("message")[0];
          messageElt.removeClass("hidden");
          messageElt.innerHTML = message;
        }
      };
    });
    cls.WidgetFactory.registerBuilder('SessionWaitingEnd', cls.SessionWaitingEndWidget);
  });
;
"use strict";

modulum('SessionWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class SessionWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     */
    cls.SessionWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.SessionWidget.prototype */ {
        __name: "SessionWidget",
        _waiter: null,
        _sidebarWidget: null,
        /** @type {classes.SessionEndWidget} */
        _endWidget: null,
        /** @type {classes.SessionEndRedirectWidget} */
        _endRedirectWidget: null,
        /** @type {classes.SessionWaitingEndWidget} */
        _waitingEndWidget: null,
        __zIndex: 0,
        _currentWidget: null,
        _currentWidgetStack: null,
        _tabbedContainerWidget: null,

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          this._currentWidgetStack = [];
          $super.constructor.call(this, opts);
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._tabbedContainerWidget) {
            this._tabbedContainerWidget.destroy();
            this._tabbedContainerWidget = null;
          }
          if (this._endRedirectWidget) {
            this._endRedirectWidget.destroy();
            this._endRedirectWidget = null;
          }
          if (this._endWidget) {
            this._endWidget.destroy();
            this._endWidget = null;
          }
          if (this._waitingEndWidget) {
            this._waitingEndWidget.destroy();
            this._waitingEndWidget = null;
          }
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          this._ignoreLayout = true;
          $super._initElement.call(this);
          this._endWidget = cls.WidgetFactory.createWidget('SessionEnd', this.getBuildParameters());
          this._endWidget.setHidden(true);
          this._element.appendChild(this._endWidget.getElement());
          this._endRedirectWidget = cls.WidgetFactory.createWidget('SessionEndRedirect', this.getBuildParameters());
          this._endRedirectWidget.setHidden(true);
          this._element.appendChild(this._endRedirectWidget.getElement());
          this._waitingEndWidget = cls.WidgetFactory.createWidget('SessionWaitingEnd', this.getBuildParameters());
          this._waitingEndWidget.setHidden(true);
          this._element.appendChild(this._waitingEndWidget.getElement());
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          // no layout
        },

        /**
         * @inheritDoc
         * @param widget
         * @param options
         */
        addChildWidget: function(widget, options) {
          options = options || {};
          options.noDOMInsert = (options.noDOMInsert !== false);
          $super.addChildWidget.call(this, widget, options);
          if (widget instanceof cls.ApplicationWidget) {
            this.getSidebarWidget().addChildWidget(widget.getSidebarWidget());
          }
        },

        _getNextApplication: function(previousWidget) {
          var nextApp = null;
          if (this._currentWidgetStack.length) {
            nextApp = this._currentWidgetStack[this._currentWidgetStack.length - 1];
            if (nextApp === previousWidget && this._currentWidgetStack.length > 1) {
              nextApp = this._currentWidgetStack[this._currentWidgetStack.length - 2];
            }
          }
          return nextApp;
        },

        /**
         * @inheritDoc
         */
        removeChildWidget: function(widget) {
          var displayedWidget = null;
          if (widget instanceof cls.ApplicationWidget) {

            this._currentWidgetStack.remove(widget);

            var sidebar = widget.getSidebarWidget();
            if (sidebar) {
              this.getSidebarWidget().removeChildWidget(sidebar);
            }
          }
          $super.removeChildWidget.call(this, widget);
        },

        /**
         *
         * @param {classes.ApplicationWidget} widget
         */
        setCurrentWidget: function(widget) {
          if (this._currentWidget !== widget && (!this._tabbedContainerHostWidget || this._tabbedContainerHostWidget !== widget)) {
            if (widget) {
              var isBuffering = context.styler.isBuffering();
              if (!isBuffering) {
                context.styler.bufferize();
              }
              var previousWidget = this.getCurrentWidget();

              if (this._tabbedContainerWidget) {
                if (previousWidget) {
                  previousWidget.disable();
                }
                this._tabbedContainerWidget.setCurrentPage(widget._tabbedPage);
              } else {
                // Magical stuff to keep webcomponent in dom to preserve context
                if ((previousWidget && previousWidget.hasChildWebComponent()) || (widget && widget.hasChildWebComponent())) {
                  if (previousWidget && previousWidget.getElement() && previousWidget.hasChildWebComponent()) {
                    previousWidget.addClass("gbc_out_of_view");
                  }
                  if (widget && !widget.hasChildWebComponent() && this.getContainerElement()) {
                    this.getContainerElement().appendChild(widget.getElement());
                  }
                  if (widget && widget.hasChildWebComponent()) {
                    if (previousWidget && !previousWidget.hasChildWebComponent() && this.getContainerElement() && previousWidget.getElement()) {
                      this.getContainerElement().removeChild(previousWidget.getElement());
                    }
                    widget.removeClass("gbc_out_of_view");
                  }
                } else if (previousWidget && previousWidget.getElement()) {
                  previousWidget.disable();
                  if (this.getContainerElement()) {
                    this.getContainerElement().replaceChild(widget.getElement(), previousWidget.getElement());
                  }
                } else {
                  if (this.getContainerElement()) {
                    this.getContainerElement().appendChild(widget.getElement());
                  }
                }
              }
              if (!this._currentWidgetStack.contains(widget)) {
                this._currentWidgetStack.push(widget);
              }
              widget.activate();
              if (!isBuffering) {
                context.styler.flush();
              }
            }
            this._currentWidget = widget;
          }
        },
        getCurrentWidget: function() {
          return this._currentWidget;
        },
        getSidebarWidget: function() {
          return this._sidebarWidget;
        },
        setSidebarWidget: function(widget) {
          this._sidebarWidget = widget;
        },
        showWaitingEnd: function() {
          this._waitingEndWidget.setHidden(false);
        },
        showEnd: function() {
          this._waitingEndWidget.setHidden(true);
          this._endWidget.setHidden(false);
          context.HostService.setCurrentTitle();
          context.HostService.setCurrentIcon();
        },
        showRedirectEnd: function() {
          this._waitingEndWidget.setHidden(true);
          this._endRedirectWidget.setHidden(false);
          context.HostService.setCurrentTitle();
          context.HostService.setCurrentIcon();
        },
        getEndWidget: function() {
          return this._endWidget;
        },
        getWaitingEndWidget: function() {
          return this._waitingEndWidget;
        },

        setTabbedContainer: function(tabbedContainerWidget) {
          this._tabbedContainerWidget = tabbedContainerWidget;
        },

        setTabbedContainerHost: function(widget) {
          this._tabbedContainerHostWidget = widget;
        }
      };
    });
    cls.WidgetFactory.registerBuilder('Session', cls.SessionWidget);
  });
;
"use strict";

modulum('WaitingWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class WaitingWidget, used for direct connection
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.WaitingWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.WaitingWidget.prototype */ {
        __name: "WaitingWidget"
      };
    });
    cls.WidgetFactory.registerBuilder('Waiting', cls.WaitingWidget);
  });
;
"use strict";

modulum('ApplicationHostAboutWidget', ['ModalWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class ApplicationHostAboutWidget
     * @memberOf classes
     * @extends classes.ModalWidget
     */
    cls.ApplicationHostAboutWidget = context.oo.Class(cls.ModalWidget, function($super) {
      return /** @lends classes.ApplicationHostAboutWidget.prototype */ {
        __name: "ApplicationHostAboutWidget",
        __templateName: "ModalWidget",

        /**
         * @type {classes.ProductInformationWidget}
         */
        _productInformation: null,

        _initElement: function() {
          this._ignoreLayout = true;
          $super._initElement.call(this);
        },

        _afterInitElement: function() {
          $super._afterInitElement.call(this);
          this._productInformation = cls.WidgetFactory.createWidget("ProductInformation", this.getBuildParameters());
          this.addChildWidget(this._productInformation);
          this.setClosable(true, true);
        },

        _initLayout: function() {
          // no layout
        },

        /**
         * @inheritDoc
         */
        show: function() {
          $super.show.call(this);
          if (!this._systemModal) {
            this._gbcSystemModal();
          }
        },

        destroy: function() {
          if (this._productInformation) {
            this._productInformation.destroy();
            this._productInformation = null;
          }
          $super.destroy.call(this);
        }
      };
    });
    cls.WidgetFactory.registerBuilder('ApplicationHostAbout', cls.ApplicationHostAboutWidget);
  });
;
"use strict";

modulum('ApplicationHostSettingsWidget', ['ModalWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class ApplicationHostSettingsWidget
     * @memberOf classes
     * @extends classes.ModalWidget
     */
    cls.ApplicationHostSettingsWidget = context.oo.Class(cls.ModalWidget, function($super) {
      return /** @lends classes.ApplicationHostSettingsWidget.prototype */ {
        __name: "ApplicationHostSettingsWidget",
        __templateName: "ModalWidget",

        _initElement: function() {
          this._ignoreLayout = true;
          $super._initElement.call(this);
        },

        _initLayout: function() {
          // no layout
        },

        _initContainerElement: function() {
          $super._initContainerElement.call(this);
          this._element.addClass("mt-dialog-about");
          var dialogContents = document.createElement("div");

          var headerTitleDom = document.createElement('span');
          headerTitleDom.innerHTML = '<i class="zmdi zmdi-settings"></i> ' + i18next.t("gwc.settings");
          this.setHeader(headerTitleDom);

          this.setClosable(true, true);
          this.setContent(dialogContents);

          this._settings = cls.WidgetFactory.createWidget("Settings", this.getBuildParameters());
          dialogContents.appendChild(this._settings.getElement());
          this._settings.setParentWidget(this);
        },

        /**
         * @inheritDoc
         */
        show: function() {
          $super.show.call(this);
          if (!this._systemModal) {
            this._gbcSystemModal();
          }
        },

        destroy: function() {
          this._settings.destroy();
          this._settings = null;
          $super.destroy.call(this);
        },

        hide: function() {
          if (this._settings) {
            this._settings._restoreDefaultButton();
          }
          $super.hide.call(this);
        },
      };
    });
    cls.WidgetFactory.registerBuilder('ApplicationHostSettings', cls.ApplicationHostSettingsWidget);
  });
;
"use strict";

modulum('ApplicationHostWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class ApplicationHostWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     */
    cls.ApplicationHostWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.ApplicationHostWidget.prototype */ {
        __name: "ApplicationHostWidget",
        /**
         * @type {classes.ApplicationHostSidebarWidget}
         */
        _sidebar: null,
        /**
         * @type {classes.ApplicationHostSidebarBackdropWidget}
         */
        _sidebarBackdrop: null,
        /**
         * @type {classes.ApplicationHostMenuWidget}
         */
        _menu: null,
        /**
         * left css position of the container
         * @type {?number}
         */
        _position: null,
        /**
         * @type {HTMLElement}
         */
        _centralContainer: null,
        _launcher: null,

        /**
         * @type {HandleRegistration}
         */
        _browserResizeHandler: null,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          this._ignoreLayout = true;
          $super._initElement.call(this);
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          // no layout
        },

        /**
         * @inheritDoc
         */
        _initContainerElement: function() {
          $super._initContainerElement.call(this);
          this._centralContainer = this._element.firstElementChild;
          this._sidebar = cls.WidgetFactory.createWidget('ApplicationHostSidebar', this.getBuildParameters());
          this._sidebar.setParentWidget(this);
          this._browserResizeHandler = context.HostService.onScreenResize(this._onDisplayChanged);
          this._sidebar.onDisplayChanged(this._onDisplayChanged);
          this._element.prependChild(this._sidebar.getElement());
          this._sidebarBackdrop = cls.WidgetFactory.createWidget('ApplicationHostSidebarBackdrop', this.getBuildParameters());
          this._sidebarBackdrop.setParentWidget(this);
          this._element.appendChild(this._sidebarBackdrop.getElement());
          if (gbc.ThemeService.getValue("theme-legacy-topbar")) {
            this._menu = cls.WidgetFactory.createWidget('ApplicationHostMenu', this.getBuildParameters());
            this._menu.setParentWidget(this);
            this._containerElement.parentNode.insertBefore(this._menu.getElement(), this._containerElement);
            this._menu.setURBar(context.__wrapper.isNative());
            this._menu.when(context.constants.widgetEvents.toggleClick, this.showSidebar.bind(this));
          }

          this._sidebar.when(context.constants.widgetEvents.toggleClick, this.hideSidebar.bind(this));
          this._sidebarBackdrop.onClick(this.hideSidebar.bind(this));
          this._launcher = cls.WidgetFactory.createWidget('ApplicationLauncher', this.getBuildParameters());
          this._launcher.setHidden(true);
          this.addChildWidget(this._launcher);
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._browserResizeHandler) {
            this._browserResizeHandler();
            this._browserResizeHandler = null;
          }
          this._sidebar.destroy();
          this._sidebarBackdrop.destroy();
          if (gbc.ThemeService.getValue("theme-legacy-topbar")) {
            this._menu.destroy();
          }
          this._launcher.destroy();
          this._centralContainer = null;
          $super.destroy.call(this);
        },
        getLauncher: function() {
          return this._launcher;
        },

        /**
         *
         * @returns {classes.ApplicationHostSidebarWidget}
         */
        getSideBar: function() {
          return this._sidebar;
        },
        getMenu: function() {
          return this._menu;
        },
        getCentralContainerPosition: function() {
          return this._position;
        },
        /**
         *
         * @param position
         * @returns {boolean} true if position has changed
         */
        setCentralContainerPosition: function(position) {
          if (position !== this._position) {
            this._position = position;
            this._centralContainer.style.left = position + "px";
            return true;
          } else {
            return false;
          }
        },
        showSidebar: function() {
          this._sidebar.setDisplayed(true);
          this._sidebarBackdrop.setDisplayed(true);
          //Save it to the stored settings
          gbc.StoredSettingsService.setSideBarVisible(true);
          gbc.LogService.ui.log("sidebar open", true);
        },
        hideSidebar: function() {
          this._sidebar.setDisplayed(false);
          this._sidebarBackdrop.setDisplayed(false);
          //Save it to the stored settings
          gbc.StoredSettingsService.setSideBarVisible(false);
          gbc.LogService.ui.log("sidebar open", false);
        },
        toggleSidebar: function() {
          if (this._sidebar.isDisplayed()) {
            this.hideSidebar();
          } else {
            this.showSidebar();
          }
        },

        enableSidebar: function(enable) {
          this._sidebar.setUnavailable(!enable);
          this._sidebarBackdrop.setUnavailable(!enable);
          if (gbc.ThemeService.getValue("theme-legacy-topbar")) {
            this._menu.setSidebarUnavailable(!enable);
          }
          this._centralContainer.toggleClass("mt-sidebar-unavailable", !enable);
          if (!gbc.StoredSettingsService.isSideBarVisible()) {
            this.hideSidebar();
          } else {
            this.showSidebar();
          }
        },
        _onDisplayChanged: function() {
          var session = context.SessionService.getCurrent(),
            app = session && session.getCurrentApplication();
          if (session && session.isInTabbedContainerMode()) {
            app = session.getTabbedContainerModeHostApplication();
            var tabbedContainerHost = session.getTabbedContainerWidget() && session.getTabbedContainerWidget().getParentWidget();
            if (tabbedContainerHost) {
              tabbedContainerHost.getLayoutEngine().forceMeasurement();
              tabbedContainerHost.getLayoutEngine().invalidateAllocatedSpace();
              tabbedContainerHost.getLayoutInformation().invalidateMeasure();
            }
          }
          if (app && app.layout) {
            app.layout.refreshLayout({
              resize: true
            });
          }
        },
        setSidebarContent: function(widget) {
          this.getSideBar().setSidebarContent(widget);
        }

      };
    });
    cls.WidgetFactory.registerBuilder('ApplicationHost', cls.ApplicationHostWidget);
  });
;
"use strict";

modulum('ApplicationInformationWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class ApplicationInformationWidget
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.ApplicationInformationWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.ApplicationInformationWidget.prototype */ {
        __name: "ApplicationInformationWidget",
        /**
         * @type Element
         */
        _currentUARElement: null,
        _initElement: function() {
          this._ignoreLayout = true;
          $super._initElement.call(this);
          this._currentUARElement = this._element.getElementsByClassName("applicationUAR")[0];
          this._currentUARElement.on('click.ApplicationInformationWidget', this._onClick.bind(this));
        },
        _initLayout: function() {
          // no layout
        },
        destroy: function() {
          this._currentUARElement.off('click.ApplicationInformationWidget');
        },
        _onClick: function() {
          this._currentUARElement.selectText();
        },
        getCurrentUAR: function() {
          return this._currentUARElement.value;
        },
        setCurrentUAR: function(uar) {
          this._currentUARElement.value = uar;
        }
      };
    });
    cls.WidgetFactory.registerBuilder('ApplicationInformation', cls.ApplicationInformationWidget);
  });
;
"use strict";

modulum('ChromeBarItemWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Item to add to the topbar (Use as a base class as well for GBC items)
     * @class ChromeBarItemWidget
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.ChromeBarItemWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.ChromeBarItemWidget.prototype */ {
        __name: "ChromeBarItemWidget",

        /** @type {classes.ImageWidget} */
        _image: null,
        /** @type {Element} */
        _textElement: null,
        /** @type {Element} */
        _imageContainer: null,
        /** @type {string} */
        _itemType: "",

        /** @function */
        _afterLayoutHandler: null,

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          this._layoutInformation = new cls.LayoutInformation(this);
          this._layoutEngine = new cls.ChromeBarItemLayoutEngine(this);
        },

        /**
         * @inheritDoc
         */
        _initElement: function(initialInformation) {
          $super._initElement.call(this, initialInformation);
          this._textElement = this._element.getElementsByTagName('span')[0];
          this._imageContainer = this._element.getElementsByClassName('gbc_imageContainer')[0];
        },

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          this.setItemType("item"); // item type by default (could be item or gbcItem)
        },

        /**
         * Client QA code for UR testing
         * @private
         */
        actionQAReady: function() {
          if (this.__qaReadyAction) {
            this.__qaReadyAction = false;
            this.emit(context.constants.widgetEvents.click);
          }
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          // Click on any item should close the right bar
          if (this.getParentWidget().closeRightBar) {
            this.getParentWidget().closeRightBar();
          } else {
            this.getParentWidget().hide();
          }
          this.emit(context.constants.widgetEvents.click, domEvent);
          return true; // bubble
        },

        /**
         * @inheritDoc
         */
        managePriorityKeyDown: function(keyString, domKeyEvent, repeat) {
          var keyProcessed = false;
          if (this.isEnabled()) {
            if (keyString === "space" || keyString === "enter" || keyString === "return") {
              this.emit(context.constants.widgetEvents.click, domKeyEvent);
              keyProcessed = true;
            }
          }

          if (keyProcessed) {
            return true;
          } else {
            return $super.managePriorityKeyDown.call(this, keyString, domKeyEvent, repeat);
          }
        },

        /**
         * Set the text of the chromebar item
         * @param {string} text - the text
         * @publicdoc
         */
        setText: function(text) {
          this._setTextContent(text, "_textElement");
          this._layoutEngine.invalidateMeasure();
          this._layoutEngine.forceMeasurement();

          // client QA code
          if (gbc.qaMode && ['qa_dialog_ready', 'qa_menu_ready'].indexOf(text) >= 0) {
            this.__qaReadyAction = true;
            if (this._afterLayoutHandler) {
              this._afterLayoutHandler();
            }
            this._afterLayoutHandler =
              context.SessionService.getCurrent().getCurrentApplication().layout.afterLayoutComplete(
                function() {
                  // event executed once : we release reference because event listener will destroy it
                  this._afterLayoutHandler = null;
                  this.actionQAReady();
                }.bind(this), true
              );
          }
        },

        /**
         * Get the text of the chromebar item
         * @return {?string}
         */
        getText: function() {
          return this._textElement ? this._textElement.textContent : null;
        },

        /**
         * Define the chromebar item image
         * @param {string} image - image url to use
         * @publicdoc
         */
        setImage: function(image) {
          if (image.length !== 0) {
            this.addClass("hasImage");
            if (!this._image) {
              this._image = cls.WidgetFactory.createWidget(image.startsWith('zmdi-') ? 'GbcImage' : 'ImageWidget', this
                .getBuildParameters());
              this._imageContainer.appendChild(this._image.getElement());
            } else if (this._image.isInstanceOf(cls.GbcImageWidget) && !image.startsWith('zmdi-')) {
              // Case where image is overrided to be something else than zmdi
              this._image.destroy();
              this._image = null;
              this.setImage(image);
            }
            this._image.setSrc(image);
          } else if (this._image) {
            this._image.getElement().remove();
            this._image.destroy();
            this._image = null;
          }
          this._layoutEngine.invalidateMeasure();
        },

        /**
         * Get the chromebar item Image
         * @return {?string}
         */
        getImage: function() {
          return this._image ? this._image.getSrc() : null;
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._image) {
            this._image.destroy();
            this._image = null;
          }
          if (this._afterLayoutHandler) {
            this._afterLayoutHandler();
            this._afterLayoutHandler = null;
          }
          $super.destroy.call(this);
        },

        /**
         * Get the item type
         * @return {string} the item type could be item (default) or gbcItem (for gbc Actions)
         */
        getItemType: function() {
          return this._itemType;
        },

        /**
         * Set the item type
         * @param {string} type - the item type could be item (default) or gbcItem (for gbc Actions)
         */
        setItemType: function(type) {
          this._itemType = type;
          this.getElement().setAttribute("chromebar-itemtype", type);
        }
      };
    });
    cls.WidgetFactory.registerBuilder('ChromeBarItem', cls.ChromeBarItemWidget);
  });
;
"use strict";

modulum('ChromeBarWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Main entry point for chrome Menu
     * Top bar used with mobile devices
     * In order, it adds:
     *  - UI Toolbar
     *  - Window Toolbar
     *  - Action Panel / Ring Menu
     *  - GBC centric actions
     * @class ChromeBarWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     */
    cls.ChromeBarWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.ChromeBarWidget.prototype */ {
        __name: "ChromeBarWidget",

        /** @type {Element} */
        _toggleRightBarElement: null,

        /** @type {string} **/
        _defaultTitle: "Genero Browser Client",

        /** @type {classes.ChromeRightBarWidget} */
        _rightBarWidget: null,

        /** @type {Element} */
        _titleElement: null,

        /** @type {Object} */
        _refreshConditions: null,

        _orientationHandler: null,

        /** @type {Boolean} **/
        _hasWindowIcon: false,

        /** @type {classes.ImageWidget} **/
        _windowIconImage: null,

        /** @type {Boolean} **/
        _lightMode: false,

        _aboutMenuItem: null,
        _settingsMenuItem: null,
        _uploadStatusMenuItem: null,
        _runtimeStatusMenuItem: null,
        _bookmarkMenuItem: null,
        _closeMenuItem: null,
        _debugMenuItem: null,
        _proxyLogMenuItem: null,
        _VMLogMenuItem: null,
        _runInGDCMenuItem: null,

        /** @type {classes.ChromeBarItemFilterWidget} **/
        _filterMenuItem: null,

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          // Handle items of both rightbar and topchromebar
          this._refreshConditions = {
            childrenNumber: 0,
            screenOrientation: 0,
            windowWidth: window.innerWidth,
          };

          $super.constructor.call(this, opts);

          if (opts.lightmode) {
            this.setLightMode(true);
          }
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          this._layoutInformation = new cls.LayoutInformation(this);
          this._layoutEngine = new cls.ChromeBarLayoutEngine(this);
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this.clearActions();

          // Destroy GBC menu items
          if (this._aboutMenuItem) {
            this._aboutMenuItem.destroy();
            this._aboutMenuItem = null;
          }
          if (this._bookmarkMenuItem) {
            this._bookmarkMenuItem.destroy();
            this._bookmarkMenuItem = null;
          }
          if (this._debugMenuItem) {
            this._debugMenuItem.destroy();
            this._debugMenuItem = null;
          }
          if (this._proxyLogMenuItem) {
            this._proxyLogMenuItem.destroy();
            this._proxyLogMenuItem = null;
          }
          if (this._VMLogMenuItem) {
            this._VMLogMenuItem.destroy();
            this._VMLogMenuItem = null;
          }
          if (this._runInGDCMenuItem) {
            this._runInGDCMenuItem.destroy();
            this._runInGDCMenuItem = null;
          }
          if (this._settingsMenuItem) {
            this._settingsMenuItem.destroy();
            this._settingsMenuItem = null;
          }
          if (this._closeMenuItem) {
            this._closeMenuItem.destroy();
            this._closeMenuItem = null;
          }
          if (this._uploadStatusMenuItem) {
            this._uploadStatusMenuItem.destroy();
            this._uploadStatusMenuItem = null;
          }
          if (this._runtimeStatusMenuItem) {
            this._runtimeStatusMenuItem.destroy();
            this._runtimeStatusMenuItem = null;
          }
          if (this._filterMenuItem) {
            this._filterMenuItem.destroy();
            this._filterMenuItem = null;
          }

          // Destroy remaining things
          this._toggleRightBarElement = null;
          this._rightBarWidget.destroy();
          this._rightBarWidget = null;
          this._titleElement = null;
          if (this._windowIconImage) {
            this._windowIconImage.destroy();
            this._windowIconImage = null;
          }

          this._orientationHandler();
          this._orientationHandler = null;
          this._resizeHandler();
          this._resizeHandler = null;

          if (gbc.LogService.isRecordingEnabled() && this._logRecordWidget) {
            this._logRecordWidget.destroy();
            this._logRecordWidget = null;
          }

          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);

          // All those are not needed in light mode
          if (!this._lightMode) {
            this._rightBarWidget = cls.WidgetFactory.createWidget('ChromeRightBar', this.getBuildParameters());
            this._rightBarWidget.setParentWidget(this);
            this._toggleRightBarElement = this._element.getElementsByClassName("mt-sidebar-action-toggle")[0];

            this._titleElement = this.getElement().querySelector(".currentDisplayedWindow");

            this._sidebarToggle = this._element.getElementsByClassName("mt-sidebar-toggle")[0];
          }
          this._refreshConditions.screenOrientation = window.orientation;
          this._orientationHandler = context.HostService.onOrientationChange(this.onOrientationChanged.bind(this));
          this._resizeHandler = context.HostService.onScreenResize(this._onResize.bind(this));

          if (gbc.LogService.isRecordingEnabled() && !this._lightMode) {
            this._logRecordWidget = cls.WidgetFactory.createWidget("LogRecorder", this.getBuildParameters());
            this._element.querySelector(".mt-toolbar-title").appendChild(this._logRecordWidget.getElement());
          }
        },

        /**
         * Show/hide filter item
         * @param {boolean} visible - true if item must be visible
         * @param {String} [filterValue] - initial filter value
         */
        showFilterMenuItem: function(visible, filterValue) {
          this._filterMenuItem.setFilterValue(filterValue);
          this._filterMenuItem.setHidden(!visible);
        },

        /**
         * @inheritDoc
         */
        _afterInitElement: function() {
          $super._afterInitElement.call(this);

          this._filterMenuItem = cls.WidgetFactory.createWidget("ChromeBarItemFilter", this.getBuildParameters());
          this._filterMenuItem.setHidden(true);
          this.addItemWidget(this._filterMenuItem);

          var gbcItems = [];
          // If we want a simple chromebar (not many items and so)
          if (this._lightMode) {
            gbcItems = ["about", "settings", "close"];
          } else {
            gbcItems = ["about", "debug", "runInGDC", "uploadStatus", "runtimeStatus", "proxyLog", "VMLog", "settings", "bookmark",
              "close"
            ];
          }

          this._createGBCMenuItems(gbcItems); // prepare gbcItem widgets
        },

        /**
         * Create all the GBC menu item (about, settings and so...)
         * Note that it doesn't add them to the dom! see _addGBCMenuItems for that
         * @param {String[]} gbcItems - list of items to create
         * @private
         */
        _createGBCMenuItems: function(gbcItems) {
          // Create all the gbc items
          gbcItems.forEach(function(item) {
            var widgetName = 'ChromeBarItem' + item.substr(0, 1).toUpperCase() + item.substr(1);
            this["_" + item + "MenuItem"] = cls.WidgetFactory.createWidget(widgetName, this.getBuildParameters());
          }.bind(this));
          this._addGBCMenuItems();
        },

        /**
         * Add the GBC menu item to the chromebar (let the chromebar moving it to the rightbar if needed)
         * @private
         */
        _addGBCMenuItems: function() {
          // About processing item
          this.addItemWidget(this._uploadStatusMenuItem);
          // About Menu item
          this.addItemWidget(this._aboutMenuItem);

          // *** Debug/Dev entries ***
          // Debug Menu item
          this.addItemWidget(this._debugMenuItem);
          // Run in GDC Menu item
          this.addItemWidget(this._runInGDCMenuItem);
          // Proxy Logs Menu item
          this.addItemWidget(this._proxyLogMenuItem);
          // VM Logs Menu item
          this.addItemWidget(this._VMLogMenuItem);

          // Settings Menu item
          this.addItemWidget(this._settingsMenuItem);
          // Bookmark Menu item
          this.addItemWidget(this._bookmarkMenuItem);
          // Close Window
          this.addItemWidget(this._closeMenuItem);
        },

        /**
         * Get a GBC menu item by its name
         * @param name
         */
        getGbcMenuItem: function(name) {
          return this["_" + name + "MenuItem"];
        },

        /**
         * Get the associated rightBar
         * @return {classes.ChromeRightBarWidget}
         */
        getRightBarWidget: function() {
          return this._rightBarWidget;
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          // Click on the burger to open left Sidebar
          if (domEvent.target.isElementOrChildOf(this._sidebarToggle)) {
            this.closeRightBar();
            this.emit(context.constants.widgetEvents.toggleClick);
          }

          // Click on the 3 dots top right
          if (domEvent.target.isElementOrChildOf(this._toggleRightBarElement)) {
            if (this._rightBarWidget) {
              this._rightBarWidget.toggle();
            }
          }

          return true; // bubble
        },

        /**
         * Close the right bar
         */
        closeRightBar: function() {
          if (this._rightBarWidget) {
            this._rightBarWidget.hide();
          }
        },

        /**
         * Add a toolbar to the chromeBar
         * @param {classes.ToolBarWidget} toolbarWidget - item to add
         * @param {number} order
         */
        addToolBar: function(toolbarWidget, order) {
          toolbarWidget.setAsChromeBar(this);
          var children = toolbarWidget.getChildren().slice(); // copy object for safe foreach
          children.forEach(function(child) {
            child.addClass("toolbarItem");
            if (!child.isInstanceOf(cls.ToolBarSeparatorWidget) && !child.isInstanceOf(cls
                .FlowDecoratorWidget)) { // Skip toolbar separators in chromebar
              this.addItemWidget(child); // Add it to chrome TopBar first for layout measurement
            }
          }.bind(this));
        },

        /**
         * Add a menu to the chromeBar (Menu or Dialog)
         * @param {classes.MenuWidget} menuWidget - widget to add
         */
        addMenu: function(menuWidget) {
          menuWidget.setAsChromeBar(this);
          var children = menuWidget.getChildren().slice(); // copy object for safe foreach
          children.forEach(function(child) {
            child.addClass("menuItem");
            this.addItemWidget(child);
          }.bind(this));
        },

        _onResize: function() {
          this._layoutEngine.forceMeasurement();
          this._layoutEngine.invalidateMeasure();
          this.refresh();
        },

        /**
         * Handler called when layout notify changes
         * @param {Boolean} force - force a refresh
         */
        refresh: function(force) {
          // Add timeout to that to throttle
          if (this._timeoutHandler) {
            this._clearTimeout(this._timeoutHandler);
          }
          this._timeoutHandler = this._registerTimeout(function() {
            this._refresh(force);
            this._containerElement.style.opacity = "1";
          }.bind(this), 100);
        },

        /**
         * Throttled Handler called when layout notify changes
         * @param {Boolean} force - force a refresh
         * @private
         */
        _refresh: function(force) {
          if (force || this.needRefresh()) { // Check if a refresh is really needed
            var sortedItemList = this._sortChromeBarItems();

            if (sortedItemList.length > 0) {
              sortedItemList.forEach(function(c) {
                this._removeChildWidgetFromDom(c);
              }.bind(this));

              sortedItemList.forEach(function(item) {
                this.adoptChildWidget(item);
              }.bind(this));
              sortedItemList = null; // cleanup
            }

            // Flow Items if necessary
            var topBarFull = false;
            var children = this.getChildren().slice(0); // copy children array to avoid list alteration while processing
            if (children) {
              // Now we choose, who should stay in topbar, or who shouldn't
              var availableSpace = this.getLayoutInformation().getRawMeasure().getWidth() - this.getLayoutInformation()
                .getDecorating()
                .getWidth();
              var currentUsedWidth = 0;
              var childWidth = 0;

              for (var j = 0; j < children.length; j++) {
                if (!topBarFull) {
                  // Hidden item take zero Width, otherwise get width from layout measure
                  childWidth = children[j].isHidden() ? 0 : children[j].getLayoutInformation().getRawMeasure().getWidth();
                  // Add total size
                  currentUsedWidth = currentUsedWidth + childWidth;
                  // TopBar is full if children take more space than container
                  topBarFull = currentUsedWidth > availableSpace;
                }
                // Check again, since it might have changed
                if (topBarFull) {
                  this._rightBarWidget.adoptChildWidget(children[j]); // Add it to the sidebar instead of topbar
                }
              }
            }

            // Show/hide right '3 dots' button if there are children in the right bar
            if (this._rightBarWidget.getChildren().length === 0) {
              this._toggleRightBarElement.addClasses("hidden");
            } else {
              this._toggleRightBarElement.removeClass("hidden");
            }
          }

        },

        /**
         * Method to check if calling a refresh is necessary
         * @return {boolean} - true if necessary false otherwise
         */
        needRefresh: function() {
          var children = this.getChildren().slice(0); // copy children array to avoid list alteration while processing
          var childrenOverflow = false,
            changedUsedWidth = false,
            childrenPosChanged = false;

          if (children) {
            // availableSpace is containerElement width ( all widget - decoration)
            var availableSpace = this.getLayoutInformation().getRawMeasure().getWidth() - this.getLayoutInformation()
              .getDecorating()
              .getWidth();

            var sortedItemList = this._sortChromeBarItems();
            var currentUsedWidth = 0;
            for (var i = 0; i < children.length; i++) {
              if (children[i].getLayoutInformation().getRawMeasure().getWidth()) {
                currentUsedWidth = currentUsedWidth + children[i].getLayoutInformation().getRawMeasure()
                  .getWidth(); // get item layout engine
              }

              // Compare the children position to the sorted children position: if changed, need a refresh
              if (!childrenPosChanged && sortedItemList[i] !== children[i]) {
                childrenPosChanged = true;
              }
            }

            childrenOverflow = currentUsedWidth > availableSpace;
            if (this._currentUsedWidth !== currentUsedWidth) {
              changedUsedWidth = true;
              this._currentUsedWidth = currentUsedWidth;
            }
          }

          return childrenOverflow || changedUsedWidth || childrenPosChanged || this._refreshConditions.screenOrientation !== window
            .orientation ||
            this._refreshConditions.windowWidth !== window.innerWidth ||
            this._refreshConditions.forceRefresh;
        },

        /**
         * Sort the items in chrome
         * @return {T[]} the Array of sorted items
         * @private
         */
        _sortChromeBarItems: function() {
          var rbChildren = this._rightBarWidget.getChildren("item").slice(0);
          var rbGbcChildren = this._rightBarWidget.getChildren("gbcItem").slice(0);
          // Sort items by *UniqueId*
          var sortedItemList = this.getChildren("item").concat(rbChildren).slice(0).sort(function(a, b) {
            return a.getAuiLinkedUniqueIdentifier() - b.getAuiLinkedUniqueIdentifier();
          });
          // Sort gbcItems by *_uuid*
          var sortedGbcItemList = this.getChildren("gbcItem").concat(rbGbcChildren).slice(0).sort(function(a, b) {
            return a._uuid - b._uuid;
          });
          return sortedItemList.concat(sortedGbcItemList);
        },

        /**
         * Handler called when screen orientation changed
         */
        onOrientationChanged: function() {
          this.closeRightBar();
          // Need to clear all children from bars (top and right) then put it back at the right places
          // Save the children before clearing it
          var chromeBarChildren = this.getChildren().slice();
          var chromeRightBarChildren = this._rightBarWidget ? this._rightBarWidget.getChildren().slice() : [];

          this.clearActions();

          for (var i = 0; i < chromeBarChildren.length; i++) {
            this.addItemWidget(chromeBarChildren[i]);
          }

          for (i = 0; i < chromeRightBarChildren.length; i++) {
            this.addItemWidget(chromeRightBarChildren[i]);
          }
          this._refreshConditions.screenOrientation = window.orientation; // Update refresh conditions
        },

        /**
         * Add an item as a child or as a chromebar child
         * @param {classes.ChromeBarItemWidget} widget - item to add
         */
        addItemWidget: function(widget) {
          if (widget && !widget.isDestroyed()) {
            var noDomInsert = false;
            this._containerElement.style.opacity = "0"; // 'Hide' style for flickering issues
            this.adoptChildWidget(widget, {
              noDOMInsert: noDomInsert
            });
          }
        },

        /**
         * Remove dom actions
         */
        clearActions: function() {
          while (this.getContainerElement() && this.getContainerElement().firstChild) {
            this.getContainerElement().removeChild(this.getContainerElement().firstChild);
          }
          if (this._rightBarWidget) {
            while (this._rightBarWidget.getContainerElement() && this._rightBarWidget.getContainerElement().firstChild) {
              this._rightBarWidget.getContainerElement().removeChild(this._rightBarWidget.getContainerElement().firstChild);
            }
          }
        },

        /**
         * Define the title displayed in the chromeBar
         * @param {String} title - title displayed
         */
        setTitle: function(title) {
          if (title) {
            this._titleElement.innerHTML = title;
          } else {
            this._titleElement.innerHTML = this._defaultTitle;
          }
        },

        /**
         * Define the icon displayed at the burger place
         * @param image
         * @param appIcon
         */
        setIcon: function(image, appIcon) {
          if (image && image !== "") {
            if (!appIcon) { // set global icon using app icon only if not previously set with window icon
              this._hasWindowIcon = true;
            } else if (this._hasWindowIcon === true) {
              return;
            }
            this._element.getElementsByClassName('zmdi')[0].addClass('hidden');
            if (!this._windowIconImage) {
              this._windowIconImage = cls.WidgetFactory.createWidget("ImageWidget", this.getBuildParameters());
              this._sidebarToggle.appendChild(this._windowIconImage.getElement());
            }
            this._windowIconImage.setSrc(image);
            this._windowIconImage.setAlignment("verticalCenter", "horizontalCenter");
            this._windowIconImage.setHidden(false);
          } else {
            this._element.getElementsByClassName('zmdi')[0].removeClass('hidden');
            if (this._windowIconImage) {
              this._windowIconImage.setHidden(true);
            }
          }
        },

        /**
         * Set menu items as hidden to Handle 4ST actionPanelPosition:none
         * @param {Boolean} hidden - true if must be hidden
         */
        setMenuItemsHidden: function(hidden) {
          this.toggleClass("menuHidden", hidden);
        },

        /**
         * Get all children of this widget with filtering options
         * @param {string?} itemType - filter result on a given itemType
         * @returns {classes.ChromeBarItemWidget[]} the list of children of this widget group
         */
        getChildren: function(itemType) {
          if (!itemType) {
            // Default
            return $super.getChildren.call(this);
          } else {
            // Filtering
            return this._children.filter(function(child) {
              return child.getItemType && child.getItemType() === itemType;
            });
          }
        },

        /**
         * Allows one to create a Chromebar without all the items (i.e: session end, logPlayer ...)
         * @param {Boolean} enable - true to enable this mode, false otherwise
         */
        setLightMode: function(enable) {
          this._lightMode = enable;
          this.toggleClass("lightmode", enable);
          if (enable) {
            this.setTitle(this._defaultTitle);
            if (this._logRecordWidget) {
              this._logRecordWidget.destroy();
              this._logRecordWidget = null;
            }
          }
        },

        /**
         * Emit the close event of the current window
         */
        closeCurrentWindow: function() {
          this._closeMenuItem.close();
        },

      };
    });
    cls.WidgetFactory.registerBuilder('ChromeBar', cls.ChromeBarWidget);
  });
;
"use strict";

modulum('ChromeRightBarWidget', ['DropDownWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * SideBar for devices with style 'chromeBar' enabled
     * This widget will display all actions/toolbar that doesn't fit in the chromeTopBar
     * @class ChromeRightBarWidget
     * @memberOf classes
     * @extends classes.DropDownWidget
     */
    cls.ChromeRightBarWidget = context.oo.Class(cls.DropDownWidget, function($super) {
      return /** @lends classes.ChromeRightBarWidget.prototype */ {
        __name: "ChromeRightBarWidget",
        __templateName: "ChromeRightBarWidget",

        /** @type {Boolean} */
        _firstItemSelected: false, // flag to keep track of first item (for styling)

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          // Setup of the DropDown
          this.reverseX = true;
          //this.setFullHeight(); // display as a panel if set, otherwise, displays as a dropdown
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);

          // Swipe to Right on opened sidebar to close it
          this.getElement().onSwipe("ChromeRightBarWidget", this.hide.bind(this), {
            direction: ["right"]
          });
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          // Close the chromebar on click on any part of it
          this.hide();
          return true;
        },

        /**
         * Overrided to allow one to click on items of the top chromebar in one click
         * @inheritDoc
         */
        shouldClose: function(targetElement) {
          var topChromeBar = this.getParentWidget();
          return !targetElement.isElementOrChildOf(topChromeBar.getElement());
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this.getElement().offSwipe("ChromeRightBarWidget");
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        addChildWidget: function(widget, options) {
          // Force a text (aui name) if not defined
          if (widget.getText && widget.getText().length <= 0) {
            widget.setText(widget._auiName);
          }
          $super.addChildWidget.call(this, widget, options);
        },

        /**
         * @inheritDoc
         */
        adoptChildWidget: function(widget) {
          $super.adoptChildWidget.call(this, widget);

          // Select the first item of the type gbcItem to add some decoration
          if (!this._firstItemSelected && this.getChildren("gbcItem").length > 0) {
            this.getChildren("gbcItem")[0].addClass("chromebar-firstGbcItem");
            this._firstItemSelected = true;
          }
        },

        /**
         * @inheritDoc
         */
        show: function(multiple) {
          // Adding some sliding effect
          //this.addClass("slide-right");
          $super.show.call(this, multiple);
          //this.removeClass("slide-right");
        },

        /**
         * Get all children of this widget with filtering options
         * @param {string?} itemType - filter result on a given itemType
         * @returns {classes.WidgetBase[]} the list of children of this widget group
         * @publicdoc
         */
        getChildren: function(itemType) {
          if (!itemType) {
            return $super.getChildren.call(this);
          } else {
            return this._children.filter(function(child) {
              if (child.isInstanceOf(cls.ToolBarSeparatorWidget) || !child.getItemType) {
                return false;
              }
              return child.getItemType() === itemType;
            });
          }
        },

      };
    });
    cls.WidgetFactory.registerBuilder('ChromeRightBar', cls.ChromeRightBarWidget);
  });
;
"use strict";

modulum('ChromeBarItemAboutWidget', ['ChromeBarItemWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * About button in ChromeBar
     * @class ChromeBarItemAboutWidget
     * @memberOf classes
     * @extends classes.ChromeBarItemWidget
     */
    cls.ChromeBarItemAboutWidget = context.oo.Class(cls.ChromeBarItemWidget, function($super) {
      return /** @lends classes.ChromeBarItemAboutWidget.prototype */ {
        __name: "ChromeBarItemAboutWidget",
        __templateName: "ChromeBarItemWidget",

        /** @type {classes.ApplicationHostAboutWidget} **/
        _aboutModal: null,

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          this.setItemType("gbcItem");
          this.setText(i18next.t('gwc.main.chromebar.appInfo'));
          this.setTitle("GBC " + context.version);
          this.setImage("zmdi-information");
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          if (this._aboutModal === null) {
            this._aboutModal = cls.WidgetFactory.createWidget('ApplicationHostAbout', this.getBuildParameters());
            document.body.appendChild(this._aboutModal.getElement());
            this._aboutModal.when(context.constants.widgetEvents.close, function() {
              this._aboutModal.destroy();
              this._aboutModal = null;
            }.bind(this), true);
          }
          this._aboutModal.show();

          return $super.manageMouseClick.call(this, domEvent);
        },

      };
    });
    cls.WidgetFactory.registerBuilder('ChromeBarItemAbout', cls.ChromeBarItemAboutWidget);
  });
;
"use strict";

modulum('ChromeBarItemBookmarkWidget', ['ChromeBarItemWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Bookmark button in ChromeBar
     * @class ChromeBarItemBookmarkWidget
     * @memberOf classes
     * @extends classes.ChromeBarItemWidget
     */
    cls.ChromeBarItemBookmarkWidget = context.oo.Class(cls.ChromeBarItemWidget, function($super) {
      return /** @lends classes.ChromeBarItemBookmarkWidget.prototype */ {
        __name: "ChromeBarItemBookmarkWidget",
        __templateName: "ChromeBarItemWidget",

        /** @type boolean */
        _activated: false,

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          this.setItemType("gbcItem");
          this.setText(i18next.t('gwc.main.chromebar.bookmark'));
          this.setTitle(i18next.t('gwc.main.chromebar.bookmarkAlt'));
          this.setImage("zmdi-bookmark-outline");
          if (gbc.SessionService.getCurrent()) {
            var bookmark = context.BookmarkService.getBookmark(gbc.SessionService.getCurrent().getAppId());
            this.setActivated(!!bookmark);
          }
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          var url = context.UrlService.currentUrl();
          this.setActivated(!this._activated);
          context.BookmarkService.switchBookmark(gbc.SessionService.getCurrent().getAppId(), url.toString());
          return false;
        },

        /**
         *
         * @param activated
         */
        setActivated: function(activated) {
          this._activated = activated;
          var i = this._element.getElementsByTagName("i")[0];
          i.toggleClass("zmdi-bookmark", !!activated)
            .toggleClass("zmdi-bookmark-outline", !activated);
        }
      };
    });
    cls.WidgetFactory.registerBuilder('ChromeBarItemBookmark', cls.ChromeBarItemBookmarkWidget);
  });
;
"use strict";

modulum('ChromeBarItemCloseWidget', ['ChromeBarItemWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Close Button in ChromeBar
     * @class ChromeBarItemCloseWidget
     * @memberOf classes
     * @extends classes.ChromeBarItemWidget
     */
    cls.ChromeBarItemCloseWidget = context.oo.Class(cls.ChromeBarItemWidget, function($super) {
      return /** @lends classes.ChromeBarItemCloseWidget.prototype */ {
        __name: "ChromeBarItemCloseWidget",
        __templateName: "ChromeBarItemWidget",

        _active: false,

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          this.setItemType("gbcItem");
          this.setText(i18next.t('gwc.main.chromebar.close'));
          this.setTitle(i18next.t('gwc.main.chromebar.close'));
          this.setImage("zmdi-close-circle");
          this.addClass("gbc_Invisible");
        },

        /**
         *
         * @param {Boolean} active
         * @param {classes.WindowWidget} windowWidget
         */
        setActive: function(active, windowWidget) {
          this._currentLinkedWindow = windowWidget;
          this._active = active;
          if (!this._destroyed) {
            if (!context.__wrapper.isNative() && this._element) {
              this._element.toggleClass("gbc_Invisible", !active);
            } else {
              this._element.addClass("gbc_Invisible");
            }
          }
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          if (this._active && this.isVisible()) {
            this.close();
          }
          return $super.manageMouseClick.call(this, domEvent);
        },

        /**
         * Emit the close
         */
        close: function() {
          if (!this._processing && this._currentLinkedWindow) {
            //this.emit(context.constants.widgetEvents.click);
            this._currentLinkedWindow._emitClose();
          }

        },

        /**
         * Attach a callback when button is clicked
         * @param hook
         * @return {*|Function}
         */
        onClick: function(hook) {
          return this.when(context.constants.widgetEvents.click, hook);

        },

        setLinkedWindow: function(window) {
          this._currentLinkedWindow = window;
          if (!window) {
            this._element.addClass("gbc_Invisible");
          }
        },

        /**
         * Defines if the widget should be hidden or not
         * @param {boolean} hidden true if the widget is hidden, false otherwise
         * @param {?classes.WindowWidget} windowWidget - get info on the window widget to hide or not if tabbed mode
         * @publicdoc
         */
        setHidden: function(hidden, windowWidget) {
          if (!windowWidget._tabbedContainerWidget) {
            $super.setHidden.call(this, hidden);
          }
        },

        /**
         *
         * @param processing
         * @private
         */
        _setProcessingStyle: function(processing) {
          this._processing = !!processing;
          if (this._element) {
            if (processing) {
              this._element.setAttribute("processing", "processing");
            } else {
              this._element.removeAttribute("processing");
            }
          }
        }
      };
    });
    cls.WidgetFactory.registerBuilder('ChromeBarItemClose', cls.ChromeBarItemCloseWidget);
  });
;
"use strict";

modulum('ChromeBarItemDebugWidget', ['ChromeBarItemWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Open AUI tree debug in chromeBar
     * @class ChromeBarItemDebugWidget
     * @memberOf classes
     * @extends classes.ChromeBarItemWidget
     */
    cls.ChromeBarItemDebugWidget = context.oo.Class(cls.ChromeBarItemWidget, function($super) {
      return /** @lends classes.ChromeBarItemDebugWidget.prototype */ {
        __name: "ChromeBarItemDebugWidget",
        __templateName: "ChromeBarItemWidget",

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          context.DebugService.registerDebugUi(this);
          this.setItemType("gbcItem");
          this.setText(i18next.t('gwc.main.chromebar.debugTools'));
          this.setTitle("[Debug] AUI tree");
          this.setImage("zmdi-memory");
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          context.DebugService.unregisterDebugUi(this);
          $super.destroy.call(this);
        },

        /**
         * Called by Debug service to tell UI that it's ready
         * @param active
         */
        activate: function(active) {
          this._element.toggleClass("debugActivated", active);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          context.DebugService.show();
          return $super.manageMouseClick.call(this, domEvent);
        },

        /**
         * @inheritDoc
         */
        isHidden: function() {
          // If debug mode is not active, this item is supposed to be hidden
          return !gbc.DebugService.isActive() ? true : $super.isHidden.call(this);
        },
      };
    });
    cls.WidgetFactory.registerBuilder('ChromeBarItemDebug', cls.ChromeBarItemDebugWidget);
  });
;
"use strict";

modulum('ChromeBarItemFilterWidget', ['ChromeBarItemWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Filter button in ChromeBar
     * @class ChromeBarItemFilterWidget
     * @memberOf classes
     * @extends classes.ChromeBarItemWidget
     */
    cls.ChromeBarItemFilterWidget = context.oo.Class(cls.ChromeBarItemWidget, function($super) {
      return /** @lends classes.ChromeBarItemFilterWidget.prototype */ {
        __name: "ChromeBarItemFilterWidget",
        __templateName: "ChromeBarItemWidget",

        /** @type {Element} */
        _filter: null,
        /** @type {Element} */
        _input: null,
        /** @type {Element} */
        _back: null,
        /** @type {Element} */
        _clear: null,

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);

          this.setItemType("item");
          this.setText(i18next.t('gwc.main.chromebar.filter'));
          this.setTitle(i18next.t('gwc.main.chromebar.filter'));
          this.setImage("zmdi-filter-variant");

          this._filter = document.createElement("span");
          this._filter.addClass("gbc_Filter");

          this._input = document.createElement("input");
          this._input.addClass("gbc_FilterInput");
          this._input.setAttribute("type", "text");
          this._input.setAttribute("placeholder", i18next.t('gwc.main.chromebar.filter'));

          this._back = document.createElement("i");
          this._back.addClasses("zmdi", "zmdi-arrow-left");

          this._clear = document.createElement("i");
          this._clear.addClasses("zmdi", "zmdi-close", "filter-clear");

          this._filter.appendChild(this._back);
          this._filter.appendChild(this._input);
          this._filter.appendChild(this._clear);

          this._input.on('keydown', function(evt) {
            evt.stopPropagation();
            if (evt.key.toLowerCase() === "enter") {
              this.getUserInterfaceWidget().getFocusedWidget().setFocus();
            }
          }.bind(this));

          this._input.on('input', this.updateFilter.bind(this));
        },

        /**
         * @inheritDoc
         */
        destroy: function() {

          this._input.off("keydown");
          this._input.off("input");

          this._filter = null;
          this._input = null;
          this._back = null;
          this._clear = null;

          $super.destroy.call(this);
        },

        /**
         * Update and send filter value to DVM
         */
        updateFilter: function() {
          var app = gbc.SessionService.getCurrent() && gbc.SessionService.getCurrent().getCurrentApplication();
          var focusedNode = app.focus.getFocusedNode();
          var event = new cls.VMConfigureEvent(focusedNode.getId(), {
            filter: this._input.value
          });
          app.typeahead.event(event, focusedNode);
        },

        /**
         * Set filter value in the input element
         * @param {String} value - filter value
         */
        setFilterValue: function(value) {
          this._input.value = value;
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {

          // click on input filter does nothing
          if (domEvent.target.isElementOrChildOf(this._input)) {
            return false;
          }

          // click on clear button, just clear the input
          if (domEvent.target.isElementOrChildOf(this._clear)) {
            this._input.value = "";
            this.updateFilter();
            this._input.domFocus();
            return false;
          }

          // hide or show input filter
          if (this._filter.isInDOM()) {
            this._image.setHidden(false);
            this._filter.remove();
          } else {
            this._image.setHidden(true);
            this._element.appendChild(this._filter);
            this._input.domFocus();
          }

          return false;
        }

      };
    });
    cls.WidgetFactory.registerBuilder('ChromeBarItemFilter', cls.ChromeBarItemFilterWidget);
  });
;
"use strict";

modulum('ChromeBarItemProxyLogWidget', ['ChromeBarItemWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Button in chromeBar to open proxy logs
     * @class ChromeBarItemProxyLogWidget
     * @memberOf classes
     * @extends classes.ChromeBarItemWidget
     */
    cls.ChromeBarItemProxyLogWidget = context.oo.Class(cls.ChromeBarItemWidget, function($super) {
      return /** @lends classes.ChromeBarItemProxyLogWidget.prototype */ {
        __name: "ChromeBarItemProxyLogWidget",
        __templateName: "ChromeBarItemWidget",

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          context.DebugService.registerDebugUi(this);
          this.setItemType("gbcItem");
          this.setText(i18next.t('gwc.main.chromebar.proxyLog'));
          this.setTitle(i18next.t('gwc.main.chromebar.proxyLog'));
          this.setImage("zmdi-file-document");
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          context.DebugService.unregisterDebugUi(this);
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          var session = context.SessionService.getCurrent();
          var connector = session.getConnector();
          var sessionId = session.getSessionId();
          window.open(connector + "/monitor/log/uaproxy-" + sessionId);

          return $super.manageMouseClick.call(this, domEvent);
        },

        /**
         * Called by Debug service to tell UI that it's ready
         * @param active
         */
        activate: function(active) {
          this._element.toggleClass("debugActivated", active);
        },

        /**
         * @inheritDoc
         */
        isHidden: function() {
          // If debug mode is not active, this item is supposed to be hidden
          return !gbc.DebugService.isActive() ? true : $super.isHidden.call(this);
        },

      };
    });
    cls.WidgetFactory.registerBuilder('ChromeBarItemProxyLog', cls.ChromeBarItemProxyLogWidget);
  });
;
"use strict";

modulum('ChromeBarItemRunInGDCWidget', ['ChromeBarItemWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Button in chromeBar to open the app in GDC
     * @class ChromeBarItemRunInGDCWidget
     * @memberOf classes
     * @extends classes.ChromeBarItemWidget
     */
    cls.ChromeBarItemRunInGDCWidget = context.oo.Class(cls.ChromeBarItemWidget, function($super) {
      return /** @lends classes.ChromeBarItemRunInGDCWidget.prototype */ {
        __name: "ChromeBarItemRunInGDCWidget",
        __templateName: "ChromeBarItemWidget",

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          context.DebugService.registerDebugUi(this);
          this.setItemType("gbcItem");
          this.setText(i18next.t('gwc.main.chromebar.runInGDC'));
          this.setTitle(i18next.t('gwc.main.chromebar.runInGDC'));
          this.setImage("zmdi-play");
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          context.DebugService.unregisterDebugUi(this);
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          var name = window.location.pathname.substr(window.location.pathname.lastIndexOf('/') + 1);
          var shortcut = '<?xml version="1.0" encoding="utf-8"?>\n' +
            '<fjs configVersion="2" product="Genero Desktop Client">\n' +
            ' <Shortcuts>\n' +
            '  <Shortcut ' +
            'name="' + name + '" ' +
            'authenticationMode="standard" ' +
            'type="http" ' +
            'proxyType="monitor" ' +
            'url="' + window.location.href + '" ' +
            '/>\n' +
            ' </Shortcuts>\n' +
            '</fjs>';

          var shortcutFile = new Blob([shortcut], {
            type: "application/genero-gdc"
          });
          //for microsoft IE
          var fileName = name + ".gdc";
          if (window.navigator && window.navigator.msSaveOrOpenBlob) {
            window.navigator.msSaveOrOpenBlob(shortcutFile, fileName);
          } else { //other browsers
            var a = document.createElement("a");
            a.style.display = "none";
            // firefox needs to have element in DOM
            document.body.appendChild(a);
            a.href = window.URL.createObjectURL(shortcutFile);
            a.download = fileName;
            a.click();
            document.body.removeChild(a);
          }

          return $super.manageMouseClick.call(this, domEvent);
        },

        /**
         * Called by Debug service to tell UI that it's ready
         * @param active
         */
        activate: function(active) {
          this._element.toggleClass("debugActivated", active);
        },

        /**
         * @inheritDoc
         */
        isHidden: function() {
          // If debug mode is not active, this item is supposed to be hidden
          return !gbc.DebugService.isActive() ? true : $super.isHidden.call(this);
        },

      };
    });
    cls.WidgetFactory.registerBuilder('ChromeBarItemRunInGDC', cls.ChromeBarItemRunInGDCWidget);
  });
;
"use strict";

modulum('ChromeBarItemRuntimeStatusWidget', ['ChromeBarItemWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Runtime Status in ChromeBar
     * Note: not added to dom, since it's handled by loading bar
     * @class ChromeBarItemRuntimeStatusWidget
     * @memberOf classes
     * @extends classes.ChromeBarItemWidget
     */
    cls.ChromeBarItemRuntimeStatusWidget = context.oo.Class(cls.ChromeBarItemWidget, function($super) {
      return /** @lends classes.ChromeBarItemRuntimeStatusWidget.prototype */ {
        __name: "ChromeBarItemRuntimeStatusWidget",
        __templateName: "ChromeBarItemWidget",

        _active: false,
        _count: 0,

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          this.setItemType("gbcItem");
          this.setTitle(i18next.t('gwc.file.upload.processing'));
          this.setImage("zmdi-upload");
        },

        /**
         * Change style when idle
         */
        setIdle: function() {
          this._count--;
          if (this._count === 0) {
            this.removeClass("processing");

          }
        },

        /**
         * Change style when processing
         */
        setProcessing: function() {
          this._count++;
          this.addClass("processing");
        }

      };
    });
    cls.WidgetFactory.registerBuilder('ChromeBarItemRuntimeStatus', cls.ChromeBarItemRuntimeStatusWidget);
  });
;
"use strict";

modulum('ChromeBarItemSettingsWidget', ['ChromeBarItemWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Button in chromeBar to open GBC settings modal
     * @class ChromeBarItemSettingsWidget
     * @memberOf classes
     * @extends classes.ChromeBarItemWidget
     */
    cls.ChromeBarItemSettingsWidget = context.oo.Class(cls.ChromeBarItemWidget, function($super) {
      return /** @lends classes.ChromeBarItemSettingsWidget.prototype */ {
        __name: "ChromeBarItemSettingsWidget",
        __templateName: "ChromeBarItemWidget",

        /** @type {classes.ApplicationHostSettingsWidget} */
        _settingsModal: null,

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          this.setItemType("gbcItem");
          this.setText(i18next.t('gwc.main.chromebar.settings'));
          this.setTitle(i18next.t('gwc.main.chromebar.settings'));
          this.setImage("zmdi-settings");

          // Add info about browser storage full
          if (gbc.LocalSettingsService._quotaExceededError) {
            this.addClass("error");
          }
          gbc.LocalSettingsService._eventListener.when("QuotaExceededError", function() {
            this.addClass("error");
          }.bind(this));
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._settingsModal) {
            this._settingsModal.destroy();
            this._settingsModal = null;
          }
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          if (this._settingsModal === null) {
            this._settingsModal = cls.WidgetFactory.createWidget('ApplicationHostSettings', this.getBuildParameters());
            document.body.appendChild(this._settingsModal.getElement());
            this._settingsModal.when(context.constants.widgetEvents.close, function() {
              if (this._settingsModal) {
                this._settingsModal.destroy();
                this._settingsModal = null;
              }
            }.bind(this), true);
          }
          this._settingsModal.show();

          return $super.manageMouseClick.call(this, domEvent);
        },

      };
    });
    cls.WidgetFactory.registerBuilder('ChromeBarItemSettings', cls.ChromeBarItemSettingsWidget);
  });
;
"use strict";

modulum('ChromeBarItemUploadStatusWidget', ['ChromeBarItemWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Close Button in ChromeBar
     * @class ChromeBarItemUploadStatusWidget
     * @memberOf classes
     * @extends classes.ChromeBarItemWidget
     */
    cls.ChromeBarItemUploadStatusWidget = context.oo.Class(cls.ChromeBarItemWidget, function($super) {
      return /** @lends classes.ChromeBarItemUploadStatusWidget.prototype */ {
        __name: "ChromeBarItemUploadStatusWidget",
        __templateName: "ChromeBarItemWidget",

        _active: false,
        _count: 0,

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          this.setItemType("gbcItem");
          this.setTitle(i18next.t('gwc.file.upload.processing'));
          this.setImage("zmdi-upload");
        },

        /**
         * Change style when idle
         */
        setIdle: function() {
          this._count--;
          if (this._count === 0) {
            this.removeClass("processing");

          }
        },

        /**
         * Change style when processing
         */
        setProcessing: function() {
          this._count++;
          this.addClass("processing");
        }

      };
    });
    cls.WidgetFactory.registerBuilder('ChromeBarItemUploadStatus', cls.ChromeBarItemUploadStatusWidget);
  });
;
"use strict";

modulum('ChromeBarItemVMLogWidget', ['ChromeBarItemWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Button in chromeBar to open VM logs
     * @class ChromeBarItemVMLogWidget
     * @memberOf classes
     * @extends classes.ChromeBarItemWidget
     */
    cls.ChromeBarItemVMLogWidget = context.oo.Class(cls.ChromeBarItemWidget, function($super) {
      return /** @lends classes.ChromeBarItemVMLogWidget.prototype */ {
        __name: "ChromeBarItemVMLogWidget",
        __templateName: "ChromeBarItemWidget",

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          context.DebugService.registerDebugUi(this);
          this.setItemType("gbcItem");
          this.setText(i18next.t('gwc.main.chromebar.vmLog'));
          this.setTitle(i18next.t('gwc.main.chromebar.vmLog'));
          this.setImage("zmdi-file-document");
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          context.DebugService.unregisterDebugUi(this);
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          var session = context.SessionService.getCurrent();
          var connector = session.getConnector();
          var sessionId = session.getSessionId();
          window.open(connector + "/monitor/log/vm-" + sessionId);

          return $super.manageMouseClick.call(this, domEvent);
        },

        /**
         * Called by Debug service to tell UI that it's ready
         * @param active
         */
        activate: function(active) {
          this._element.toggleClass("debugActivated", active);
        },

        /**
         * @inheritDoc
         */
        isHidden: function() {
          // If debug mode is not active, this item is supposed to be hidden
          return !gbc.DebugService.isActive() ? true : $super.isHidden.call(this);
        },

      };
    });
    cls.WidgetFactory.registerBuilder('ChromeBarItemVMLog', cls.ChromeBarItemVMLogWidget);
  });
;
"use strict";

modulum('LogLevelSelectorWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class LogLevelSelectorWidget
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.LogLevelSelectorWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.LogLevelSelectorWidget.prototype */ {
        __name: "LogLevelSelectorWidget",

        _currentItem: null,

        _initElement: function() {
          $super._initElement.call(this);
          this.setCurrent(context.LogService.getCurrentLevel());
          this._element.on("click", function(evt) {
            if (evt.target.dataset.loglevel) {
              this.setCurrent(evt.target.dataset.loglevel);
              this.emit("loglevel", evt.target.dataset.loglevel);
            }
          }.bind(this));
        },
        setCurrent: function(level) {
          if (this._currentItem) {
            this._currentItem.removeClass("active");
          }
          this._currentItem = this._element.querySelector("." + level);
          if (!this._currentItem) {
            this._currentItem = this._element.querySelector(".none");
          }
          this._currentItem.addClass("active");
        }
      };
    });
    cls.WidgetFactory.registerBuilder('LogLevelSelector', cls.LogLevelSelectorWidget);
  });
;
"use strict";

modulum('LogInfoWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Display useful info about a log (GBC log only)
     * @class LogInfoWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     */
    cls.LogInfoWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.LogInfoWidget.prototype */ {
        __name: "LogInfoWidget",

        _infoGBCElement: null,
        _infoBrowserElement: null,
        _infoThemeElement: null,
        _infosettingsElement: null,

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
        },

        _initElement: function() {
          $super._initElement.call(this);
          this._infoGBCElement = this.getElement().querySelector(".loginfo-gbc");
          this._infoBrowserElement = this.getElement().querySelector(".loginfo-browser");
          this._infoThemeElement = this.getElement().querySelector(".loginfo-theme");
          this._infosettingsElement = this.getElement().querySelector(".loginfo-settings");
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          $super.destroy.call(this);
        },

        /**
         * Define the GBC related info
         * @param {Object} gbcInfo
         */
        setGBCInfo: function(gbcInfo) {
          var themes = gbcInfo.availableThemes.map(function(t) {
            return t.name;
          });
          var sideBarInfo = gbcInfo.isSideBarVisible ? "Yes: " + gbcInfo.sideBarSize + "px" : 'No';
          var body = "<ul>";
          body += "<li><span class='title'>- " + i18next.t('gwc.logPlayer.logInfo.version') + ": </span><span class='value'>" +
            gbcInfo.version + "-" + gbcInfo.build +
            "</span></li>";
          body += "<li><span class='title'>- " + i18next.t('gwc.logPlayer.logInfo.platform') + ": </span><span class='value'>" +
            gbcInfo.platformName + "</span></li>";
          body += "<li><span class='title'>- " + i18next.t('gwc.logPlayer.logInfo.protocol') + ": </span><span class='value'>" +
            gbcInfo.protocolType + "</span></li>";
          body += "<li><span class='title'>- " + i18next.t('gwc.logPlayer.logInfo.theme') + ": </span><span class='value'>" +
            gbcInfo.activeTheme + "</span></li>";
          body += "<li><span class='title'>- " + i18next.t('gwc.logPlayer.logInfo.availableThemes') +
            ": </span><span class='value'>" + themes + "</span></li>";
          body += "<li><span class='title'>- " + i18next.t('gwc.logPlayer.logInfo.sidebar') + ": </span><span class='value'>" +
            sideBarInfo + "</span></li>";
          body += "</ul>";
          this._infoGBCElement.querySelector(".panel-body").innerHTML = body;
        },

        /**
         * Define the Browser related info
         * @param {Object} browserInfo
         */
        setBrowserInfo: function(browserInfo) {
          var body = "<ul>";
          body += "<li><span class='title'>- " + i18next.t('gwc.logPlayer.logInfo.userAgent') + ":</span><span class='value'>" +
            browserInfo.userAgent + '</span></li>';
          body += "<li><span class='title'>- " + i18next.t('gwc.logPlayer.logInfo.os') + ": </span><span class='value'>" +
            browserInfo.os + '</span></li>';
          body += "<li><span class='title'>- " + i18next.t('gwc.logPlayer.logInfo.lang') + ": </span><span class='value'>" +
            browserInfo.activeLanguage + "</span></li>";
          body += "<li><span class='title'>- " + i18next.t('gwc.logPlayer.logInfo.availableLang') +
            ": </span><span class='value'> " + browserInfo.availableLanguages +
            "</span></li>";
          body += "<li><span class='title'>- " + i18next.t('gwc.logPlayer.logInfo.dimension') + ": </span><span class='value'>" +
            browserInfo.dimension.width + 'x' +
            browserInfo.dimension.height + '</span></li>';
          body += "<li><span class='title'>- " + i18next.t('gwc.logPlayer.logInfo.url') + ": </span><span class='value'>" +
            browserInfo.url + "</span></li>";
          body += "</ul>";
          this._infoBrowserElement.querySelector(".panel-body").innerHTML = body;
        },

        /**
         * Display the themes variables
         * @param {Object} theme
         */
        setTheme: function(theme) {
          var themeEntries = Object.keys(theme);
          var body = "<ul>";

          for (var i = 0; i < themeEntries.length; i++) {
            body += "<li><span class='title'>$" + themeEntries[i] + "</span> = <span class='value'>" + theme[themeEntries[i]] +
              "</span></li>";
          }
          body += "</ul>";

          this._infoThemeElement.querySelector(".panel-body").innerHTML = body;
        },

        /**
         * Display the StoredSettings
         * @param {Object} settings
         */
        setSettings: function(settings) {
          var body = JSON.stringify(settings, "\n", 2);
          this._infosettingsElement.querySelector(".panel-body").innerHTML = "<pre>" + body + "</pre>";
        },

      };
    });
    cls.WidgetFactory.registerBuilder('LogInfo', cls.LogInfoWidget);
  });
;
"use strict";

modulum('LogPlayerWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Widget used to replay logs from VM, GBC, GDC and so
     * @class LogPlayerWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     */
    cls.LogPlayerWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.LogPlayerWidget.prototype */ {
        __name: "LogPlayerWidget",

        /** @type {Element} **/
        _fileInput: null,
        /** @type {Element} **/
        _delayInput: null,
        /** @type {Element} **/
        _delayFromLogElement: null,
        /** @type {classes.ToggleCheckBoxWidget} **/
        _delayFromLogWidget: null,
        /** @type {Element} **/
        _showHelpersElement: null,
        /** @type {classes.ToggleCheckBoxWidget} **/
        _showHelpersWidget: null,
        /** @type {Element} **/
        _resetButton: null,
        /** @type {Element} **/
        _nextStepButton: null,
        /** @type {Element} **/
        _playAllButton: null,
        /** @type {Element} **/
        _pauseButton: null,
        /** @type {Element} **/
        _forwardInput: null,
        /** @type {Element} **/
        _forwardButton: null,
        /** @type {classes.ToggleCheckBoxWidget} **/
        _statsCheckWidget: null,
        /** @type {Element} **/
        _statsElement: null,
        /** @type {Array} **/
        _log: null,
        /** @type {Number} **/
        _currentLogLine: 0,
        /** @type {Number} **/
        _currentDvmOrder: 0,
        /** @type {Number} **/
        _numberOfDvmOrdersToProcess: 0,
        /** @type {Number} **/
        _processedDvmOrders: 0,
        /** @type {Number} **/
        _startTime: null,
        /** @type {Number} **/
        _maxNumberOfElements: null,
        /** @type {Number} **/
        _maxNumberOfWidgets: null,
        /** @type {Element} **/
        _debugCursorElement: null,
        /** @type {Element} **/
        _keyPressedElement: null,
        /** @type {Element} **/
        _mousePressedElement: null,
        /** @type {Element} **/
        _headerElement: null,
        /** @type {Object} **/
        _gbcBrowserInfo: null,
        /** @type {classes.LogInfoWidget} **/
        _logInfoWidget: null,
        /** @type {Boolean} **/
        _isPaused: false,
        /** @type {Object} **/
        _userInteractionElement: null,
        /** @type {Boolean} **/
        _userInteractionAllowed: false,
        /** @type {classes.ToggleCheckBoxWidget} **/
        _userInteractionWidget: null,

        /** @type {Element} **/
        _customStyle: null,

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);

          window._logplayer = this;

          var root = this.getElement();

          this._fileInput = root.querySelector(".logplayer-fileinput");
          this._fileInput.on('change.LogPlayerWidget', this.loadFile.bind(this));

          this._headerElement = root.querySelector("header");
          this._resetButton = root.querySelector(".logplayer-reset");
          this._nextStepButton = root.querySelector(".logplayer-step");
          this._playAllButton = root.querySelector(".logplayer-play");
          this._pauseButton = root.querySelector(".logplayer-pause");
          this._forwardInput = root.querySelector(".logplayer-forward-count");
          this._forwardButton = root.querySelector(".logplayer-forward");
          this._delayInput = root.querySelector(".logplayer-delay");
          this._delayFromLogElement = root.querySelector(".logplayer-delayfromlog");
          this._statsElement = root.querySelector(".logplayer-stats");
          this._showHelpersElement = root.querySelector(".logplayer-showHelpers");
          this._debugCursorElement = root.querySelector(".logplayer-cursor");
          this._keyPressedElement = root.querySelector(".logplayer-keypressed");
          this._mousePressedElement = root.querySelector(".logplayer-mousepressed");
          this._userInteractionElement = root.querySelector(".logplayer-userInteraction");

          // Default value
          this.setDelayInputValue(500);

          this._gbcTitle = document.querySelector(".mt-toolbar-title");

          this.setButtonEnabled(this._resetButton, false);
          this.setButtonEnabled(this._nextStepButton, false);
          this.setButtonEnabled(this._playAllButton, false);
          this.setButtonEnabled(this._pauseButton, false);
          this.setButtonEnabled(this._forwardButton, false);

          this._statsCheckWidget = cls.WidgetFactory.createWidget("ToggleCheckBox", this.getBuildParameters());
          this._statsCheckWidget.setEnabled(true);
          this._statsCheckWidget.setText(i18next.t("gwc.logPlayer.topBar.statistics"));
          this._statsCheckWidget.setTitle(i18next.t("gwc.logPlayer.topBar.statisticsTitle"));
          this._statsCheckWidget.setValue(false);
          this._statsElement.appendChild(this._statsCheckWidget.getElement());

          this._delayFromLogWidget = cls.WidgetFactory.createWidget("ToggleCheckBox", this.getBuildParameters());
          this._delayFromLogWidget.setEnabled(true);
          this._delayFromLogWidget.setText(i18next.t("gwc.logPlayer.topBar.delayFromLog"));
          this._delayFromLogWidget.setValue(false);
          this._delayFromLogElement.appendChild(this._delayFromLogWidget.getElement());

          this._showHelpersWidget = cls.WidgetFactory.createWidget("ToggleCheckBox", this.getBuildParameters());
          this._showHelpersWidget.setEnabled(true);
          this._showHelpersWidget.setText(i18next.t("gwc.logPlayer.topBar.showHelpers"));
          this._showHelpersWidget.setTitle(i18next.t("gwc.logPlayer.topBar.showHelpersTitle"));
          this._showHelpersWidget.setValue(true);
          this._showHelpersElement.appendChild(this._showHelpersWidget.getElement());

          if (gbc.DebugService.isActive()) {
            this._userInteractionWidget = cls.WidgetFactory.createWidget("ToggleCheckBox", this.getBuildParameters());
            this._userInteractionWidget.setEnabled(true);
            this._userInteractionWidget.setText("User Interaction");
            this._userInteractionWidget.setValue(false);
            this._userInteractionWidget.when(context.constants.widgetEvents.change, function() {
              this.addOverlay(!this._userInteractionWidget.getValue(), false, true);
            }.bind(this));
            this._userInteractionElement.appendChild(this._userInteractionWidget.getElement());
          }
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._statsCheckWidget) {
            this._statsCheckWidget.destroy();
            this._statsCheckWidget = null;
          }
          if (this._delayFromLogWidget) {
            this._delayFromLogWidget.destroy();
            this._delayFromLogWidget = null;
            this._delayFromLogElement = null;
          }
          if (this._showHelpersWidget) {
            this._showHelpersWidget.destroy();
            this._showHelpersWidget = null;
          }
          if (this._logInfoWidget) {
            this._logInfoWidget.destroy();
            this._logInfoWidget = null;
          }
          if (this._customStyle) {
            document.getElementsByTagName('head')[0].removeChild(this._customStyle);
          }

          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          // no layout
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          var target = domEvent.target;
          if (target.isElementOrChildOf(this._resetButton)) {
            this.reset();
          } else if (target.isElementOrChildOf(this._nextStepButton)) {
            this.nextStep();
          } else if (target.isElementOrChildOf(this._playAllButton)) {
            this.play();
          } else if (target.isElementOrChildOf(this._forwardButton)) {
            this.forward();
          } else if (target.isElementOrChildOf(this._pauseButton)) {
            this.pause();
          }
          return true;
        },

        /**
         * Define a delay between orders
         * @param {Number} value - value in ms
         */
        setDelayInputValue: function(value) {
          this._delayInput.value = value;
        },

        /**
         * Define the step to go forward to
         * @param {Number} value - step number to go to
         */
        setForwardInputValue: function(value) {
          this._forwardInput.value = value;
        },

        /**
         * Method called when content is read from a log file
         * @param {String|String[]} content
         */
        loadContent: function(content) {
          this._nextStepButton.removeAttribute('disabled');
          this._playAllButton.removeAttribute('disabled');
          this._log = null;
          this.reset();
          var rawContent = content;

          content = content.split('\n').map(function(line) {
            return line.trim();
          });
          if (content.length > 0) {
            if (rawContent.indexOf('gbcLog') < 0 && this._logInfoWidget) {
              this._logInfoWidget.destroy();
            }
            var firstLine = content[0];
            if (firstLine === 'LOGVERSION=2') {
              this.parseGdcLog(content);
            } else if (firstLine.substr(0, 5) === 'om 0 ') {
              this.parseFglLog(content);
            } else if (firstLine === 'guilog v2') {
              this.parseFglLogV2(content);
            } else if (firstLine === '#Version: 1.0') {
              this.parseUaproxyLog(content);
            } else if (rawContent.indexOf('gbcLog') >= 0) {
              this.parseGbcLog(JSON.parse(rawContent));
            }
            this.setButtonEnabled(this._resetButton, true);
            this.setButtonEnabled(this._nextStepButton, true);
            this.setButtonEnabled(this._playAllButton, true);
            this.setButtonEnabled(this._forwardButton, true);
          }
        },

        /**
         * Method called when a file has been inputed
         * @param event
         */
        loadFile: function(event) {
          if (event.target.files.length > 0) {
            context.LogPlayerService.cleanApplications(); //Reset all current applications
            this._fileInput.setAttribute("title", event.target.files[0].name + " loaded");
            this._gbcTitle = document.querySelector(".mt-toolbar-title");
            this._gbcTitle.innerHTML = "<b>Log Player : </b> " + event.target.files[0].name;

            var reader = new FileReader();
            reader.onload = function(fEvent) {
              this.loadContent(fEvent.target.result);
            }.bind(this);
            reader.readAsText(event.target.files[0]);
          }
        },

        /**
         * Reset logPlayer at first instruction
         */
        reset: function() {
          // Current app reset
          if (gbc.SessionService.getCurrent()) {
            gbc.SessionService.getCurrent().closeSession();
            gbc.SessionService.getCurrent().destroy();
          }
          if (this._logInfoWidget) {
            this._logInfoWidget.setHidden(false);
          }

          this.setButtonEnabled(this._resetButton, true);
          this.setButtonEnabled(this._nextStepButton, true);
          this.setButtonEnabled(this._playAllButton, true);
          this.setButtonEnabled(this._forwardButton, true);
          this.addOverlay(false, true);

          this._currentLogLine = 0;
          this._currentDvmOrder = 0;
          this._numberOfDvmOrdersToProcess = 0;
          this._processedDvmOrders = 0;

          gbc.LogPlayerService.cleanApplications();
          var appElement = document.querySelector(".gbc_ApplicationWidget");
          if (appElement) {
            appElement.innerHTML = "";
          }
          if (this._gbcTitle) {
            this._gbcTitle.parent("gbc_ApplicationLauncherWidget").removeClass("hidden");
          }
          this._cleanDebugHelper();
          this.setButtonEnabled(this._fileInput, true);

        },

        /**
         * Parse a GDC formatted log
         * @param log
         */
        parseGdcLog: function(log) {
          this._log = [];
          for (var i = 0; i < log.length; ++i) {
            if (i !== 0) {
              var line = log[i];
              if (line.length > 0) {
                var appEnd = line.indexOf(':');
                var senderEnd = line.indexOf(':', appEnd + 1);
                var delayEnd = line.indexOf(':', senderEnd + 1);

                var entry = {};
                entry.app = line.substring(0, appEnd);
                entry.sender = line.substring(appEnd + 1, senderEnd);
                entry.delay = line.substring(senderEnd + 1, delayEnd);
                entry.content = context.LogPlayerService.mockOrderResources(line.substring(delayEnd + 1));

                this._log.push(entry);
              }
            }
          }
        },

        /**
         * Parse a GBC formatted Log
         * @param {Object} log - json Formated log
         */
        parseGbcLog: function(log) {
          this._currentLogType = log.logType;
          this._delayFromLogWidget.setValue(true);
          this.setDelayInputValue(5); // if gbcLog: put some small value in this field
          this._log = [];
          var lastKnownTimestamp = 0;
          var style = 'color: #007da0'; // console style

          this._gbcBrowserInfo = log.browserInfos;
          // Show info in the page when parsing log
          if (this._logInfoWidget) {
            this._logInfoWidget.destroy();
          }
          this._logInfoWidget = cls.WidgetFactory.createWidget("LogInfo", this.getBuildParameters());
          window.document.querySelector(".gbc_ApplicationLauncherWidget>.containerElement").appendChild(this._logInfoWidget.getElement());
          this._logInfoWidget.setGBCInfo(log.gbcInfos);
          this._logInfoWidget.setBrowserInfo(log.browserInfos);
          this._logInfoWidget.setTheme(log.themeVariables);
          this._logInfoWidget.setSettings(log.storedSettings);

          this._customStyle = document.createElement('style');
          this._customStyle.type = 'text/css';
          document.getElementsByTagName('head')[0].appendChild(this._customStyle);

          // Ensure messages are well positioned
          context.HostService.onScreenResize(function() {
            var margin = document.body.clientWidth - log.browserInfos.dimension.width;
            this._customStyle.innerHTML = '.gbc_ApplicationHostWidget .mt-centralcontainer{ left: 0px!important}\n';
            this._customStyle.innerHTML += '.gbc_MessageWidget.bottom-right, .gbc_MessageWidget.top-right{ margin-right: ' +
              margin + 'px }\n';
          }.bind(this));

          var margin = document.body.clientWidth - log.browserInfos.dimension.width;
          this._customStyle.innerHTML = '.gbc_MessageWidget.bottom-right, .gbc_MessageWidget.top-right{ margin-right: ' + margin +
            'px; }\n';
          this._customStyle.innerHTML +=
            '.gbc_ChromeBarWidget.mt-toolbar .mt-sidebar-toggle, .gbc_ApplicationHostSidebarWidget .mt-sidebar-toggle { display:inherit!important; pointer-events:all!important;}\n';

          // If log specifically said: no sidebar
          if (!log.gbcInfos.isSideBarVisible) {
            var st = document.createElement('style');
            st.type = 'text/css';
            st.innerHTML = '.mt-sidebar:not(.mt-sidebar-unavailable){ left: -100%; }';
            document.getElementsByTagName('head')[0].appendChild(st);
            gbc.HostService.getApplicationHostWidget().hideSidebar();
            this._customStyle.innerHTML += ".gbc_ApplicationHostWidget .mt-centralcontainer{ left: 0px!important}";
          }
          // Header part in console
          console.log('%c ~~~~~~~~~~~~~~~~~~~   Starting GBC log   ~~~~~~~~~~~~~~~~~~~', style);
          console.log('%c Recorded date : ', style, new Date(log.runDate));
          console.log('%c GBC ' + log.gbcInfos.version + '-' + log.gbcInfos.build + ' - Platform: ' + log.gbcInfos.platformName +
            ' - Protocol: ' + log.gbcInfos.protocolType, style);
          console.log('%c   - Theme: ' + log.gbcInfos.activeTheme, style);
          console.log('%c   - Available themes: ', style, log.gbcInfos.availableThemes);
          console.log('%c BROWSER ', style);
          console.log('%c   - User Agent: ', style, log.browserInfos.userAgent);
          console.log('%c   - OS: ', style, log.browserInfos.os);
          console.log('%c   - Language: ', style, log.browserInfos.activeLanguage, log.browserInfos.availableLanguages);
          console.log('%c   - Dimension: ', style, log.browserInfos.dimension);
          console.log('%c   - URL: ', style, log.browserInfos.url);
          console.log('%c THEME VARIABLES: ', style, log.themeVariables);
          console.log('%c STORED SETTINGS: ', style, log.storedSettings);

          // Activate debug mode if log has been recorded with it
          if (log.gbcInfos.debugMode) {
            gbc.DebugService.activate(true);
          }

          var line = null,
            entry = {};

          // Pre-Process every log when parsing
          for (var i = 1; i < log.logs.length; ++i) { // start at 1 since 0 is "gbclog"
            line = log.logs[i];
            entry = {};
            entry.delay = 0;
            entry.app = "" + line.appId;

            // Get info about timestamp
            lastKnownTimestamp = line.t ? line.t : lastKnownTimestamp;
            entry.timestamp = lastKnownTimestamp;

            // Timestamp / delay calculation
            if (this._log.length >= 1) {
              if (lastKnownTimestamp !== this._log[this._log.length - 1].timestamp) {
                if (this._log[this._log.length - 1].timestamp > 0) {
                  entry.delay = lastKnownTimestamp - this._log[this._log.length - 1].timestamp;
                }
              }
            }

            // In this case, it should be treated as a DVM RESPONSE
            if (line.provider === "[NETWORK]") {
              if (line.httpType === "HTTP RESPONSE") {
                entry.sender = "DVM";
                entry.app = "" + line.appId;
                entry.content = context.LogPlayerService.mockOrderResources(line.data, log.images);
                this._log.push(entry);
              } else if (line.httpType === "HTTP REQUEST") {
                entry.sender = "GBC-NETWORK";
                entry.content = line.type;
                if (line.uaDetails === "auiOrder") {
                  entry.content = line.data;
                } else {
                  entry.app = "?";
                }

                this._log.push(entry);
              }
            } else if (line.provider === "[MOUSE]") {
              // Add a move entry delay 500ms before the click
              entry.sender = "GBC";
              entry.data = line;
              entry.data.move = true;
              entry.data.click = false;
              var entryClick = JSON.parse(JSON.stringify(entry)); // deep copy the first entry
              entry.data.rightClick = false;
              this._log.push(entry);
              // Add the click entry
              entryClick.data.move = false;
              entryClick.data.click = true;
              this._log.push(entryClick);
            } else {
              entry.sender = "GBC";
              entry.data = line;
              this._log.push(entry);
            }
          }
        },

        /**
         * Parse a FGL formatted log
         * @param log
         */
        parseFglLog: function(log) {
          this._log = [];
          for (var i = 0; i < log.length; ++i) {
            var line = log[i];
            if (line.length > 0) {
              var entry = {};
              entry.app = "0";
              entry.delay = 1000;
              if (line[0] === '#') {
                if (line.substr(0, 7) === '#event ') {
                  entry.sender = "FE";
                } else {
                  entry.sender = "COMMENT";
                }
                entry.content = context.LogPlayerService.mockOrderResources(line.substring(1));
              } else {
                entry.sender = "DVM";
                entry.content = context.LogPlayerService.mockOrderResources(line);
              }
              this._log.push(entry);
            }
          }
        },

        /**
         * Parse a FGL with new log format
         * @param log
         */
        parseFglLogV2: function(log) {
          this._log = [];
          var lastOrderTime = 0;
          for (var i = 1; i < log.length; ++i) {
            var line = log[i];
            if (line.length > 0) {
              var colonIndex = line.indexOf(':');
              var info = line.substr(0, colonIndex).split(' ');
              var entry = {};
              entry.app = info[0];
              var timestamp = parseInt(info[1]);
              entry.delay = timestamp - lastOrderTime;
              lastOrderTime = timestamp;
              entry.sender = info[2] === 'i' ? "FE" : "DVM";
              entry.content = context.LogPlayerService.mockOrderResources(line.substr(colonIndex + 1));
              this._log.push(entry);
            }
          }
        },

        /**
         * Parse UA proxy formatted log
         * @param log
         */
        parseUaproxyLog: function(log) {
          this._log = [];
          var fieldsCount = null;
          var relativeTimeFieldIndex = null;
          var contextsFieldIndex = null;
          var eventTypeFieldIndex = null;
          var eventParamsFieldIndex = null;
          var timeSinceLastDvmOrder = 0;

          for (var i = 0; i < log.length; ++i) {
            var line = log[i];
            if (line.length !== 0) {
              if (line[0] === '#') {
                if (line.substr(0, 9) === '#Fields: ') {
                  var fields = line.substr(9).split(' ');
                  fieldsCount = fields.length;
                  relativeTimeFieldIndex = fields.indexOf('relative-time');
                  contextsFieldIndex = fields.indexOf('contexts');
                  eventTypeFieldIndex = fields.indexOf('event-type');
                  eventParamsFieldIndex = fields.indexOf('event-params');
                  if (relativeTimeFieldIndex === -1 || contextsFieldIndex === -1 || eventTypeFieldIndex === -1 ||
                    eventParamsFieldIndex === -1) {
                    this.addLog(" ", '<b>Log fields missing. Enable "ALL DEBUG" categories</b>');
                    return;
                  }
                }
              } else {
                var sectionStart = -1;
                var sections = [];
                for (var j = 0; j < line.length; ++j) {
                  var c = line[j];
                  if (c === ' ') {
                    sections.push(line.substring(sectionStart + 1, j));
                    sectionStart = j;
                  } else if (c === '"') {
                    j = line.indexOf('"', j + 1);
                  }
                  if (sections.length === fieldsCount - 1) {
                    sections.push(line.substr(j + 1));
                    break;
                  }
                }
                timeSinceLastDvmOrder += parseFloat(sections[relativeTimeFieldIndex]);
                var contexts = sections[contextsFieldIndex];
                var eventType = sections[eventTypeFieldIndex];
                var eventParams = sections[eventParamsFieldIndex];
                var vmIdIndex = contexts.indexOf('VM=');
                var vmId = null;
                if (vmIdIndex !== -1) {
                  var semiColonIndex = contexts.indexOf(';', vmIdIndex);
                  if (semiColonIndex === -1) {
                    semiColonIndex = undefined;
                  }
                  vmId = contexts.substring(vmIdIndex + 3, semiColonIndex);
                }
                if (vmId !== null) {
                  if (eventType === '"Sending VM"' || eventType === '"Sending UA"') {
                    if ((eventParams.indexOf("meta Connection") === 0 || eventParams.indexOf("om") === 0 || eventParams.indexOf(
                        "event _om") === 0)) {
                      var sender = eventType === '"Sending UA"' ? "DVM" : "FE";
                      var orders = eventParams;
                      var crIndex = -1;
                      do {
                        crIndex = orders.indexOf('\\n', crIndex + 1);
                        if (crIndex > 1 && orders[crIndex - 1] !== '\\') {
                          orders = orders.substr(0, crIndex) + '\n' + orders.substr(crIndex + 2);
                        }
                      } while (crIndex !== -1);
                      var order = this.detachString(orders);
                      order = order.replace(/([^\\])\\t/g, '$1\t');
                      order = order.replace(/\\\\n/g, '\\n');
                      order = order.replace(/\\\\\\\\/g, '//');
                      order = order.replace(/\\\\"/g, '\\"');
                      order = order.replace(/\\r/g, '');
                      order = order.replace(/%/g, "%25");
                      order = decodeURIComponent(order.replace(/\\x/g, "%"));
                      order = context.LogPlayerService.mockOrderResources(order);

                      if (order !== '-') { // '-' marks the DVM deconection
                        var entry = {};
                        entry.app = this.detachString(vmId);
                        entry.sender = sender;
                        entry.content = order;
                        entry.delay = sender === 'DVM' ? Math.round(timeSinceLastDvmOrder * 1000) : 0;
                        timeSinceLastDvmOrder = 0;
                        this._log.push(entry);
                      }
                      orders = orders.substring(crIndex + 2);
                    } else if (/X-FourJs-Closed: true/.test(line)) {
                      var closeEntry = {};
                      closeEntry.app = this.detachString(vmId);
                      closeEntry.sender = "";
                      closeEntry.content = "";
                      closeEntry.close = true;
                      closeEntry.delay = 0;
                      timeSinceLastDvmOrder = 0;
                      this._log.push(closeEntry);

                    }
                  }
                }
              }
            }
          }
        },

        /**
         * Go to the next step
         */
        nextStep: function() {
          if (this._log) {
            this._processedDvmOrders = 0;
            this._numberOfDvmOrdersToProcess = 1;
            this.run();
          }
        },

        /**
         * Play the log at current step
         */
        play: function() {
          if (this._log) {
            this._startTime = performance.now();
            this._processedDvmOrders = 0;
            this._numberOfDvmOrdersToProcess = this._log.length;
            this.run();
          }
        },

        /**
         * Pause the log execution
         */
        pause: function() {
          this._isPaused = true;
          this.setButtonEnabled(this._playAllButton, true);
          this.setButtonEnabled(this._pauseButton, false);
          this.setButtonEnabled(this._nextStepButton, true);
          this.setButtonEnabled(this._resetButton, true);
          this.addOverlay(false);
        },

        /**
         * FastForward at a given step
         * @see this.setForwardInputValue method
         */
        forward: function() {
          if (this._log) {
            this._processedDvmOrders = 0;
            this._numberOfDvmOrdersToProcess = this._forwardInput.value;
            this.run();
          }
        },

        /**
         * Rework an entry to add some extra info in case of gbcLog
         * @param {Object} entry - log entry to re-format
         * @return {Object} return the modified entry
         * @private
         */
        _handleGBCLog: function(entry) {
          var entryData = entry.data;
          if (entryData) {
            // get category
            var mouseMatch = entryData.provider.match(/\[MOUSE\]/);
            var keyboardMatch = entryData.provider.match(/\[KEYBOARD\]/);
            var uiMatch = entryData.provider.match(/\[UI\]/);
            var outstr = "";

            // Anything MOUSE related
            if (mouseMatch) {
              var x = entryData.clientX - 16; // 16px is the half of the cursor image
              var y = entryData.clientY + this._headerElement.clientHeight - 16;

              var action = entryData.click ? "click" : "move";
              action = entryData.rightClick ? "rightClick" : action;

              outstr = action + ' at x:' + x + ' y:' + y;
              console.log('%c ' + outstr + ' on', 'color: #007da0', entryData.itemId, entryData.itemElement);

              var clickDelay = action === "click" ? entry.delay : 100;
              entry.delay = action === "move" ? 0 : entry.delay;

              this.setDebugMouse(x, y, action, clickDelay);
              // Anything KEYBOARD related
            } else if (keyboardMatch) {
              outstr = 'Keyboard key pressed: ';
              console.log('%c ' + outstr, 'color: #007da0', entryData.eventKey || entryData.bufferedKey);
              if (entryData.bufferedKey && entryData.eventKey && entryData.type === "onKeyDown") {
                this.setDebugKeyboardKey(entryData.bufferedKey);
              }
              // Anything UI related
            } else if (uiMatch) {
              if (entryData.type === "sidebar") {
                if (entryData.status) {
                  gbc.HostService.getApplicationHostWidget().showSidebar();
                } else {
                  gbc.HostService.getApplicationHostWidget().hideSidebar();
                }
              } else if (entryData.type === "dropdown") {
                if (entryData.name === "ChromeRightBarWidget") {
                  console.log("chromebar open");
                  var rb = gbc.SessionService.getCurrent().getCurrentApplication().getChromeBar().getRightBarWidget();
                  if (entryData.status) {
                    rb.show();
                  } else {
                    rb.hide();
                  }
                } else if (entryData.name === "ContextMenuWidget") {
                  if (entryData.data.parentName === "TableColumnTitleWidget") {
                    var tbColumn = window.gbcWidget(entryData.data.auiTag);
                    var titleWidget = tbColumn.getTitleWidget();
                    if (entryData.status) {
                      titleWidget.showContextMenu(entryData.data.x);
                    } else if (titleWidget._contextMenu) {
                      titleWidget._contextMenu.hide();
                    }
                  }
                }
              }
            }
          }
          if (entry.content && entry.content.substr(0, 4) === "om 0") {
            entry.dimension = this._gbcBrowserInfo.dimension;
          }
          return entry;
        },

        /**
         * Run the Log player
         */
        run: function() {
          this.addOverlay(true);
          // Set the control button accordingly
          if (!this._isPaused) {
            this.setButtonEnabled(this._resetButton, false);
          }
          this.setButtonEnabled(this._nextStepButton, this._isPaused);
          this.setButtonEnabled(this._playAllButton, this._isPaused);
          this.setButtonEnabled(this._pauseButton, !this._isPaused);
          this.setButtonEnabled(this._forwardButton, false);

          // Prevent file upload while processing
          this.setButtonEnabled(this._fileInput, false);

          // While there are instruction to process
          while (this._currentLogLine < this._log.length) {
            if (this._isPaused) {
              this._isPaused = false;
              return;
            }
            var entry = this._log[this._currentLogLine];
            ++this._currentLogLine;
            var isDvm = entry.sender === 'DVM' && entry.content.substr(0, 5) !== 'meta ';
            if (this._currentLogType === "gbcLog") {
              entry = this._handleGBCLog(entry);
            }
            // Handle delay from log if option is activated
            if (!this._delayFromLogWidget.getValue()) {
              entry.delay = isDvm ? parseInt(this._delayInput.value, 10) : 5;
            }

            if (entry.content) {
              this.addLog(entry.app + ':' + entry.sender, entry.content, isDvm);
              if (isDvm) {
                this.setForwardInputValue(this._currentDvmOrder);
                ++this._processedDvmOrders;
                ++this._currentDvmOrder;

                var callback = null;
                if (this._processedDvmOrders < this._numberOfDvmOrdersToProcess && this._currentLogLine < this._log.length) {
                  callback = this._delayRunner(entry.delay);
                } else {
                  callback = this._setPlayerEnabled.bind(this);
                  this.emit(context.constants.widgetEvents.logForwardDone);
                }
                var app = context.LogPlayerService.getApplication(0, entry.app);
                context.LogPlayerService.setVisibleApplication(app);
                app.dvm.manageAuiOrders(entry.content, callback);
                // Entry provides a dimension: use it to change the app width!
                if (entry.dimension) {
                  document.querySelector(".gbc_ApplicationWidget").style.width = entry.dimension.width + "px";
                  document.querySelector(".gbc_ApplicationWidget").style.height = entry.dimension.height + "px";
                  document.querySelector(".gbc_SessionWidget").style.overflow = "auto"; // allow scrolling
                }
                this.emit(context.constants.widgetEvents.logStepDone, this._processedDvmOrders);
                break;
              } else if (entry.close) {
                var closeApp = context.LogPlayerService.getApplication(0, entry.app);
                if (closeApp) {
                  closeApp.setEnding();
                  closeApp.stop();
                  context.LogPlayerService.removeApplication(0, entry.app);
                }
              } else {
                this._delayRunner(entry.delay)();
                break;
              }
            } else {
              this._delayRunner(entry.delay)();
              break; // no entry
            }
          }

          // Update the statistics widget
          if (this._statsCheckWidget.getValue()) {
            var elementNumber = document.getElementsByTagName('*').length;
            if (this._maxNumberOfElements === null || elementNumber > this._maxNumberOfElements) {
              this._maxNumberOfElements = elementNumber;
            }
            var widgetNumber = gbc.WidgetService.getAllWidgetsCount();
            if (this._maxNumberOfWidgets === null || widgetNumber > this._maxNumberOfWidgets) {
              this._maxNumberOfWidgets = widgetNumber;
            }
          }

          // End of the log
          if (this._currentLogLine >= this._log.length) {
            // Generate the log report
            var reportTime = "";
            if (this._startTime !== null) {
              var t1 = performance.now();
              reportTime = "Duration: " + parseInt(t1 - this._startTime) + " milliseconds.";
              this.addLog(" ", reportTime);
              this._startTime = null;
            }
            var reportDOM = "";
            if (this._maxNumberOfElements !== null) {
              reportDOM = "Max number of DOM elements: " + this._maxNumberOfElements;
              this.addLog(" ", reportDOM);
              this._maxNumberOfElements = null;
            }
            var reportWidget = "";
            if (this._maxNumberOfWidgets !== null) {
              reportWidget = "Max number of widgets: " + this._maxNumberOfWidgets;
              this.addLog(" ", reportDOM);
              this._maxNumberOfWidgets = null;
            }
            if (!gbc.qaMode && (reportDOM !== "" || reportTime !== "")) {
              gbc.alert(reportTime + "\n" + reportDOM + "\n" + reportWidget, "LogPlayer", function() {
                this.addOverlay(false);
              }.bind(this));

              if (this._logInfoWidget) {
                this._logInfoWidget.setHidden(true);
              }

            }

            // End of log, set the button accordingly
            this.setButtonEnabled(this._resetButton, true);
            this.setButtonEnabled(this._nextStepButton, false);
            this.setButtonEnabled(this._playAllButton, false);
            this.setButtonEnabled(this._pauseButton, false);
            this.setButtonEnabled(this._forwardButton, false);
            this.setButtonEnabled(this._fileInput, true);
            this.log = [];

            context.SessionService.getCurrent().closeSession();
            this.addLog(" ", '<b>== LOG FINISHED ==</b>');
            context.LogPlayerService.cleanApplications();
            this._cleanDebugHelper();
            this.emit(context.constants.widgetEvents.ready);
          }
        },

        /**
         * Wrapper to delay the logPlayer instructions
         * @param {Number} delay - in ms
         * @return {function} callback
         * @private
         */
        _delayRunner: function(delay) {
          return function() {
            this._registerTimeout(function() {
              this.run();
            }.bind(this), delay || this._delayInput.value);
          }.bind(this);
        },

        /**
         * Set player enabled
         * @private
         */
        _setPlayerEnabled: function() {
          this.setButtonEnabled(this._resetButton, true);
          this.setButtonEnabled(this._nextStepButton, true);
          this.setButtonEnabled(this._playAllButton, true);
          this.setButtonEnabled(this._pauseButton, false);
          this.setButtonEnabled(this._forwardButton, true);
          this.setButtonEnabled(this._fileInput, false);
        },

        /**
         * Display a log in the console
         * @param context
         * @param content
         * @param withOrderNumber
         */
        addLog: function(context, content, withOrderNumber) {
          var orderNr = withOrderNumber ? this._currentDvmOrder : ' ';
          console.log("LOGPLAYER", orderNr, context, content);
        },

        /**
         * Change the state of a given button
         * @param {Element} button - button element to change
         * @param {Boolean} enabled - true to activate the button, false otherwise
         */
        setButtonEnabled: function(button, enabled) {
          if (enabled) {
            button.removeClass("disabled");
            button.removeAttribute("disabled");
            if (button === this._fileInput) {
              this._fileInput.querySelector("input").removeAttribute("disabled");
            }
          } else {
            button.addClass("disabled");
            button.setAttribute("disabled", "disabled");
            if (button === this._fileInput) {
              this._fileInput.querySelector("input").setAttribute("disabled", "disabled");
            }
          }
        },

        /**
         * Detaches the huge uaproxy log string from chunks we really need for memory optimi
         * @param {string} s
         * @return {string}
         */
        detachString: function(s) {
          return (' ' + s).slice(1);
        },

        /**
         * Method to put a visual mouse pointer at a given position
         * @param {Number|Boolean} x - horizontal position or false to hide it
         * @param {Number?} y - vertical position
         * @param {String?} action - click or move
         * @param {Number?} clickDelay - delay the click effect (in ms)
         */
        setDebugMouse: function(x, y, action, clickDelay) {
          if (this._showHelpersWidget.getValue()) {
            this._cleanDebugHelper();
            if (x && y) {
              this._debugCursorElement.removeClass("hidden");
              if (action === "move") {
                this._debugCursorElement.style.top = y + "px";
                this._debugCursorElement.style.left = x + "px";
              }
              if (action.toLowerCase().indexOf("click") >= 0) {
                this._mousePressedElement.removeClass("hidden");
                var left = this._mousePressedElement.querySelector(".key-left");
                var right = this._mousePressedElement.querySelector(".key-right");

                this._registerTimeout(function() {
                  this._debugCursorElement.addClass("highlight");
                  if (action === "click") {
                    left.addClasses("pressed");
                  } else if (action === "rightClick") {
                    right.addClasses("pressed");
                  }
                  this._registerTimeout(function() {
                    this._debugCursorElement.removeClass("highlight");
                    left.removeClass("pressed");
                    right.removeClass("pressed");
                  }.bind(this), 500);
                }.bind(this), clickDelay);
              }
            } else {
              this._mousePressedElement.addClass("hidden");
              this._debugCursorElement.addClass("hidden");
            }
          }
        },

        /**
         * Method to add a visual info about pressed key
         * @param {String} key - key to display
         */
        setDebugKeyboardKey: function(key) {
          if (this._showHelpersWidget.getValue()) {
            this._cleanDebugHelper();
            this._keyPressedElement.removeClass("hidden");
            var keyletter = this._keyPressedElement.querySelector(".key-letter");
            var keymod = this._keyPressedElement.querySelector(".key-modifier");

            var keyMatch = key.match(/(ctrl|alt|mod|shift)*\+*(.*)/);

            if (keyMatch[1]) { // has modifier
              keymod.innerHTML = "<span>" + keyMatch[1] + "</span>";
              keymod.addClass("pressed");
              keymod.removeClass("hidden");
              key = keyMatch[2];
            } else {
              key = keyMatch[2];
              keymod.addClass("hidden");
            }
            switch (key) {
              case "up":
                key = "";
                break;
              case "down":
                key = "";
                break;
              case "left":
                key = "";
                break;
              case "right":
                key = "";
                break;
              default:
                break;
            }

            keyletter.innerHTML = "<span>" + key + "</span>";
            keyletter.addClass("pressed");

            this._registerTimeout(function() {
              keymod.removeClass("pressed");
              keyletter.removeClass("pressed");
            }, 500);
          }
        },

        /**
         * Clear screen of mouse and keyboard info
         * @private
         */
        _cleanDebugHelper: function() {
          this._keyPressedElement.addClass("hidden");
          this._debugCursorElement.addClass("hidden");
          this._mousePressedElement.addClass("hidden");
        },

        /**
         * Add / remove an overlay to prevent any user interaction while playing a log
         * @param {Boolean} overlay - true to prevent user interaction, false otherwise
         * @param {Boolean} [force] - true to force the given value without check
         */
        addOverlay: function(overlay, force) {
          // Only if overlay status is not forced
          if (!force) {
            if (this._userInteractionWidget) {
              overlay = !this._userInteractionWidget.getValue();
            } else {
              overlay = true;
            }
          }
          gbc.OverlayService.setCursor("logplayer", "not-allowed");

          if (overlay) {
            this.addClass("running");
            gbc.OverlayService.enable("logplayer", this.getContainerElement());
          } else {
            this.removeClass("running");
            gbc.OverlayService.disable("logplayer");
          }
        }

      };
    });
    cls.WidgetFactory.registerBuilder('LogPlayer', cls.LogPlayerWidget);
  });
;
"use strict";

modulum('LogRecorderWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class LogPlayerWidget
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.LogRecorderWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.LogRecorderWidget.prototype */ {
        __name: "LogRecorderWidget",

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          this.setTitle(i18next.t('gwc.main.chromebar.getRecordedLog'));
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(dom) {
          gbc.LogService.download();
          return true;
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          $super.destroy.call(this);
        },

      };
    });
    cls.WidgetFactory.registerBuilder('LogRecorder', cls.LogRecorderWidget);
  });
;
"use strict";

modulum('LogTypesSelectorWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class LogTypesSelectorWidget
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.LogTypesSelectorWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.LogTypesSelectorWidget.prototype */ {
        __name: "LogTypesSelectorWidget",

        /**
         * @type {Array<{name:string, label:string}>}
         */
        _types: null,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          this.setTypes(context.LogService.getTypes());
          this.setCurrentTypes(context.LogService.getActiveLogTypes());
          this._element.on("click", function(evt) {
            if (evt.target.dataset.logtype) {
              this.emit("logtype", evt.target.dataset.logtype);
            }
          }.bind(this));
        },

        /**
         *
         * @param {Array<{name:string, label:string}>} types
         */
        setTypes: function(types) {
          this._types = types;
          this._element.empty();
          for (var i = 0; i < types.length; i++) {
            this._element.innerHTML += '<div data-logtype="' + types[i].name + '" class="active">' + types[i].label + '</div>';
          }
        },
        /**
         *
         * @param {Array<string>} types name of activated loggers
         */
        setCurrentTypes: function(types) {
          var matcher = function(val) {
            return function(i) {
              return i === val;
            };
          };
          for (var i = 0; i < this._types.length; i++) {
            var val = this._types[i].name,
              item = this._element.querySelector('[data-logtype="' + val + '"]');
            if (item) {
              item.toggleClass("active", !types || !!types.find(matcher(val)));
            }
          }
        }
      };
    });
    cls.WidgetFactory.registerBuilder('LogTypesSelector', cls.LogTypesSelectorWidget);
  });
;
"use strict";

modulum('MainContainerWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class MainContainerWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     */
    cls.MainContainerWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.MainContainerWidget.prototype */ {
        __name: "MainContainerWidget",

        _initElement: function() {
          this._ignoreLayout = true;
          $super._initElement.call(this);
        },

        _initLayout: function() {
          // no layout
        }
      };
    });
    cls.WidgetFactory.registerBuilder('MainContainer', cls.MainContainerWidget);
  });
;
"use strict";

modulum('ApplicationHostMenuAboutWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class ApplicationHostMenuAboutWidget
     * @deprecated This is only used if "theme-legacy-topbar" theme variable is on
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.ApplicationHostMenuAboutWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.ApplicationHostMenuAboutWidget.prototype */ {
        __name: "ApplicationHostMenuAboutWidget",

        /** @type {classes.ApplicationHostAboutWidget} */
        _aboutModal: null,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          this._ignoreLayout = true;
          $super._initElement.call(this);
          this._element.setAttribute('title', "GBC " + context.version);
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          // no layout
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._aboutModal) {
            this._aboutModal.destroy();
            this._aboutModal = null;
          }
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          if (this._aboutModal === null) {
            this._aboutModal = cls.WidgetFactory.createWidget('ApplicationHostAbout', this.getBuildParameters());
            document.body.appendChild(this._aboutModal.getElement());
            this._aboutModal.when(context.constants.widgetEvents.close, function() {
              this._aboutModal.destroy();
              this._aboutModal = null;
            }.bind(this), true);
          }
          this._aboutModal.show();

          return false;
        }
      };
    });
    cls.WidgetFactory.registerBuilder('ApplicationHostAboutMenu', cls.ApplicationHostMenuAboutWidget);
  });
;
"use strict";

modulum('ApplicationHostMenuBookmarkWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class ApplicationHostMenuBookmarkWidget
     * @deprecated This is only used if "theme-legacy-topbar" theme variable is on
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.ApplicationHostMenuBookmarkWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.ApplicationHostMenuBookmarkWidget.prototype */ {
        __name: "ApplicationHostMenuBookmarkWidget",

        /** @type boolean */
        _activated: false,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          this._ignoreLayout = true;
          $super._initElement.call(this);
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          // no layout
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          var url = context.UrlService.currentUrl();
          this.setActivated(!this._activated);
          context.BookmarkService.switchBookmark(gbc.SessionService.getCurrent().getAppId(), url.toString());
          return false;
        },

        setActivated: function(activated) {
          this._activated = activated;
          var i = this._element.getElementsByTagName("i")[0];
          i.toggleClass("zmdi-bookmark", !!activated)
            .toggleClass("zmdi-bookmark-outline", !activated);
        }
      };
    });
    cls.WidgetFactory.registerBuilder('ApplicationBookmarkHostMenu', cls.ApplicationHostMenuBookmarkWidget);
  });
;
"use strict";

modulum('ApplicationHostMenuDebugWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class ApplicationHostMenuDebugWidget
     * @deprecated This is only used if "theme-legacy-topbar" theme variable is on
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.ApplicationHostMenuDebugWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.ApplicationHostMenuDebugWidget.prototype */ {
        __name: "ApplicationHostMenuDebugWidget",

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          context.DebugService.registerDebugUi(this);
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          this._ignoreLayout = true;
          $super._initElement.call(this);
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          // no layout
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          context.DebugService.unregisterDebugUi(this);
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          context.DebugService.show();
          return false;
        },

        activate: function(active) {
          this._element.toggleClass("debugActivated", active);
        }
      };
    });
    cls.WidgetFactory.registerBuilder('ApplicationHostDebugMenu', cls.ApplicationHostMenuDebugWidget);
  });
;
"use strict";

modulum('ApplicationHostMenuProxyLogWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class ApplicationHostMenuProxyLogWidget
     * @deprecated This is only used if "theme-legacy-topbar" theme variable is on
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.ApplicationHostMenuProxyLogWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.ApplicationHostMenuProxyLogWidget.prototype */ {
        __name: "ApplicationHostMenuProxyLogWidget",

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          context.DebugService.registerDebugUi(this);
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          this._ignoreLayout = true;
          $super._initElement.call(this);
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          // no layout
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          context.DebugService.unregisterDebugUi(this);
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          var session = context.SessionService.getCurrent();
          var connector = session.getConnector();
          var sessionId = session.getSessionId();
          window.open(connector + "/monitor/log/uaproxy-" + sessionId);
          return false;
        },

        activate: function(active) {
          this._element.toggleClass("debugActivated", active);
        }
      };
    });
    cls.WidgetFactory.registerBuilder('ApplicationHostMenuProxyLog', cls.ApplicationHostMenuProxyLogWidget);
  });
;
"use strict";

modulum('ApplicationHostMenuRunInGdcWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class ApplicationHostMenuRunInGdcWidget
     * @deprecated This is only used if "theme-legacy-topbar" theme variable is on
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.ApplicationHostMenuRunInGdcWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.ApplicationHostMenuRunInGdcWidget.prototype */ {
        __name: "ApplicationHostMenuRunInGdcWidget",

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          context.DebugService.registerDebugUi(this);
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          this._ignoreLayout = true;
          $super._initElement.call(this);
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          // no layout
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          context.DebugService.unregisterDebugUi(this);
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          var name = window.location.pathname.substr(window.location.pathname.lastIndexOf('/') + 1);
          var shortcut = '<?xml version="1.0" encoding="utf-8"?>\n' +
            '<fjs configVersion="2" product="Genero Desktop Client">\n' +
            ' <Shortcuts>\n' +
            '  <Shortcut ' +
            'name="' + name + '" ' +
            'authenticationMode="standard" ' +
            'type="http" ' +
            'proxyType="monitor" ' +
            'url="' + window.location.href + '" ' +
            '/>\n' +
            ' </Shortcuts>\n' +
            '</fjs>';

          var shortcutFile = new Blob([shortcut], {
            type: "application/genero-gdc"
          });
          //for microsoft IE
          var fileName = name + ".gdc";
          if (window.navigator && window.navigator.msSaveOrOpenBlob) {
            window.navigator.msSaveOrOpenBlob(shortcutFile, fileName);
          } else { //other browsers
            var a = document.createElement("a");
            a.style.display = "none";
            // firefox needs to have element in DOM
            document.body.appendChild(a);
            a.href = window.URL.createObjectURL(shortcutFile);
            a.download = fileName;
            a.click();
            document.body.removeChild(a);
          }

          return false;
        },

        activate: function(active) {
          this._element.toggleClass("debugActivated", active);
        }
      };
    });
    cls.WidgetFactory.registerBuilder('ApplicationHostMenuRunInGdc', cls.ApplicationHostMenuRunInGdcWidget);
  });
;
"use strict";

modulum('ApplicationHostMenuRunInGwcWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class ApplicationHostMenuRunInGwcWidget
     * @deprecated This is not used anymore, and will be removed soon
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.ApplicationHostMenuRunInGwcWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.ApplicationHostMenuRunInGwcWidget.prototype */ {
        __name: "ApplicationHostMenuRunInGwcWidget",

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          context.DebugService.registerDebugUi(this);
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          this._ignoreLayout = true;
          $super._initElement.call(this);
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          // no layout
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          context.DebugService.unregisterDebugUi(this);
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          window.open(window.location.href.replace("/ua/r/", "/wa/r/"));
          return false;
        },

        activate: function(active) {
          var session = context.SessionService.getCurrent(),
            sessionInfo = session && session.info(),
            sessionServerVersion = sessionInfo && sessionInfo.serverVersion;
          if (cls.ServerHelper.compare(sessionServerVersion || context.bootstrapInfo.serverVersion, "GAS/3.10.00") < 0) {
            this._element.toggleClass("debugActivated", active);
          }
        }
      };
    });
    cls.WidgetFactory.registerBuilder('ApplicationHostMenuRunInGwc', cls.ApplicationHostMenuRunInGwcWidget);
  });
;
"use strict";

modulum('ApplicationHostMenuRuntimeWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class ApplicationHostMenuRuntimeWidget
     * @deprecated This is only used if "theme-legacy-topbar" theme variable is on
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.ApplicationHostMenuRuntimeWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.ApplicationHostMenuRuntimeWidget.prototype */ {
        __name: "ApplicationHostMenuRuntimeWidget",
        _initElement: function() {
          this._ignoreLayout = true;
          $super._initElement.call(this);
          this._element.querySelector('a').title = i18next.t("gwc.app.busy");
        },
        _initLayout: function() {
          // no layout
        },
        setIdle: function() {
          this.removeClass("processing");
        },
        setProcessing: function() {
          this.addClass("processing");
        }
      };
    });
    cls.WidgetFactory.registerBuilder('ApplicationHostMenuRuntime', cls.ApplicationHostMenuRuntimeWidget);
  });
;
"use strict";

modulum('ApplicationHostMenuSettingsWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class ApplicationHostMenuSettingsWidget
     * @deprecated This is only used if "theme-legacy-topbar" theme variable is on
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.ApplicationHostMenuSettingsWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.ApplicationHostMenuSettingsWidget.prototype */ {
        __name: "ApplicationHostMenuSettingsWidget",

        /** @type {classes.ApplicationHostSettingsWidget} */
        _settingsModal: null,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          this._ignoreLayout = true;
          $super._initElement.call(this);
          this._element.setAttribute('title', "Stored settings");

          if (gbc.LocalSettingsService._quotaExceededError) {
            this.addClass("error");
          }
          gbc.LocalSettingsService._eventListener.when("QuotaExceededError", function() {
            this.addClass("error");
          }.bind(this));

        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          // no layout
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._settingsModal) {
            this._settingsModal.destroy();
            this._settingsModal = null;
          }
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          if (this._settingsModal === null) {
            this._settingsModal = cls.WidgetFactory.createWidget('ApplicationHostSettings', this.getBuildParameters());
            document.body.appendChild(this._settingsModal.getElement());
            this._settingsModal.when(context.constants.widgetEvents.close, function() {
              this._settingsModal.destroy();
              this._settingsModal = null;
            }.bind(this), true);
          }
          this._settingsModal.show();
          return false;
        }
      };
    });
    cls.WidgetFactory.registerBuilder('ApplicationHostSettingsMenu', cls.ApplicationHostMenuSettingsWidget);
  });
;
"use strict";

modulum('ApplicationHostMenuUploadsWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class ApplicationHostMenuUploadsWidget
     * @deprecated This is only used if "theme-legacy-topbar" theme variable is on
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.ApplicationHostMenuUploadsWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.ApplicationHostMenuUploadsWidget.prototype */ {
        __name: "ApplicationHostMenuUploadsWidget",
        _count: 0,
        _initElement: function() {
          this._ignoreLayout = true;
          $super._initElement.call(this);
          this._element.querySelector('a').title = i18next.t("gwc.file.upload.processing");
        },
        _initLayout: function() {
          // no layout
        },

        setIdle: function() {
          this._count--;
          if (!this._count) {
            this.removeClass("processing");
          }
        },
        setProcessing: function() {
          this._count++;
          this.addClass("processing");
        }
      };
    });
    cls.WidgetFactory.registerBuilder('ApplicationHostUploadsMenu', cls.ApplicationHostMenuUploadsWidget);
  });
;
"use strict";

modulum('ApplicationHostMenuVmLogWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class ApplicationHostMenuVmLogWidget
     * @deprecated This is only used if "theme-legacy-topbar" theme variable is on
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.ApplicationHostMenuVmLogWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.ApplicationHostMenuVmLogWidget.prototype */ {
        __name: "ApplicationHostMenuVmLogWidget",

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          context.DebugService.registerDebugUi(this);
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          this._ignoreLayout = true;
          $super._initElement.call(this);
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          // no layout
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          context.DebugService.unregisterDebugUi(this);
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          var session = context.SessionService.getCurrent();
          var connector = session.getConnector();
          var sessionId = session.getSessionId();
          window.open(connector + "/monitor/log/vm-" + sessionId);
          return false;
        },

        activate: function(active) {
          this._element.toggleClass("debugActivated", active);
        }
      };
    });
    cls.WidgetFactory.registerBuilder('ApplicationHostMenuVmLog', cls.ApplicationHostMenuVmLogWidget);
  });
;
"use strict";

modulum('ApplicationHostMenuWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class ApplicationHostMenuWidget
     * @deprecated This is only used if "theme-legacy-topbar" theme variable is on
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     */
    cls.ApplicationHostMenuWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.ApplicationHostMenuWidget.prototype */ {
        __name: "ApplicationHostMenuWidget",
        _windowIconImage: null,
        _hasWindowIcon: false,
        /** @type {Element} */
        _titleElement: null,
        _defaultTitle: "Genero Browser Client",
        /** @type {Element} */
        _sidebarToggle: null,
        _aboutMenu: null,
        _debugMenu: null,
        _settingsMenu: null,
        _runtimeStatus: null,
        _uploadStatus: null,
        _bookmarkWidget: null,
        _closeWidget: null,

        /** @type {Element} */
        _toggleSettings: null,
        _sidebarBackdrop: null,
        _barsContainerZindex: 0,

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          this._createMenuItems();
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          this._ignoreLayout = true;
          $super._initElement.call(this);
          this._sidebarToggle = this._element.getElementsByClassName("mt-sidebar-toggle")[0];
          if (!this._titleElement) {
            this._titleElement = this._element.getElementsByClassName("currentDisplayedWindow")[0];
            this.setText();
          }

          this._toggleSettings = this._element.querySelector(".mt-sidebar-action-toggle");
          if (this._toggleSettings) {
            this._element.querySelector(".mt-actions").onSwipe("MenuWidgetSettings", this._closeSettingsBar.bind(this), {
              direction: ["right"]
            });
          }
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          // no layout
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._destroyMenuItems();

          if (this._toggleSettings) {
            this._element.querySelector(".mt-actions").offSwipe("MenuWidgetSettings");
          }

          if (this._windowIconImage) {
            this._windowIconImage.destroy();
            this._windowIconImage = null;
          }
          this._sidebarToggle = null;
          this._toggleSettings = null;
          this._sidebarBackdrop = null;
          this._titleElement = null;

          $super.destroy.call(this);
        },

        _createMenuItems: function() {
          this._uploadStatus = cls.WidgetFactory.createWidget('ApplicationHostUploadsMenu', this.getBuildParameters());
          this.addChildWidget(this._uploadStatus);
          this._runtimeStatus = cls.WidgetFactory.createWidget('ApplicationHostMenuRuntime', this.getBuildParameters());
          this.addChildWidget(this._runtimeStatus);
          this._aboutMenu = cls.WidgetFactory.createWidget('ApplicationHostAboutMenu', this.getBuildParameters());
          this.addChildWidget(this._aboutMenu);
          this._settingsMenu = cls.WidgetFactory.createWidget('ApplicationHostSettingsMenu', this.getBuildParameters());
          this.addChildWidget(this._settingsMenu);
          //debug
          this._proxyLogMenu = cls.WidgetFactory.createWidget('ApplicationHostMenuProxyLog', this.getBuildParameters());
          this.addChildWidget(this._proxyLogMenu);
          this._vmLogMenu = cls.WidgetFactory.createWidget('ApplicationHostMenuVmLog', this.getBuildParameters());
          this.addChildWidget(this._vmLogMenu);
          this._runInGwcMenu = cls.WidgetFactory.createWidget('ApplicationHostMenuRunInGwc', this.getBuildParameters());
          this.addChildWidget(this._runInGwcMenu);
          this._runInGdcMenu = cls.WidgetFactory.createWidget('ApplicationHostMenuRunInGdc', this.getBuildParameters());
          this.addChildWidget(this._runInGdcMenu);
          this._debugMenu = cls.WidgetFactory.createWidget('ApplicationHostDebugMenu', this.getBuildParameters());
          this.addChildWidget(this._debugMenu);
        },

        _destroyMenuItems: function() {
          this._destroyMenuItem(this._runtimeStatus);
          this._runtimeStatus = null;
          this._destroyMenuItem(this._proxyLogMenu);
          this._proxyLogMenu = null;
          this._destroyMenuItem(this._vmLogMenu);
          this._vmLogMenu = null;
          this._destroyMenuItem(this._runInGwcMenu);
          this._runInGwcMenu = null;
          this._destroyMenuItem(this._runInGdcMenu);
          this._runInGdcMenu = null;
          this._destroyMenuItem(this._aboutMenu);
          this._aboutMenu = null;
          this._destroyMenuItem(this._debugMenu);
          this._debugMenu = null;
          this._destroyMenuItem(this._settingsMenu);
          this._settingsMenu = null;
          this._destroyMenuItem(this._uploadStatus);
          this._uploadStatus = null;

          this._destroyMenuItem(this._bookmarkWidget);
          this._bookmarkWidget = null;
          this._destroyMenuItem(this._closeWidget);
          this._closeWidget = null;
        },

        _destroyMenuItem: function(item) {
          if (item) {
            this.removeChildWidget(item);
            item.destroy();
          }
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          var target = domEvent.target;
          if (target.isElementOrChildOf(this._sidebarToggle)) {
            this.emit(context.constants.widgetEvents.toggleClick);
          } else if (target.isElementOrChildOf(this._toggleSettings) || target.isElementOrChildOf(this._sidebarBackdrop)) {
            this._toggleSettingsBar();
          }

          return true;
        },

        /**
         * Set the Bar in UR mode (no debug display, no close button)
         * @param {Boolean} isUR - true to enable this mode
         */
        setURBar: function(isUR) {
          if (isUR) {
            this._proxyLogMenu.setHidden(true);
            this._vmLogMenu.setHidden(true);
            this._runInGwcMenu.setHidden(true);
            this._runInGdcMenu.setHidden(true);
            this._debugMenu.setHidden(true);
          }
        },

        /**
         * Create a reference to the BookmarkWidget
         * @param {classes.ApplicationHostMenuBookmarkWidget} widget
         */
        setBookmarkWidget: function(widget) {
          this._bookmarkWidget = widget;
          if (context.__wrapper.isNative()) {
            this._bookmarkWidget.setHidden(true);
          }
        },

        /**
         * Create a reference to the CloseWidget
         * @param {classes.ApplicationHostMenuWindowCloseWidget} widget
         */
        setCloseWidget: function(widget) {
          this._closeWidget = widget;
          if (context.__wrapper.isNative()) {
            this._closeWidget.setHidden(true);
          }
        },

        _toggleSettingsBar: function() {
          // TODO why we don't use ApplicationHostSidebarBackdropWidget ???? like left sidebar ?
          this._sidebarBackdrop = this._element.querySelector(".mt-sidebar-backdrop");
          var barsContainer = this._parentWidget._element.querySelector(".gbc_barsContainer");
          if (this._toggleSettings.hasClass("open")) {
            this._toggleSettings.removeClass("open");
            this._sidebarBackdrop.removeClass("mt-sidebar-displayed");
            this._element.querySelector(".mt-actions").removeClass("open");
            if (barsContainer) {
              barsContainer.style["z-index"] = this._barsContainerZindex;
            }
          } else if (this._element.querySelector(".mt-actions")) {
            this._toggleSettings.addClass("open");
            this._element.querySelector(".mt-actions").addClass("open");
            this._barsContainerZindex = barsContainer ? barsContainer.style["z-index"] : 0;
            if (barsContainer) {
              barsContainer.style["z-index"] = "0";
            }
            this._sidebarBackdrop.addClass("mt-sidebar-displayed");
          }
        },

        _closeSettingsBar: function() {
          if (this._toggleSettings.hasClass("open")) {
            this._toggleSettings.removeClass("open");
            this._element.querySelector(".mt-actions").removeClass("open");
            this._sidebarBackdrop.removeClass("mt-sidebar-displayed");
          }
        },

        setSidebarUnavailable: function(unavailable) {
          this._sidebarToggle.toggleClass("mt-sidebar-unavailable", !!unavailable);
        },

        setText: function(title) {
          this._setElementAttribute("innerHTML", title || this._defaultTitle, "_titleElement");
        },

        setIcon: function(image, appIcon) {
          if (image && image !== "") {
            if (!appIcon) { // set global icon using app icon only if not previously set with window icon
              this._hasWindowIcon = true;
            } else if (this._hasWindowIcon === true) {
              return;
            }
            this._element.getElementsByClassName('zmdi')[0].addClass('hidden');
            if (!this._windowIconImage) {
              this._windowIconImage = cls.WidgetFactory.createWidget("ImageWidget", this.getBuildParameters());
              this._sidebarToggle.appendChild(this._windowIconImage.getElement());
            }
            this._windowIconImage.setSrc(image);
            this._windowIconImage.setAlignment("verticalCenter", "horizontalCenter");
            this._windowIconImage.setHidden(false);
          } else {
            this._element.getElementsByClassName('zmdi')[0].removeClass('hidden');
            if (this._windowIconImage) {
              this._windowIconImage.setHidden(true);
            }
          }
        }
      };
    });
    cls.WidgetFactory.registerBuilder('ApplicationHostMenu', cls.ApplicationHostMenuWidget);
  });
;
"use strict";

modulum('ApplicationHostMenuWindowCloseWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class ApplicationHostMenuWindowCloseWidget
     * @deprecated This is only used if "theme-legacy-topbar" theme variable is on
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.ApplicationHostMenuWindowCloseWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.ApplicationHostMenuWindowCloseWidget.prototype */ {
        __name: "ApplicationHostMenuWindowCloseWidget",

        /** @type boolean */
        _activated: false,
        /** @type boolean */
        _processing: false,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          this._ignoreLayout = true;
          $super._initElement.call(this);
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          // no layout
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          if (!this._processing && this._active && this.isVisible()) {
            this.emit(context.constants.widgetEvents.click);
          }
          return false;
        },

        setActive: function(active) {
          this._active = active;
          if (!context.__wrapper.isNative()) {
            this._element.toggleClass("gbc_Invisible", !active);
          } else {
            this._element.addClass("gbc_Invisible");
          }
        },

        onClick: function(hook) {
          return this.when(context.constants.widgetEvents.click, hook);
        },

        _setProcessingStyle: function(processing) {
          this._processing = !!processing;
          if (this._element) {
            if (processing) {
              this._element.setAttribute("processing", "processing");
            } else {
              this._element.removeAttribute("processing");
            }
          }
        }
      };
    });
    cls.WidgetFactory.registerBuilder('ApplicationHostWindowCloseMenu', cls.ApplicationHostMenuWindowCloseWidget);
  });
;
"use strict";

modulum('MonitorDebugLayoutInfoWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class MonitorDebugLayoutInfoWidget
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.MonitorDebugLayoutInfoWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.MonitorDebugLayoutInfoWidget.prototype */ {
        __name: "MonitorDebugLayoutInfoWidget",
        _layoutEngineName: null,
        _posX: null,
        _posY: null,
        _gridWidth: null,
        _gridHeight: null,
        _width: null,
        _height: null,
        _measuredHasSize: null,
        _measuredWidth: null,
        _measuredHeight: null,
        _minimalHasSize: null,
        _minimalWidth: null,
        _minimalHeight: null,
        _maximalHasSize: null,
        _maximalWidth: null,
        _maximalHeight: null,
        _availableHasSize: null,
        _availableWidth: null,
        _availableHeight: null,
        _allocatedHasSize: null,
        _allocatedWidth: null,
        _allocatedHeight: null,
        _preferredHasSize: null,
        _preferredWidth: null,
        _preferredHeight: null,
        _decoratingHasSize: null,
        _decoratingWidth: null,
        _decoratingHeight: null,
        _decoratingoffsetHasSize: null,
        _decoratingoffsetWidth: null,
        _decoratingoffsetHeight: null,
        _stretchX: null,
        _stretchY: null,
        _childrenStretchX: null,
        _childrenStretchY: null,
        _invalidatedMeasure: null,
        _invalidatedAllocatedSpace: null,
        _initElement: function() {
          $super._initElement.call(this);
          this._layoutEngineName = this._element.getElementsByClassName("value_layoutEngineName")[0];
          this._posX = this._element.getElementsByClassName("value_posX")[0];
          this._posY = this._element.getElementsByClassName("value_posY")[0];
          this._gridWidth = this._element.getElementsByClassName("value_gridWidth")[0];
          this._gridHeight = this._element.getElementsByClassName("value_gridHeight")[0];
          this._width = this._element.getElementsByClassName("value_width")[0];
          this._height = this._element.getElementsByClassName("value_height")[0];
          this._measuredHasSize = this._element.getElementsByClassName("value_measured_hasSize")[0];
          this._measuredWidth = this._element.getElementsByClassName("value_measured_width")[0];
          this._measuredHeight = this._element.getElementsByClassName("value_measured_height")[0];
          this._minimalHasSize = this._element.getElementsByClassName("value_minimal_hasSize")[0];
          this._minimalWidth = this._element.getElementsByClassName("value_minimal_width")[0];
          this._minimalHeight = this._element.getElementsByClassName("value_minimal_height")[0];
          this._maximalHasSize = this._element.getElementsByClassName("value_maximal_hasSize")[0];
          this._maximalWidth = this._element.getElementsByClassName("value_maximal_width")[0];
          this._maximalHeight = this._element.getElementsByClassName("value_maximal_height")[0];
          this._availableHasSize = this._element.getElementsByClassName("value_available_hasSize")[0];
          this._availableWidth = this._element.getElementsByClassName("value_available_width")[0];
          this._availableHeight = this._element.getElementsByClassName("value_available_height")[0];
          this._allocatedHasSize = this._element.getElementsByClassName("value_allocated_hasSize")[0];
          this._allocatedWidth = this._element.getElementsByClassName("value_allocated_width")[0];
          this._allocatedHeight = this._element.getElementsByClassName("value_allocated_height")[0];
          this._preferredHasSize = this._element.getElementsByClassName("value_preferred_hasSize")[0];
          this._preferredWidth = this._element.getElementsByClassName("value_preferred_width")[0];
          this._preferredHeight = this._element.getElementsByClassName("value_preferred_height")[0];
          this._decoratingHasSize = this._element.getElementsByClassName("value_decorating_hasSize")[0];
          this._decoratingWidth = this._element.getElementsByClassName("value_decorating_width")[0];
          this._decoratingHeight = this._element.getElementsByClassName("value_decorating_height")[0];
          this._decoratingoffsetHasSize = this._element.getElementsByClassName("value_decoratingoffset_hasSize")[0];
          this._decoratingoffsetWidth = this._element.getElementsByClassName("value_decoratingoffset_width")[0];
          this._decoratingoffsetHeight = this._element.getElementsByClassName("value_decoratingoffset_height")[0];
          this._stretchX = this._element.getElementsByClassName("value_stretch_x")[0];
          this._stretchY = this._element.getElementsByClassName("value_stretch_y")[0];
          this._childrenStretchX = this._element.getElementsByClassName("value_stretch_children_x")[0];
          this._childrenStretchY = this._element.getElementsByClassName("value_stretch_children_y")[0];
          this._invalidatedMeasure = this._element.getElementsByClassName("value_invalidated_measure")[0];
          this._invalidatedAllocatedSpace = this._element.getElementsByClassName("value_invalidated_allocatedspace")[0];

        },
        setLayoutEngineName: function(value) {
          this._layoutEngineName.textContent = value;
        },
        setPosX: function(value) {
          this._posX.textContent = value;
        },
        setPosY: function(value) {
          this._posY.textContent = value;
        },
        setGridWidth: function(value) {
          this._gridWidth.textContent = value;
        },
        setGridHeight: function(value) {
          this._gridHeight.textContent = value;
        },
        setWidth: function(value) {
          this._width.textContent = value;
        },
        setHeight: function(value) {
          this._height.textContent = value;
        },
        setMeasuredHasSize: function(value) {
          this._measuredHasSize.textContent = value;
        },
        setMeasuredWidth: function(value) {
          this._measuredWidth.textContent = value;
        },
        setMeasuredHeight: function(value) {
          this._measuredHeight.textContent = value;
        },
        setMinimalHasSize: function(value) {
          this._minimalHasSize.textContent = value;
        },
        setMinimalWidth: function(value) {
          this._minimalWidth.textContent = value;
        },
        setMinimalHeight: function(value) {
          this._minimalHeight.textContent = value;
        },
        setMaximalHasSize: function(value) {
          this._maximalHasSize.textContent = value;
        },
        setMaximalWidth: function(value) {
          this._maximalWidth.textContent = value;
        },
        setMaximalHeight: function(value) {
          this._maximalHeight.textContent = value;
        },
        setAvailableHasSize: function(value) {
          this._availableHasSize.textContent = value;
        },
        setAvailableWidth: function(value) {
          this._availableWidth.textContent = value;
        },
        setAvailableHeight: function(value) {
          this._availableHeight.textContent = value;
        },
        setAllocatedHasSize: function(value) {
          this._allocatedHasSize.textContent = value;
        },
        setAllocatedWidth: function(value) {
          this._allocatedWidth.textContent = value;
        },
        setAllocatedHeight: function(value) {
          this._allocatedHeight.textContent = value;
        },
        setPreferredHasSize: function(value) {
          this._preferredHasSize.textContent = value;
        },
        setPreferredWidth: function(value) {
          this._preferredWidth.textContent = value;
        },
        setPreferredHeight: function(value) {
          this._preferredHeight.textContent = value;
        },
        setDecoratingHasSize: function(value) {
          this._decoratingHasSize.textContent = value;
        },
        setDecoratingWidth: function(value) {
          this._decoratingWidth.textContent = value;
        },
        setDecoratingHeight: function(value) {
          this._decoratingHeight.textContent = value;
        },
        setDecoratingoffsetHasSize: function(value) {
          this._decoratingoffsetHasSize.textContent = value;
        },
        setDecoratingoffsetWidth: function(value) {
          this._decoratingoffsetWidth.textContent = value;
        },
        setDecoratingoffsetHeight: function(value) {
          this._decoratingoffsetHeight.textContent = value;
        },
        setStretchX: function(value) {
          this._stretchX.textContent = value;
        },
        setStretchY: function(value) {
          this._stretchY.textContent = value;
        },
        setChildrenStretchX: function(value) {
          this._childrenStretchX.textContent = value;
        },
        setChildrenStretchY: function(value) {
          this._childrenStretchY.textContent = value;
        },
        setInvalidatedMeasure: function(value) {
          this._invalidatedMeasure.textContent = value;
        },
        setInvalidatedAllocatedSpace: function(value) {
          this._invalidatedAllocatedSpace.textContent = value;
        },
        /**
         * Remove the layout panel and add a message instead
         */
        setNoLayout: function() {
          this.setLayoutEngineName("No layout information");
          this._element.querySelector(".aui").addClass("hidden");
          this._element.querySelector(".measures").addClass("hidden");
          this._element.querySelector(".stretch").addClass("hidden");
          this._element.querySelector("h6").addClass("hidden");

        }
      };
    });
    cls.WidgetFactory.registerBuilder('MonitorDebugLayoutInfo', cls.MonitorDebugLayoutInfoWidget);
  });
;
"use strict";

modulum('MonitorDebugNodeInfoWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class MonitorDebugNodeInfoWidget
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.MonitorDebugNodeInfoWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.MonitorDebugNodeInfoWidget.prototype */ {
        __name: "MonitorDebugNodeInfoWidget",
        _propertiesContainer: null,
        _initElement: function() {
          $super._initElement.call(this);
          this._propertiesContainer = this._element.querySelector("table>tbody");
          this._element.on("click", "table>thead>tr", this._onClick.bind(this));
        },
        _onClick: function() {
          var table = this._element.childTag("table");
          if (table) {
            var i = 0,
              cats = table.querySelectorAll(".category"),
              len = cats.length;
            for (; i < len; i++) {
              context.DebugService.auiview[".cat_" + cats[i].textContent] = true;
              gbc.DebugService.catClicked(cats[i].textContent, true);
            }
          }
          event.stopPropagation();
        },
        getPropertiesContainer: function() {
          return this._propertiesContainer;
        }
      };
    });
    cls.WidgetFactory.registerBuilder('MonitorDebugNodeInfo', cls.MonitorDebugNodeInfoWidget);
  });
;
"use strict";

modulum('MonitorDebugTreeItemWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class MonitorDebugTreeItemWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     */
    cls.MonitorDebugTreeItemWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.MonitorDebugTreeItemWidget.prototype */ {
        __name: "MonitorDebugTreeItemWidget",
        _container: null,
        _label: null,
        _idRef: null,
        _idRefNumber: null,
        _collapsed: false,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          this._container = this._element.child("description");
          this._label = this._container.child("label");
          this._idRef = this._container.child("idRef");
          this._container
            .on("click.MonitorDebugTreeItemWidget", this._onClick.bind(this))
            .on("dblclick.MonitorDebugTreeItemWidget", this._onDoubleClick.bind(this));
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._container
            .off("click.MonitorDebugTreeItemWidget")
            .off("dblclick.MonitorDebugTreeItemWidget");
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        _onClick: function() {
          this.emit(gbc.constants.widgetEvents.click);
          event.stopPropagation();
        },

        /**
         * @inheritDoc
         */
        _onDoubleClick: function(event) {
          this._toggleCollapsed();
          event.stopPropagation();
        },

        /**
         * Define the label of the item in the tree view
         * @param {string} label - text to display
         */
        setLabel: function(label) {
          this._label.textContent = label;
        },

        /**
         * Define the VM idRef of the item in the tree view
         * @param {string} idRef - idRef to set
         */
        setIdRef: function(idRef) {
          this._idRefNumber = idRef;
          this._idRef.textContent = idRef;
        },

        /**
         * Get the VM idRef of the item
         * @return {null}
         */
        getIdRef: function() {
          return this._idRefNumber;
        },

        /**
         * Define the color of the icon
         * @param {string} color - CSS compliant color
         */
        setIconColor: function(color) {
          this.setStyle('>.description>.icon', {
            "background-color": color
          });
        },

        /**
         * Expand / collapse a tree part
         * @param {boolean} collapsed - true if collapsed, false otherwise
         */
        setCollapsed: function(collapsed) {
          this._toggleCollapsed(!!collapsed);
        },

        /**
         * Expand / collapse a tree part
         * @param {boolean} collapsed - true if collapsed, false otherwise
         * @private
         */
        _toggleCollapsed: function(collapsed) {
          if (collapsed === true) {
            if (!this._collapsed) {
              this._collapsed = true;
              this._containerElement.remove();
            }
          } else if (collapsed === false) {
            if (this._collapsed) {
              this._collapsed = false;
              this._element.appendChild(this._containerElement);
            }
          } else {
            this._collapsed = !this._collapsed;
            if (this._collapsed) {
              this._containerElement.remove();
            } else {
              this._element.appendChild(this._containerElement);
            }
          }
          this._element.toggleClass("collapsed", !!this._collapsed);
        },

        /**
         * Set item as highlighted
         * @param {boolean} highlighted - true if highlighted, false otherwise
         */
        setHighlighted: function(highlighted) {
          this._element.toggleClass("highlighted", highlighted);
          if (highlighted) {
            var p = this.getParentWidget();
            while (p instanceof cls.MonitorDebugTreeItemWidget) {
              p.setCollapsed(false);
              p = p.getParentWidget();
            }
          }
        },

        setFocused: function(focused) {
          this._element.toggleClass("vmFocusedNode", focused);
        }
      };
    });
    cls.WidgetFactory.registerBuilder('MonitorDebugTreeItem', cls.MonitorDebugTreeItemWidget);
  });
;
"use strict";

modulum('MonitorDebugTreeWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class MonitorDebugTreeWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     */
    cls.MonitorDebugTreeWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.MonitorDebugTreeWidget.prototype */ {
        __name: "MonitorDebugTreeWidget",
        _nodeDebug: null,
        _layoutInfo: null,
        _vmFocusedWidgetId: null,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          this._nodeDebug = this._element.getElementsByClassName('nodeDebug')[0];
          this._layoutInfo = this._element.getElementsByClassName('layoutInfo')[0];
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._nodeDebug.innerHTML = "";
          this._layoutInfo.innerHTML = "";
          $super.destroy.call(this);
        },

        /**
         * Set the content of the right part of the debugger (AUI attributes)
         * @param content
         */
        setNodeDebugContent: function(content) {
          this._nodeDebug.innerHTML = "";
          this._nodeDebug.appendChild(content);
        },

        /**
         * Set the content of the layout part of the debugger (AUI layout attributes)
         * @param content
         */
        setLayoutInfoContent: function(content) {
          this._layoutInfo.innerHTML = "";
          this._layoutInfo.appendChild(content);
        },

        /**
         * Set the selected item in the debugger
         * @param {number} id - id of the selected widget
         * @param {Array} items - children of the item
         * @return {*}
         */
        setSelectedItem: function(id, items) {
          var matchingItem = null;
          if (items === undefined) {
            matchingItem = this.setSelectedItem(id, this.getChildren());
            if (matchingItem) {
              var view = this._element.child('part');
              var itemRect = matchingItem._container.getBoundingClientRect();
              var viewRect = view.getBoundingClientRect();
              if (itemRect.bottom > viewRect.height || itemRect.top < 0) {
                view.scrollTop += itemRect.top - viewRect.height / 2;
              }
            }
          } else {
            for (var i = 0; i < items.length; ++i) {
              var item = items[i];
              var match = item.getIdRef() === id;
              item.setHighlighted(match);
              item.setFocused(item.getIdRef() === this._vmFocusedWidgetId);
              var childMatchingItem = this.setSelectedItem(id, item.getChildren());
              if (match) {
                matchingItem = item;
              } else if (!matchingItem) {
                matchingItem = childMatchingItem;
              }
            }
          }
          return matchingItem;
        },

        /**
         * Highlight the VM focused Widget
         * @param {number} id - id of the focused widget
         */
        setVMFocusedWidget: function(id) {
          this._vmFocusedWidgetId = id;
          console.log("setVMFocusedWidget");
        }

      };
    });
    cls.WidgetFactory.registerBuilder('MonitorDebugTree', cls.MonitorDebugTreeWidget);
  });
;
"use strict";

modulum('MonitorWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class MonitorWidget
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.MonitorWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.MonitorWidget.prototype */ {
        __name: "MonitorWidget",
        _initElement: function() {
          $super._initElement.call(this);
        }
      };
    });
    cls.WidgetFactory.registerBuilder('Monitor', cls.MonitorWidget);
  });
;
"use strict";

modulum('ProductInformationWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class ProductInformationWidget
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.ProductInformationWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.ProductInformationWidget.prototype */ {
        __name: "ProductInformationWidget",

        _initElement: function() {
          this._ignoreLayout = true;
          $super._initElement.call(this);

          var versionElement = this._element.getElementsByClassName("field_version")[0];
          versionElement.textContent = context.version;

          var buildElement = this._element.getElementsByClassName("field_build")[0];
          buildElement.textContent = context.build + (context.dirtyFlag || "");

          if (context.tag === "dev-snapshot") {
            var tagElement = this._element.getElementsByClassName("field_tag")[0];
            tagElement.textContent = "(dev-snapshot)";
          }

          var logoElement = this._element.getElementsByClassName("field_logo")[0];
          logoElement.setAttribute("src", context.ThemeService.getResource("img/logo.png"));
          logoElement.setAttribute("alt", "Genero Browser Client");
        },

        _initLayout: function() {
          // no layout
        }
      };
    });
    cls.WidgetFactory.registerBuilder('ProductInformation', cls.ProductInformationWidget);
  });
;
"use strict";

modulum('SettingsWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class SettingsWidget
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.SettingsWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.SettingsWidget.prototype */ {
        __name: "SettingsWidget",

        _lngWidget: null,
        _lngDefaultWidget: null,
        _themeWidget: null,
        _themeHandleRegistration: null,
        _enableWidget: null,
        _resetWidget: null,
        _msgWidget: null,
        _typeaheadWidget: null,
        _loglevelWidget: null,
        _logtypesWidget: null,

        _lngElement: null,
        _themeElement: null,
        _enableElement: null,
        _resetElement: null,
        _resetConfirm: false,

        _storeSettingsEnabled: false,

        _initElement: function() {
          this._ignoreLayout = true;
          $super._initElement.call(this);

          this._storeSettingsEnabled = gbc.StoredSettingsService.areEnabled();

          //Language widget
          this._lngDefaultWidget = cls.WidgetFactory.createWidget("CheckBoxWidget", this.getBuildParameters());
          this._lngDefaultWidget.setEnabled(true);
          this._lngDefaultWidget.setText(i18next.t("gwc.storedSettings.defaultLng"));
          var isDefault = !!gbc.StoredSettingsService.getSettings("gwc.app.defaultLocale");
          this._lngDefaultWidget.setValue(isDefault);

          this._lngWidget = cls.WidgetFactory.createWidget("ComboBoxWidget", this.getBuildParameters());
          this._lngWidget.setNotNull(true);
          this._lngWidget.setEnabled(!isDefault);
          // Redefine the onclickFunction
          this._lngWidget._element.off('click.ComboBoxWidget');
          this._lngWidget._element.on('click.ComboBoxWidget', function(event) {
            event.stopPropagation();
            this._lngWidget.emit(context.constants.widgetEvents.click, event);
            this._lngWidget.emit(context.constants.widgetEvents.focus, event);
          }.bind(this));

          var allLng = gbc.I18NService.getAllLng();
          this._lngWidget.setChoices(allLng.map(function(lng) {
            return {
              text: lng.language,
              value: lng.locale
            };
          }));
          this._lngWidget.setValue(context.StoredSettingsService.getLanguage());

          this._lngWidget.when(context.constants.widgetEvents.click, function(event, data) {
            this._lngWidget.toggleDropDown();
          }.bind(this));
          this._lngWidget.when(context.constants.widgetEvents.change, function() {
            var lng = this._lngWidget.getValue();
            this.setLanguage(lng);
          }.bind(this));

          this._lngDefaultWidget.when(context.constants.widgetEvents.click, function(event, data) {
            gbc.StoredSettingsService.setSettings("gwc.app.defaultLocale", this._lngDefaultWidget.getValue() === true);
            this._lngWidget.setEnabled(!this._lngDefaultWidget.getValue());

            if (this._lngDefaultWidget.getValue()) {
              this.setLanguage(gbc.I18NService.getBrowserLanguage());
            } else {
              this._lngWidget.emit(context.constants.widgetEvents.change, this._lngWidget.getValue());
            }

          }.bind(this));

          this._themeWidget = cls.WidgetFactory.createWidget("ComboBoxWidget", this.getBuildParameters());
          this._themeWidget.setNotNull(true);
          var allThemes = context.ThemeService.getAvailableThemes();
          this._themeWidget.setChoices(allThemes.map(function(theme) {
            return {
              text: theme.title,
              value: theme.name
            };
          }));
          this._themeWidget.setValue(context.ThemeService.getCurrentTheme(), true);
          this._themeHandleRegistration = context.ThemeService.whenThemeChanged(function() {
            this._themeWidget.setValue(context.ThemeService.getCurrentTheme(), true);
          }.bind(this));
          this._themeWidget.setEnabled(allThemes.length > 1);
          this._themeWidget.when(context.constants.widgetEvents.change, function() {
            var theme = this._themeWidget.getValue();
            context.ThemeService.loadTheme(theme, function() {});
          }.bind(this));

          // Enable StoredSettings button
          this._enableWidget = cls.WidgetFactory.createWidget("CheckBoxWidget", this.getBuildParameters());
          this._enableWidget.setEnabled(true);
          this._enableWidget.setText(i18next.t("gwc.storedSettings.enable"));
          this.enableStoredSettings(this._storeSettingsEnabled);
          this._enableWidget.when(context.constants.widgetEvents.click, function() {
            this.toggleStoredSettings();
          }.bind(this));

          // Reset StoredSettings button
          this._resetWidget = cls.WidgetFactory.createWidget("ButtonWidget", this.getBuildParameters());
          this._resetWidget.setText(i18next.t("gwc.storedSettings.reset"));
          this._resetWidget.when(context.constants.widgetEvents.click, function() {
            this.resetStoredSettings(this._resetConfirm);
          }.bind(this));

          // Get containers for each widget
          this._lngElement = this._element.getElementsByClassName("lngSettings")[0];
          this._themeElement = this._element.getElementsByClassName("themeSettings")[0];
          this._storedSettingsElement = this._element.getElementsByClassName("storedSettings")[0];

          // Add widgets in each container
          this._lngElement.appendChild(this._lngWidget.getElement());
          this._lngElement.appendChild(this._lngDefaultWidget.getElement());
          this._themeElement.appendChild(this._themeWidget.getElement());
          this._storedSettingsElement.appendChild(this._resetWidget.getElement());
          this._storedSettingsElement.appendChild(this._enableWidget.getElement());

          this._msgWidget = this._element.querySelector(".message");

          if (gbc.LocalSettingsService._quotaExceededError) {
            this._msgWidget.removeClass("hidden");
          }
          gbc.LocalSettingsService._eventListener.when("QuotaExceededError", function() {
            this._msgWidget.removeClass("hidden");
          }.bind(this));

          // Debug & QA
          if (context.DebugService.isActive()) {
            this._typeaheadWidget = cls.WidgetFactory.createWidget("EditWidget", this.getBuildParameters());
            this._typeaheadWidget.setEnabled(true);
            this._typeaheadWidget.setType("number");
            var minDuration = gbc.SessionService.getCurrent() &&
              gbc.SessionService.getCurrent().getCurrentApplication() &&
              gbc.SessionService.getCurrent().getCurrentApplication().protocolInterface.getNetworkDelay() || 0;
            this._typeaheadWidget.setValue("" + minDuration);
            this._typeaheadWidget.getInputElement().on('input', function(evt) {
              var val = parseInt(this._typeaheadWidget.getValue(), 10);
              if (val > 0) {
                gbc.SessionService.getCurrent().getCurrentApplication().protocolInterface.setNetworkDelay(val);
              }
            }.bind(this));

            this._element.getElementsByClassName("debugTopic")[0].removeClass("hidden");
            this._debugTypeaheadElement = this._element.getElementsByClassName("typeahead")[0];
            this._debugTypeaheadElement.appendChild(this._typeaheadWidget.getElement());

            this._loglevelWidget = cls.WidgetFactory.createWidget("LogLevelSelector", this.getBuildParameters());
            this._loglevelWidget.when("loglevel", function(evt, src, level) {
              context.LogService.changeLevel(level);
              context.StoredSettingsService.setLoglevel(level);
            });
            this._debugLoglevelElement = this._element.getElementsByClassName("loglevel")[0];
            this._debugLoglevelElement.appendChild(this._loglevelWidget.getElement());

            this._logtypesWidget = cls.WidgetFactory.createWidget("LogTypesSelector", this.getBuildParameters());
            this._logtypesWidget.when("logtype", function(evt, src, type) {
              context.LogService.toggleType(type);
              var currentTypes = context.LogService.getActiveLogTypes();
              context.StoredSettingsService.setLogtypes(currentTypes);
              this._logtypesWidget.setCurrentTypes(currentTypes);
            }.bind(this));
            this._debugLogtypesElement = this._element.getElementsByClassName("logtypes")[0];
            this._debugLogtypesElement.appendChild(this._logtypesWidget.getElement());
          }
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._themeHandleRegistration) {
            this._themeHandleRegistration();
            this._themeHandleRegistration = null;
          }
          if (this._lngWidget) {
            this._lngWidget.destroy();
            this._lngWidget = null;
          }
          if (this._lngDefaultWidget) {
            this._lngDefaultWidget.destroy();
            this._lngDefaultWidget = null;
          }
          if (this._themeWidget) {
            this._themeWidget.destroy();
            this._themeWidget = null;
          }
          if (this._enableWidget) {
            this._enableWidget.destroy();
            this._enableWidget = null;
          }
          if (this._resetWidget) {
            this._resetWidget.destroy();
            this._resetWidget = null;
          }
          if (this._typeaheadWidget) {
            this._typeaheadWidget.destroy();
            this._typeaheadWidget = null;
          }
          if (this._loglevelWidget) {
            this._loglevelWidget.destroy();
            this._loglevelWidget = null;
          }
          if (this._logtypesWidget) {
            this._logtypesWidget.destroy();
            this._logtypesWidget = null;
          }

          this._msgWidget = null;
          $super.destroy.call(this);
        },

        _initLayout: function() {
          // no layout
        },

        _restoreDefaultButton: function() {
          // Restore default button
          this._resetConfirm = false;
          this._resetWidget.setText(i18next.t("gwc.storedSettings.reset"));
          this._resetWidget.setEnabled(true);
          this._resetWidget.setBackgroundColor(null);
          this._resetWidget.setColor(null);
        },

        setLanguage: function(lng) {
          gbc.StoredSettingsService.setLanguage(lng);
          this.getParentWidget().setFooter(i18next.t("gwc.storedSettings.changed"));
        },

        toggleStoredSettings: function() {
          if (this._storeSettingsEnabled) {
            this.enableStoredSettings(false);
          } else {
            this.enableStoredSettings(true);
          }
        },

        /**
         *
         * @param status
         */
        enableStoredSettings: function(status) {
          this._enableWidget.setValue(status ? this._enableWidget._checkedValue : this._enableWidget._uncheckedValue);
          this._storeSettingsEnabled = status;
          gbc.StoredSettingsService.enable(status);

        },
        /**
         *
         * @param force if not true, will ask for confirmation
         */
        resetStoredSettings: function(force) {
          // Ask for confirmation first
          if (!force) {
            this._resetWidget.setBackgroundColor(context.ThemeService.getValue("mt-red-200"));
            this._resetWidget.setColor(context.ThemeService.getValue("theme-secondary-color"));
            this._resetWidget.setText(i18next.t("gwc.storedSettings.confirm"));
            this._resetConfirm = true;
          } else { // Reset once confirmed
            gbc.StoredSettingsService.reset();
            this._resetConfirm = false;
            this._resetWidget.setText(i18next.t("gwc.storedSettings.done"));
            this._resetWidget.setEnabled(false);
            this._resetWidget.setBackgroundColor(context.ThemeService.getValue("mt-green-200"));
            this._resetWidget.setColor(context.ThemeService.getValue("theme-secondary-color"));
            this._registerTimeout(function() {
              this._restoreDefaultButton();
            }.bind(this), 2000);
          }
        }
      };
    });
    cls.WidgetFactory.registerBuilder('Settings', cls.SettingsWidget);
  });
;
"use strict";

modulum('ApplicationHostSidebarBackdropWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class ApplicationHostSidebarBackdropWidget
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.ApplicationHostSidebarBackdropWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.ApplicationHostSidebarBackdropWidget.prototype */ {
        __name: "ApplicationHostSidebarBackdropWidget",

        /**
         * @inheritDoc
         */
        _initElement: function() {
          this._ignoreLayout = true;
          $super._initElement.call(this);
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          // no layout
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          this.emit(context.constants.widgetEvents.click);
          return false;
        },

        setDisplayed: function(displayed) {
          this.getElement().toggleClass("mt-sidebar-displayed", !!displayed);
        },

        setUnavailable: function(unavailable) {
          this.getElement().toggleClass("mt-sidebar-unavailable", !!unavailable);
        },

        onClick: function(hook) {
          return this.when(context.constants.widgetEvents.click, hook);
        }
      };
    });
    cls.WidgetFactory.registerBuilder('ApplicationHostSidebarBackdrop', cls.ApplicationHostSidebarBackdropWidget);
  });
;
"use strict";

modulum('ApplicationHostSidebarWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class ApplicationHostSidebarWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     */
    cls.ApplicationHostSidebarWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.ApplicationHostSidebarWidget.prototype */ {
        __name: "ApplicationHostSidebarWidget",
        _resizerElement: null,
        _dragHandle: null,
        _sidebarToggle: null,
        /**
         * For mobile only
         */
        _screenOrientation: null,
        /**
         * @type ?number
         */
        _resizeHandle: null,
        _origin: null,
        _contentElement: null,
        _sidebarContentElement: null,
        _alternateContentWidget: null,
        _titleElement: null,
        _titleTextElement: null,
        _unavailable: false,
        /**
         * @type ?number
         */
        _currentSize: null,

        _initElement: function() {
          this._ignoreLayout = true;
          this._currentSize = cls.Size.translate(context.ThemeService.getValue("theme-sidebar-default-width"));
          $super._initElement.call(this);
          this._contentElement = this._element.getElementsByClassName("mt-content")[0];
          this._sidebarContentElement = this._element.getElementsByClassName("mt-sidebar-content")[0];
          this._titleElement = this._element.getElementsByClassName("mt-sidebar-title")[0];
          this._titleTextElement = this._element.getElementsByClassName("mt-sidebar-title-text")[0];

          this._sidebarToggle = this._element.getElementsByClassName("mt-sidebar-toggle")[0];

          this._element.on("transitionend.ApplicationHostSidebarWidget", this._onTransitionEnd.bind(this));
          this._element.on("oTransitionend.ApplicationHostSidebarWidget", this._onTransitionEnd.bind(this));
          this._element.on("webkitTransitionend.ApplicationHostSidebarWidget", this._onTransitionEnd.bind(this));

          this._resizerElement = this._element.getElementsByClassName("resizer")[0];
          this._dragHandle = this._resizerElement.getElementsByClassName("firefox_placekeeper")[0];
          this._resizerElement.setAttribute("draggable", "true");
          this._resizerElement.on("dragstart.ApplicationHostSidebarWidget", this._onDragStart.bind(this));
          this._resizerElement.on("dragend.ApplicationHostSidebarWidget", this._onDragEnd.bind(this));
          this._resizerElement.on("drag.ApplicationHostSidebarWidget", this._onDrag.throttle(5).bind(this));
          if (window.browserInfo.isIE || window.browserInfo.isEdge) {
            this._resizerElement.on("mousedown.ApplicationHostSidebarWidget", function() {
              this._resizerElement.style.opacity = 0;
            }.bind(this));
            this._resizerElement.on("mouseup.ApplicationHostSidebarWidget", function() {
              this._resizerElement.style.opacity = "";
            }.bind(this));
          }
          window.addEventListener("resize", this.updateResizeTimer.bind(this));

          this._element.onSwipe('ApplicationHostSidebarWidget', this._onSwipe.bind(this), {
            direction: ["left"],
            ignore: this._resizerElement
          });

        },
        _initLayout: function() {
          // no layout
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          // TODO
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          var target = domEvent.target;
          if (target.isElementOrChildOf(this._sidebarToggle)) {
            this.emit(context.constants.widgetEvents.toggleClick);
          }
          return true;
        },

        updateResizeTimer: function() {
          if (window.isMobile() && !window.isOrientationImplemented) {
            window.orientation = window.innerWidth > window.innerHeight ? 90 : 0;
          }
          // for mobiles, only relayout on screen orientation
          if (!window.isMobile() || this._screenOrientation !== window.orientation) {
            this._screenOrientation = window.orientation;
            if (this._resizeHandle) {
              this._clearTimeout(this._resizeHandle);
              this._resizeHandle = null;
            }
            this._resizeHandle = this._registerTimeout(this.updateResize.bind(this, null, false), 100);
          }
        },
        updateResize: function(deltaX, absolute) {
          var previousSize = this._currentSize;
          this._resizeHandle = null;

          var max = cls.Size.translate(context.ThemeService.getValue("theme-sidebar-max-width"));
          if (absolute) {
            this._currentSize = deltaX;
          } else {
            this._currentSize = (Object.isNumber(this._origin) ? this._origin : this._currentSize) + (deltaX || 0);
            if (this._currentSize < 16) {
              this._currentSize = 16;
            }
          }
          if (this._currentSize > max) {
            this._currentSize = max;
          }
          if (!this.isAlwaysVisible()) {
            this.getParentWidget().setCentralContainerPosition(0);
          } else {
            this.getParentWidget().setCentralContainerPosition(this._currentSize);
          }
          // if sidebar size or visibility changed, we emit displayChanged
          if (this._currentSize !== previousSize) {
            // if sidebar size changed only, we update size
            this.setStyle({
              width: this._currentSize + "px"
            });
            // Save sidebar width into storedSettings
            gbc.StoredSettingsService.setSideBarwidth(this._currentSize);
          }
          this.emit(context.constants.widgetEvents.displayChanged);
        },
        /**
         *
         * @returns {classes.ApplicationHostWidget}
         */
        getParentWidget: function() {
          return $super.getParentWidget.call(this);
        },
        /**
         * @inheritDoc
         */
        setParentWidget: function(widget, options) {
          $super.setParentWidget.call(this, widget, options);
          var sidebarwidth = gbc.StoredSettingsService.getSideBarwidth();
          if (sidebarwidth) {
            this._origin = !!this._origin ? this._origin : sidebarwidth;
            this.updateResize(sidebarwidth, true);
          }
        },

        setDisplayed: function(displayed) {
          this.getElement().toggleClass("mt-sidebar-displayed", !!displayed);
        },
        isDisplayed: function() {
          return this.getElement().hasClass("mt-sidebar-displayed");
        },

        isUnavailable: function() {
          return this._unavailable;
        },
        setUnavailable: function(unavailable) {
          this._unavailable = !!unavailable;
          this.getElement().toggleClass("mt-sidebar-unavailable", !!unavailable);
        },

        _onTransitionEnd: function(evt) {
          if (evt.target.hasClass("mt-sidebar")) {
            var positionUpdated = this.getParentWidget().setCentralContainerPosition(!this.isAlwaysVisible() ? 0 : this
              ._currentSize);
            if (positionUpdated) {
              this.emit(context.constants.widgetEvents.displayChanged);
            }
          }
        },
        getCurrentSize: function() {
          return this._currentSize;
        },
        getTitle: function() {
          return this._titleTextElement.textContent;
        },
        setTitle: function(title) {
          this._titleTextElement.textContent = title;
        },
        onDisplayChanged: function(hook) {
          return this.when(context.constants.widgetEvents.displayChanged, hook);
        },

        _onDragOver: function(evt) {
          this._pageX = evt.clientX || evt.screenX || evt.pageX;
          evt.preventCancelableDefault();
        },
        _onDragStart: function(evt) {
          document.body.on("dragover.ApplicationHostSidebarWidget", this._onDragOver.bind(this));
          this._isDragging = true;
          if (window.browserInfo.isFirefox) {
            evt.dataTransfer.setData('text', ''); // for Firefox compatibility
          }
          if (evt.dataTransfer.setDragImage) {
            evt.dataTransfer.setDragImage(this._dragHandle, 0, 0);
          }
          evt.dataTransfer.effectAllowed = "move";
          this._pageX = this._resizerDragX = evt.clientX || evt.screenX || evt.pageX;
          this._origin = this._currentSize;
        },
        _onDragEnd: function(evt) {
          document.body.off("dragover.ApplicationHostSidebarWidget");
          this._isDragging = false;
          this._origin = this._currentSize;
          // Save sidebar width into storedSettings
          gbc.StoredSettingsService.setSideBarwidth(this._currentSize);
        },
        _onDrag: function(evt) {
          if (this._isDragging) {
            var deltaX = this._pageX - this._resizerDragX;
            this.updateResize(deltaX);

          }
        },
        isAlwaysVisible: function() {
          return window.matchMedia(
            "screen and (min-width: " + context.ThemeService.getValue("theme-sidebar-always-visible-min-width") + ")"
          ).matches;
        },

        setActiveWindow: function(win) {
          var sidebarSessionsItems = this.getChildren();
          for (var a = 0; a < sidebarSessionsItems.length; a++) {
            var sidebarSessionsItem = sidebarSessionsItems[a];
            var sidebarAppItems = sidebarSessionsItem.getChildren();
            for (var w = 0; w < sidebarAppItems.length; w++) {
              var sidebarAppItem = sidebarAppItems[w];
              sidebarAppItem._element.removeClass('activeWindow');
              var sidebarWinItems = sidebarAppItem.getChildren();
              for (var s = 0; s < sidebarWinItems.length; s++) {
                var sidebarWinItem = sidebarWinItems[s];
                var isActiveWindow = sidebarWinItem._windowWidget === win;
                sidebarWinItem._element.toggleClass('visibleWindow', isActiveWindow);
                if (isActiveWindow) {
                  sidebarAppItem._element.addClass('activeWindow');
                }
              }
            }
          }
        },
        setTitleText: function(text) {
          if (this._titleTextElement) {
            this._titleTextElement.textContent = text;
          }
        },

        _onSwipe: function(evt, distance) {
          this.emit(context.constants.widgetEvents.toggleClick);
        },
        setSidebarContent: function(widget) {
          if (this._alternateContentWidget && this._alternateContentWidget.getElement() &&
            this._alternateContentWidget.getElement().parent("mt-sidebar") === this.getElement()) {
            this._alternateContentWidget.getElement().remove();
          }
          if (widget) {
            this._contentElement.style.display = "none";
            this._titleElement.style.display = "none";
            this._sidebarContentElement.appendChild(widget.getElement());
          } else {
            this._contentElement.style.display = "";
            this._titleElement.style.display = "";
          }
        }
      };
    });
    cls.WidgetFactory.registerBuilder('ApplicationHostSidebar', cls.ApplicationHostSidebarWidget);
  });
;
"use strict";

modulum('SessionSidebarApplicationItemWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class SessionSidebarApplicationItemWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     */
    cls.SessionSidebarApplicationItemWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.SessionSidebarApplicationItemWidget.prototype */ {
        __name: "SessionSidebarApplicationItemWidget",
        _applicationName: null,
        _applicationIconImage: null,
        /**
         * @type {classes.ApplicationWidget}
         */
        _applicationWidget: null,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          this._ignoreLayout = true;
          $super._initElement.call(this);
          this._applicationName = this._element.getElementsByClassName("applicationName")[0];
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          this._applicationWidget.getParentWidget().setCurrentWidget(this._applicationWidget);
          this._children[0]._windowWidget.getUserInterfaceWidget()._syncCurrentWindow();
          this.closeSidebar();
          return false;
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._applicationWidget = null;
          if (this._applicationIconImage) {
            this._applicationIconImage.destroy();
            this._applicationIconImage = null;
          }
          this._applicationName = null;
          $super.destroy.call(this);
        },

        /**
         *
         * @param {classes.WidgetBase} widget
         */
        _addChildWidgetToDom: function(widget) {
          var itemHost = document.createElement('li');
          itemHost.addClass('mt-action');
          widget.getLayoutInformation().setHostElement(itemHost);
          this._containerElement.appendChild(itemHost);
          itemHost.appendChild(widget._element);
        },

        /**
         *
         * @param {classes.WidgetBase} widget
         */
        _removeChildWidgetFromDom: function(widget) {
          var info = widget.getLayoutInformation(),
            host = info && info.getHostElement();
          if (host && host.parentNode === this._containerElement) {
            widget._element.remove();
            host.remove();
            host = null;
          }
        },
        setApplicationName: function(text) {
          this._applicationName.textContent = text;
          this._applicationName.setAttribute("title", text);
        },
        getApplicationName: function() {
          return this._applicationName.textContent;
        },
        setApplicationWidget: function(widget) {
          this._applicationWidget = widget;
        },
        setApplicationIcon: function(image) {
          if (!this._applicationIconImage) {
            this._applicationIconImage = cls.WidgetFactory.createWidget("ImageWidget", this.getBuildParameters());
            this._element.getElementsByClassName("applicationIcon")[0].prependChild(this._applicationIconImage.getElement());
          }
          this._applicationIconImage.setHidden(true);
          if (image && image !== "") {
            this._applicationIconImage.setSrc(image);
            this._applicationIconImage.setHidden(false);
          }
        },
        onClose: function(hook) {
          this.when(context.constants.widgetEvents.close, hook);
        },
        closeSidebar: function() {
          this.getParentWidget().getParentWidget().getParentWidget().hideSidebar();
        },
        unfreeze: function() {
          this.getContainerElement().removeClass("noAction");
        },
        freeze: function() {
          this.getContainerElement().addClass("noAction");
        },
        setProcessing: function(isProcessing) {
          if (isProcessing) {
            this.getElement().setAttribute("processing", "processing");
          } else {
            this.getElement().removeAttribute("processing");
          }
        }
      };
    });
    cls.WidgetFactory.registerBuilder('SessionSidebarApplicationItem', cls.SessionSidebarApplicationItemWidget);
  });
;
"use strict";

modulum('SessionSidebarWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class SessionSidebarWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     */
    cls.SessionSidebarWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.SessionSidebarWidget.prototype */ {
        __name: "SessionSidebarWidget",

        _initElement: function() {
          this._ignoreLayout = true;
          $super._initElement.call(this);
        },

        _initLayout: function() {
          // no layout
        },

        /**
         *
         * @param {classes.WidgetBase} widget
         */
        _addChildWidgetToDom: function(widget) {
          var itemHost = document.createElement('li');
          itemHost.addClass('mt-action');
          widget.getLayoutInformation().setHostElement(itemHost);
          this._containerElement.appendChild(itemHost);
          itemHost.appendChild(widget._element);
        },

        /**
         *
         * @param {classes.WidgetBase} widget
         */
        _removeChildWidgetFromDom: function(widget) {
          if (widget) {
            var info = widget.getLayoutInformation(),
              host = info && info.getHostElement();
            if (host && host.parentNode === this._containerElement) {
              widget._element.remove();
              host.remove();
              host = null;
            }
          }
        }

      };
    });
    cls.WidgetFactory.registerBuilder('SessionSidebar', cls.SessionSidebarWidget);
  });
;
"use strict";

modulum('SessionSidebarWindowItemWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class SessionSidebarWindowItemWidget
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.SessionSidebarWindowItemWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.SessionSidebarWindowItemWidget.prototype */ {
        __name: "SessionSidebarWindowItemWidget",

        /** @type {Element} */
        _windowNameElement: null,
        /** @type {classes.ImageWidget} */
        _windowIconImage: null,
        /** @type {classes.WindowWidget} */
        _windowWidget: null,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          this._ignoreLayout = true;
          $super._initElement.call(this);
          this._windowNameElement = this._element.getElementsByClassName("windowName")[0];
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          var ui = this._windowWidget.getUserInterfaceWidget();

          var appWidget = ui.getParentWidget();
          appWidget.getParentWidget().setCurrentWidget(appWidget);
          ui._syncCurrentWindow();

          this.setActiveWindow(this._windowWidget);
          ui.setCurrentWindowId(this._windowWidget._auiTag);

          if (gbc.StoredSettingsService.isSideBarVisible()) {
            this.getParentWidget().closeSidebar();
          }
          return false;
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._windowWidget = null;
          this._windowNameElement = null;
          if (this._windowIconImage) {
            this._windowIconImage.destroy();
            this._windowIconImage = null;
          }

          $super.destroy.call(this);
        },

        /**
         * Set window's name
         * @param {String} name - window's name
         * @publicdoc
         */
        setWindowName: function(name) {
          this._windowNameElement.textContent = name;
          this._windowNameElement.setAttribute("title", name);
        },

        /**
         * Get window's name
         * @return {string} window's name
         * @publicdoc
         */
        getWindowName: function() {
          return this._windowNameElement.textContent;
        },

        /**
         * Change the image icon
         * @param {String} image - image path
         * @publicdoc
         */
        setWindowIcon: function(image) {
          if (!this._windowIconImage) {
            this._windowIconImage = cls.WidgetFactory.createWidget("ImageWidget", this.getBuildParameters());
            this._element.getElementsByClassName("windowIcon")[0].prependChild(this._windowIconImage.getElement());
          }
          this._windowIconImage.setHidden(true);
          if (image && image !== "") {
            this._windowIconImage.setSrc(image);
            this._windowIconImage.setHidden(false);
          }
        },

        /**
         * Set the corresponding window widget
         * @param {classes.WindowWidget} widget - window
         */
        setWindowWidget: function(widget) {
          this._windowWidget = widget;
        },

        /**
         * TODO doc, is it useful to have setActiveWindow & setCurrent ?
         */
        setCurrent: function() {
          if (!this.getParentWidget() || !this.getParentWidget().getParentWidget()) {
            return;
          }
          var sessionSidebar = this.getParentWidget().getParentWidget().getParentWidget();
          var apps = sessionSidebar.getChildren();
          for (var a = 0; a < apps.length; a++) {
            var sidebarAppItem = apps[a];
            var wins = sidebarAppItem.getChildren();
            for (var w = 0; w < wins.length; w++) {
              var sidebarWinItem = wins[w];
              sidebarWinItem._element.toggleClass('activeWindow', sidebarWinItem === this.getParentWidget());
              this.setActiveWindow(this._windowWidget);
            }
          }
        },

        /**
         * TODO doc, is it useful to have setActiveWindow & setCurrent ?
         * @param win
         */
        setActiveWindow: function(win) {
          var sessionSidebar = this.getParentWidget().getParentWidget().getParentWidget();
          var apps = sessionSidebar.getChildren();
          for (var a = 0; a < apps.length; a++) {
            var sidebarAppItem = apps[a];
            var wins = sidebarAppItem.getChildren();
            for (var w = 0; w < wins.length; w++) {
              var sidebarWinItem = wins[w];
              sidebarWinItem._element.toggleClass('activeWindow', sidebarWinItem === this.getParentWidget());
              var subs = sidebarWinItem.getChildren();
              for (var s = 0; s < subs.length; s++) {
                var sidebarSubWinItem = subs[s];
                sidebarSubWinItem._element.toggleClass('visibleWindow', sidebarSubWinItem._windowWidget === win);
              }
            }
          }
        },

        /**
         * Returns if window is the current one
         * @return {boolean} - true if window is current
         * @publicdoc
         */
        isCurrent: function() {
          return this._element.hasClass('activeWindow');
        },

        /**
         * Set window froze or not
         * @param {boolean} frozen - true if window is frozen
         */
        setFrozen: function(frozen) {
          this._element.toggleClass("frozenWindow", !!frozen);
        }
      };
    });
    cls.WidgetFactory.registerBuilder('SessionSidebarWindowItem', cls.SessionSidebarWindowItemWidget);
  });
;
"use strict";

modulum('ApplicationLauncherBookmarkItemWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class ApplicationLauncherBookmarkItemWidget
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.ApplicationLauncherBookmarkItemWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.ApplicationLauncherBookmarkItemWidget.prototype */ {
        __name: "ApplicationLauncherBookmarkItemWidget",
        constructor: function(opts) {
          var bookmarkItem = (opts || {}).bookmark;
          $super.constructor.call(this, opts);
          this._element.getElementsByClassName("title")[0].textContent = bookmarkItem.name;
          this._element.getElementsByClassName("link")[0].textContent = bookmarkItem.url;
          this._element.getElementsByClassName("desc")[0].on("click.ApplicationLauncherBookmarkItemWidget", function() {
            var data = context.BookmarkService.getBookmark("" + bookmarkItem.name);
            if (data) {
              context.UrlService.goTo(data.url);
            }
          });
          this._element.getElementsByClassName("logs")[0].on("click.ApplicationLauncherBookmarkItemWidget", function() {
            //TODO : pop logs
          });
          this._element.getElementsByClassName("delete")[0].on("click.ApplicationLauncherBookmarkItemWidget", function() {
            var deleter = this._element.getElementsByClassName("delete")[0];
            if (deleter.hasClass("deleting")) {
              return true;
            }
            deleter.addClass("deleting");
            this._element.getElementsByClassName("desc")[0].addClass("hidden");
            var removed = context.BookmarkService.removeBookmark(bookmarkItem.name);
            var timer = this._registerTimeout(function() {
              timer = null;
              this.destroy();
            }.bind(this), 10000);

            deleter.getElementsByTagName("i")[0].removeClass("zmdi-delete");
            deleter.getElementsByTagName("i")[0].addClass("zmdi-undo");
            var undo = document.createElement("b");
            undo.addClass("undo");
            undo.textContent = "Undo";
            deleter.appendChild(undo);
            deleter.on("click.undo", function() {
              if (timer) {
                this._clearTimeout(timer);
                timer = null;
              }
              deleter.getElementsByTagName("i")[0].addClass("zmdi-delete");
              deleter.getElementsByTagName("i")[0].removeClass("zmdi-undo");
              deleter.removeClass("deleting");
              this._element.getElementsByClassName("desc")[0].removeClass("hidden");
              context.BookmarkService.getBookmarks().add(removed, this._element.index());
              context.LocalSettingsService.write("bookmarks", context.BookmarkService.getBookmarks());
              undo.remove();
              deleter.off("click.undo");
              return false;
            }.bind(this));
          }.bind(this));
        },
        destroy: function() {
          this._element.getElementsByClassName("desc")[0].off("click.ApplicationLauncherBookmarkItemWidget");
          this._element.getElementsByClassName("logs")[0].off("click.ApplicationLauncherBookmarkItemWidget");
          this._element.getElementsByClassName("delete")[0].off("click.ApplicationLauncherBookmarkItemWidget");
          $super.destroy.call(this);
        }
      };
    });
    cls.WidgetFactory.registerBuilder('ApplicationLauncherBookmarkItem', cls.ApplicationLauncherBookmarkItemWidget);
  });
;
"use strict";

modulum('ApplicationLauncherBookmarkWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class ApplicationLauncherBookmarkWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     */
    cls.ApplicationLauncherBookmarkWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.ApplicationLauncherBookmarkWidget.prototype */ {
        __name: "ApplicationLauncherBookmarkWidget",
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          this.refresh();
          context.BookmarkService.onRefreshed(this.refresh.bind(this));
        },
        refresh: function() {
          while (this._children.length) {
            this._children.pop().destroy();
          }
          var bookmark = context.BookmarkService.getBookmarks();
          for (var i = 0; i < bookmark.length; i++) {
            var opts = this.getBuildParameters();
            opts.bookmark = bookmark[i];
            var item = cls.WidgetFactory.createWidget('ApplicationLauncherBookmarkItem', opts);
            this.addChildWidget(item);
          }
        }
      };
    });
    cls.WidgetFactory.registerBuilder('ApplicationLauncherBookmark', cls.ApplicationLauncherBookmarkWidget);
  });
;
"use strict";

modulum('ApplicationLauncherHistoryItemWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class ApplicationLauncherHistoryItemWidget
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.ApplicationLauncherHistoryItemWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.ApplicationLauncherHistoryItemWidget.prototype */ {
        __name: "ApplicationLauncherHistoryItemWidget",
        constructor: function(opts) {
          var historyItem = (opts || {}).history;
          $super.constructor.call(this, opts);
          this._element.getElementsByClassName("title")[0].textContent = historyItem.name;
          this._element.getElementsByClassName("link")[0].textContent = historyItem.url;
          this._element.getElementsByClassName("desc")[0].on("click.ApplicationLauncherHistoryItemWidget", function() {
            var data = context.HistoryService.getHistory("" + historyItem.name);
            if (data) {
              context.UrlService.goTo(data.url);
            }
          });
          this._element.getElementsByClassName("logs")[0].on("click.ApplicationLauncherHistoryItemWidget", function() {
            //TODO : pop logs
          });
          this._element.getElementsByClassName("delete")[0].on("click.ApplicationLauncherHistoryItemWidget", function() {
            context.HistoryService.removeHistory("" + historyItem.name);
          });
        },
        destroy: function() {
          this._element.getElementsByClassName("desc")[0].off("click.ApplicationLauncherHistoryItemWidget");
          this._element.getElementsByClassName("logs")[0].off("click.ApplicationLauncherHistoryItemWidget");
          this._element.getElementsByClassName("delete")[0].off("click.ApplicationLauncherHistoryItemWidget");
          if (this._element) {
            this._element.remove();
          }
          $super.destroy.call(this);
        }
      };
    });
    cls.WidgetFactory.registerBuilder('ApplicationLauncherHistoryItem', cls.ApplicationLauncherHistoryItemWidget);
  });
;
"use strict";

modulum('ApplicationLauncherHistoryWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class ApplicationLauncherHistoryWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     */
    cls.ApplicationLauncherHistoryWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.ApplicationLauncherHistoryWidget.prototype */ {
        __name: "ApplicationLauncherHistoryWidget",

        _currentHistory: null,

        constructor: function(opts) {
          $super.constructor.call(this, opts);
          this._currentHistory = [];
          this._element.getElementsByClassName("removeHistory")[0].on("click.ApplicationLauncherHistoryWidget", function() {
            context.HistoryService.clearHistory();
          });
          this.refresh();
          context.HistoryService.onRefreshed(this.refresh.bind(this));
        },
        refresh: function() {

          var history = context.HistoryService.getHistory();
          var diff = history.length - this._currentHistory.length;

          //detect if new history seems different, if so we rebuild the whole history
          //if (this._currentHistory.length > 0 && history.length > 0 && diff > -1) {

          //  if (this._currentHistory[this._currentHistory.length - 1].date !== history[history.length - 1].date) {
          while (this._children.length) {
            this._children.pop().destroy();
          }
          this._currentHistory.length = 0;
          //  }
          //}
          var i = 0;
          if (this._currentHistory.length === 0) {
            for (i = 0; i < history.length; i++) {
              this._addHistoryItem(history[i]);
            }
          } else {
            // loop to add only new item
            for (i = diff - 1; i > -1; i--) {
              this._addHistoryItem(history[i], {
                position: 0
              });
            }
          }
        },

        /**
         *
         * @param historyItem {Object}
         * @param {Object=} options - possible options
         * @param {boolean=} options.noDOMInsert - won't add child to DOM
         * @param {number=} options.position - insert position
         * @param {string=} options.tag - context tag
         * @param {string=} options.mode - context mode : null|"replace"
         * @private
         */
        _addHistoryItem: function(historyItem, options) {

          var opts = this.getBuildParameters();
          opts.history = historyItem;

          var item = cls.WidgetFactory.createWidget('ApplicationLauncherHistoryItem', opts);
          this.addChildWidget(item, options);
          this._currentHistory.push(historyItem);
        },

        destroy: function() {
          this._element.getElementsByClassName("removeHistory")[0].off("click.ApplicationLauncherHistoryWidget");
          for (var i = this.getChildren().length - 1; i > -1; i--) {
            var currentChildren = this.getChildren()[i];
            currentChildren.destroy();
            currentChildren = null;
          }
          this._currentHistory.length = 0;
          $super.destroy.call(this);
        }
      };
    });
    cls.WidgetFactory.registerBuilder('ApplicationLauncherHistory', cls.ApplicationLauncherHistoryWidget);
  });
;
"use strict";

modulum('ApplicationLauncherStartLogPlayerWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class ApplicationLauncherStartLogPlayerWidget
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.ApplicationLauncherStartLogPlayerWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.ApplicationLauncherStartLogPlayerWidget.prototype */ {
        __name: "ApplicationLauncherStartLogPlayerWidget",

        /**
         * @type HTMLElement
         */
        _buttonElement: null,
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          this._buttonElement = this._element.getElementsByTagName("button")[0];
          this._buttonElement.on("click.ApplicationLauncherStartLogPlayerWidget", this.startLogPlayer.bind(this));
        },
        destroy: function() {
          this._buttonElement.off("click.ApplicationLauncherStartLogPlayerWidget");
        },
        startLogPlayer: function() {
          window.location.href = document.location.origin + document.location.pathname + "?logplayer=1";
        }
      };
    });
    cls.WidgetFactory.registerBuilder('ApplicationLauncherStartLogPlayer', cls.ApplicationLauncherStartLogPlayerWidget);
  });
;
"use strict";

modulum('ApplicationLauncherUrlInputWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class ApplicationLauncherUrlInputWidget
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.ApplicationLauncherUrlInputWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.ApplicationLauncherUrlInputWidget.prototype */ {
        __name: "ApplicationLauncherUrlInputWidget",

        /**
         * @type HTMLElement
         */
        _buttonElement: null,
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          this._inputElement = this._element.getElementsByTagName("input")[0];
          this._buttonElement = this._element.getElementsByTagName("button")[0];
          this._buttonElement.on("click.ApplicationLauncherUrlInputWidget", this.launchUrl.bind(this));
          this._inputElement.on("keydown.ApplicationLauncherUrlInputWidget", function(evt) {
            var key = cls.KeyboardApplicationService.keymap[evt.which];
            if (key === "enter") { // enter key
              this.launchUrl();
            }
          }.bind(this));
          this._inputElement.on("keyup.ApplicationLauncherUrlInputWidget", this._updateButton.bind(this));
          this._inputElement.on("mouseover.ApplicationLauncherUrlInputWidget", this._updateButton.bind(this));

        },
        destroy: function() {
          this._buttonElement.off("click.ApplicationLauncherUrlInputWidget");
          this._inputElement.off("keydown.ApplicationLauncherUrlInputWidget");
          this._inputElement.off("keyup.ApplicationLauncherUrlInputWidget");
          this._inputElement.off("mouseover.ApplicationLauncherUrlInputWidget");
        },
        _updateButton: function() {
          if (this._inputElement.value) {
            this._buttonElement.removeAttribute("disabled");
            this._buttonElement.removeClass("disabled");
          } else {
            this._buttonElement.setAttribute("disabled", "disabled");
            this._buttonElement.addClass("disabled");
          }
        },
        launchUrl: function() {
          var value = this._inputElement.value;
          context.UrlService.goTo(value);
        }

      };
    });
    cls.WidgetFactory.registerBuilder('ApplicationLauncherUrlInput', cls.ApplicationLauncherUrlInputWidget);
  });
;
"use strict";

modulum('ApplicationLauncherWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class ApplicationLauncherWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     */
    cls.ApplicationLauncherWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.ApplicationLauncherWidget.prototype */ {
        __name: "ApplicationLauncherWidget",
        _startLogPlayer: null,
        _urlInput: null,
        _history: null,
        _bookmark: null,

        /** @type {classes.ChromeBarWidget} **/
        _chromeBar: null,

        constructor: function(opts) {
          $super.constructor.call(this, opts);
          if (!context.HostService.isLogPlayerRequested()) {
            this._urlInput = cls.WidgetFactory.createWidget('ApplicationLauncherUrlInput', this.getBuildParameters());
            this._element.prependChild(this._urlInput.getElement());
            this._startLogPlayer = cls.WidgetFactory.createWidget('ApplicationLauncherStartLogPlayer', this.getBuildParameters());
            this._element.prependChild(this._startLogPlayer.getElement());
            this._history = cls.WidgetFactory.createWidget('ApplicationLauncherHistory', this.getBuildParameters());
            this.addChildWidget(this._history);
            this._bookmark = cls.WidgetFactory.createWidget('ApplicationLauncherBookmark', this.getBuildParameters());
            this.addChildWidget(this._bookmark);
          }

          if (!gbc.ThemeService.getValue("theme-legacy-topbar")) {
            var chromeBarOpt = this.getBuildParameters();
            chromeBarOpt.lightmode = true;
            this._chromeBar = cls.WidgetFactory.createWidget("ChromeBar", chromeBarOpt);
            this._element.prependChild(this._chromeBar.getElement());
            this._chromeBar.setLightMode(true);
          }
        },
        destroy: function() {
          this._urlInput.destroy();
          this._urlInput = null;
          this._history.destroy();
          this._history = null;
          this._bookmark.destroy();
          this._bookmark = null;
          $super.destroy.call(this);
        },
        getHistory: function() {
          return this._history;
        },
        setHidden: function(hidden) {
          $super.setHidden.call(this, hidden);
          if (this.getParentWidget()) {
            this.getParentWidget().enableSidebar(hidden);
          }
        },
        /**
         * @inheritDoc
         * @param {classes.ApplicationHostWidget} widget
         * @param {Object=} options - possible options
         * @param {boolean=} options.noLayoutInvalidation - won't affect parent layout
         */
        setParentWidget: function(widget, options) {
          $super.setParentWidget.call(this, widget, options);
          widget.enableSidebar(!this.isVisible());
        }
      };
    });
    cls.WidgetFactory.registerBuilder('ApplicationLauncher', cls.ApplicationLauncherWidget);
  });
;
"use strict";

modulum('CanvasAbstractWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Abstract class for canvas element widget.
     * @class CanvasAbstractWidget
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.CanvasAbstractWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.CanvasAbstractWidget.prototype */ {
        __name: "CanvasAbstractWidget",

        /**
         * Flag for augmentedFace
         * @type {boolean}
         */
        __virtual: true,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          this._element.on('click.CanvasAbstractWidget', this._onClick.bind(this));
          this._element.on('contextmenu.CanvasAbstractWidget', this._onContextMenu.bind(this));
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._element.off("click.CanvasAbstractWidget");
          this._element.off("contextmenu.CanvasAbstractWidget");
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        _onClick: function(event) {
          this.emit(context.constants.widgetEvents.click, event);
        },

        /**
         * Handle contextmenu event
         * @param {*} event
         */
        _onContextMenu: function(event) {
          this.emit(context.constants.widgetEvents.rightClick, event);
        },

        setColor: function(color) {
          this._element.setAttribute('fill', color);
        }
      };
    });
  }
);
;
"use strict";

modulum('CanvasArcWidget', ['CanvasAbstractWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * CanvasArc widget.
     * @class CanvasArcWidget
     * @memberOf classes
     * @extends classes.CanvasAbstractWidget
     */
    cls.CanvasArcWidget = context.oo.Class(cls.CanvasAbstractWidget, function($super) {
      return /** @lends classes.CanvasArcWidget.prototype */ {
        __name: "CanvasArcWidget",

        _initElement: function() {
          this._element = document.createElementNS("http://www.w3.org/2000/svg", "path");
          $super._initElement.call(this);
        },

        setParameters: function(startX, startY, diameter, startDegrees, extentDegrees) {
          var startAngle = (extentDegrees >= 0 ? startDegrees : startDegrees + extentDegrees) * Math.PI / 180;
          var endAngle = (extentDegrees >= 0 ? startDegrees + extentDegrees : startDegrees) * Math.PI / 180;

          var d2 = diameter / 2;
          var r = Math.abs(d2);
          var cx = startX + d2;
          var cy = startY - d2;

          var x1 = cx + r * Math.cos(startAngle);
          var y1 = cy + r * Math.sin(startAngle);
          var x2 = cx + r * Math.cos(endAngle);
          var y2 = cy + r * Math.sin(endAngle);

          var largeArcFlag = Math.abs(extentDegrees) < 180 ? 0 : 1;

          var d = "M " + cx + " " + cy + " " +
            "L " + x1 + " " + y1 + " " +
            "A " + r + " " + r + " 0 " + largeArcFlag + " 1 " + x2 + " " + y2 + " " +
            "Z";

          this._element.setAttribute('d', d);
        }
      };
    });
    cls.WidgetFactory.registerBuilder('CanvasArc', cls.CanvasArcWidget);
  }
);
;
"use strict";

modulum('CanvasCircleWidget', ['CanvasAbstractWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Button widget.
     * @class CanvasCircleWidget
     * @memberOf classes
     * @extends classes.CanvasAbstractWidget
     */
    cls.CanvasCircleWidget = context.oo.Class(cls.CanvasAbstractWidget, function($super) {
      return /** @lends classes.CanvasCircleWidget.prototype */ {
        __name: "CanvasCircleWidget",

        _initElement: function() {
          this._element = document.createElementNS("http://www.w3.org/2000/svg", "circle");
          $super._initElement.call(this);
        },

        setParameters: function(cx, cy, r) {
          this._element.setAttribute('cx', cx);
          this._element.setAttribute('cy', cy);
          this._element.setAttribute('r', r);
        }
      };
    });
    cls.WidgetFactory.registerBuilder('CanvasCircle', cls.CanvasCircleWidget);
  }
);
;
"use strict";

modulum('CanvasLineWidget', ['CanvasAbstractWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Button widget.
     * @class CanvasLineWidget
     * @memberOf classes
     * @extends classes.CanvasAbstractWidget
     */
    cls.CanvasLineWidget = context.oo.Class(cls.CanvasAbstractWidget, function($super) {
      return /** @lends classes.CanvasLineWidget.prototype */ {
        __name: "CanvasLineWidget",

        _initElement: function() {
          this._element = document.createElementNS("http://www.w3.org/2000/svg", "line");
          this._element.setAttribute('stroke-width', "2px");
          $super._initElement.call(this);
        },

        setParameters: function(x1, y1, x2, y2) {
          this._element.setAttribute('x1', x1);
          this._element.setAttribute('y1', y1);
          this._element.setAttribute('x2', x2);
          this._element.setAttribute('y2', y2);
        },

        setColor: function(color) {
          this._element.setAttribute('stroke', color);
        }
      };
    });
    cls.WidgetFactory.registerBuilder('CanvasLine', cls.CanvasLineWidget);
  }
);
;
"use strict";

modulum('CanvasOvalWidget', ['CanvasAbstractWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Button widget.
     * @class CanvasOvalWidget
     * @memberOf classes
     * @extends classes.CanvasAbstractWidget
     */
    cls.CanvasOvalWidget = context.oo.Class(cls.CanvasAbstractWidget, function($super) {
      return /** @lends classes.CanvasOvalWidget.prototype */ {
        __name: "CanvasOvalWidget",

        _initElement: function() {
          this._element = document.createElementNS("http://www.w3.org/2000/svg", "ellipse");
          $super._initElement.call(this);
        },

        setParameters: function(cx, cy, rx, ry) {
          this._element.setAttribute('cx', cx);
          this._element.setAttribute('cy', cy);
          this._element.setAttribute('rx', rx);
          this._element.setAttribute('ry', ry);
        }
      };
    });
    cls.WidgetFactory.registerBuilder('CanvasOval', cls.CanvasOvalWidget);
  }
);
;
"use strict";

modulum('CanvasPolygonWidget', ['CanvasAbstractWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Button widget.
     * @class CanvasPolygonWidget
     * @memberOf classes
     * @extends classes.CanvasAbstractWidget
     */
    cls.CanvasPolygonWidget = context.oo.Class(cls.CanvasAbstractWidget, function($super) {
      return /** @lends classes.CanvasPolygonWidget.prototype */ {
        __name: "CanvasPolygonWidget",

        _initElement: function() {
          this._element = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
          $super._initElement.call(this);
        },

        setParameters: function(points) {
          var pointsStr = "";
          for (var i = 0; i < points.length; i = i + 2) {
            if (i !== 0) {
              pointsStr += ' ';
            }
            pointsStr += points[i + 1] + ',' + points[i];
          }
          this._element.setAttribute('points', pointsStr);
        }
      };
    });
    cls.WidgetFactory.registerBuilder('CanvasPolygon', cls.CanvasPolygonWidget);
  }
);
;
"use strict";

modulum('CanvasRectangleWidget', ['CanvasAbstractWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Button widget.
     * @class CanvasRectangleWidget
     * @memberOf classes
     * @extends classes.CanvasAbstractWidget
     */
    cls.CanvasRectangleWidget = context.oo.Class(cls.CanvasAbstractWidget, function($super) {
      return /** @lends classes.CanvasRectangleWidget.prototype */ {
        __name: "CanvasRectangleWidget",

        _initElement: function() {
          this._element = document.createElementNS("http://www.w3.org/2000/svg", "rect");
          $super._initElement.call(this);
        },

        setParameters: function(x, y, width, height) {
          this._element.setAttribute('x', x);
          this._element.setAttribute('y', y);
          this._element.setAttribute('width', width);
          this._element.setAttribute('height', height);
        }
      };
    });
    cls.WidgetFactory.registerBuilder('CanvasRectangle', cls.CanvasRectangleWidget);
  }
);
;
"use strict";

modulum('CanvasTextWidget', ['CanvasAbstractWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Button widget.
     * @class CanvasTextWidget
     * @memberOf classes
     * @extends classes.CanvasAbstractWidget
     */
    cls.CanvasTextWidget = context.oo.Class(cls.CanvasAbstractWidget, function($super) {
      return /** @lends classes.CanvasTextWidget.prototype */ {
        __name: "CanvasTextWidget",

        _initElement: function() {
          this._element = document.createElementNS("http://www.w3.org/2000/svg", "text");
          $super._initElement.call(this);
        },

        setParameters: function(canvasWidth, canvasHeight, x, y, xTextAnchor, yTextAnchor, text) {
          this._element.setAttribute('x', '0');
          switch (yTextAnchor) {
            case 'start':
              this._element.setAttribute('y', '1.25ex');
              break;
            case 'middle':
              this._element.setAttribute('y', '.5ex');
              break;
            case 'end':
              this._element.setAttribute('y', '-.25ex');
              break;
          }
          this._element.setAttribute('text-anchor', xTextAnchor);
          this._element.textContent = text;
          var sx = canvasWidth !== 0 ? 1000 / canvasWidth : 0;
          var sy = canvasHeight !== 0 ? -1000 / canvasHeight : 0;
          this._element.setAttribute("transform", "matrix(" + sx + " 0 0 " + sy + " " + x + " " + y + ")");
        }
      };
    });
    cls.WidgetFactory.registerBuilder('CanvasText', cls.CanvasTextWidget);
  }
);
;
"use strict";

modulum('CanvasWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Button widget.
     * @class CanvasWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     */
    cls.CanvasWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.CanvasWidget.prototype */ {
        __name: "CanvasWidget",

        _svgElement: null,

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          this._layoutInformation = new cls.LayoutInformation(this);
          this._layoutEngine = new cls.LeafLayoutEngine(this);
          this._layoutEngine._shouldFillHeight = true;
          this._layoutInformation.getSizePolicyConfig()._defaultMode = 'fixed';
          this._layoutInformation.getSizePolicyConfig().setMode('fixed');
          this._layoutInformation.forcedMinimalHeight = 20;
          this._layoutInformation.forceMinimalMeasuredHeight = true;
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          this._svgElement = document.createElementNS("http://www.w3.org/2000/svg", "svg");
          this._svgElement.setAttribute("class", "gbc-label-text-container gbc_" + this.__name);
          this._svgElement.setAttribute("preserveAspectRatio", "none");
          this._svgElement.setAttribute("viewBox", "0 0 1000 1000");
          this._svgElement.setAttribute("width", "100%");
          this._svgElement.setAttribute("height", "100%");
          this._svgElement.setAttribute("overflow", "hidden");
          this._containerElement = document.createElementNS("http://www.w3.org/2000/svg", "g");
          this._containerElement.setAttribute("class", "containerElement");
          this._containerElement.setAttribute("transform", "matrix(1 0 0 -1 0 1000)");
          this._svgElement.appendChild(this._containerElement);
          this._element.appendChild(this._svgElement);
        },

        /**
         * @inheritDoc
         */
        manageMouseRightClick: function(domEvent) {
          domEvent.preventCancelableDefault();
          return false;
        },

        /**
         * @inheritDoc
         */
        _initContainerElement: function() {},

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._svgElement = null;
          $super.destroy.call(this);
        }

      };
    });
    cls.WidgetFactory.registerBuilder('Canvas', cls.CanvasWidget);
  }
);
;
"use strict";

modulum('AccordionFolderWidget', ['FolderWidgetBase'],
  /**
   * @param {gbc} context
   * @param {classes} cls
   */
  function(context, cls) {

    /**
     * Accordion Folder widget.
     * @class AccordionFolderWidget
     * @memberOf classes
     * @extends classes.FolderWidgetBase
     * @publicdoc Widgets
     */
    cls.AccordionFolderWidget = context.oo.Class(cls.FolderWidgetBase, function($super) {
      return /** @lends classes.AccordionFolderWidget.prototype */ {
        __name: "AccordionFolderWidget",

        /** @function */
        _pageVisibilityHandler: null,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);

          this._pageVisibilityHandler = this.when(gbc.constants.widgetEvents.pageVisibility, this.forceRelayout.bind(this));
          // Set the default value of the collapsers to the theme definition
          this.setCollapserPosition(gbc.ThemeService.getValue("gbc-AccordionFolderWidget-collapser-position"));
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._pageVisibilityHandler) {
            this._pageVisibilityHandler();
            this._pageVisibilityHandler = null;
          }

          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          this._layoutInformation = new cls.LayoutInformation(this);
          this._layoutEngine = new cls.AccordionFolderLayoutEngine(this);

          $super._initLayout.call(this);

        },

        /**
         * @inheritDoc
         */
        addChildWidget: function(widget, options) {

          options = options || {};
          options.noDOMInsert = true;

          /** @type classes.PageWidget */
          var pageWidget = widget;

          var titleWidget = pageWidget.getTitleWidget();

          var accordionElement = document.createElement("div");
          accordionElement.addClass("gbc_AccordionElement");
          accordionElement.addClass("g_measurable");

          var accordionPage = document.createElement("div");
          accordionPage.addClass("gbc_AccordionPage");
          accordionPage.addClass("g_measurable");

          accordionElement.appendChild(titleWidget.getElement());
          accordionPage.appendChild(pageWidget.getElement());
          accordionElement.appendChild(accordionPage);

          this.getContainerElement().appendChild(accordionElement);

          this.forceRelayout();

          $super.addChildWidget.call(this, widget, options);
        },

        /**
         * @inheritDoc
         */
        removeChildWidget: function(widget) {
          var accordionPage = widget.getElement().parentNode;
          // only current page is in DOM
          if (accordionPage) {
            var accordionElement = accordionPage.parentNode;
            accordionPage.remove();
            if (accordionElement) {
              accordionElement.remove();
            }
          }

          $super.removeChildWidget.call(this, widget);
        },

        /**
         * Force relayout of widget
         */
        forceRelayout: function() {
          this.getLayoutEngine().forceMeasurement();
          this.getLayoutEngine().invalidateMeasure();
        },

        /**
         * @inheritDoc
         */
        setCurrentPage: function(page, executeAction) {

          var accordionElement;
          var accordionPage;
          if (this._currentPage && this._currentPage !== page) {
            // remove currentPage class from previous current accordion page
            accordionPage = this._currentPage.getElement().parentNode;
            accordionElement = accordionPage.parentNode;
            accordionPage.removeClass("currentPage");
            accordionElement.removeClass("currentPage");
          }
          var modified = $super.setCurrentPage.call(this, page, executeAction);
          if (modified) {
            // add currentPage class to new current accordion page
            accordionPage = this._currentPage.getElement().parentNode;
            accordionElement = accordionPage.parentNode;
            accordionPage.addClass("currentPage");
            accordionElement.addClass("currentPage");
          }
          return modified;
        },

        /**
         * Define the position of the collapser
         * @param {string} pos - could be 'left' or 'right' (default)
         */
        setCollapserPosition: function(pos) {
          this.removeClass("collapser-position-left");
          this.removeClass("collapser-position-right");
          this.addClass("collapser-position-" + pos);
        }

      };
    });
    cls.WidgetFactory.registerBuilder("Folder[position=accordion]", cls.AccordionFolderWidget);
  });
;
"use strict";

modulum('BoxWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Box Widget
     * @publicdoc Widgets
     * @class BoxWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     */
    cls.BoxWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.BoxWidget.prototype */ {
        __name: "BoxWidget",
        _canSplit: null,
        _splitters: null,
        _splitterIdentifier: null,
        _ignoreStoredSettings: false,

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          this._splitters = [];
          $super.constructor.call(this, opts);
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._splitters) {
            for (var i = this._splitters.length - 1; i > -1; i--) {
              var currentChildren = this._splitters[i].widget;
              currentChildren.destroy();
              currentChildren = null;
            }
            this._splitters.length = 0;
          }
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        addChildWidget: function(widget, options) {
          if (!(widget instanceof cls.SplitterWidget)) {
            options = options || {
              position: ((this._children.length || -1) + 1) / 2
            };
            if (Object.isNumber(options.position)) {
              options.position = options.position * 2;
            }
            if (!!options.position) {
              var splitter = this._createSplitter();
              splitter.activateSplitter(this._canSplit);
              var onSplit = splitter.when(context.constants.widgetEvents.splitter, this._onSplit.bind(this));
              var onSplitStart = splitter.when(context.constants.widgetEvents.splitterStart, this._onSplitStart.bind(this));
              var onSplitEnd = splitter.when(context.constants.widgetEvents.splitterEnd, this._onSplitEnd.bind(this));
              this.addChildWidget(splitter, {
                position: options.position - 1
              });
              this._splitters.splice(options.position / 2, 0, {
                widget: splitter,
                onSplit: onSplit,
                onSplitStart: onSplitStart,
                onSplitEnd: onSplitEnd
              });
            }
          }
          $super.addChildWidget.call(this, widget, options);
        },

        /**
         * Create a splitter widget
         * @return {classes.SplitterWidget} the created splitter widget
         * @protected
         */
        _createSplitter: function() {
          return null;
        },

        /**
         * _onSplit
         * @param {classes.Event} event the event
         * @param {classes.EventListener} sender the sender
         * @param {*} delta the delta value
         * @private
         */
        _onSplit: function(event, sender, delta) {
          this._layoutEngine.splitting(delta);
          this.emit(context.constants.widgetEvents.splitter);
        },

        /**
         * _onSplitStart
         * @param {classes.Event} event the event
         * @param {classes.EventListener} sender the sender
         * @private
         */
        _onSplitStart: function(event, sender) {
          this._layoutEngine.startSplitting((this._children.indexOf(sender) - 1) / 2);
        },

        /**
         * _onSplitEnd
         * @param {classes.Event} event the event
         * @param {classes.EventListener} sender the sender
         * @private
         */
        _onSplitEnd: function(event, sender) {
          this._layoutEngine.stopSplitting();
          if (!this._ignoreStoredSettings) {
            context.StoredSettingsService.setSplitter(this._splitterIdentifier.formName,
              this._splitterIdentifier.id, this._layoutEngine._referenceSplitHints);
          }
        },

        /**
         * @inheritDoc
         */
        removeChildWidget: function(widget) {
          if (!(widget instanceof cls.SplitterWidget)) {
            var pos = this._children.indexOf(widget) - 1;
            if (pos > 0) {
              this._children[pos].destroy();
            }
          } else {
            var item = this._splitters.find(function(item) {
              return item.widget === widget;
            });
            if (item) {
              item.onSplit();
              item.onSplitStart();
              item.onSplitEnd();
              this._splitters.remove(item);
            }
          }
          $super.removeChildWidget.call(this, widget);
        },

        /**
         * @inheritDoc
         */
        _addChildWidgetToDom: function(widget, position) {
          this.getLayoutEngine().registerChild(widget, position);
          var widgetHost = document.createElement('div');
          widgetHost.addClass('g_BoxElement');
          widget.getLayoutInformation().setHostElement(widgetHost);
          widgetHost.appendChild(widget._element);
          widgetHost.insertAt(position, this._containerElement);
        },

        /**
         * @inheritDoc
         */
        _removeChildWidgetFromDom: function(widget) {
          this.getLayoutEngine().unregisterChild(widget);
          var info = widget.getLayoutInformation(),
            host = info && info.getHostElement();
          if (host && host.parentNode === this._containerElement) {
            widget._element.remove();
            host.remove();
            host = null;
          }
        },

        /**
         * getIndexOfChild
         * @param {classes.WidgetBase} widget the widget
         * @return {number} the index
         */
        getIndexOfChild: function(widget) {
          if (!(widget instanceof cls.SplitterWidget)) {
            return this._children.indexOf(widget) / 2;
          } else {
            return this._children.indexOf(widget);
          }
        },

        /**
         * ignoreStoredSettings
         * @param {boolean} ignore ignore stored settings
         */
        ignoreStoredSettings: function(ignore) {
          this._ignoreStoredSettings = !!ignore;
        },

        /**
         * Initialize splitter layout engine hints
         */
        initSplitterLayoutEngine: function() {
          if (!this._ignoreStoredSettings) {
            if (this._layoutEngine.initSplitHints) {
              this._layoutEngine.initSplitHints(context.StoredSettingsService.getSplitter(
                this._splitterIdentifier.formName, this._splitterIdentifier.id));
            }
          }
        },

        /**
         * switchSplitters
         * @param {boolean} canSplit can split
         * @param {*} splitterId splitter id
         */
        switchSplitters: function(canSplit, splitterId) {
          if (this._canSplit !== canSplit) {
            this._splitterIdentifier = splitterId;

            this.initSplitterLayoutEngine();

            this._canSplit = canSplit;
            for (var i = 0; i < this._splitters.length; i++) {
              this._splitters[i].widget.activateSplitter(this._canSplit);
            }
          }
        }
      };
    });
    cls.WidgetFactory.registerBuilder('Box', cls.BoxWidget);
  });
;
"use strict";

modulum('ChoiceDropDownWidget', ['DropDownWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Choice DropDown widget.
     * @class ChoiceDropDownWidget
     * @memberOf classes
     * @extends classes.DropDownWidget
     */
    cls.ChoiceDropDownWidget = context.oo.Class(cls.DropDownWidget, function($super) {
      return /** @lends classes.ChoiceDropDownWidget.prototype */ {
        $static: {
          widgetEvents: {
            currentChildrenChange: "currentChildrenChange",
          }
        },
        __name: "ChoiceDropDownWidget",
        __templateName: "DropDownWidget",
        /**
         * Indicated if dropdown can handle a multiple items selection. In this case dropdown isn't closed on item click
         * @type {boolean}
         */
        _allowMultipleChoices: false,
        /**
         * Current highlighted & selected element
         * @type {HTMLElement}
         */
        _currentElement: null,

        /**
         * @inheritDoc
         */
        _initContainerElement: function() {
          $super._initContainerElement.call(this);

          // on dropdown close reset current children selected
          this.onClose(function() {
            this.setCurrentPosition(null);
          }.bind(this));

          if (!window.isMobile()) {
            this._element.on('mouseover.ChoiceDropDownWidget', this._onHover.bind(this));
          } else {
            this._element.on('touchstart.ChoiceDropDownWidget', this._onHover.bind(this));

          }
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (!window.isMobile()) {
            this._element.off('mouseover.ChoiceDropDownWidget');
          } else {
            this._element.off('touchstart.ChoiceDropDownWidget');
          }

          if (this.getChildren() && this.getChildren().length > 0) {
            console.warn("We are destroying " + this.getParentWidget().__name +
              " DropDown whereas it still has children. We will automatically destroy children. Please verify how DropDown has been implemented as this may be a side effect."
            );
            this.destroyChildren();
          }

          $super.destroy.call(this);
        },

        /**
         * Mouse/touch handler used to highlight current item.
         * We can't use css :hover otherwise there will be duplicated highlights with keyboard navigation
         * @param event
         * @private
         */
        _onHover: function(event) {
          var element = event.target;
          if (element) {
            var widgetElement = element.hasClass("gbc_WidgetBase") ? element : element.parent("gbc_WidgetBase");
            this._highlightCurrentItem(widgetElement);
          }
        },

        /**
         * @inheritDoc
         */
        managePriorityKeyDown: function(keyString, domKeyEvent, repeat) {
          var keyProcessed = false;

          if (this.isVisible()) {
            keyProcessed = true;
            switch (keyString) {
              case "enter":
              case "return":
                this._onClick(null, this.getCurrentChildren());
                break;
              case "up":
                this.navigateTo(-1);
                break;
              case "down":
                this.navigateTo(1);
                break;
              case "pageup":
                this.navigateTo(-10);
                break;
              case "pagedown":
                this.navigateTo(10);
                break;
              case "home":
                this.navigateTo(Number.NEGATIVE_INFINITY);
                break;
              case "end":
                this.navigateTo(Number.POSITIVE_INFINITY);
                break;
              default:
                keyProcessed = false;
            }
          }
          keyProcessed = $super.managePriorityKeyDown.call(this, keyString, domKeyEvent, repeat) || keyProcessed;
          return keyProcessed;
        },

        /**
         * Navigate through a dropdown item using step number. Main method used in keyboard navigation
         * @param {number} pos - position of the item to select
         * @publicdoc
         */
        navigateTo: function(pos) {
          var nextChild = null;
          // get new item position
          var newPos = this.getIndexOfChild(this.getCurrentChildren()) + pos;
          // if new item position if outside of limits
          if (newPos < 0 || newPos > (this.getChildren().length - 1)) {
            // we fallback to first or last item
            if (newPos < 0) {
              newPos = 0;
            } else {
              newPos = this.getChildren().length - 1;
            }
            nextChild = this.getChildren()[newPos];
            // if first or last item isn't focusable, then we end the navigation
            if (!nextChild.isEnabled() || nextChild.isHidden()) {
              return;
            }
          } else {
            // get new item
            nextChild = this.getChildren()[newPos];
          }
          // if new item isn't focusable, we continue navigation
          if (!nextChild.isEnabled() || nextChild.isHidden()) {
            return this.navigateTo(pos < 0 ? pos - 1 : pos + 1);
          }

          // new item validated
          this.setCurrentPosition(nextChild);
          if (!this.isVisible()) {
            this.emit(context.constants.widgetEvents.select, this.getCurrentValue());
          }
        },

        /**
         * Update selected item (highlight + position update + childrenChange emit)
         * @param {classes.WidgetBase} currentChildren
         * @publicdoc
         */
        setCurrentPosition: function(currentChildren) {
          if (currentChildren !== null) {
            this._highlightCurrentItem(currentChildren.getElement());
            this.scrollItemIntoView(currentChildren.getElement());
            this.getParentWidget().emit(cls.ChoiceDropDownWidget.widgetEvents.currentChildrenChange, currentChildren);
          } else {
            this._highlightCurrentItem(null);
          }
        },

        /**
         * Highlight current item of the dropdown
         * @param widgetElement
         * @private
         */
        _highlightCurrentItem: function(widgetElement) {
          if (this._currentElement && this._currentElement !== widgetElement) {
            this._currentElement.removeClass("current");
          }
          this._currentElement = widgetElement;
          if (this._currentElement &&
            !this._currentElement.hasClass("current") &&
            !this._currentElement.hasClass("hidden") &&
            (!this._currentElement.hasClass("disabled") || this._currentElement.hasAttribute("interruptable-active"))) {
            this._currentElement.addClass("current");
          }
        },

        /**
         * Returns current widget element being selected (flagged with 'current' class)
         * @returns {?Element} The current child DOM element
         * @publicdoc
         */
        getCurrentElement: function() {
          return this._currentElement;
        },

        /**
         * Scroll to element if needed
         * @param {HTMLElement} element element
         * @publicdoc
         */
        scrollItemIntoView: function(element) {
          var elemTop = element.offsetTop;
          var elemHeight = element.offsetHeight;
          var parentContainer = this.getElement();
          var containerTop = parentContainer.scrollTop;
          var containerHeight = parentContainer.offsetHeight;
          if (containerTop > elemTop) {
            element.scrollIntoView();
          } else if (containerTop + containerHeight < elemTop + elemHeight) {
            element.scrollIntoView(false);
          }
        },

        /**
         * Returns position of value in dropdown choices list
         * @param {*} value
         * @returns {number}
         * @publicdoc
         */
        getValueIndex: function(value) {
          var children = this.getChildren();
          for (var i = 0; i < children.length; i++) {
            var child = children[i];
            if (child.getValue && child.getValue() === value) {
              return i;
            }
          }
          return -1;
        },

        /**
         * Bind handler which is executed each time a dropdown item is selected
         * @param {Hook} hook
         * @returns {HandleRegistration} bound handler
         * @publicdoc
         */
        onCurrentChildrenChange: function(hook) {
          return this.getParentWidget().when(cls.ChoiceDropDownWidget.widgetEvents.currentChildrenChange, hook);
        },

        /**
         * On click handler raised when selecting an item in the dropdown :
         * Parent widget get value of clicked item and dropdown is closed.
         * @param event
         * @param sender
         * @param domEvent
         * @private
         */
        _onClick: function(event, sender, domEvent) {
          if (sender && sender.getValue) {
            var value = sender.getValue();
            var parentWidget = this.getParentWidget();
            if (parentWidget && parentWidget.setEditing) {
              parentWidget.setEditing(true);
              if (parentWidget._setMultiValue) {
                parentWidget._setMultiValue(value);
              } else if (parentWidget.setValue) {
                parentWidget.setValue(value);
              }
            }
          }
          if (domEvent) {
            domEvent.stopPropagation();
          }
          if (!this._allowMultipleChoices) {
            this.hide();
          }

          this.getParentWidget().emit(context.constants.widgetEvents.focus, event);
          if (sender && sender.ddOnClickCallback) {
            sender.ddOnClickCallback();
          }
        },

        /**
         * @inheritDoc
         */
        addChildWidget: function(widget, options) {
          $super.addChildWidget.call(this, widget, options);
          this._bindClickToItem(widget, options);
        },

        /**
         * @inheritDoc
         */
        adoptChildWidget: function(widget, options) {
          $super.adoptChildWidget.call(this, widget, options);
          this._bindClickToItem(widget, options);
        },

        /**
         * Bind clicks handlers to dropdown item widget and flag it as being inside dropdown
         * @param {classes.WidgetBase} widget - item widget
         * @param {object} options - addChildWidget/adoptChildWidget option paramaters
         * @private
         */
        _bindClickToItem: function(widget, options) {
          widget.isInDropDown = true;
          widget.ddOnClickCallback = options && options.clickCallback;
          widget._clickHandlerFromChoiceDropDown = widget.when(context.constants.widgetEvents.click, function(event, sender,
            domEvent) {
            this._onClick.call(this, event, widget, domEvent);
          }.bind(this));
        },

        /**
         * @inheritDoc
         */
        removeChildWidget: function(widget) {
          if (widget) {
            if (widget._clickHandlerFromChoiceDropDown) {
              widget._clickHandlerFromChoiceDropDown();
              widget._clickHandlerFromChoiceDropDown = null;
            }
            widget.ddOnClickCallback = null;
            widget.isInDropDown = false;
          }
          $super.removeChildWidget.call(this, widget);
        },

        /**
         * @inheritDoc
         */
        show: function(multiple) {
          if (this.getChildren().length > 0) {
            $super.show.call(this, multiple);
            if (this.getParentWidget().getValue) {
              var defaultValue = this.getParentWidget().getValue();
              var index = this.getValueIndex(defaultValue);
              if (index !== -1) {
                this.setCurrentPosition(this.getChildren()[index]);
              }
            }
          }
        },

        /**
         * set whether or not this list will accept multiple values
         * @param {boolean} allow allow
         * @publicdoc
         */
        allowMultipleChoices: function(allow) {
          this._allowMultipleChoices = allow;
        }
      };
    });
    cls.WidgetFactory.registerBuilder('ChoiceDropDown', cls.ChoiceDropDownWidget);
  });
;
"use strict";

modulum('CompleterWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Manages a dropdown attached to an edit to provide predefined choices
     * @class CompleterWidget
     * @memberOf classes
     * @extends classes.WidgetBase
     * @publicdoc Widgets
     */
    cls.CompleterWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.CompleterWidget.prototype */ {
        __name: "CompleterWidget",
        /**
         * Dropdown used to display completer items
         * @type {classes.ChoiceDropDownWidget}
         */
        _dropDown: null,
        /**
         * Flag to indicate of completer results are visible or not
         * @type {boolean}
         */
        _isVisible: null,
        /**
         * Completer size
         * @type {number}
         */
        _size: 0,
        /**
         * Completer delay in ms to display its results
         * @type {number}
         */
        _completerDelay: 50,
        /**
         * Completer input element
         * @type {HTMLElement}
         */
        _input: null,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          this._dropDown = cls.WidgetFactory.createWidget("ChoiceDropDown", this.getBuildParameters());
          this._dropDown.setParentWidget(this);
          this._dropDown.autoSize = true;
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._dropDown.destroy();
          this._dropDown = null;
          this._input = null;
          $super.destroy.call(this);
        },

        /**
         * Add a completer to the parent widget
         * @param {classes.WidgetBase} parentWidget to which is attached completer
         * @publicdoc
         */
        addCompleterWidget: function(parentWidget) {
          this.setParentWidget(parentWidget);

          var parentElement = parentWidget.getElement();
          parentElement.parentNode.insertBefore(this.getElement(), parentElement.nextSibling);

          this._input = parentWidget.getElement().getElementsByTagName("input")[0];

          // set edit input of parent widget as parent element
          if (this._dropDown) {
            this._dropDown.parentElement = this._input;
          }
        },

        /**
         * @inheritDoc
         */
        managePriorityKeyDown: function(keyString, domKeyEvent, repeat) {
          var keyProcessed = false;

          if (this.isVisible()) {
            switch (keyString) {
              case "esc":
              case "enter":
              case "return":
              case "up":
              case "down":
              case "pageup":
              case "pagedown":
                keyProcessed = this._dropDown.managePriorityKeyDown(keyString, domKeyEvent, repeat);
                break;
              case "tab":
              case "shift+tab":
                this.hide();
                break;

            }
          }
          return keyProcessed;
        },

        /**
         * Bind handler which is executed each time a completer item is selected
         * @param {Hook} hook - function to execute each time a completer item is selected (we pass item value in parameter of the hook)
         * @returns {HandleRegistration} bound handler
         * @publicdoc
         */
        onCurrentChildrenChange: function(hook) {
          return this._dropDown.onCurrentChildrenChange(function(evt, parent, children) {
            hook(children.getValue());
          });
        },

        /**
         * @inheritDoc
         */
        isReversed: function() {
          return this._parentWidget.isReversed();
        },

        /**
         * @inheritDoc
         */
        isVisible: function() {
          return this._dropDown.isVisible();
        },

        /**
         * Add item label in dropdown
         * @param {string} choice - item label to be displayed
         * @publicdoc
         */
        addChoice: function(choice) {
          var label = cls.WidgetFactory.createWidget("Label", this.getBuildParameters());
          label.setValue(choice);
          this._dropDown.addChildWidget(label, {
            clickCallback: function() {
              this.getParentWidget().setFocus();
            }.bind(this)
          });
        },

        /**
         * Remove all items from dropdown
         * @publicdoc
         */
        clearChoices: function() {
          this._dropDown.destroyChildren();
        },

        /**
         * Set completer items size
         * @param {number} size - size of the completer
         * @publicdoc
         */
        setSize: function(size) {
          this._size = size;
        },

        /**
         * Return completer items size
         * @returns {number} completer size
         * @publicdoc
         */
        getSize: function() {
          return this._size;
        },

        /**
         * Returns completer current input value
         * @returns {string} completer value
         * @publicdoc
         */
        getValue: function() {
          return this.getParentWidget().getValue();
        },

        /**
         * Set current completer input value
         * @param {string} value - value to set in completer
         * @param {boolean} fromVM - indicates if we set value from VM order or not
         * @publicdoc
         */
        setValue: function(value, fromVM) {
          this.getParentWidget().setValue(value, fromVM);
        },

        /**
         * @inheritDoc
         */
        setEditing: function(b) {
          this.getParentWidget().setEditing(b);
        },

        /**
         * @inheritDoc
         */
        hasVMFocus: function() {
          var parent = this.getParentWidget();
          return parent.hasVMFocus() || parent.getParentWidget().hasVMFocus();
        },

        /**
         * Show completer results
         * @publicdoc
         */
        show: function() {
          this._registerTimeout(this._show.bind(this, true), this._completerDelay);
        },

        /**
         * Hide completer results
         * @publicdoc
         */
        hide: function() {
          this._registerTimeout(this._show.bind(this, false), this._completerDelay);
        },

        /**
         * Internal method to show/hide completer results
         * @param visibility
         * @private
         */
        _show: function(visibility) {
          if (this._dropDown) {
            if (visibility === true) {
              if (!this.hasVMFocus()) {
                return;
              }
              var element = this.getParentWidget().getElement();
              if (element) {
                this._dropDown.x = element.getBoundingClientRect().left;
                this._dropDown.width = element.getBoundingClientRect().width;
              }
              this._dropDown.show();
            } else {
              this._dropDown.hide();
            }
          }
        }
      };
    });
    cls.WidgetFactory.registerBuilder('Completer', cls.CompleterWidget);
  });
;
"use strict";

modulum('ContextMenuWidget', ['ChoiceDropDownWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * ContextMenu DropDown widget.
     * @class ContextMenuWidget
     * @memberOf classes
     * @extends classes.DropDownWidget
     */
    cls.ContextMenuWidget = context.oo.Class(cls.ChoiceDropDownWidget, function($super) {
      /** @lends classes.ContextMenuWidget.prototype */
      return {
        __name: "ContextMenuWidget",
        __templateName: "DropDownWidget",

        /** @type {Map<string, classes.MenuLabelWidget|classes.HLineWidget>} */
        _actionWidgets: null,
        /** @type {Map<string, classes.MenuLabelWidget|classes.HLineWidget>} */
        _extraActionWidgets: null,

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          this._ignoreLayout = true;
          $super._initElement.call(this);
        },

        /**
         * @inheritDoc
         */
        _initContainerElement: function() {
          $super._initContainerElement.call(this);

          this._actionWidgets = new Map();
          this._extraActionWidgets = new Map();

          this.allowMultipleChoices(true);
          this.getElement().addClass("menu");
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          // no layout
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          $super.destroy.call(this);

          this.removeAndDestroyActions();
          this._actionWidgets = null;
          this._extraActionWidgets = null;
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          if (!domEvent.target.elementOrParent("gbc_CheckBoxWidget")) { // if click is not on a checkbox
            this.hide(); // hide context menu
          }
          return false;
        },

        /**
         * @inheritDoc
         */
        managePriorityKeyDown: function(keyString, domKeyEvent, repeat) {
          var keyProcessed = false;

          if (this.isVisible()) {
            switch (keyString) {
              case "tab":
              case "shift+tab":
                this.hide();
                break;
              case "space":
                var currentChild = this.getCurrentChildren();
                if (currentChild.getName() === "CheckBoxWidget") {
                  currentChild.manageMouseClick(null);
                } else {
                  this._onClick(null, currentChild);
                }
                keyProcessed = true;
                break;
            }
          }

          if (!keyProcessed) {
            keyProcessed = $super.managePriorityKeyDown.call(this, keyString, domKeyEvent, repeat);
          }
          return keyProcessed;
        },

        /**
         * Remove and destroy all actions widgets
         * @param {boolean} [onlyExtra] - if true remove only extra actions else remove all
         */
        removeAndDestroyActions: function(onlyExtra) {

          // remove extra actions widgets
          this._extraActionWidgets.forEach(function(value, key) {
            this.removeAndDestroyAction(key, true);
          }.bind(this));
          this._extraActionWidgets.clear();

          if (!onlyExtra) {
            // remove other actions widgets
            this._actionWidgets.forEach(function(value, key) {
              this.removeAndDestroyAction(key, false);
            }.bind(this));
            this._actionWidgets.clear();
          }
        },

        /**
         * Remove and destroy one action widget
         * @param {string} actionName - name of the action
         * @param {boolean} extra - is action in the extra actions ?
         */
        removeAndDestroyAction: function(actionName, extra) {
          var widgets = this._actionWidgets;
          if (extra) {
            widgets = this._extraActionWidgets;
          }
          var actionWidget = widgets.get(actionName);
          if (!!actionWidget) {
            if (!actionWidget._destroyed) {
              actionWidget.destroy();
            }
            widgets.delete(actionName);
          }
        },

        /**
         * Add/create one action (widget) in the contextmenu
         * @param {string} actionName - name
         * @param {string} actionText - text
         * @param {string} actionImage - image
         * @param {string} actionAccelerator - accelerator of the action
         * @param {Object} opts - actions options
         * @param {boolean} extra - is it an extra actions ?
         */
        addAction: function(actionName, actionText, actionImage, actionAccelerator, opts, extra) {
          var widgets = this._actionWidgets;
          if (extra) {
            widgets = this._extraActionWidgets;
            if (this._extraActionWidgets.size === 0 && this.hasVisibleAction()) {
              // before the first extra action add a separator
              this.addSeparator(extra);
            }

          }
          var actionWidget = widgets.get(actionName);

          if (!actionWidget) {
            if (actionText.length > 0) {
              actionWidget = cls.WidgetFactory.createWidget("MenuLabel", this.getBuildParameters());
              actionWidget.setText(actionText);
              if (actionImage) {
                actionWidget.setImage(actionImage);
              }
              if (actionAccelerator) {
                if (window.browserInfo.isSafari) {
                  actionAccelerator.replace("Control", "")
                    .replace("-", "");
                } else {
                  actionAccelerator.replace("-", "+")
                    .replace("Control", "Ctrl");
                }
                actionWidget.setComment(actionAccelerator);
              }
              if (opts.disabled) {
                actionWidget.setEnabled(false);
              }
              if (opts.hidden) {
                actionWidget.setHidden(opts.hidden);
              }

              widgets.set(actionName, actionWidget);
              this.addChildWidget(actionWidget, opts);
            }
          } else {
            // if action already exists just show it
            actionWidget.setHidden(false);
          }
        },

        /**
         * Returns if there is at least one visible action
         * @returns {boolean} true if there is at least one visible actions
         */
        hasVisibleAction: function() {
          var visible = false;
          for (var i = 0; i < this.getChildren().length; i++) {
            if (this.getChildren()[i].isVisible()) {
              visible = true;
              break;
            }
          }
          return visible;
        },

        /**
         * Add separator
         * @param {boolean} extra - add it in extra action list ??
         */
        addSeparator: function(extra) {
          var widgets = this._actionWidgets;
          var line = cls.WidgetFactory.createWidget("HLine", this.getBuildParameters());
          line.setEnabled(false);
          if (extra) {
            widgets = this._extraActionWidgets;
            widgets.set(line.getRootClassName(), line);
          }
          this.addChildWidget(line);
        }
      };
    });
    cls.WidgetFactory.registerBuilder('ContextMenu', cls.ContextMenuWidget);
  });
;
"use strict";

modulum('DropDownWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * DropDown widget.
     * @class DropDownWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     * @publicdoc
     */
    cls.DropDownWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.DropDownWidget.prototype */ {
        __name: "DropDownWidget",

        $static: {
          widgetEvents: {
            dropDownOpen: "dropDownOpen",
            dropDownClose: "dropDownClose"
          },
          /**
           * Static list of current dropdowns instances being displayed
           * @type {Array}
           */
          displayedDropDowns: [],
          /**
           * Returns true if at least one dropdown is being displayed
           * @returns {boolean}
           * @publicdoc
           */
          hasAnyVisible: function() {
            return cls.DropDownWidget.displayedDropDowns.length > 0;
          },
          /**
           * Return current active dropdown
           * @returns {classes.DropDownWidget}
           * @publicdoc
           */
          getActiveDropDown: function() {
            return cls.DropDownWidget.displayedDropDowns[cls.DropDownWidget.displayedDropDowns.length - 1];
          },
          /**
           * Hide and remove all active dropdowns from DOM
           */
          hideAll: function() {
            while (cls.DropDownWidget.displayedDropDowns.length) {
              cls.DropDownWidget.displayedDropDowns.pop().remove();
            }
          },
          /**
           * Returns true if targeted element is contained in one of the current displayed dropdowns
           * @param {HTMLElement} targetElement
           * @returns {boolean}
           * @publicdoc
           */
          isChildOfDropDown: function(targetElement) {
            var inDropDown = false;
            for (var i = 0; i < cls.DropDownWidget.displayedDropDowns.length; i++) {
              var dropdown = cls.DropDownWidget.displayedDropDowns[i];
              if (dropdown.getElement().contains(targetElement) || !dropdown.shouldClose(targetElement)) {
                inDropDown = true;
                break;
              }
            }
            return inDropDown;
          },
          /**
           * Returns true if targeted element is contained in one of the current displayed dropdowns or is dropdown associated widget element
           * @param {HTMLElement} targetElement
           * @returns {boolean}
           * @publicdoc
           */
          isChildOrParentOfDropDown: function(targetElement) {
            var inDropDown = false;
            for (var i = 0; i < cls.DropDownWidget.displayedDropDowns.length; i++) {
              var dropdown = cls.DropDownWidget.displayedDropDowns[i];
              if (dropdown.getElement().contains(targetElement) || dropdown.getParentWidget().getElement().contains(
                  targetElement) || !dropdown.shouldClose(targetElement)) {
                inDropDown = true;
                break;
              }
            }
            return inDropDown;
          }
        },
        /**
         * Flag to indicate if dropdown should size accordingly to its parent element (parent element width aligned) with a maximum allowed height (afterwards dropdown is vertically scrollable)
         * By default no.
         * @type {boolean}
         * @publicdoc
         */
        autoSize: false,
        /**
         * Default min width of the dropdown
         * @type {number}
         */
        _defaultMinWidth: 0,
        /**
         * Default max height of the dropdown
         * @type {number}
         */
        _defaultMaxHeight: 0,
        /**
         * Flag to position dropdown using right-to-left basis (ex: arabic).
         * Take note that to have a full right-to-left mode the parent widget need to be set as reversed using setReverse method
         * By default its left-to-right positioned.
         * @type {boolean}
         * @publicdoc
         */
        reverseX: false,
        /**
         * Flag to position dropdown below its corresponding widget or above it.
         * By default its positioned below it.
         * @type {boolean}
         * @publicdoc
         */
        reverseY: false,
        /**
         * Private flag set to true if we detected a need to reverse horizontal dropdown position (because of an overflow or if public reverseX attribute is set to true)
         * @type {boolean}
         * @private
         */
        __reverseX: false,
        /**
         * Private flag set to true if we detected a need to reverse vertical dropdown position (because of an overflow or if public reverseY attribute is set to true)
         * @type {boolean}
         * @private
         */
        __reverseY: false,
        /**
         * Horizontal absolute position.
         * It replace default widget relative positioning if not null.
         * @type {?number}
         * @publicdoc
         */
        x: null,
        /**
         * Vertical absolute position of the dropdown.
         * It replace default widget relative positioning if not null.
         * @type {?number}
         * @publicdoc
         */
        y: null,
        /**
         * Set no height
         */
        _fullHeight: false,
        /**
         * Minimum width of the dropdown to use if not null.
         * @type {?number}
         * @publicdoc
         */
        minWidth: null,
        /**
         * Maximum width of the dropdown to use if not null.
         * @type {?number}
         * @publicdoc
         */
        maxWidth: null,
        /**
         * Maximum height of the dropdown to use if not null.
         * @type {?number}
         * @publicdoc
         */
        maxHeight: null,
        /**
         * Parent element to use to measure and position DropDown instead of default one (default one is parent widget element).
         * @type {HTMLElement}
         * @publicdoc
         */
        parentElement: null,
        /**
         * Custom rendering function to use instead of integrated one to measure and render the dropdown.
         * The function is null by default.
         * @type {Function}
         * @publicdoc
         */
        renderFunction: null,
        /**
         * Dropdown open/close bound handlers
         * @function
         */
        _handlers: null,

        /**
         * Dropdown container
         * @type {HTMLElement}
         */
        _container: null,

        /**
         * Flags current class as being a dropdown. Can be useful to know if a parent widget is dropdown
         * @type {boolean}
         * @publicdoc
         */
        isDropDown: true,

        _stylingContext: "widget",

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          this._defaultMinWidth = parseFloat(window.gbc.ThemeService.getValue("gbc-DropDownWidget-min-width"));
          this._defaultMaxHeight = parseFloat(window.gbc.ThemeService.getValue("gbc-DropDownWidget-max-height"));
        },

        /**
         * @inheritDoc
         */
        _initContainerElement: function() {
          $super._initContainerElement.call(this);

          this._handlers = [];

          this._container = window.document.getElementsByClassName("gbc_DropDownContainerWidget")[0];

          // on window close we emit dropdown close event
          this._handlers.push(this.when(context.constants.widgetEvents.close, this.closeRequest.bind(this)));

          // update aria selection on dropdown open/close
          this.onOpen(function() {
            this.setAriaSelection();
          }.bind(this));

          this.onClose(function() {
            this._parentWidget.setAriaSelection();
          }.bind(this));
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this.hide();

          if (this._handlers) {
            for (var i = 0; i < this._handlers.length; i++) {
              this._handlers[i]();
            }
            this._handlers.length = 0;
          }
          this.unbindListeners();

          if (this._parentWidget && this._parentWidget.removeChildWidget) {
            this._parentWidget.removeChildWidget(this);
          }
          this._parentWidget = null;
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        managePriorityKeyDown: function(keyString, domKeyEvent, repeat) {
          var keyProcessed = false;
          if (this.isVisible()) {
            // if dropdown is open, all keys are prevented (no accelerator can be executed during dropdown display)
            switch (keyString) {
              case "enter":
              case "return":
              case "esc":
                this.hide();
                keyProcessed = true;
                break;

            }
          }

          return keyProcessed;
        },

        /**
         * Bind an handler executed when dropdown is displayed
         * @param {Hook} hook the hook to fire
         * @returns {HandleRegistration} return handler to unbind reference
         */
        onOpen: function(hook) {
          this._handlers.push(this.when(cls.DropDownWidget.widgetEvents.dropDownOpen, hook));
          return this._handlers[this._handlers.length - 1];
        },

        /**
         * Bind an handler executed when dropdown is closed
         * @param {Hook} hook the hook to fire
         * @returns {HandleRegistration} return handler to unbind reference
         */
        onClose: function(hook) {
          this._handlers.push(this.when(cls.DropDownWidget.widgetEvents.dropDownClose, hook));
          return this._handlers[this._handlers.length - 1];
        },

        openRequest: function() {
          this.emit(cls.DropDownWidget.widgetEvents.dropDownOpen);
        },

        closeRequest: function() {
          this.emit(cls.DropDownWidget.widgetEvents.dropDownClose);
        },

        /**
         * Let dropdown hide on click (if outside of dropdown and widget), scroll events or dragAndDrop events.
         * Setting this method to null will cancel auto hide of the dropdown
         * @publicdoc
         */
        bindListeners: function() {
          //this._hideHandler = this.hide.bind(this);
          if (this._hideHandler) {
            this._hideHandler(); // removeEventListener
            this._hideHandler = null;
          }
          if (!window.isMobile()) {
            this._hideHandler = context.HostService.onScreenResize(this.hide.bind(this));
          } else {
            this._hideHandler = context.HostService.onOrientationChange(this.hide.bind(this));
          }
        },

        /**
         * Unbind events and listeneners used to auto hide dropdown
         * @publicdoc
         */
        unbindListeners: function() {
          if (this._hideHandler && !cls.DropDownWidget.hasAnyVisible()) {
            this._hideHandler(); // removeEventListener
            this._hideHandler = null;
          }
        },

        /**
         * Hide all displayed dropdowns
         * @publicdoc
         */
        hide: function() {
          cls.DropDownWidget.hideAll();
        },

        /**
         * Remove current dropdown fro DOM. Use hide method to close dropdown instead as much as possible
         */
        remove: function() {
          // first thing to do is update active dropdowns list which is checked and used in following methods
          cls.DropDownWidget.displayedDropDowns.remove(this);
          this._setVisible(false);

          // unbind handlers & remove overlay when no more dropdowns are visible
          if (!cls.DropDownWidget.hasAnyVisible()) {
            context.OverlayService.disable("dropdown");
            this.unbindListeners();
          }

          this.removeDropDown();
          this.closeRequest();

          // update current dropdown being focused
          var activeDropDown = cls.DropDownWidget.getActiveDropDown();
          var session = context.SessionService.getCurrent();
          if (session) {
            var app = session.getCurrentApplication();
            if (app) {
              app.focus.setFocusedDropDownWidget(activeDropDown ? activeDropDown.getParentWidget() : null);
            }
          }
          this.getParentWidget().emit(context.constants.widgetEvents.close);
        },

        /**
         * Show the widget dropdown
         * @param {boolean} multiple - if true we do not hide previous displayed dropdowns (ex: sub menus).
         * @publicdoc
         */
        show: function(multiple) {
          if (!this.isVisible()) {
            if (!multiple) {
              this.hide();
            }
            // set visible (remove parent class hidden) before dropdown measuring
            this._setVisible(true);

            // bind handlers & add overlay on first dropdown display
            if (!cls.DropDownWidget.hasAnyVisible()) {
              var currentWindow = context.HostService.getCurrentWindow();
              var windowContainer = currentWindow ? currentWindow.getWindowMiddleContainer() : null;
              context.OverlayService.enable("dropdown", windowContainer);
              this.bindListeners();
            }
            // dropdown rendering (measure & positioning method)
            this.addDropDown();
            this.openRequest();

            // update current focused dropdown
            cls.DropDownWidget.displayedDropDowns.push(this);
            var session = context.SessionService.getCurrent();
            if (session) {
              var app = session.getCurrentApplication();
              if (app) {
                app.focus.setFocusedDropDownWidget(this.getParentWidget());
              }
            }
          }
        },

        /**
         * Toggle dropdown display
         * @param {boolean} show - force display if set to true, hide if set to false
         * @returns {boolean} returns dropdown visibility
         * @publicdoc
         */
        toggle: function(show) {
          if (this.isVisible() || show === false) {
            this.hide();
          } else if (!this.isVisible() || show === true) {
            this.show();
          }
        },

        /**
         * Check & update main dropdown container visibility on dropdown display/hide
         * @param {boolean} visible - wanted visibility
         * @private
         */
        _setVisible: function(visible) {
          if (this._container) {
            if (visible) {
              if (this._container.hasClass("hidden")) {
                this._container.removeClass("hidden");
              }
            } else {
              // only hide dropdowns container is we removed last dropdown child from it
              if (!cls.DropDownWidget.hasAnyVisible() && !this._container.hasClass("hidden")) {
                this._container.addClass("hidden");
              }
            }
          }
          this._isVisible = visible;
          // flag widget as expanded for aria attribute
          this.getParentWidget().setAriaAttribute("expanded", visible.toString());
          // emit a visibility change notification on the dropdown
          this.emit(context.constants.widgetEvents.visibilityChange, visible);
          gbc.LogService.ui.log("DropDown open", visible, this.__name, this);
        },

        /**
         * Indicate if dropdown if currently visible or not
         * @returns {boolean} true if dropdown if currently visible
         * @publicdoc
         */
        isVisible: function() {
          return this._isVisible;
        },

        /**
         * Explicitly focus dropdown element
         * @publicdoc
         */
        focus: function() {
          this._element.focus();
        },

        /**
         * Set content of the dropdown
         * @param {HTMLElement} content - element to add in the dropdown
         * @param {WidgetBase} parentWidget - if defined, set the widget as parent widget of the dropdown (optional)
         * @publicdoc
         */
        setContent: function(content, parentWidget) {
          this.getElement().appendChild(content);
          if (parentWidget) {
            this.setParentWidget(parentWidget);
          }
        },

        /**
         * Override this method if you want a custom check during dropdown hiding.
         * This method is executed when you click on corresponding dropdown widget (usually parent widget of dropdown) and determines if it should close dropdown in that case.
         * By default it's set to yes.
         * @param {HTMLElement} targetElement - source element which raise blur event
         * @returns {boolean} if false we cancel dropdown closing
         */
        shouldClose: function(targetElement) {
          return true;
        },

        /**
         * Remove the content of the dropdown
         * @param {HTMLElement} content - element to remove from the dropdown
         * @publicdoc
         */
        removeContent: function(content) {
          this.getElement().removeChild(content);
        },

        /**
         * Enable or disable/hide the dropdown.
         * @param {boolean} enabled - true if dropdown is active
         * @publicdoc
         */
        setEnabled: function(enabled) {
          $super.setEnabled.call(this, enabled);
          this.hide();
        },

        /**
         * Force the dropdown to take full height
         */
        setFullHeight: function() {
          this._fullHeight = true;
        },

        /**
         * Remove the dropdown from the DOM
         * @publicdoc
         */
        removeDropDown: function() {
          this.getElement().remove();
          this._container.removeClass("dd_" + this.getParentWidget().getName());
        },

        /**
         * Add dropdown in DOM and set its position & size
         * @publicdoc
         */
        addDropDown: function() {
          this._container.addClass("dd_" + this.getParentWidget().getName());
          // we insert dropdown in DOM before measuring it to be able to get its generated height
          this._container.appendChild(this.getElement());

          // measure and render dropdown
          // if  custom rendering function is defined we use it else use default one
          if (this.renderFunction && typeof this.renderFunction === "function") {
            this.renderFunction();
          } else {
            this.renderDropDown();
          }
        },

        /**
         * Render the dropdown. Measure its width, height and calculate its top and left position and sets them.
         * By default dropdown will :
         *  - take width of its corresponding widget.
         *  - be positioned right under the corresponding widget and left aligned with it.
         * @publicdoc
         */
        renderDropDown: function() {
          // 0 - Initialization
          // need parent widget size + sidebar size in our measure process
          var parentSize = (this.parentElement ? this.parentElement : this.getParentWidget().getElement()).getBoundingClientRect();
          var sidebar = context.HostService.getApplicationHostWidget().getSideBar();
          var sidebarWidth = sidebar && !sidebar.isUnavailable() && sidebar.isAlwaysVisible() ? sidebar.getCurrentSize() : 0;
          var ddSize = {};
          // Flags used to reverse dropdown position if case of overflow measurements.
          // These flags can be updated in next methods.
          this.__reverseX = false;
          this.__reverseY = false;

          // 1 - Min & max width calculation
          var ddWidth = this._widthMeasure(parentSize, sidebarWidth);
          // typeof is string if value is "unset"
          ddSize["min-width"] = ddSize["max-width"] = this._getSizeUnit(ddWidth);

          // 2 - Horizontal positioning
          var x = this._horizontalMeasure(ddWidth, parentSize, sidebarWidth);
          ddSize[this.__reverseX ? "right" : "left"] = this._getSizeUnit(x);
          ddSize[this.__reverseX ? "left" : "right"] = "unset"; // reset other flag which could have been used before

          // 3 - Vertical positioning
          var y = this._verticalMeasure(parentSize);
          ddSize[this.__reverseY ? "bottom" : "top"] = this._getSizeUnit(y);
          ddSize[this.__reverseY ? "top" : "bottom"] = this._fullHeight ? 0 :
            "unset"; // reset other flag which could have been used before

          // 4 - Max height calculation
          var ddHeight = this._maxHeightMeasure(y);
          ddSize["max-height"] = this._fullHeight ? "inherit" : this._getSizeUnit(ddHeight);

          this.setStyle(ddSize);

          this.__reverseX = false;
          this.__reverseY = false;
        },

        /**
         * Return value with its corresponding unit
         * @param value
         * @returns {string} value
         * @private
         */
        _getSizeUnit: function(value) {
          return typeof value === "string" ? value : (value + "px");
        },

        /**
         * We calculate horizontal position (by default using left attribute) of the dropdown depending of its width and client width
         * @param {number} dropDownWidth - dropDown calculated width
         * @param {ClientRect} parentSize - corresponding widget size
         * @param {number} sidebarWidth - sidebar width
         * @returns {number} left (or right if reversed) position in pixels
         * @private
         */
        _horizontalMeasure: function(dropDownWidth, parentSize, sidebarWidth) {
          var x = 0;

          if (this.getParentWidget().isReversed()) {
            this.addClass("reverse");
          }

          this.__reverseX = this.reverseX || this.getParentWidget().isReversed();
          // if dropDownWidth is "unset" we take scrollWidth
          var ddWidth = dropDownWidth === "unset" ? this._element.scrollWidth : dropDownWidth;

          // 1. Get X positioning depending of provided attributes
          if (this.x) { // widget knows left location to use
            // CENTER means middle of the current window
            x = (this.x === "CENTER" ? (window.innerWidth - ddWidth + sidebarWidth) / 2 : this.x);
          } else if (!this.__reverseX) {
            x = Math.max(0, (parentSize.left + document.body.scrollLeft), sidebarWidth);
          }

          // 2. Adjust X positioning if horizontally overflowed
          // 2.1 dropdown is going to be overflowed by screen size limit, we flag it as reverse to inverse positioning
          if (!this.__reverseX && (x + ddWidth > document.body.clientWidth)) {
            this.__reverseX = true;
          }

          // 2.2 substract provided X or parentElement right position to clientWidth
          if (this.__reverseX) {
            if (this.x) {
              x = Math.max(0, document.body.clientWidth - x);
            } else {
              x = Math.max(0, (document.body.clientWidth - document.body.scrollLeft - parentSize.right));
            }
          }

          return x;
        },

        /**
         * We calculate vertical position (by default using top attribute) of the dropdown depending of its height and client height
         * @param {ClientRect} parentSize - corresponding widget size
         * @returns {number} top (or bottom if reversed) position in pixels
         * @private
         */
        _verticalMeasure: function(parentSize) {
          var y = 0;
          this.__reverseY = this.reverseY;
          // 1. Get Y positioning depending of provided attributes
          if (this.y) { // widget knowns top location to use
            // CENTER means middle of the current window
            y = (this.y === "CENTER" ? (window.innerHeight - this._element.scrollHeight) / 2 : this.y);
          } else {
            // Try to position dropdown right under widget if enough space available otherwise position dropdown below it
            y = Math.max(0, (parentSize.bottom + document.body.scrollTop));
          }

          // 2. Adjust dropdown Y positioning by comparing dropdown height with remaining viewport height
          var height = this.maxHeight ? this.maxHeight : Math.min(this._element.scrollHeight, this._defaultMaxHeight);
          // screen size limit : we need to adjust vertical position
          if (y + height > document.body.clientHeight) { // unsufficiant size below widget, check to position dropdown above it
            // try to position dropdown using above widget
            y = Math.max(0, document.body.clientHeight - (this.y ? this.y : parentSize.top) - document.body.scrollTop +
              2); // 2px for box-shadow
            // if no space available either to position dropdown above widget, we place it at the top of the screen
            if (y + height > document.body.clientHeight) { // place dropdown at top of the screen
              y = 2;
            } else { // place above widget (usage of bottom attribute)
              this.__reverseY = true;
            }
          }
          return y;
        },

        /**
         * We calculate width of the dropdown. We take in consideration sidebar and menu panel which can overflow widget content (scrollbars may then appear)
         * @param {ClientRect} parentSize - corresponding widget size
         * @param {number} sidebarWidth - sidebar width
         * @returns {string|number} width to use as a number or "unset" string if no width is required
         * @private
         */
        _widthMeasure: function(parentSize, sidebarWidth) {
          var w = 0;
          if (this.minWidth) {
            w = this.minWidth;
          } else if (this.autoSize) {
            // Take larger width between parent widget, dropdown content and default min width.
            // Check if visible area is smaller that this width (dropdown or parent widget overflowed by horizontal scrollbars) and take visible area as width if it's the case
            w = Math.min(Math.max(parentSize.width, (this.width ? this.width : 0), this._defaultMinWidth), this
              ._visibleAreaWidthMeasure(
                parentSize, sidebarWidth));
          } else if (this.maxWidth) {
            w = this.maxWidth;
          } else {
            w = "unset";
          }
          return w;
        },

        /**
         * Calculate width of the middle visible area (we subtract menu panel and sidebar from clientWidth)
         * @param {ClientRect} parentSize - corresponding widget size
         * @param {number} sidebarWidth - sidebar width
         * @returns {number} returns width of the middle visible area (we subtract menu panel and sidebar from clientWidth)
         * @private
         */
        _visibleAreaWidthMeasure: function(parentSize, sidebarWidth) {
          var w = document.body.clientWidth;
          if (this.autoSize) {
            // horizontal scrollbars & overflow issue with right action panel in case of too large dropdown widget
            // we need to subtract the overflowed width of the dropdown
            // possible overflow are sidebar & right menu panel
            var currentWindow = this.getWindowWidget();
            if (currentWindow) {
              var menuRightWidth = currentWindow.getWindowMenuContainerRight().getBoundingClientRect();
              if ((menuRightWidth.width > 0 || sidebarWidth > 0) && parentSize.width > 0) {
                w = menuRightWidth.left - Math.max(0, parentSize.left, sidebarWidth);
              }
            }
          }
          return w;
        },

        /**
         * We calculate max height of the dropdown. Then vertical scrollbars will be added in dropdown.
         * @param {number} ddVerticalPosition - vertical (y) position of the dropdown. Basically top position.
         * @returns {string} max height to use in pixels
         * @private
         */
        _maxHeightMeasure: function(ddVerticalPosition) {
          var h = 0;
          if (this.maxHeight) {
            h = this.maxHeight;
          } else if (this.autoSize) {
            h = this._defaultMaxHeight;
          } else { // by default fit content height
            h = this._element.scrollHeight + 1;
          }
          // case when screen height is smaller that dropdown height
          if (Math.min(h, this._defaultMaxHeight) > document.body.clientHeight) { // dropdown take whole screen height
            h = document.body.clientHeight - 5;
          } else if ((h + ddVerticalPosition) > document.body.clientHeight) {
            // case when dropdown has big height and is being overflowed by screen
            h = document.body.clientHeight - ddVerticalPosition - 5;
          }
          return h;
        }

      };
    });
    cls.WidgetFactory.registerBuilder('DropDown', cls.DropDownWidget);
  });
;
"use strict";

modulum('FolderWidget', ['FolderWidgetBase'],
  function(context, cls) {

    /**
     * Folder widget.
     * @class FolderWidget
     * @memberOf classes
     * @extends classes.FolderWidgetBase
     * @publicdoc Widgets
     */
    cls.FolderWidget = context.oo.Class(cls.FolderWidgetBase, function($super) {
      return /** @lends classes.FolderWidget.prototype */ {
        __name: "FolderWidget",

        /** @type {Element} */
        _tabsTitlesHostElement: null,
        /** @type {Element} */
        _tabsTitlesElement: null,
        /** @type {String} */
        _tabsPosition: "top",
        /** @type {classes.ScrollTabDecorator} */
        _scroller: null,

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          this._layoutInformation = new cls.FolderLayoutInformation(this);
          this._layoutEngine = new cls.FolderLayoutEngine(this);

          $super._initLayout.call(this);
        },

        /**
         * @inheritDoc
         */
        _initContainerElement: function() {
          $super._initContainerElement.call(this);
          this._tabsTitlesHostElement = this._element.getElementsByClassName("mt-tab-titles")[0];
          this._tabsTitlesElement = this._element.getElementsByClassName("mt-tab-titles-container")[0];

          this._scroller = new cls.ScrollTabDecorator(this);
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._scroller) {
            this._scroller.destroy();
            this._scroller = null;
          }
          if (this._tabsTitlesHostElement) {
            this._tabsTitlesHostElement = null;
          }
          if (this._tabsTitlesElement) {
            this._tabsTitlesElement = null;
          }
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        addChildWidget: function(widget, options) {
          /** @type classes.PageWidget */
          var pageWidget = widget;

          var titleWidget = pageWidget.getTitleWidget();
          this._tabsTitlesElement.appendChild(titleWidget.getElement());

          $super.addChildWidget.call(this, pageWidget, options);
        },

        /**
         * @inheritDoc
         */
        setCurrentPage: function(page, executeAction) {
          var modified = $super.setCurrentPage.call(this, page, executeAction);
          if (modified) {
            this.scrollTo(this._currentPage);
          }
          return modified;
        },

        /**
         * Gets the tabs titles host element
         * @returns {Element} the element
         */
        getTabsTitlesHostElement: function() {
          return this._tabsTitlesHostElement;
        },

        /**
         * Get tabs position
         * @return {string} tabs pos: top, right, bottom, left
         * @publicdoc
         */
        getTabsPosition: function() {
          return this._tabsPosition;
        },

        /**
         * Set the tabs position
         * @param {string} position - could be top, right, bottom or left
         * @publicdoc
         */
        setTabPosition: function(position) {
          if (["top", "bottom", "left", "right"].indexOf(position) < 0) {
            position = "top";
          }
          this._element.setAttribute("__FolderWidget", position);
          this._scroller.updatePosition("__FolderWidget", position);

          this._tabsPosition = position;
        },

        /**
         * Go to the given page
         * @param {classes.PageWidget} page - page to navigate to
         * @publicdoc
         */
        scrollTo: function(page) {
          var title = page && page.getTitleWidget();
          if (title) {
            this._scroller.scrollTo(title.getElement());
          }
          this._scroller.refreshScrollers();
        },

        /**
         * Update visibility of scrollers
         */
        updateScrollersVisibility: function() {
          var isVertical = ["left", "right"].indexOf(this._tabsPosition) >= 0;
          var isHorizontal = ["top", "bottom"].indexOf(this._tabsPosition) >= 0;
          var sizeAttr = isVertical ? "height" : isHorizontal ? "width" : false;
          var info = this.getLayoutInformation();

          if (sizeAttr && this._scroller) {
            // Check if there is space enough to display the full bar or need scrolling
            var tabsTitlesSize = this.getChildren().map(function(item) {
              return item.isHidden() ? 0 :
                item.getLayoutInformation()[isHorizontal ? "getTitleMeasureWidth" : "getTitleMeasureHeight"]();
            }).reduce(function(next, prev) {
              return next + prev;
            }, 0);
            var tabsTitlesHostSize = this._getAllocatedSize(isHorizontal) -
              info[isHorizontal ? "getTitlesContainerDeltaWidth" : "getTitlesContainerDeltaHeight"]();

            if (tabsTitlesHostSize <= tabsTitlesSize) {
              this._scroller.showScroller(true);
            } else {
              this._scroller.showScroller(false);
            }
          }
        },

        /**
         * get the corrent allocatid size
         * @param isHorizontal is horizontal
         * @returns {number}
         * @protected
         */
        _getAllocatedSize: function(isHorizontal) {
          var info = this.getLayoutInformation();
          return info.getAllocated()[isHorizontal ? "getWidth" : "getHeight"]();
        }
      };
    });
    cls.WidgetFactory.registerBuilder('Folder', cls.FolderWidget);
  });
;
"use strict";

modulum('FolderWidgetBase', ['WidgetGroupBase'],
  /**
   * @param {gbc} context
   * @param {classes} cls
   */
  function(context, cls) {

    /**
     * Folder widget base class.
     * @class FolderWidgetBase
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     * @publicdoc Widgets
     */
    cls.FolderWidgetBase = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.FolderWidgetBase.prototype */ {
        __name: "FolderWidgetBase",

        /** @type {boolean} */
        __virtual: true,

        /** @type {String} */
        __dataContentPlaceholderSelector: ".containerElement",

        /**
         * @type {classes.PageWidget}
         */
        _currentPage: null,
        /**
         * @type {Function}
         */
        _onLayoutUnbindHandler: null,
        /**
         * is true if folder only contains current page in DOM
         * @type {boolean}
         */
        isMinified: false,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          this._ignoreLayout = true;
          $super._initElement.call(this);
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          if (this._layoutEngine) {
            this._onLayoutUnbindHandler = this._layoutEngine.onLayoutApplied(this.removePagesFromDom.bind(this));
          }
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._onLayoutUnbindHandler) {
            this._onLayoutUnbindHandler();
            this._onLayoutUnbindHandler = null;
          }

          $super.destroy.call(this);
        },

        /**
         *  @inheritDoc
         */
        addChildWidget: function(widget, options) {
          if (!widget.isInstanceOf(cls.PageWidget)) {
            throw "Only PageWidgets can be added in FolderWidgetBase";
          }
          $super.addChildWidget.call(this, widget, options);
          /** @type classes.PageWidget */
          var pageWidget = widget;

          if (this._children.length === 1) {
            // First page to be added, set it as current, false to prevent action on initial rendering
            this.setCurrentPage(pageWidget, false);
          }
        },

        /**
         * @inheritDoc
         */
        removeChildWidget: function(widget) {
          /** @type classes.PageWidget */
          var pageWidget = widget;

          var nextCurrentIndex = -1;

          if (pageWidget === this.getCurrentPage()) {
            this._currentPage = null;
            nextCurrentIndex = this._children.indexOf(pageWidget);
            if (nextCurrentIndex >= this._children.length - 1) {
              nextCurrentIndex = this._children.length - 2;
            }
          }
          if (pageWidget.getTitleWidget()) {
            pageWidget.getTitleWidget().getElement().remove();
          }

          pageWidget.getElement().remove();

          $super.removeChildWidget.call(this, pageWidget);

          if (!!this._children.length && nextCurrentIndex !== -1) {
            this.setCurrentPage(this._children[nextCurrentIndex], false);
          }
        },

        addPagesInDom: function() {
          for (var i = 0; i < this.getChildren().length; i++) {
            var page = this.getChildren()[i];
            if (page !== this.getCurrentPage() && !page.hasChildWebComponent()) {
              page.addPageInDom();
            }
          }
          if (!this._onLayoutUnbindHandler) {
            this._onLayoutUnbindHandler = this._layoutEngine.onLayoutApplied(this.removePagesFromDom.bind(this));
          }
          this.isMinified = false;
        },

        removePagesFromDom: function() {
          for (var i = 0; i < this.getChildren().length; i++) {
            var page = this.getChildren()[i];
            if (page !== this.getCurrentPage() && !page.hasChildWebComponent()) {
              page.removePageFromDom();
            }
          }
          if (this._onLayoutUnbindHandler) {
            this._onLayoutUnbindHandler();
            this._onLayoutUnbindHandler = null;
          }
          this.isMinified = true;
        },

        /**
         *  Click on title handler.
         *  @param {classes.PageWidget} page - page corresponding to the title
         */
        onTitleClick: function(page) {
          // False parameter to prevent action (will be triggered on page click)
          if (this.setCurrentPage(page, false)) {
            this.emit(context.constants.widgetEvents.requestFocus);
          }
        },

        /**
         * Get the current page
         * @returns {classes.PageWidget} the current page
         * @publicdoc
         */
        getCurrentPage: function() {
          return this._currentPage;
        },

        /**
         * Defines the current displayed page
         * @param {classes.PageWidget} page - the new current page
         * @param {boolean} [executeAction] - execute action of page
         * @return {boolean} true if the page has changed
         * @publicdoc
         */
        setCurrentPage: function(page, executeAction) {
          // TODO - ensuring not to set hidden page as current page might break huge screens
          // TODO - has to deal with VisibleIdVMBehavior order in apply behaviors
          if (this._currentPage !== page /* && !page.isHidden()*/ ) {
            for (var i = 0; i < this._children.length; ++i) {
              var child = this._children[i];
              child.getTitleWidget().setCurrent(child === page);
            }
            if (this._currentPage) {
              // do not remove page from dom if not measured yet or if it contains a WebComponent
              if (this.isMinified && !this._currentPage.hasChildWebComponent()) {
                this._currentPage.removePageFromDom();
              }
              this._currentPage.getElement().removeClass("currentPage");
              this._currentPage.disable();
            }
            this._currentPage = page;
            this._currentPage.getElement().addClass("currentPage");

            if (this.isMinified && !this._currentPage.hasChildWebComponent()) {
              this._currentPage.addPageInDom();
            }

            this._currentPage.activate();
            if (page) {
              this.getLayoutEngine().invalidateAllocatedSpace();
            }

            this.emit(context.constants.widgetEvents.change, page, executeAction);

            return true;
          }
          return false;
        },

        /**
         * Refresh the current page using VM focused widget or using first visible page otherwise
         * @publicdoc
         */
        updateCurrentPage: function() {
          var focusedWidget = this.getUserInterfaceWidget().getVMFocusedWidget();
          var focusedWidgetIsPage = !!focusedWidget && focusedWidget instanceof cls.PageWidget;
          if (focusedWidgetIsPage && !focusedWidget.isHidden()) {
            this.setCurrentPage(focusedWidget);
          } else {
            var firstVisiblePage = null;
            if (this._children) {
              for (var i = 0; i < this._children.length; i++) {
                var page = this._children[i];
                if (!page.isHidden()) {
                  if (!firstVisiblePage) {
                    firstVisiblePage = page;
                  }
                  if (focusedWidget && !focusedWidgetIsPage && focusedWidget.isChildOf(page)) {
                    this.setCurrentPage(page);
                    firstVisiblePage = null;
                    break;
                  }
                }
              }
            }
            if (firstVisiblePage) {
              // false parameter to not execute action in this case
              this.setCurrentPage(firstVisiblePage, false);
            }
          }
        },

        /**
         * Returns the number of page in the folder
         * @return {number} page count
         * @publicdoc
         */
        getPageCount: function() {
          return this._children.length;
        },

        /**
         * Returns the number of visible page in the folder
         * @return {number} visible page count
         * @publicdoc
         */
        getVisiblePageCount: function() {
          var count = 0;
          for (var i = 0; i < this._children.length; i++) {
            var page = this._children[i];
            if (!page.isHidden()) {
              count++;
            }
          }
          return count;
        }
      };
    });
  });
;
"use strict";

modulum('FormWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Form widget.
     * @class FormWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     * @publicdoc Widgets
     */
    cls.FormWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.FormWidget.prototype */ {
        __name: "FormWidget",
        /**
         * title of the current form
         * @type {?string}
         */
        _text: null,
        _scrollValues: null,

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          this._layoutInformation = new cls.FormLayoutInformation(this);
          this._layoutEngine = new cls.FormLayoutEngine(this);
        },

        /**
         * @inheritDoc
         */
        addChildWidget: function(widget, options) {
          if (this._children.length !== 0) {
            throw "A form can only contain a single child";
          }
          $super.addChildWidget.call(this, widget, options);
        },

        /**
         * @param {string} text title of the current form
         */
        setText: function(text) {
          this._text = text;
        },

        /**
         * @returns {string} title of the current form
         */
        getText: function() {
          return this._text;
        }
      };
    });
    cls.WidgetFactory.registerBuilder('Form', cls.FormWidget);
  });
;
"use strict";

modulum('GridWidget', ['WidgetGridLayoutBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Grid widget.
     * @class GridWidget
     * @memberOf classes
     * @extends classes.WidgetGridLayoutBase
     */
    cls.GridWidget = context.oo.Class(cls.WidgetGridLayoutBase, function($super) {
      return /** @lends classes.GridWidget.prototype */ {
        __name: "GridWidget",
        _scrollWidget: null,
        _pageSize: null,
        _size: null,

        destroy: function() {
          if (this._scrollWidget) {
            this._scrollWidget.destroy();
            this._scrollWidget = null;
          }
          $super.destroy.call(this);
        },

        setEnabled: function(enabled) {
          $super.setEnabled.call(this, enabled);
          var scrollWidget = this.getScrollWidget();
          if (scrollWidget) {
            scrollWidget.setEnabled(enabled);
          }
        },
      };
    });
    cls.WidgetFactory.registerBuilder('Grid', cls.GridWidget);
  });
;
"use strict";

modulum('GroupTitleWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Group title widget.
     * @class GroupTitleWidget
     * @memberOf classes
     * @extends classes.WidgetBase
     * @publicdoc
     */
    cls.GroupTitleWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.GroupTitleWidget.prototype */ {
        __name: "GroupTitleWidget",

        /**
         * @type {HTMLElement}
         */
        _textContainer: null,

        /**
         * is owner group collapsible
         * @type {boolean}
         */
        _isCollapsible: false,
        /**
         * @type {HTMLElement}
         */
        _collapser: null,
        /**
         * @type {HTMLElement}
         */
        _collapserIcon: null,

        /**
         * is owner group collapsed
         * @type {boolean}
         */
        _collapsed: false,

        /**
         * has text
         * @type {boolean}
         */
        _isEmpty: true,

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          this._layoutInformation = new cls.LayoutInformation(this);
          this._layoutEngine = new cls.LeafLayoutEngine(this);
          this._layoutInformation.getSizePolicyConfig().setMode('dynamic');
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          this._textContainer = this._element.getElementsByTagName('span')[0];
          this._collapser = this._element.getElementsByTagName('span')[1];
          this._collapserIcon = this._element.getElementsByTagName('i')[0];
        },
        /**
         * @inheritDoc
         */
        destroy: function() {
          this._textContainer = null;
          this._collapser = null;
          this._collapserIcon = null;
          $super.destroy.call(this);
        },
        /**
         * Defines group title text
         * @param {string} text - text describing the group
         * @publicdoc
         */
        setText: function(text) {
          this.domAttributesMutator(function() {
            this._textContainer.textContent = text;
            this._element.toggleClass("empty", !text);
          }.bind(this));
          this._isEmpty = !text;
          this.getLayoutEngine().forceMeasurement();
          this.getLayoutEngine().invalidateMeasure();
        },

        /**
         * Returns group title text
         * @returns {string} text describing the group
         * @publicdoc
         */
        getText: function() {
          return this._textContainer.textContent;
        },

        /**
         * Display collapsible control if needed
         * @param {boolean} collapsible
         */
        setCollapsible: function(collapsible) {
          this._isCollapsible = Boolean(collapsible);
          this._element.toggleClass("collapsible", this._isCollapsible);
        },

        /**
         * whether or not owner group is collapsed
         * @return {boolean}
         */
        isCollapsed: function() {
          return this._collapsed;
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          if (!this._isEmpty) {
            this._collapsed = !this._collapsed;
            this._updateToggle();
            this.emit(context.constants.widgetEvents.click);
          }
          return true;
        },

        /**
         * set the collapsed state
         * @param {boolean} collapsed the collapsed state
         */
        setCollapsed: function(collapsed) {
          if (this._collapsed !== Boolean(collapsed)) {
            this._collapsed = Boolean(collapsed);
            this._updateToggle();
          }
        },
        /**
         * update the toggle icon
         * @private
         */
        _updateToggle: function() {
          this._collapserIcon.toggleClass("zmdi-chevron-down", !this._collapsed).toggleClass("zmdi-chevron-right", this._collapsed);
        },

        /**
         * Define the position of the collapser
         * @param {string} pos - could be 'left' or 'right' (default)
         */
        setCollapserPosition: function(pos) {
          this.removeClass("collapser-position-right");
          this.removeClass("collapser-position-left");
          this.addClass("collapser-position-" + pos);
        }
      };
    });
    cls.WidgetFactory.registerBuilder('GroupTitle', cls.GroupTitleWidget);
  });
;
"use strict";

modulum('GroupWidget', ['WidgetGridLayoutBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Group widget.
     * @class GroupWidget
     * @memberOf classes
     * @extends classes.WidgetGridLayoutBase
     * @publicdoc
     */
    cls.GroupWidget = context.oo.Class(cls.WidgetGridLayoutBase, function($super) {
      return /** @lends classes.GroupWidget.prototype */ {
        __name: "GroupWidget",
        /**
         * @type {classes.GroupTitleWidget}
         */
        _title: null,

        /**
         * @type {HandleRegistration}
         */
        _titleClickHandler: null,

        /**
         * flag to determine if group is collapsible
         * @type {boolean}
         */
        _isCollapsible: false,

        /**
         * @type {HandleRegistration}
         */
        _gridWidthHandle: null,

        /**
         * @type {HTMLElement}
         */
        _groupWidgetContent: null,

        /**
         * @type {HTMLElement}
         */
        _groupContent: null,

        /**
         * @type {{formName:string, id:string}}
         */
        _groupIdentifier: null,
        /**
         * set the stored settings identifier
         * @param {{formName:string, id:string}} id
         */
        setGroupIdentifier: function(id) {
          this._groupIdentifier = id;
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);

          this._title = cls.WidgetFactory.createWidget("GroupTitle", this.getBuildParameters());
          this._titleClickHandler = this._title.when(context.constants.widgetEvents.click, this._onTitleClick.bind(this));
          this._groupWidgetContent = this._element.getElementsByClassName("gbc_GroupWidgetContent")[0];
          this._groupWidgetContent.prependChild(this._title.getElement());
          this._groupContent = this._groupWidgetContent.getElementsByClassName("containerElement")[0];
          // Set the default value of the collapsers to the theme definition
          this.setCollapserPosition(gbc.ThemeService.getValue("gbc-GroupWidget-collapser-position"));
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          this._layoutInformation = new cls.LayoutInformation(this);
          this._layoutEngine = new cls.GroupLayoutEngine(this);
          this._gridWidthHandle = this.getLayoutInformation().onGridInfoChanged(this._onGridWidthChanged.bind(this));
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._titleClickHandler) {
            this._titleClickHandler();
            this._titleClickHandler = null;
          }

          if (this._title) {
            this._title.destroy();
            this._title = null;
          }
          if (this._gridWidthHandle) {
            this._gridWidthHandle();
            this._gridWidthHandle = null;
          }
          this._groupWidgetContent = null;
          this._groupContent = null;
          $super.destroy.call(this);
        },

        /**
         * Handle grid width changes
         */
        _onGridWidthChanged: function() {
          this._title.getLayoutInformation().setGridWidth(this.getLayoutInformation().getGridWidth());
        },

        /**
         * @inheritDoc
         */
        setGridChildrenInParent: function(isGridChildrenInParent) {
          if (this._isGridChildrenInParent !== isGridChildrenInParent) {
            if (!isGridChildrenInParent) {
              this._groupContent.removeClass("gridChildrenInParent");
            }
            $super.setGridChildrenInParent.call(this, isGridChildrenInParent);
            if (isGridChildrenInParent) {
              this._groupContent.addClass("gridChildrenInParent");
            }
          }
        },
        /**
         * Defines group title text
         * @param {string} text - text describing the group
         * @publicdoc
         */
        setText: function(text) {
          this._title.setText(text);
          this.getLayoutEngine().forceMeasurement();
          this.getLayoutEngine().invalidateMeasure();
        },

        /**
         * Returns group title text
         * @returns {string} text describing the group
         * @publicdoc
         */
        getText: function() {
          return this._title.getText();
        },
        /**
         * when group title is clicked
         * @private
         */
        _onTitleClick: function() {
          if (this._isCollapsible) {
            this._updateCollapsedState();
            this.emit(context.constants.widgetEvents.toggleClick);
          }
        },

        /**
         * Set the group collapsible
         * @param {boolean} collapsible
         */
        setCollapsible: function(collapsible) {
          this._isCollapsible = Boolean(collapsible);
          this._title.setCollapsible(this._isCollapsible);
          if (this._isCollapsible) {
            this.setCollapsed(Boolean(context.StoredSettingsService
              .getGroupCollapsedState(this._groupIdentifier.formName, this._groupIdentifier.id)));
          }
        },

        /**
         * set the collapsed state
         * @param {boolean} collapsed the collapsed state
         * @return {boolean} true if collapsed state has changed
         */
        setCollapsed: function(collapsed) {
          var result = false;
          if (this._isCollapsible) {
            if (this._title.isCollapsed() !== Boolean(collapsed)) {
              this._title.setCollapsed(collapsed);
              this._updateCollapsedState();
              result = true;
            }
          }
          return result;
        },

        /**
         * Define the position of the collapser
         * @param {string} pos - could be 'left' or 'right' (default)
         */
        setCollapserPosition: function(pos) {
          this._title.setCollapserPosition(pos);
        },

        /**
         * update the layout engine collapsed information
         * @private
         */
        _updateCollapsedState: function() {
          this._layoutEngine._willRenderContent = !this._title.isCollapsed();
          context.StoredSettingsService.setGroupCollapsedState(this._groupIdentifier.formName,
            this._groupIdentifier.id, Boolean(this._title.isCollapsed()));
          this.getLayoutEngine().forceMeasurement();
          this.getLayoutEngine().invalidateMeasure();
        }

      };
    });
    cls.WidgetFactory.registerBuilder('Group', cls.GroupWidget);
  });
;
"use strict";

modulum('HBoxSplitterWidget', ['SplitterWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Splitter widget.
     * @class HBoxSplitterWidget
     * @memberOf classes
     * @extends classes.SplitterWidget
     */
    cls.HBoxSplitterWidget = context.oo.Class(cls.SplitterWidget, function($super) {
      return /** @lends classes.HBoxSplitterWidget.prototype */ {
        __name: "HBoxSplitterWidget",
        __templateName: "SplitterWidget",
        _initElement: function() {
          $super._initElement.call(this);
          this._element.addClass("gbc_SplitterWidget");
        },
        _initLayout: function() {
          $super._initLayout.call(this);
          this._layoutInformation.setMaximal(8, cls.Size.maximal);
        },
        _onDragOver: function(evt) {
          $super._onDragOver.call(this, evt);
          this._pagePosition = evt.pageX;
        },
        _updateResizerDrag: function(evt) {
          this._pagePosition = evt.pageX;
          this._resizerDragPosition = evt.pageX;
        },
        updateSplits: function(delta) {
          if (this.isReversed()) {
            delta = -delta;
          }
          $super.updateSplits.call(this, delta);
        },

        // Touch only
        _onTouchStart: function(evt) {
          this._splitStartPos = evt.touches[0].clientX;
          $super._onTouchStart.call(this, evt);
        },

        _onTouchMove: function(evt) {
          this._pagePosition = evt.touches[0].clientX;
          $super._onTouchMove.call(this, evt);
        },

      };
    });
    cls.WidgetFactory.registerBuilder('HBoxSplitter', cls.HBoxSplitterWidget);
  });
;
"use strict";

modulum('HBoxSplitViewWidget', ['HBoxWidget', 'WidgetFactory'],
  /**
   * @param {gbc} context
   * @param {classes} cls
   */
  function(context, cls) {

    /**
     * HBoxSplitViewWidget widget is an advanced HBox widget. It can acts as a normal HBox or as SplitView
     * with each child group displayed full viewport
     * @class HBoxSplitViewWidget
     * @memberOf classes
     * @extends classes.HBoxWidget
     * @publicdoc Widgets
     */
    cls.HBoxSplitViewWidget = context.oo.Class(cls.HBoxWidget, function($super) {
      return /** @lends classes.HBoxSplitViewWidget.prototype */ {
        __name: "HBoxSplitViewWidget",
        /**
         * index of current hbox child group being visible.
         * @type {number}
         */
        _currentDisplayedGroupIndex: 0,
        /**
         * current group widget being displayed
         * @type {classes.WidgetBase}
         */
        _currentGroupWidget: null,
        /**
         * group active listeners (focus + visibility)
         * @type {Map<string, Function>}
         */
        _displayGroupActiveHandlers: null,
        /**
         * swipe event handler
         * @type {Function}
         */
        _swipeHandler: null,
        /**
         * screen size/orientation handler. Disable or enable SplitView mechanism depending of screen size
         * @type {Function}
         */
        _screenSizeHandler: null,
        /**
         * resize handler used in screen resize setTimeout
         * @type {Function}
         */
        _resizeHandle: null,
        /**
         * UserInterface widget of current HBoxSplitView
         * @type {classes.UserInterfaceWidget}
         */
        _uiWidget: null,
        /**
         * Flag to indicate current state of HBox
         * @type {boolean}
         */
        _isSplitView: false,
        /**
         * Flag to indicate we are currently swiping
         * @type {boolean}
         */
        _isSwiping: false,
        /**
         * Index of previewed group. This index is going to become the current one if swipe is executed successfully
         * @type {number}
         */
        _previewedIndex: -1,
        /**
         * Flag to indicate if we are currently scrolling instead of swiping
         * @type {boolean}
         */
        _isScrolling: false,
        /**
         * Indicates if current group has horizontal scrollbars (only set for mobiles)
         * @type {boolean}
         */
        _currentGroupOverflowing: false,
        /**
         * Main SplitView element on which is bound swipe
         * @type {HTMLElement}
         */
        _splitViewContent: null,
        /**
         * Left arrow element (visual assistant to swipe)
         * @type {HTMLElement}
         */
        _leftArrow: null,
        /**
         * Right arrow element (visual assistant to swipe)
         * @type {HTMLElement}
         */
        _rightArrow: null,
        /**
         * Dots elements container (visual assistant to swipe)
         * @type {HTMLElement}
         */
        _dots: null,
        /**
         * 4ST attribute value for arrows. By default it's disabled and hidden
         * @type {string}
         */
        _arrowsStyle: "no",
        /**
         * 4ST attribute value for dots. By default it's disabled and hidden
         * @type {boolean}
         */
        _withDots: false,

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          opts = opts || {};
          this._uiWidget = opts.uiWidget;
          $super.constructor.call(this, opts);
        },

        /**
         * @inheritDoc
         */
        _initContainerElement: function() {
          $super._initContainerElement.call(this);
          this._displayGroupActiveHandlers = new Map();

          this._splitViewContent = this.getElement().getElementsByClassName("splitViewContent")[0];
          this._leftArrow = this.getElement().getElementsByClassName("left_arrow")[0];
          this._rightArrow = this.getElement().getElementsByClassName("right_arrow")[0];
          this._dots = this.getElement().getElementsByClassName("dots")[0];

          // Listen to mobile orientation and disable/enable splitview mechanism if screen size condition is met
          this._screenSizeHandler = context.HostService.onScreenResize(function() {
            if (this._resizeHandle) {
              this._clearTimeout(this._resizeHandle);
            }
            this._resizeHandle = this._registerTimeout(this._initSplitView.bind(this), 100);
          }.bind(this));

          // add left/right arrows events
          this._leftArrow.on("click.SplitViewLeftArrow", function() {
            var newIndex = this._currentDisplayedGroupIndex - 1;
            if (newIndex >= 0) {
              this._displayGroupByIndex(newIndex);
            }
          }.bind(this));

          this._rightArrow.on("click.SplitViewRightArrow", function() {
            var newIndex = this._currentDisplayedGroupIndex + 1;
            if (newIndex < this.getGroupsLength()) {
              this._displayGroupByIndex(newIndex);
            }
          }.bind(this));

        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._resizeHandle) {
            this._clearTimeout(this._resizeHandle);
            this._resizeHandle = null;
          }
          if (this._screenSizeHandler) {
            this._screenSizeHandler();
            this._screenSizeHandler = null;
          }
          this._uiWidget = null;
          this._releaseSplitViewHandlers();
          for (var i = 0; i < this._dots.children.length; i++) {
            this._dots.children[i].off("click.SplitViewDot");
          }
          this._leftArrow.off("click.SplitViewLeftArrow");
          this._rightArrow.off("click.SplitViewRightArrow");
          this._leftArrow = null;
          this._rightArrow = null;
          this._dots = null;
          this._currentDisplayedGroupIndex = 0;
          this._currentGroupWidget = null;
          this._splitViewContent = null;
          this._displayGroupActiveHandlers = null;

          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          this._layoutInformation = new cls.LayoutInformation(this);
          // attach corresponding layout engine
          if (this.isSplitView()) {
            this._layoutEngine = new cls.SplitViewLayoutEngine(this);
            this._layoutInformation.getStretched().setDefaultX(true);
            this._layoutInformation.getStretched().setDefaultY(true);
            if (this.areArrowsSolid()) {
              this.enableSolidArrows();
            }
          } else {
            this._layoutEngine = new cls.HBoxLayoutEngine(this);
          }

          // disable/enable splitview mechanism if screen size condition is met
          this._initSplitView();
        },

        /**
         * @inheritDoc
         */
        addChildWidget: function(widget, options) {
          $super.addChildWidget.call(this, widget, options);
          if (this.isSplitView()) {
            this._prepareGroup(widget, true);
            this._listenToGroupVisibilityChange(widget);
          }
        },

        /**
         * Returns true if HBox is a SplitView
         * @returns {boolean}
         */
        isSplitView: function() {
          return window.innerWidth <= context.ThemeService.getValue("mt-responsive-screen-width-breakpoint");
        },

        /**
         * Initialise SplitView or HBox depending of splitview condition match
         * @private
         */
        _initSplitView: function() {
          this._resizeHandle = null;

          if (this.isSplitView()) {
            this._enableSplitView();
            this._isSplitView = true;
          } else {
            this._disableSplitView();
            this._isSplitView = false;
          }
        },

        /**
         * Transform normal HBox into a SplitView
         * @private
         */
        _enableSplitView: function() {
          if (!this._isSplitView) {

            this._displayGroupActiveHandlers.clear();

            // Update the layout engine and register children in it.
            var oldEngine = this._layoutEngine;
            this._layoutEngine = new cls.SplitViewLayoutEngine(this);
            this._layoutInformation.getStretched().setDefaultX(true);
            this._layoutInformation.getStretched().setDefaultY(true);
            if (this.areArrowsSolid()) {
              this.enableSolidArrows();
            }

            for (var i = 0; i < this.getChildren().length; i++) {
              var child = this.getChildren()[i];
              this._prepareGroup(child);
              if (!child.isHidden()) {
                oldEngine.unregisterChild(child);
                this._layoutEngine.registerChild(child);
              }
              this._listenToGroupVisibilityChange(child);
            }

            // measures new layout
            context.SessionService.getCurrent().getCurrentApplication().layout.refreshLayout();

            // global listening to focus change
            if (this._uiWidget) {
              this._displayGroupActiveHandlers.set(this._uiWidget.getUniqueIdentifier() + "_focus", this._uiWidget.when(context
                .constants
                .widgetEvents.splitViewChange,
                this._displayFocusedGroup.bind(this)));
            }
            // add swipe mechanism
            this._swipeHandler = this._displayGroupByDirection.bind(this);

            // IMPORTANT : bind swipe on element and not containerElement otherwise swipe won't work on iOS because containerElement is being translated and is considered out of view
            this._splitViewContent.onSwipe("HBoxSplitViewWidget", this._swipeHandler, {
              direction: ["left", "right"],
              velocity: 0.6,
              distance: 0.45,
              startCallback: this._beforeSwipe.bind(this),
              moveCallback: this._duringSwipe.bind(this),
              endCallback: this._afterSwipe.bind(this),
            });
            // display current group
            this._moveGroup(this._currentDisplayedGroupIndex);

            this.getElement().addClass("isSplitView");

            // show arrows or dots if enabled by 4ST
            this._showArrowsDots();
          }
        },

        /**
         * Transform a SplitView into an HBox
         * @private
         */
        _disableSplitView: function() {
          if (this._isSplitView) {
            // Update the layout engine and register children in it.
            this._hideArrowsDots();

            this.getElement().removeClass("isSplitView");
            // remove transition styles
            this._removeSplitViewStyles();

            var oldEngine = this._layoutEngine;
            this._layoutEngine = new cls.HBoxLayoutEngine(this);
            this._layoutInformation.getStretched().setDefaultX(false);
            this._layoutInformation.getStretched().setDefaultY(false);

            this.disableSolidArrows();
            // need to loop from end in order to layout properly splitters (check DBoxLayoutEngine)
            for (var i = this.getChildren().length - 1; i >= 0; i--) {
              var child = this.getChildren()[i];
              if (child instanceof cls.SplitterWidget) {
                child.setHidden(false);
              }
              oldEngine.unregisterChild(child);
              this._layoutEngine.registerChild(child);
              if (child.getElement().parentNode.hasClass("hidden")) {
                child.getElement().parentNode.removeClass("hidden");
              }
            }
            // relayout splitters
            this.initSplitterLayoutEngine();
            // measure new layout
            context.SessionService.getCurrent().getCurrentApplication().layout.refreshLayout();
            // destroy previous splitview handlers
            this._releaseSplitViewHandlers();
          }
        },

        /**
         * Delete SplitView focus & swipe related listeners
         * @private
         */
        _releaseSplitViewHandlers: function() {
          if (this._swipeHandler) {
            this._splitViewContent.offSwipe("HBoxSplitViewWidget");
            this._swipeHandler = null;
          }
          if (this._displayGroupActiveHandlers) {
            this._displayGroupActiveHandlers.forEach(function(handler) {
              handler();
              handler = null;
            });
            this._displayGroupActiveHandlers.clear();
          }
        },

        /**
         * Remove preview transition styles from SplitView container element
         * @private
         */
        _removeSplitViewStyles: function() {
          this.getContainerElement().style.removeProperty("transform");
          this.getContainerElement().style.removeProperty("transition-duration");
        },

        /**
         * Hide group if splitter. Otherwise bind group to focus change
         * @param {classes.WidgetBase} widget - SplitView child group
         * @param {boolean=} firstCreation - indicates if it's first group creation
         * @private
         */
        _prepareGroup: function(widget, firstCreation) {
          if (widget instanceof cls.SplitterWidget) { // hide splitter in splitview
            widget.setHidden(true);
          } else if (!widget.isHidden()) {
            // each child group need to listen to focus to display. Mostly needed for folder pages.
            this._displayGroupActiveHandlers.set(widget.getUniqueIdentifier() + "_focus", widget.when(context.constants.widgetEvents
              .splitViewChange, this
              ._displayFocusedGroup
              .bind(this)));

            if (firstCreation) {
              this._addDot();
            }
          }
          if (widget.isHidden()) {
            if (widget.getElement().parentNode) {
              widget.getElement().parentNode.addClass("hidden");
            }
          }
        },

        /**
         * Listen to group visibility change to be able to add/remove it from swipeable element
         * @param {classes.WidgetBase} widget - SplitView child group
         * @private
         */
        _listenToGroupVisibilityChange: function(widget) {
          if (!(widget instanceof cls.SplitterWidget)) {
            this._displayGroupActiveHandlers.set(widget.getUniqueIdentifier() + "_visibility", widget.when(context.constants
              .widgetEvents.visibilityChange, this._addRemoveGroup.bind(this, widget)));
          }
        },

        /**
         * Add or remove a group in the list of swipeable groups of the HBox SplitView depending of group visibility
         * @param {classes.WidgetBase} widget - SplitView child group
         * @private
         */
        _addRemoveGroup: function(widget) {
          if (widget.isHidden()) {
            this._removeGroup(widget);
          } else {
            this._addGroup(widget);
          }
        },

        /**
         * Dynamically add a group in the list of swipeable groups of the HBox SplitView
         * @param {classes.WidgetBase} widget - SplitView child group
         * @private
         */
        _addGroup: function(widget) {
          this._prepareGroup(widget);
          this._layoutEngine.registerChild(widget);
          widget.getElement().parentNode.removeClass("hidden");
        },

        /**
         * Dynamically remove a group in the list of swipeable groups of the HBox SplitView
         * @param {classes.WidgetBase} widget - SplitView child group
         * @private
         */
        _removeGroup: function(widget) {
          // if we are currently displaying the last group and one of the splitview group gets hidden we need to display previous group which becomes the last one
          if (this._currentDisplayedGroupIndex === this.getGroupsLength() - 1 && this._currentDisplayedGroupIndex > 0) {
            this._displayGroupByIndex(this._currentDisplayedGroupIndex - 1);
          }
          var handler = this._displayGroupActiveHandlers.get(widget.getUniqueIdentifier() + "_focus");
          if (handler) {
            handler();
          }
          this._displayGroupActiveHandlers.delete(widget.getUniqueIdentifier() + "_focus");
          this._layoutEngine.unregisterChild(widget);
          widget.getElement().parentNode.addClass("hidden");
        },

        /**
         * Display parent group of the VM focused widget
         * @param {object} data - event data
         * @param {classes.WidgetBase} caller - event caller
         * @param {classes.WidgetBase} focusedWidget - new focused widget
         * @private
         */
        _displayFocusedGroup: function(data, caller, focusedWidget) {
          var newGroupIndex = this._currentDisplayedGroupIndex;

          var newVmFocusWidget = focusedWidget ? focusedWidget : this.getUserInterfaceWidget().getVMFocusedWidget();
          if (newVmFocusWidget) {
            var i = 0;
            var child = null;
            // detect new focused element group position
            for (i = 0; i < this.getLayoutEngine().getRegisteredWidgets().length; i++) {
              child = this.getLayoutEngine().getRegisteredWidgets()[i];
              if (newVmFocusWidget === child || newVmFocusWidget.isChildOf(child)) {
                // index of current group subtracted by number of previous splitters
                newGroupIndex = i;
                break;
              }
            }
          }

          // Display current focused group or first group by default (if none focused)
          this._displayGroupByIndex(newGroupIndex);
        },

        /**
         * Display a group by it's index position
         * @param {number} groupIndex
         * @private
         */
        _displayGroupByIndex: function(groupIndex) {
          if (this._currentDisplayedGroupIndex !== groupIndex) {
            this._currentDisplayedGroupIndex = groupIndex;
            this._currentGroupWidget = this.getLayoutEngine().getRegisteredWidgets()[groupIndex];
            // generate group transition
            this._moveGroup(groupIndex, 0.5);
          }
        },

        /**
         * On swipe start
         * @param {object} evt - event data
         * @private
         */
        _beforeSwipe: function(evt) {
          // disable swipe animation
          this.getContainerElement().addClass('disableAnimation');
          this._previewedIndex = -1;

          // save splitview current width for upcoming preview calculation
          this._splitViewWidth = this.getLayoutInformation().getAllocated().getWidth();
          // detect if current group has horizontal scrollbars which could conflict with swipe
          this._currentGroupOverflowing = false;
          if (evt.touches) {
            var clickedElement = evt.target;
            // exclude arrows and dots elements which are direct children of splitview
            if (clickedElement && clickedElement.parentNode && !clickedElement.parentNode.hasClass("isSplitView")) {
              this._currentGroupOverflowing = this._currentGroupWidget && this._currentGroupWidget.getLayoutInformation()
                .getAllocated()
                .getWidth() > (this._splitViewWidth +
                  2); // add 2px for margins
            }
          }
        },

        /**
         * Preview next group and adjust transition during whole swipe
         * @param {object} evt - data
         * @param {number} startX - starting swipe position
         * @private
         */
        _duringSwipe: function(evt, startX) {
          if (evt) {
            var clientX = evt.changedTouches ? evt.changedTouches[0].clientX : evt.clientX;
            var distance = Math.round(clientX - startX);
            var directionSign = Math.sign(distance);

            // Detect scroll
            this._isScrolling = false;
            if (this
              ._currentGroupOverflowing) { // if current group has horizontal scrollbars we give priority to scroll before swipe
              var rect = this._currentGroupWidget.getElement().getBoundingClientRect();
              if ((directionSign < 0 && rect.right > window.innerWidth) || (directionSign >= 0 && rect.left <
                  0)) { // need to scroll
                this._isScrolling = true;
              }
            }

            // Prepare for swipe if no scroll
            // get previewed group to see if we have something to preview
            this._previewedIndex = this._currentDisplayedGroupIndex - directionSign;
            // if we have nothing to preview on current SplitView bubble event we let parent SplitView (if it exists) to preview itself
            this._isSwiping = !this._isScrolling && this._previewedIndex >= 0 && this._previewedIndex < this.getGroupsLength();
            if (this._isSwiping) { // we have a group to preview
              evt.stopPropagation(); // don't bubble event to parent
              this._previewGroup(this._currentDisplayedGroupIndex, distance);
            }
          }
        },

        /**
         * Returns number of groups which are swipeable
         * @returns {number}
         */
        getGroupsLength: function() {
          return this.getLayoutEngine().getRegisteredWidgets().length;
        },

        /**
         * On successful swipe we update current group index. This callback is executed right before touch release callback and only on a completed swipe.
         * @param {string} direction - direction of the swipe
         * @private
         */
        _displayGroupByDirection: function(direction) {
          if (this._isSwiping && this._previewedIndex >= 0 && (direction === "left" || direction === "right")) {
            // display new group as a slide from right/left depending of current group related position
            this._currentDisplayedGroupIndex = this._previewedIndex;
            this._currentGroupWidget = this.getLayoutEngine().getRegisteredWidgets()[this._previewedIndex];
          }
        },

        /**
         * On each touch/mouse release we update current group or reset preview
         * @param {object} evt - event data
         * @param {number} swipedVelocity - swipe velocity (swipe speed)
         * @param {number} swipedFraction - distance of swipe
         * @private
         */
        _afterSwipe: function(evt, swipedVelocity, swipedFraction) {
          this._isSwiping = false;

          if (this._previewedIndex !== -1) {
            // focus group (can generate a transition if group index has changed or simply reset preview if swipe wasn't complete)
            this._previewedIndex = -1;
            var duration = (swipedVelocity > 0 ? swipedFraction : "1") * 0.5;
            // update style to generate transition
            this._moveGroup(this._currentDisplayedGroupIndex, duration);
          }
          // enable transition animation
          this.getContainerElement().removeClass('disableAnimation');
        },

        /**
         * Display group by index
         * @param {Number} index - index of current group in parent children list
         * @param {Number=} duration - duration of transition in seconds. If none we don't animate.
         * @private
         */
        _moveGroup: function(index, duration) {
          var current = index * -100; // convert position into percentage
          // perf note : setProperty method not used because 60% slower under IE11

          // first update arrows & dots 4ST before generating transition to avoid css animation conflicts
          this._updateCurrentDot();
          if (this.areArrowsVisible()) {
            this._showArrows();
          }

          if (duration) {
            this.getContainerElement().style.transitionDuration = duration + "s";
          } else {
            this.getContainerElement().style.removeProperty("transition-duration");
          }
          // translate splitview
          this.getContainerElement().style.transform = "translate(" + current + "%)";
        },

        /**
         * Preview group by index
         * @param {Number} index - index of current group in parent children list
         * @param {Number} previewDistance - distance of current previewed group
         * @private
         */
        _previewGroup: function(index, previewDistance) {
          var preview = -(index * this._splitViewWidth) + previewDistance;
          // translate splitview
          this.getContainerElement().style.transform = "translate(" + preview + "px)";
        },

        /******** 4ST styles methods *********/

        /**
         * Create a dot element and add it in the DOM
         * @private
         */
        _addDot: function() {
          var div = document.createElement("div");
          div.addClass("dot");
          div.on("click.SplitViewDot", this._displayGroupByIndex.bind(this, this._dots.children.length));
          // add listener
          this._dots.appendChild(div);
        },

        /**
         * Update current dot status
         * @private
         */
        _updateCurrentDot: function() {
          for (var i = 0; i < this._dots.children.length; i++) {
            var dot = this._dots.children[i];
            if (i === this._currentDisplayedGroupIndex) {
              if (!dot.hasClass("current")) {
                dot.addClass("current");
              }
            } else {
              dot.removeClass("current");
            }
          }
        },

        /**
         * Returns true if arrows should be visible/enabled
         * @returns {boolean}
         */
        areArrowsVisible: function() {
          return this.isSplitView() && (this.areArrowsOverlay() || this.areArrowsSolid());
        },

        /**
         * Returns true if arrows should be displayed as overlay on splitview content
         * @returns {boolean}
         */
        areArrowsOverlay: function() {
          return this._arrowsStyle === "overlay";
        },

        /**
         * Returns true if arrows should be displayed as solid next to splitview content
         * @returns {boolean}
         */
        areArrowsSolid: function() {
          return this._arrowsStyle === "solid";
        },

        enableSolidArrows: function() {
          this._layoutInformation.setDecorating(60, 0);
          this._layoutInformation.setDecoratingOffset(30, 0);
          if (!this._leftArrow.hasClass("solid")) {
            this._leftArrow.addClass("solid");
          }
          if (!this._rightArrow.hasClass("solid")) {
            this._rightArrow.addClass("solid");
          }
        },

        disableSolidArrows: function() {
          this._layoutInformation.setDecorating(0, 0);
          this._layoutInformation.setDecoratingOffset(0, 0);
          this._leftArrow.removeClass("solid");
          this._rightArrow.removeClass("solid");
        },

        /**
         * Returns true if dots should be visible/enabled
         * @returns {boolean}
         */
        areDotsVisible: function() {
          return this.isSplitView() && this._withDots;
        },

        /**
         * Display arrows and dots depending of current group being focused
         * @private
         */
        _showArrowsDots: function() {
          if (this.areArrowsVisible()) {
            this._showArrows();
          }
          if (this.areDotsVisible()) {
            this._showDots();
          }
        },

        /**
         * Hide arrows and dots
         * @private
         */
        _hideArrowsDots: function() {
          this._hideArrows();
          this._hideDots();
        },

        /**
         * Display arrows and synchronize their visibility with current group
         * @private
         */
        _showArrows: function() {
          if (this._currentDisplayedGroupIndex > 0) {
            this._leftArrow.removeClass("disabled");
          } else {
            if (!this._leftArrow.hasClass("disabled")) {
              this._leftArrow.addClass("disabled");
            }
          }
          if (this._currentDisplayedGroupIndex < this.getGroupsLength() - 1) {
            this._rightArrow.removeClass("disabled");
          } else {
            if (!this._rightArrow.hasClass("disabled")) {
              this._rightArrow.addClass("disabled");
            }
          }
        },

        /**
         * Display dots
         * @private
         */
        _showDots: function() {
          this._dots.removeClass("disabled");
          this._updateCurrentDot();
        },

        /**
         * Hide arrows
         * @private
         */
        _hideArrows: function() {
          if (!this._leftArrow.hasClass("disabled")) {
            this._leftArrow.addClass("disabled");
          }
          if (!this._rightArrow.hasClass("disabled")) {
            this._rightArrow.addClass("disabled");
          }
        },

        /**
         * Hide dots
         * @private
         */
        _hideDots: function() {
          if (!this._dots.hasClass("disabled")) {
            this._dots.addClass("disabled");
          }
        },

        /**
         * Set current arrows style
         * @param {string} style
         */
        setArrowsStyle: function(style) {
          this._arrowsStyle = style;
          if (this.areArrowsVisible()) {
            this._showArrows();
          } else {
            this._hideArrows();
          }

          if (this.areArrowsSolid()) {
            this.enableSolidArrows();
          } else {
            this.disableSolidArrows();
          }
        },

        /**
         * Set current dots style
         * @param {string} style
         */
        setWithDots: function(style) {
          this._withDots = style === 'yes';
          if (this.areDotsVisible()) {
            this._showDots();
          } else {
            this._hideDots();
          }
        }
      };
    });
    cls.WidgetFactory.registerBuilder("HBoxSplitView", cls.HBoxSplitViewWidget);
  });
;
"use strict";

modulum('HBoxWidget', ['BoxWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * HBox widget
     * @publicdoc Widgets
     * @class HBoxWidget
     * @memberOf classes
     * @extends classes.BoxWidget
     */
    cls.HBoxWidget = context.oo.Class(cls.BoxWidget, function($super) {
      return /** @lends classes.HBoxWidget.prototype */ {
        __name: "HBoxWidget",
        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          this._element.addClass("g_HBoxLayoutEngine");
        },
        /**
         * @inheritDoc
         */
        _initLayout: function() {
          this._layoutInformation = new cls.LayoutInformation(this);
          this._layoutEngine = new cls.HBoxLayoutEngine(this);
        },
        /**
         * @inheritDoc
         */
        _createSplitter: function() {
          return cls.WidgetFactory.createWidget("HBoxSplitter", this.getBuildParameters());
        }
      };
    });
    cls.WidgetFactory.registerBuilder('HBox', cls.HBoxWidget);
  });
;
"use strict";

/**
 * @callback ListDropDownItemRenderer
 * @param {string[]} model splitted string model
 * @param {Object} item the object value
 * @return {string} rendered html
 */

/**
 * @typedef {Object} ListDropDownWidgetItem
 * @property {string} text
 * @property {string} value
 */

modulum('ListDropDownWidget', ['DropDownWidget', 'WidgetFactory'],
  function(context, cls) {
    /**
     * Choice DropDown widget.
     * @class ListDropDownWidget
     * @memberOf classes
     * @extends classes.DropDownWidget
     */
    cls.ListDropDownWidget = context.oo.Class(cls.DropDownWidget, function($super) {
      return /** @lends classes.ListDropDownWidget.prototype */ {
        /** @lends classes.ListDropDownWidget */
        $static: {
          /**
           *
           * @private
           */
          _defaultItemRenderer: null,
          /**
           * Produces the default item renderer
           * @return {ListDropDownItemRenderer}
           */
          getDefaultItemRenderer: function() {
            if (!cls.ListDropDownWidget._defaultItemRenderer) {
              var uiModel = context.TemplateService.renderDOM(
                cls.CheckBoxWidget.prototype.__name,
                cls.CheckBoxWidget.prototype.__ascendance
              );
              uiModel.className += " " + cls.CheckBoxWidget.prototype.__ascendanceClasses;
              uiModel.addClass("gbc_ListDropDownWidget_item");
              uiModel.setAttribute("combovalue", "#$value#");
              var labelElement = document.createElement('div');
              labelElement.addClass('label');
              labelElement.textContent = "#$text#";
              uiModel.getElementsByClassName('content')[0].appendChild(labelElement);
              var model = uiModel.outerHTML.split("#");
              cls.ListDropDownWidget._defaultItemRenderer = function(model, item) {
                var result = "",
                  len = model.length;
                for (var i = 0; i < len; i++) {
                  // escape HTML conflicting chars such as quote and double-quotes before adding it in the DOM
                  result += model[i][0] === "$" ? (item[model[i].substr(1)].escapeHTML() || "") : model[i];
                }
                return result;
              }.bind(null, model);
            }
            return cls.ListDropDownWidget._defaultItemRenderer;
          }
        },
        __name: "ListDropDownWidget",
        __templateName: "DropDownWidget",
        /**
         * @inheritDoc
         */
        autoSize: true,
        /**
         * whether or not this list will allow multiple value selection
         * @type {boolean}
         */
        _allowMultipleValues: false,
        /**
         * whether or not this list will allow null value
         * @type {boolean}
         */
        _notNull: false,
        /**
         * internal - used for positioning computation
         * @type {number}
         */
        _nullableShift: 0,
        /**
         * current items - raw data
         * @type {Object[]}
         */
        _items: null,
        /**
         * currently highlighted element
         * @type {number}
         */
        _currentIndex: -1,
        /**
         * currently set value
         * @type {string}
         */
        _currentValue: "",
        /**
         * item renderer
         * @type {ListDropDownItemRenderer}
         */
        _itemRenderer: null,

        /**
         * @inheritDoc
         */
        _initContainerElement: function() {
          $super._initContainerElement.call(this);

          this._items = [];
          this._itemRenderer = cls.ListDropDownWidget.getDefaultItemRenderer();
          this._containerElement.on("click.ListDropDownWidget", this._onClick.bind(this));
          if (!window.isMobile()) {
            this._containerElement.on('mouseover.ListDropDownWidget', this._onMouseover.bind(this));
          }

          this.onOpen(function() {
            if (this.getParentWidget().getEditValue) {
              var currentValue = this.getParentWidget().getValue() || this.getParentWidget().getEditValue();
              this.setCurrentValue(currentValue);
            }
          }.bind(this));
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._containerElement.off("click.ListDropDownWidget");
          if (!window.isMobile()) {
            this._containerElement.off('mouseover.ListDropDownWidget');
          }
          this._items.length = 0;
          $super.destroy.call(this);
        },

        /**
         * Mouse over handler used to highlight current item.
         * We can't use css :hover otherwise there will be duplicated highlights with keyboard navigation
         * @param event
         * @private
         */
        _onMouseover: function(event) {
          var element = event.target;
          if (element) {
            var widgetElement = element.hasClass("gbc_WidgetBase") ? element : element.parent("gbc_WidgetBase");
            this._highlightCurrentItem(widgetElement);
          }
        },

        /**
         * Highlight current item of the dropdown
         * @param widgetElement
         * @private
         */
        _highlightCurrentItem: function(widgetElement) {
          if (this._currentElement && this._currentElement !== widgetElement) {
            this._currentElement.removeClass("current");
          }
          this._currentElement = widgetElement;
          if (this._currentElement &&
            !this._currentElement.hasClass("current") &&
            !this._currentElement.hasClass("hidden") &&
            (!this._currentElement.hasClass("disabled") || this._currentElement.hasAttribute("interruptable-active"))) {
            this._currentElement.addClass("current");
          }
        },

        /**
         * set the items
         * @param {ListDropDownWidgetItem[]} list items
         */
        setItems: function(list) {
          var len = list.length;
          this._items = [];
          for (var i = 0; i < len; i++) {
            this._items.push({
              text: list[i].text,
              value: list[i].value,
              searchText: list[i].text.toLocaleLowerCase()
            });
          }
          this._updateUIList();
        },

        /**
         * Get the items
         * @return {ListDropDownWidgetItem[]} list items
         */
        getItems: function() {
          return this._items;
        },

        /**
         * refresh DOM list
         * @private
         */
        _updateUIList: function() {
          var len = this._items.length,
            hasNull = false,
            content = [];
          for (var i = 0; i < len; i++) {
            content.push(this._itemRenderer(this._items[i]));
            if (this._items[i].value === "") {
              hasNull = true;
            }
            if (this._items[i].value === this._currentValue) {
              this._currentIndex = i;
            }
          }
          if (!hasNull && !this._notNull) {
            this._nullableShift = 1;
            content.push(this._itemRenderer({
              text: "",
              value: "",
              searchText: ""
            }));
            if (this._currentValue === "") {
              this._currentIndex = len;
            }
          } else {
            this._nullableShift = 0;
          }
          this._containerElement.innerHTML = content.join("");

          if (this.isVisible()) {
            this.hide();
            this.show();
          }

          this._updateCurrentIndex();
          this._updateUIListAria();
          this._updateUIListSelects();
        },
        /**
         * udpate current index value from current value and current items
         * @private
         */
        _updateCurrentIndex: function() {
          this._currentIndex = -1;
          var len = this._items.length,
            hasNull = false;
          for (var i = 0; i < len; i++) {
            if (this._currentValue === this._items[i].value) {
              this._currentIndex = i;
            }
            if (this._items[i].value === "") {
              hasNull = true;
            }
          }
          if (!hasNull && !this._notNull) {
            if (this._currentValue === "") {
              this._currentIndex = len;
            }
          }
        },

        /**
         * update item checkboxes visibility
         * @private
         */
        _updateUIListSelects: function() {
          this.domAttributesMutator(function() {
            var checkboxes = this._containerElement.querySelectorAll(".gbc_ListDropDownWidget_item i.zmdi"),
              len = checkboxes.length;
            for (var i = 0; i < len; i++) {
              checkboxes[i].setAttribute("style", this._allowMultipleValues ? "" : "display:none !important");
            }
          }.bind(this));
        },

        /**
         * update items accessibility attributes
         * @private
         */
        _updateUIListAria: function() {
          this.domAttributesMutator(function() {
            var items = this._containerElement.querySelectorAll(".gbc_ListDropDownWidget_item"),
              len = items.length;
            for (var i = 0; i < len; ++i) {
              items[i].setAttribute("aria-role", 'option');
              items[i].setAttribute("aria-posinset", (i + 1).toString());
              items[i].setAttribute("aria-setsize", len.toString());
            }
          }.bind(this));
        },

        /**
         * Get item value by its index
         * @param {number} index index
         * @return {string} the value
         */
        valueByIndex: function(index) {
          var item = this._items[index];
          return item && item.value || "";
        },

        /**
         * Get item index by its value
         * @param {string} value value
         * @return {number} the index
         */
        indexByValue: function(value) {
          var i = 0,
            found = false,
            len = this._items.length;
          for (; i < len; i++) {
            if (this._items[i].value === value) {
              found = true;
              break;
            }
          }
          if (!found && !this._notNull) {
            return len;
          }
          return i < len ? i : -1;
        },

        /**
         * Get item by its value
         * @param {string} value value
         * @return {Object} the item
         */
        findByValue: function(value) {
          return this._items.find(function(item) {
            return item.value === value;
          });
        },
        /**
         * find item starting by searchPattern beginning at current index. will loop to cover all items.
         * @param {string} searchPattern first letters of searched item
         * @param {boolean} startAfterCurrentItem exclude current index item as first matching element
         * @return {Object} found item
         */
        findStartingByText: function(searchPattern, startAfterCurrentItem) {
          var current = this._currentIndex + (startAfterCurrentItem ? 1 : 0);
          return this._items.find(function(item, i) {
            return i >= current && item.searchText.indexOf(searchPattern) === 0;
          }) || this._items.find(function(item, i) {
            return i < current && item.searchText.indexOf(searchPattern) === 0;
          });
        },
        /**
         * set whether or not this list will allow null value
         * @param {boolean} notNull not null
         */
        setNotNull: function(notNull) {
          if (this._notNull !== notNull) {
            this._notNull = notNull;
            this._updateUIList();
          }
        },
        /**
         * @inheritDoc
         */
        managePriorityKeyDown: function(keyString, domKeyEvent, repeat) {
          var keyProcessed = true;

          switch (keyString) {
            case "space":
              if (!this.isVisible()) {
                if (this.getParentWidget().canInputText && this.getParentWidget().canInputText()) {
                  return false;
                }
                this.show();
              } else if (this._allowMultipleValues) {
                this._selectItem(this.getCurrentValue());
              } else {
                this.hide();
              }
              break;
            case "enter":
            case "return":
              if (!this._allowMultipleValues) {
                this._selectItem(this.getCurrentValue());
              }
              this.hide();
              break;
            case "up":
              this.navigateTo(-1);
              break;
            case "down":
              this.navigateTo(1);
              break;
            case "pageup":
              this.navigateTo(-10);
              break;
            case "pagedown":
              this.navigateTo(10);
              break;
            case "home":
              this.navigateTo(Number.NEGATIVE_INFINITY);
              break;
            case "end":
              this.navigateTo(Number.POSITIVE_INFINITY);
              break;
            case "tab":
            case "shift+tab":
              if (this.isVisible()) {
                this.hide();
              }
              keyProcessed = false;
              break;
            default:
              keyProcessed = false;
          }

          if (keyProcessed) {
            return true;
          } else {
            return $super.managePriorityKeyDown.call(this, keyString, domKeyEvent, repeat);
          }
        },

        /**
         * set current index on item
         * @param {Object} item item
         */
        navigateToItem: function(item) {
          this.setCurrentPosition(this.indexByValue(item.value));
        },

        /**
         * set current index relatively
         * @param {number} pos shifting value
         */
        navigateTo: function(pos) {
          if (pos === Number.NEGATIVE_INFINITY) {
            pos = 0;
          } else if (pos === Number.POSITIVE_INFINITY) {
            pos = this._items.length - 1 + this._nullableShift;
          } else {
            pos = Math.min(Math.max(0, this._currentIndex + pos), this._items.length - 1 + this._nullableShift);
          }
          this.setCurrentPosition(pos);
          if (!this.isVisible()) {
            this.emit(context.constants.widgetEvents.select, this.getCurrentValue());
          }
        },
        /**
         * get value of the current index
         * @return {string}
         */
        getCurrentValue: function() {
          return this.valueByIndex(this._currentIndex);
        },
        /**
         * set the current value
         * @param {string} value
         */
        setCurrentValue: function(value) {
          this._currentValue = value || "";
          if (this._allowMultipleValues) {
            this.setSelectedValues(value);
          }
          this.setCurrentPosition(this.indexByValue(value));
        },
        /**
         * set current index and potentially scroll to it
         * @param {number} pos index
         */
        setCurrentPosition: function(pos) {
          var currents = this._containerElement.querySelectorAll(".current"),
            len = currents.length;
          for (var i = 0; i < len; i++) {
            currents[i].removeClass("current");
          }
          var item = this._containerElement.children[pos];
          if (item) {
            this._currentElement = item;
            this._currentIndex = pos;
            item.addClass("current");
            if (this.isVisible()) {
              this.scrollItemIntoView(item);
            }
          }
        },

        /**
         * sorts input array in the same order as items array
         * @param {string[]} values input values
         * @return {string[]} sorted array
         */
        sortValues: function(values) {
          var result = [],
            len = this._items.length,
            hasNull = false;
          for (var i = 0; i < len; i++) {
            var value = this._items[i].value;
            if (values.indexOf(value) >= 0) {
              result.push(value);
              if (value === "") {
                hasNull = true;
              }
            }
          }
          if (!hasNull && values.indexOf("") >= 0) {
            result.push("");
          }
          return result;
        },
        /**
         * check items accordingly to value
         * @param {string} value value
         */
        setSelectedValues: function(value) {
          this.clearSelectedValues();
          if (value !== null) {
            value.split("|").map(function(itemValue) {
              this.toggleValue(itemValue, true);
            }.bind(this));
          }
        },
        /**
         * toggle the checked state of the given value
         * @param {string} value value
         * @param {boolean} [forcedValue] forced value
         */
        toggleValue: function(value, forcedValue) {
          var items = this._containerElement.querySelectorAll('.gbc_ListDropDownWidget_item');
          var check = null;
          // need to loop over items and directly check 'combovalue' attribute in order to manage quoted/double-quoted chars in value
          for (var i = 0; i < items.length; i++) {
            var item = items[i];
            if (item.getAttribute("combovalue") === value) {
              check = item.querySelector("i");
              break;
            }
          }
          if (check) {
            if (forcedValue === true || check.hasClass("unchecked")) {
              check.removeClass("unchecked").addClass("checked");
            } else if (forcedValue === false || check.hasClass("checked")) {
              check.removeClass("checked").addClass("unchecked");
            }
          }
        },
        /**
         * clear the checked state of the items
         */
        clearSelectedValues: function() {
          var checked = this._containerElement.querySelectorAll(".checked"),
            len = checked.length;
          for (var i = 0; i < len; i++) {
            checked[i].removeClass("checked").addClass("unchecked");
          }
        },
        /**
         * Scroll to element if needed
         * @param {HTMLElement} element element
         * @publicdoc
         */
        scrollItemIntoView: function(element) {
          var elemTop = element.offsetTop;
          var elemHeight = element.offsetHeight;
          var parentContainer = this.getElement();
          var containerTop = parentContainer.scrollTop;
          var containerHeight = parentContainer.offsetHeight;
          if (containerTop > elemTop) {
            element.scrollIntoView();
          } else if (containerTop + containerHeight < elemTop + elemHeight) {
            element.scrollIntoView(false);
          }
        },

        /**
         * On click handler raised when selecting an item in the dropdown :
         * Parent widget get value of clicked item and dropdown is closed.
         * @param domEvent
         * @private
         */
        _onClick: function(domEvent) {
          var item = domEvent.target.closest("gbc_ListDropDownWidget_item"),
            value = item && item.getAttribute("combovalue");
          if (value !== null) {
            this._selectItem(value);
            if (domEvent) {
              domEvent.stopPropagation();
            }

            if (!this._allowMultipleValues) {
              this.hide();
            }
            this.getParentWidget().emit(context.constants.widgetEvents.focus, domEvent);
          }
        },
        /**
         * Set value as selected item
         * @param {string} value value
         * @private
         */
        _selectItem: function(value) {
          this.setCurrentValue(value);
          this.toggleValue(value);
          this.emit(context.constants.widgetEvents.select, value);
        },

        /**
         * @inheritDoc
         */
        addChildWidget: function(widget, options) {
          // nothing intentionally here
        },

        /**
         * @inheritDoc
         */
        removeChildWidget: function(widget) {
          // nothing intentionally here
        },

        /**
         * set whether or not this list will allow null value
         * @param {boolean} allow allow
         */
        allowMultipleChoices: function(allow) {
          this._allowMultipleValues = allow;
          this._updateCurrentIndex();
          this._updateUIListSelects();
        }
      };
    });
    cls.WidgetFactory.registerBuilder('ListDropDown', cls.ListDropDownWidget);
  });
;
"use strict";

modulum('ListViewRowWidget', ['WidgetGroupBase'],
  function(context, cls) {

    /**
     * ListViewRow widget.
     * @class ListViewRowWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     * @publicdoc
     */
    cls.ListViewRowWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.ListViewRowWidget.prototype */ {
        __name: "ListViewRowWidget",

        /** @type boolean */
        _current: false,
        /** @type classes.ImageWidget */
        _imageWidget: null,
        /** @type boolean */
        _horizontalLayout: false,

        /** @type Element */
        _imageElement: null,

        /** @type classes.RowBoundDecoratorWidget */
        _rowBoundDecoratorWidget: null,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          this._ignoreLayout = true;
          $super._initElement.call(this);

          this._imageElement = this._element.getElementsByClassName("gbc_ListViewRowImage")[0];
          this._element.onDoubleTap("ListViewRowWidget", this._onDoubleClick.bind(this));
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          // no layout
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._element.offDoubleTap("ListViewRowWidget");

          if (this._imageWidget) {
            this._imageWidget.destroy();
            this._imageWidget = null;
          }
          if (this._rowBoundDecoratorWidget) {
            this._rowBoundDecoratorWidget.destroy();
            this._rowBoundDecoratorWidget = null;
          }
          this._imageElement = null;

          this.destroyChildren();
          $super.destroy.call(this);
        },

        /**
         * Request focus for this row
         * @param {*} domEvent - dom event object
         */
        requestFocus: function(domEvent) {
          var listViewWidget = this.getTableWidgetBase();
          if (listViewWidget) {
            listViewWidget.requestFocusFromWidget(this._children[0], domEvent);
          }
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {

          // Send a request focus only if none of the child widgets has been clicked
          // Otherwise, the request has already been sent
          var childClicked = false;
          for (var i = 0; !childClicked && i < this._children.length; ++i) {
            childClicked = domEvent.target.isElementOrChildOf(this._children[i].getElement());
          }
          var listViewWidget = this.getTableWidgetBase();
          if (!childClicked) {
            this.requestFocus(domEvent);
          }

          // trigger row action (but never if click is on rowbound)
          var clickInRowbound = listViewWidget.hasRowBound() && domEvent.target.isElementOrChildOf(this._rowBoundDecoratorWidget
            .getElement());
          if (!listViewWidget.isRowActionTriggerByDoubleClick() && !clickInRowbound) {
            listViewWidget.emit(context.constants.widgetEvents.rowAction);
            return false;
          }
          return true;
        },

        /**
         * @inheritDoc
         */
        manageMouseDblClick: function(domEvent) {
          this._onDoubleClick(domEvent);
          return false;
        },

        /**
         * Handle double click on row event
         * @param {Object} event
         */
        _onDoubleClick: function(event) {
          var listViewWidget = this.getTableWidgetBase();
          if (listViewWidget && listViewWidget.isRowActionTriggerByDoubleClick()) {
            listViewWidget.emit(context.constants.widgetEvents.rowAction);
          }
        },

        /**
         * @inheritDoc
         */
        addChildWidget: function(widget, options) {
          if (this._children.length > 2) {
            throw "A listview item can only contain two children";
          }
          $super.addChildWidget.call(this, widget, options);
        },

        /**
         * Sets the first and second widgets layout type to horizontal or vertical
         * @param {boolean} horizontal true for horizontal layout, false otherwise
         */
        setHorizontalLayout: function(horizontal) {
          this._horizontalLayout = horizontal;
          this._element.toggleClass('horizontal', horizontal);
        },

        /**
         * @return {boolean} true if the layout is horizontal
         */
        isHorizontalLayout: function() {
          return this._horizontalLayout;
        },

        /**
         * Set image of the row
         * @param {string} path - image path
         */
        setImage: function(path) {
          if (path && path !== "") {
            if (!this._imageWidget) {
              this._imageWidget = cls.WidgetFactory.createWidget("ImageWidget", this.getBuildParameters());
              this._imageWidget.setParentWidget(this);
              this._imageElement.appendChild(this._imageWidget.getElement());
            }
            this._imageWidget.setSrc(path);

            // fix for ie11, this browser is not able to auto resize an SVG
            if (window.browserInfo.isIE) {
              var width = null;
              if (path.startsWith("font:")) {
                width = this.getParentWidget().getRowHeight() + "px";
              }
              this.setStyle(" .gbc_ImageWidget", {
                "width": width
              });
            } // end ie11 fix

            this._imageWidget.getElement().removeClass("hidden");
            this._imageElement.removeClass("hidden");

          } else if (this._imageWidget) {
            this._imageElement.addClass("hidden");
          }
        },

        /**
         * Returns the number of line in the row
         * @returns {number} number of line in the row
         * @publicdoc
         */
        getLineCount: function() {
          if (this._horizontalLayout) {
            return Math.min(this.getChildren().length, 1);
          } else {
            return this.getChildren().length;
          }
        },

        /**
         * Sets if the row is the current one
         * @param {boolean} current - true if row is the current one, false otherwise
         * @publicdoc
         */
        setCurrent: function(current) {
          if (this._current !== current) {
            this._current = current;
            if (!!current) {
              this._element.addClass("currentRow");
            } else {
              this._element.removeClass("currentRow");
            }
          }
        },

        /**
         * @inheritDoc
         */
        isLayoutMeasureable: function(deep) {
          return true;
        },

        /**
         * Creates and adds rowBound decorator element to DOM
         */
        addRowBoundDecorator: function() {
          this._rowBoundDecoratorWidget = cls.WidgetFactory.createWidget("RowBoundDecorator", this.getBuildParameters());
          this._rowBoundDecoratorWidget.setParentWidget(this);
          this._element.appendChild(this._rowBoundDecoratorWidget.getElement());
        }
      };
    });
    cls.WidgetFactory.registerBuilder('ListViewRow', cls.ListViewRowWidget);
  });
;
"use strict";

modulum('ListViewWidget', ['TableWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Listview widget.
     * @class ListViewWidget
     * @memberOf classes
     * @extends classes.TableWidgetBase
     * @publicdoc
     */
    cls.ListViewWidget = context.oo.Class(cls.TableWidgetBase, function($super) {
      return /** @lends classes.ListViewWidget.prototype */ {
        __name: "ListViewWidget",

        $static: {
          defaultRowHeight: 24,
          defaultOneLineHeightRatio: 1.7,
          defaultTwoLinesHeightRatio: 2.6
        },

        /** styles */
        _highlightCurrentRowCssSelector: ":not(.disabled).highlight .gbc_ListViewRowWidget.currentRow",

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          this.setRowHeight(cls.ListViewWidget.defaultRowHeight);
          this.getScrollableArea().on('scroll.ListViewWidget', this._onScroll.bind(this));
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          this._layoutInformation = new cls.LayoutInformation(this);
          this._layoutEngine = new cls.ListViewLayoutEngine(this);

          this._layoutInformation.getStretched().setDefaultX(true);
          this._layoutInformation.getStretched().setDefaultY(true);

          var minPageSize = parseInt(context.ThemeService.getValue("gbc-ListViewWidget-min-page-size"), 10);
          this._layoutEngine.setMinPageSize(isNaN(minPageSize) ? 1 : minPageSize);
          var minWidth = parseInt(context.ThemeService.getValue("gbc-ListViewWidget-min-width"), 10);
          this._layoutEngine.setMinWidth(isNaN(minWidth) ? 60 : minWidth);
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this.destroyChildren();
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        setFocus: function(fromMouse) {
          this.domFocus(fromMouse);
          $super.setFocus.call(this, fromMouse);
        },

        /**
         * Called when a scroll is done
         * @param {Object} event - scroll event
         */
        _onScroll: function(event) {
          this.afterDomMutator(function() {
            if (event.target) {
              // Emit scroll event for vertical scrolling
              this.emit(context.constants.widgetEvents.scroll, event, this.getRowHeight());
            }
          }.bind(this));
        },

        /**
         * Returns row widgets
         * @returns {classes.ListViewRowWidget[]} array of row widgets
         * @publicdoc
         */
        getRows: function() {
          return this.getChildren();
        },

        /**
         * @inheritDoc
         */
        addChildWidget: function(widget, options) {

          $super.addChildWidget.call(this, widget, options);

          if (widget.isInstanceOf(cls.ListViewRowWidget)) {
            widget.setHidden(this._children.length >= this._visibleRows);
            if (this.hasRowBound()) {
              widget.addRowBoundDecorator();
            }
          }
        },

        /**
         * @inheritDoc
         */
        setVisibleRows: function(visibleRows) {
          if (this._visibleRows !== visibleRows) {
            this._visibleRows = visibleRows;
            var rows = this.getChildren();
            for (var i = 0; i < rows.length; ++i) {
              var row = rows[i];
              row.setHidden(i >= visibleRows);
            }
          }
        },

        /**
         * @inheritDoc
         */
        setRowHeight: function(height) {
          if (this._rowHeight !== height) {
            this._rowHeight = height;
            this.setStyle(" .gbc_ListViewRowWidget", {
              "height": height + "px"
            });

            this.setStyle(" .gbc_ImageWidget", {
              "height": height + "px"
            });

            this.updateVerticalScroll(true); // refresh vertical scroll if row height has changed
          }
        },

        /**
         * @inheritDoc
         */
        updateContentPosition: function(size, pageSize, offset, forceScroll) {

          if (size !== null) {
            this.setSize(size);
            this._pageSize = pageSize;

            var top = 0;
            var height = 0;

            if (this.isEnabled()) {
              top = offset * this.getRowHeight();
              height = (size - offset) * this.getRowHeight();
            } else {
              height = this._visibleRows * this.getRowHeight();
            }

            this.setStyle({
              preSelector: ".g_measured ",
              selector: ".gbc_ListViewRowsContainer"
            }, {
              "margin-top": top + "px",
              "height": height + "px"
            });

            // if offset is different or if scrolltop value of current scrollarea is different too different from calculated value
            // need to rest scrolltop of scrollablearea
            if (!!forceScroll || (this.lastSentOffset === null || this.lastSentOffset === offset) && offset !== this._offset) {
              this._offset = offset;
              // need to do this because to scroll we need to wait the style "height" set just before is really applied in the dom
              this.afterDomMutator(function() {
                this.doScroll(top, false);
              }.bind(this));
            }
            this.lastSentOffset = null;
          }
        },

        /**
         * Returns if vertical scroll bar is at end
         * @returns {boolean} true if vertical Scroll bar is at end
         */
        isVerticalScrollAtEnd: function() {
          var scrollArea = this.getScrollableArea();
          return (scrollArea.scrollTop + scrollArea.clientHeight) === scrollArea.scrollHeight;
        },

        /**
         * Do native vertical scroll
         * @param {number} value - new scroll value
         * @param {boolean} delta - if true, value is added to old scroll value
         */
        doScroll: function(value, delta) {
          var top = value;
          if (delta) {
            top = (this.getScrollableArea().scrollTop + value);
          }
          this.getScrollableArea().scrollTop = top;
        },

        /**
         * @inheritDoc
         */
        setCurrentRow: function(row, ensureRowVisible) {
          this._currentRow = row;
          var children = this.getChildren();
          var length = children.length;
          for (var i = 0; i < length; ++i) {
            var rowWidget = children[i];
            rowWidget.setCurrent(i === row);
          }
        },

        // ============== START - STYLE FUNCTIONS ===================
        /**
         * @inheritDoc
         */
        setHighlightColor: function(color) {

          if (this._highlightColor !== color) {
            this._highlightColor = color;

            color = (color === null ? null : color + " !important");
            this.setStyle({
              selector: this._highlightCurrentRowCssSelector,
              appliesOnRoot: true
            }, {
              "background-color": color
            });

            this.setStyle({
              selector: this._highlightCurrentRowCssSelector + " *",
              appliesOnRoot: true
            }, {
              "background-color": color
            });
          }
        },

        /**
         * @inheritDoc
         */
        setHighlightTextColor: function(color) {

          if (this._highlightTextColor !== color) {
            this._highlightTextColor = color;

            color = (color === null ? null : color + " !important");
            this.setStyle({
              selector: this._highlightCurrentRowCssSelector + " *",
              appliesOnRoot: true
            }, {
              "color": color,
              "fill": color
            });
          }
        },

        /**
         * @inheritDoc
         */
        setHighlightCurrentRow: function(b) {
          this._highlightCurrentRow = b;
          this.getElement().toggleClass("highlight", b);
          this.getElement().toggleClass("nohighlight", !b);
        },

        /**
         * Update highlight row
         */
        updateHighlight: function() {
          this.setCurrentRow(this._currentRow);
        },

        // ============== END - STYLE FUNCTIONS ===================

        // ============== START - DOM ELEMENT GETTERS ===================
        /**
         * @inheritDoc
         */
        getScrollableArea: function() {
          if (!this._scrollAreaElement) {
            this._scrollAreaElement = this._element.getElementsByClassName("gbc_ListViewScrollArea")[0];
          }
          return this._scrollAreaElement;
        }
        // ============== END - DOM ELEMENT GETTERS =====================
      };
    });
    cls.WidgetFactory.registerBuilder("Table[tableType=listView]", cls.ListViewWidget);
  });
;
"use strict";

modulum('ModalWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Modal widget.
     * @class ModalWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     */
    cls.ModalWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.ModalWidget.prototype */ {
        __name: "ModalWidget",
        /**
         * header element
         * @type {HTMLElement}
         */
        _header: null,
        /**
         * header hidden state
         * @type {boolean}
         */
        _headerHidden: false,
        /**
         * footer element
         * @type {HTMLElement}
         */
        _footer: null,
        /**
         * title element
         * @type {HTMLElement}
         */
        _title: null,
        /**
         * dialog pane element
         * @type {HTMLElement}
         */
        _dialogPane: null,

        /**
         * header actions host element
         * @type {HTMLElement}
         */
        _actionsHost: null,
        /**
         * close button element
         * @type {HTMLElement}
         */
        _closeButton: null,

        /**
         * is displayed
         * @type {boolean}
         */
        _displayed: false,
        /**
         * is a system modal
         * @type {boolean}
         */
        _systemModal: false,
        /**
         * resize handler
         */
        _systemModalResizeHandler: null,

        /**
         * flag to set first fixed size
         * @type {boolean}
         */
        _hasInitialContainment: true,
        /**
         * is movable
         * @type {boolean}
         */
        _canMove: false,
        /**
         * has it moved
         * @type {boolean}
         */
        _hasBeenMoved: false,
        /**
         * internal computing information
         * @type {?{current:{x:number, y:number}, reference:{x:number, y:number}, minDelta:{x:number, y:number}, maxDelta:{x:number, y:number}, drag:{x:number, y:number}}}
         */
        _movingPositions: null,
        /**
         * is it moving
         * @type {boolean}
         */
        _isMoving: false,
        /**
         * move drag handle element
         * @type {HTMLElement}
         */
        _movableDragHandle: null,

        /**
         * is it sizable
         * @type {boolean}
         */
        _canSize: false,
        /**
         * has it resized
         * @type {boolean}
         */
        _hasBeenSized: false,
        /**
         * internal computing information
         * @type {?{current:{x:number, y:number}, size:{x:number, y:number}, min:{x:number, y:number}, max:{x:number, y:number}, contentMin:{x:number, y:number}, decoration:{x:number, y:number}, drag:{x:number, y:number}}}
         */
        _sizingPositions: null,
        /**
         * is it resizing
         * @type {boolean}
         */
        _isSizing: false,
        /**
         * resize drag handle element
         * @type {HTMLElement}
         */
        _sizableDragHandle: null,
        /**
         * resize drag indicator element
         * @type {HTMLElement}
         */
        _resizerIcon: null,
        /**
         * is modal closable. Yes by default.
         * @type {boolean}
         */
        _isClosable: true,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          this._header = this._element.getElementsByClassName('mt-dialog-header')[0];
          this._header.toggleClass("hidden", false);
          this._footer = this._element.getElementsByClassName('mt-dialog-footer')[0];
          this._title = this._header.getElementsByClassName('mt-dialog-title')[0];
          this._actionsHost = this._header.getElementsByClassName('mt-dialog-actions')[0];
          this._dialogPane = this._element.querySelector(".mt-dialog-pane");
          this._closeButton = this._actionsHost.getElementsByClassName('close')[0];
          this._resizerIcon = this._element.getElementsByClassName("mt-resizer-icon")[0];
          this._closeButton.on("click.ModalWidget", function() {
            this.emit(context.constants.widgetEvents.close);
          }.bind(this));
          this._element.on("click.ModalWidget", function(evt) {
            if (evt.target === evt.currentTarget) {
              this.emit(context.constants.widgetEvents.modalOut);
            }
          }.bind(this));
          this._initMovable();
          this._initSizable();
          this.setMovable(true);
        },

        resetLayout: function() {
          this._hasInitialContainment = true;
          this._hasBeenMoved = false;
          this._hasBeenSized = false;
          this._dialogPane.style.left = "";
          this._dialogPane.style.right = "";
          this._dialogPane.style.width = "";
          this._dialogPane.style.height = "";
          this._dialogPane.style.top = "";
          this._dialogPane.removeClass("moved");
          this._dialogPane.removeClass("sized");
          this._resetMovable();
          this._resetSizable();
          this.getLayoutEngine().reset(true);
          this.getLayoutInformation().reset(true);
        },
        /**
         * set first fixed size
         * @private
         */
        _removeInitialContainment: function() {
          if (this._hasInitialContainment) {
            this._hasInitialContainment = false;
            var containerRect = this.getElement().getBoundingClientRect(),
              dialogRect = this._dialogPane.getBoundingClientRect();
            this._setAsMoved(
              this.isReversed() ? containerRect.right - dialogRect.right : (dialogRect.left - containerRect.left),
              dialogRect.top - containerRect.top);
            this._dialogPane.removeClass("initial");
          }
        },

        /**
         * Make the modal window movable
         * @param {boolean} movable will it be movable
         */
        setMovable: function(movable) {
          this._canMove = movable;
          this._element.toggleClass("movable", movable);
        },

        /**
         * Start the movable process
         * @private
         */
        _initMovable: function() {
          this._resetMovable();
          this._movableDragHandle = this._element.getElementsByClassName("movable_firefox_placekeeper")[0];
          this._header.setAttribute("draggable", "true");
          this._header.on("dragstart.MovableModalWidget", this._onMovableDragStart.bind(this));
          this._header.on("dragend.MovableModalWidget", this._onMovableDragEnd.bind(this));
          this._header.on("drag.MovableModalWidget", this._onMovableDrag.bind(this));
        },

        _resetMovable: function() {
          this._movingPositions = {
            reference: {
              x: 0,
              y: 0
            },
            current: {
              x: 0,
              y: 0
            },
            minDelta: {
              x: 0,
              y: 0
            },
            maxDelta: {
              x: 0,
              y: 0
            },
            drag: {
              x: 0,
              y: 0
            }
          };
        },

        /**
         * handle on drag over for move
         * @param {MouseEvent} evt the event
         * @private
         */
        _onMovableDragOver: function(evt) {
          this._movingPositions.current.x = evt.pageX;
          this._movingPositions.current.y = evt.pageY;
          evt.preventCancelableDefault();
        },
        /**
         * move at given position
         * @param {number} x x position
         * @param {number} y y position
         * @private
         */
        _setAsMoved: function(x, y) {
          this._dialogPane.addClass("moved");
          this._removeInitialContainment();
          this._movingPositions.reference.x = x;
          this._movingPositions.reference.y = y;
          this._dialogPane.style.left = this.isReversed() ? "" :
            ("" + Math.max(context.ThemeService.getValue("theme-margin-ratio") * 8, this._movingPositions.reference.x) + "px");
          this._dialogPane.style.right = !this.isReversed() ? "" :
            ("" + Math.max(context.ThemeService.getValue("theme-margin-ratio") * 8, this._movingPositions.reference.x) + "px");
          this._dialogPane.style.top = "" + Math.max(context.ThemeService.getValue("theme-margin-ratio") * 8, this._movingPositions
              .reference
              .y) +
            "px";
          this._hasBeenMoved = true;
        },
        /**
         * set first position
         * @private
         */
        _initMoved: function() {
          var containerRect = this.getElement().getBoundingClientRect(),
            dialogRect = this._dialogPane.getBoundingClientRect();
          var min = context.ThemeService.getValue("theme-margin-ratio") * 8,
            x = Math.max(min, this.isReversed() ? containerRect.right - dialogRect.right : (dialogRect.left - containerRect.left)),
            y = Math.max(min, dialogRect.top - containerRect.top);
          this._setAsMoved(x, y);
        },

        /**
         * handle on drag start for move
         * @param {MouseEvent} evt the event
         * @private
         */
        _onMovableDragStart: function(evt) {
          if (this._canMove) {
            this._element.addClass("moving");
            var containerRect = this.getElement().getBoundingClientRect(),
              dialogRect = this._dialogPane.getBoundingClientRect();
            if (!this._hasBeenMoved) {
              this._setAsMoved(this.isReversed() ? containerRect.right - dialogRect.right : (dialogRect.left - containerRect.left),
                dialogRect.top - containerRect.top);
            }
            this._movingPositions.minDelta.x =
              (this.isReversed() ? dialogRect.right - containerRect.right : (containerRect.left - dialogRect.left)) +
              context.ThemeService.getValue("theme-margin-ratio") * 8;
            this._movingPositions.minDelta.y = containerRect.top - dialogRect.top + context.ThemeService.getValue(
              "theme-margin-ratio") * 8;
            this._movingPositions.maxDelta.x =
              (this.isReversed() ?
                dialogRect.right - containerRect.right + containerRect.width - dialogRect.width :
                (containerRect.left - dialogRect.left + containerRect.width - dialogRect.width)) -
              context.ThemeService.getValue("theme-margin-ratio") * 8;
            this._movingPositions.maxDelta.y = containerRect.height + containerRect.top - dialogRect.height - dialogRect.top -
              context.ThemeService.getValue("theme-margin-ratio") * 8;
            this.getElement().on("dragover.MovableModalWidget", this._onMovableDragOver.bind(this));
            this._isMoving = true;
            if (window.browserInfo.isFirefox) {
              evt.dataTransfer.setData('text', ''); // for Firefox compatibility
            }
            if (evt.dataTransfer.setDragImage) {
              evt.dataTransfer.setDragImage(this._movableDragHandle, 0, 0);
            }
            evt.dataTransfer.effectAllowed = "move";
            this._movingPositions.current.x = evt.pageX;
            this._movingPositions.current.y = evt.pageY;
            this._movingPositions.drag.x = evt.pageX;
            this._movingPositions.drag.y = evt.pageY;
          } else {
            evt.preventCancelableDefault();
          }
          return false;
        },

        /**
         * handle on drag end for move
         * @param {MouseEvent} evt the event
         * @private
         */
        _onMovableDragEnd: function(evt) {
          this._element.removeClass("moving");
          this.getElement().off("dragover.MovableModalWidget");
          var deltaX = (this._movingPositions.current.x - this._movingPositions.drag.x) * (this.isReversed() ? -1 : 1);
          var deltaY = this._movingPositions.current.y - this._movingPositions.drag.y;
          if (deltaX * deltaX + deltaY * deltaY > 16 * 16) {
            this._movingPositions.reference.x =
              Math.max(context.ThemeService.getValue("theme-margin-ratio") * 8, this._movingPositions.reference.x +
                Math.min(Math.max(deltaX, this._movingPositions.minDelta.x), this._movingPositions.maxDelta.x));
            this._movingPositions.reference.y =
              Math.max(context.ThemeService.getValue("theme-margin-ratio") * 8, this._movingPositions.reference.y +
                Math.min(Math.max(deltaY, this._movingPositions.minDelta.y), this._movingPositions.maxDelta.y));
            this._isMoving = false;
          }
        },

        /**
         * handle on drag for move
         * @param {MouseEvent} evt the event
         * @private
         */
        _onMovableDrag: function(evt) {
          if (this._isMoving) {
            var deltaX = (this._movingPositions.current.x - this._movingPositions.drag.x) * (this.isReversed() ? -1 : 1);
            var deltaY = this._movingPositions.current.y - this._movingPositions.drag.y;
            if (deltaX * deltaX + deltaY * deltaY > 100) {
              this._updateMovablePosition(
                Math.min(Math.max(deltaX, this._movingPositions.minDelta.x), this._movingPositions.maxDelta.x),
                Math.min(Math.max(deltaY, this._movingPositions.minDelta.y), this._movingPositions.maxDelta.y)
              );
            }
          }
        },

        /**
         * update visual position when moving
         * @param {number} deltaX x position delta
         * @param {number} deltaY y position delta
         * @private
         */
        _updateMovablePosition: function(deltaX, deltaY) {
          this._dialogPane.style.left = this.isReversed() ? "" :
            ("" + Math.max(context.ThemeService.getValue("theme-margin-ratio") * 8, this._movingPositions.reference.x + deltaX) +
              "px");
          this._dialogPane.style.right = !this.isReversed() ? "" :
            ("" + Math.max(context.ThemeService.getValue("theme-margin-ratio") * 8, this._movingPositions.reference.x + deltaX) +
              "px");
          this._dialogPane.style.top = "" + Math.max(context.ThemeService.getValue("theme-margin-ratio") * 8, this._movingPositions
            .reference
            .y +
            deltaY) + "px";
        },

        /**
         * Make the modal window resizable
         * @param {boolean} sizable will it be sizable
         */
        setSizable: function(sizable) {
          this._canSize = sizable;
          this._element.toggleClass("sizable", sizable);
        },
        /**
         * init sizable data
         * @private
         */
        _initSizable: function() {
          this._resetSizable();
          this._resizer = this._element.querySelector(".mt-dialog-resizer");
          this._sizableDragHandle = this._element.getElementsByClassName("sizable_firefox_placekeeper")[0];
          this._resizer.setAttribute("draggable", "true");
          this._resizer.on("dragstart.SizableModalWidget", this._onSizableDragStart.bind(this));
          this._resizer.on("dragend.SizableModalWidget", this._onSizableDragEnd.bind(this));
          this._resizer.on("drag.SizableModalWidget", this._onSizableDrag.bind(this));
        },

        _resetSizable: function() {
          this._sizingPositions = {
            size: {
              x: 0,
              y: 0
            },
            reference: {
              x: 0,
              y: 0
            },
            current: {
              x: 0,
              y: 0
            },
            min: {
              x: 0,
              y: 0
            },
            contentMin: {
              x: 0,
              y: 0
            },
            max: {
              x: 0,
              y: 0
            },
            drag: {
              x: 0,
              y: 0
            },
            decoration: {
              x: 0,
              y: 0
            }
          };
        },

        /**
         * handle on drag over for resize
         * @param {MouseEvent} evt the event
         * @private
         */
        _onSizableDragOver: function(evt) {
          this._sizingPositions.current.x = evt.pageX;
          this._sizingPositions.current.y = evt.pageY;
          evt.preventCancelableDefault();
        },
        /**
         * handle on drag start for resize
         * @param {MouseEvent} evt the event
         * @private
         */
        _onSizableDragStart: function(evt) {
          if (this._canSize) {
            this._element.addClass("sizing");
            var containerRect = this.getElement().getBoundingClientRect(),
              dialogRect = this._dialogPane.getBoundingClientRect(),
              contentRect = (this._element.querySelector(".gbc_WindowContent") || this._containerElement).getBoundingClientRect();
            if (!this._hasBeenMoved) {
              this._setAsMoved(dialogRect.left - containerRect.left, dialogRect.top - containerRect.top);
            }
            if (!this._hasBeenSized) {
              this._dialogPane.addClass("sized");
              this._removeInitialContainment();
              this._sizingPositions.min.x = dialogRect.width;
              this._sizingPositions.min.y = dialogRect.height;
              this._hasBeenSized = true;
            }
            this._sizingPositions.decoration.x = dialogRect.width - contentRect.width;
            this._sizingPositions.decoration.y = dialogRect.height - contentRect.height;

            this._sizingPositions.min.x = this._sizingPositions.contentMin.x ?
              this._sizingPositions.contentMin.x + this._sizingPositions.decoration.x + window.scrollBarSize : dialogRect.width;
            this._sizingPositions.min.y = this._sizingPositions.contentMin.y ?
              this._sizingPositions.contentMin.y + this._sizingPositions.decoration.y + window.scrollBarSize : dialogRect.height;
            this._sizingPositions.size.x = this._sizingPositions.reference.x = dialogRect.width;
            this._sizingPositions.size.y = this._sizingPositions.reference.y = dialogRect.height;

            this._sizingPositions.max.x = (this.isReversed() ?
                containerRect.width + dialogRect.right - containerRect.right :
                (containerRect.width - dialogRect.left + containerRect.left)) - context.ThemeService.getValue(
                "theme-margin-ratio") *
              8;
            this._sizingPositions.max.y = containerRect.height - dialogRect.top +
              containerRect.top - context.ThemeService.getValue("theme-margin-ratio") * 8;
            this.getElement().on("dragover.SizableModalWidget", this._onSizableDragOver.bind(this));
            this._isSizing = true;
            if (window.browserInfo.isFirefox) {
              evt.dataTransfer.setData('text', ''); // for Firefox compatibility
            }
            if (evt.dataTransfer.setDragImage) {
              evt.dataTransfer.setDragImage(this._sizableDragHandle, 0, 0);
            }
            evt.dataTransfer.effectAllowed = "move";
            this._sizingPositions.current.x = evt.pageX;
            this._sizingPositions.current.y = evt.pageY;
            this._sizingPositions.drag.x = evt.pageX;
            this._sizingPositions.drag.y = evt.pageY;
          } else {
            evt.preventCancelableDefault();
          }
          return false;
        },

        /**
         * handle on drag end for resize
         * @param {MouseEvent} evt the event
         * @private
         */
        _onSizableDragEnd: function(evt) {
          this._element.removeClass("sizing");
          this.getElement().off("dragover.SizableModalWidget");
          var deltaX = this._sizingPositions.reference.x + (this._sizingPositions.current.x - this._sizingPositions.drag.x) * (this
            .isReversed() ? -1 : 1);
          var deltaY = this._sizingPositions.reference.y + this._sizingPositions.current.y - this._sizingPositions.drag.y;
          this._sizingPositions.reference.x = Math.min(Math.max(deltaX, this._sizingPositions.min.x), this._sizingPositions.max.x);
          this._sizingPositions.reference.y = Math.min(Math.max(deltaY, this._sizingPositions.min.y), this._sizingPositions.max.y);
          this._sizingPositions.size.x = this._sizingPositions.reference.x;
          this._sizingPositions.size.y = this._sizingPositions.reference.y;
          this._isSizing = false;

          this.emit(context.constants.widgetEvents.modalResize);
        },

        /**
         * handle on drag for resize
         * @param {MouseEvent} evt the event
         * @private
         */
        _onSizableDrag: function(evt) {
          if (this._isSizing) {
            var deltaX = this._sizingPositions.reference.x + (this._sizingPositions.current.x - this._sizingPositions.drag.x) * (
              this.isReversed() ? -1 : 1);
            var deltaY = this._sizingPositions.reference.y + this._sizingPositions.current.y - this._sizingPositions.drag.y;
            this._sizingPositions.size.x = Math.min(Math.max(deltaX, this._sizingPositions.min.x), this._sizingPositions.max.x);
            this._sizingPositions.size.y = Math.min(Math.max(deltaY, this._sizingPositions.min.y), this._sizingPositions.max.y);
            this._updateSizablePosition(this._sizingPositions.size.x, this._sizingPositions.size.y);
          }
        },
        /**
         * update visual size when resizing
         * @param {number} deltaX x position delta
         * @param {number} deltaY y position delta
         * @private
         */
        _updateSizablePosition: function(deltaX, deltaY) {
          this._dialogPane.style.width = "" + deltaX + "px";
          this._dialogPane.style.height = "" + deltaY + "px";
          this.emit(context.constants.widgetEvents.modalResize);
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._closeButton.off("click.ModalWidget");
          if (this._element) {
            this._element.off("click.ModalWidget");
            this._element.off("keydown.ModalWidget");
          }
          if (this._image) {
            this._image.destroy();
            this._image = null;
          }
          if (this._systemModalResizeHandler) {
            this._systemModalResizeHandler();
            this._systemModalResizeHandler = null;
          }

          $super.destroy.call(this);
        },

        /**
         * Set that the modal is only for GBC
         */
        _gbcSystemModal: function() {
          this._systemModal = true;
          this._element.addClass("gbc_SystemModal");
          this._element.setAttribute("tabindex", "0");
          if (!this._systemModalResizeHandler) {
            this._systemModalResizeHandler = context.HostService.onScreenResize(this.resizeHandler.bind(this));
          }
          this._element.domFocus();
          // do not propagate key event  to avoid sending them to VM
          this._element.on("keydown.ModalWidget", function(evt) {
            if (evt.keyCode === 27) {
              this.hide();
              if (!this.isDestroyed()) {
                this.destroy();
              }
            }
            evt.stopPropagation();
            // TODO we should prevent default browser behavior for CTRL+A, CTRL+P, CTRL+S, BACKSPACE
            // like in gbc.js document.body.addEventListener('keydown', function(event) {
          }.bind(this));
          gbc.LogService.ui.log("SystemModal open", true, this.__name, this);
        },
        /**
         * fired when resizing
         */
        resizeHandler: function() {
          if (this._element) {
            this._element.toggleClass("left-realign", this._dialogPane.offsetWidth > this._element.offsetWidth);
            this._element.toggleClass("top-realign", this._dialogPane.offsetHeight > this._element.offsetHeight);
          }
        },

        /**
         * @inheritDoc
         */
        setBackgroundColor: function(color) {
          this._backgroundColor = color;
          this.setStyle('.mt-dialog-pane', {
            "background-color": !!color && !this._ignoreBackgroundColor ? color : null
          });
        },

        /**
         * set the modal header
         * @param {string|HTMLElement} header the header
         */
        setHeader: function(header) {
          if (Object.isString(header)) {
            this._header.toggleClass("hidden", (header.length === 0) || this._headerHidden);
            this._title.textContent = header;
          } else {
            this._title.empty();
            if (header) {
              this._title.appendChild(header);
            }
          }
        },
        /**
         * set header raw hidden state
         * @param {boolean} headerHidden is header hidden
         */
        setHeaderHidden: function(headerHidden) {
          if (headerHidden !== this._headerHidden) {
            this._headerHidden = Boolean(headerHidden);
            this._header.toggleClass("hidden", (this._title.textContent.length === 0) || this._headerHidden);
          }
        },
        /**
         * Set the image of the modal widget
         * @param {string} image the image src
         */
        setImage: function(image) {
          if (!!image && image !== "") {
            if (!this._image) {
              this._image = cls.WidgetFactory.createWidget("ImageWidget", this.getBuildParameters());
              this._title.parentNode.insertBefore(this._image.getElement(), this._title);
            }
            this._image.setSrc(image);
          }
        },

        /**
         * set the modal footer
         * @param {string|HTMLElement} footer - the footer
         */
        setFooter: function(footer) {
          if (Object.isString(footer)) {
            this._footer.textContent = footer;
          } else {
            this._footer.empty();
            if (footer) {
              this._footer.appendChild(footer);
            }
          }
        },

        /**
         * set the modal content
         * @param {string|HTMLElement} content - the content
         */
        setContent: function(content) {
          if (Object.isString(content)) {
            this._containerElement.textContent = content;
          } else {
            if (this._containerElement.children.length !== 1 ||
              this._containerElement.children[0] !== content) {
              // Setting this._containerElement.innerHTML = "" can cause unwanted cleaning under IE11. In our case content.innerHTML gets cleaned (GBC-727). Prefer cleaning by looping on children
              this._containerElement.empty();
              if (content) {
                this._containerElement.appendChild(content);
              }
            }
          }
        },

        /**
         * Set the modal closable
         * @param {boolean} closable -  true if the dialog is closable, false otherwise
         * @param {boolean} directlyHide -
         * @param {boolean} hideOnClickOut - true if dialg should be hidden when user click outside of modal
         */
        setClosable: function(closable, directlyHide, hideOnClickOut) {
          if (closable) {
            this._closeButton.removeClass("hidden");
          } else {
            this._closeButton.addClass("hidden");
          }
          this._isClosable = closable;

          if (directlyHide) {
            this._closeButton.on("click.ModalWidget", function() {
              this.hide();
            }.bind(this));
          }
          if (hideOnClickOut) {
            this._element.on("click.ModalWidget", function(evt) {
              if (evt.target === evt.currentTarget) {
                this.hide();
              }
            }.bind(this));
          }
        },

        /**
         * is the modal closable
         * @returns {boolean} true if the dialog is closable, false otherwise
         */
        isClosable: function() {
          return this._isClosable;
        },
        /**
         * show the modal
         */
        show: function() {
          if (this._element) {
            this._element.addClass("displayed");
          }
          this._displayed = true;

          if (this._systemModal) {
            gbc.systemModalOpened = true;
            this._element.domFocus();
            this.resizeHandler();
          }
        },
        /**
         * hide the modal
         */
        hide: function() {
          if (this._element && this.isVisible()) {
            this._element.removeClass("displayed");
            this._displayed = false;
            this.emit(context.constants.widgetEvents.close);
            //Restore the window icon
            if (gbc.HostService.getCurrentWindow()) {
              gbc.HostService.getCurrentWindow().setImage("");
              gbc.HostService.setDisplayedWindow(gbc.HostService.getCurrentWindow());
            }
          }
          if (this._systemModal) {
            gbc.systemModalOpened = false;
            gbc.LogService.ui.log("SystemModal open", false, this.__name);
          }
        },
        /**
         * test if the modal is visible
         * @return {boolean} true if the modal is visible
         */
        isVisible: function() {
          return this._displayed;
        },
        /**
         * register a hook when modal is closed
         * @param {Hook} hook the hook to fire
         * @param {boolean=} once - if true, will only fire once
         * @return {HandleRegistration} a handle registration to free the hook
         */
        onClose: function(hook, once) {
          this.when(context.constants.widgetEvents.close, hook, once);
        },
        /**
         * set the header max width
         * @param {number} width the width
         */
        setHeaderMaxWidth: function(width) {
          this.setStyle(".mt-dialog-header", {
            "max-width": width + 'px'
          });
        }
      };
    });
    cls.WidgetFactory.registerBuilder('Modal', cls.ModalWidget);
  });
;
"use strict";

modulum('PagedScrollGridWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Paged Scroll Grid widget to display Scroll grid with tiles
     * @class PagedScrollGridWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     * @publicdoc
     */
    cls.PagedScrollGridWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {

      return /** @lends classes.PagedScrollGridWidget.prototype */ {
        __name: "PagedScrollGridWidget",
        _rowActionTriggerByDoubleClick: true,
        _currentRow: 0,
        _focusOnField: false,

        /** styles */
        _highlightColor: null,
        _highlightTextColor: null,
        _highlightCurrentRow: null,
        _highlightCurrentRowCssSelector: ":not(.disabled) .gbc_PagedScrollGridWidget.highlight.currentRow",
        _highlightCurrentCellCssSelector: ":not(.disabled) .gbc_PagedScrollGridWidget .g_GridElement >.currentRow",
        _highlightCurrentCell: null,

        _paginationWidget: null,
        _onOffsetHandler: null,

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          $super._initLayout.call(this);
          this._layoutEngine = new cls.StretchableScrollLayoutEngine(this);
          this._layoutInformation.getStretched().setDefaultX(true);
          this._layoutInformation.getStretched().setDefaultY(true);
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          this._paginationWidget = cls.WidgetFactory.createWidget("Pagination", this.getBuildParameters());
          // Forward scroll events
          this._onOffsetHandler = this._paginationWidget.when(context.constants.widgetEvents.offset, function(event) {
            this.emit(context.constants.widgetEvents.offset, event.data[0]);
          }.bind(this));
          this._element.appendChild(this._paginationWidget.getElement());
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._onOffsetHandler) {
            this._onOffsetHandler();
            this._onOffsetHandler = null;
          }
          this._paginationWidget.destroy();
          this._paginationWidget = null;

          this.destroyChildren();
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          if (domEvent.target.isElementOrChildOf(this._containerElement)) {
            cls.ScrollGridWidget._onClick.call(this, domEvent);
          }
          return true;
        },

        /**
         * @inheritDoc
         */
        manageMouseDblClick: function(domEvent) {
          if (domEvent.target.isElementOrChildOf(this._containerElement)) {
            cls.ScrollGridWidget._onDblClick.call(this, domEvent);
          }
          return true;
        },

        /**
         * @inheritDoc
         */
        addChildWidget: function(widget, options) {
          $super.addChildWidget.call(this, widget, options);
          widget.removeClass("gbc_WidgetBase_standalone");
          widget.addClass("gbc_WidgetBase_in_array");
        },

        /**
         * Indicates  how the row action must be triggered.
         * @param {boolean} b - true if must be triggered by doubleClick, false otherwise
         */
        setRowActionTriggerByDoubleClick: function(b) {
          this._rowActionTriggerByDoubleClick = b;
        },

        /**
         * Defines if focus is on a field or (default) on a row
         * @param {boolean} focusOnField - true if focus on field activated
         */
        setFocusOnField: function(focusOnField) {
          if (this._focusOnField !== focusOnField) {
            this._focusOnField = focusOnField;
            this.updateHighlight();
          }
        },

        /**
         * Returns if focus is on a field (table item) (by default focus is on a row)
         * @returns {boolean} true if focus on field activated
         */
        hasFocusOnField: function() {
          return this._focusOnField;
        },

        /**
         * Get the Data area height
         * @returns {number} scroll data area width
         */
        getDataAreaWidth: function() {
          return this.getContainerElement().getBoundingClientRect().width;
        },

        /**
         * Get the Data area height
         * @returns {number} scroll data area height
         */
        getDataAreaHeight: function() {
          return this.getContainerElement().getBoundingClientRect().height;
        },

        /**
         * Get the width of a Row
         * @return {number} row width or 1;
         */
        getRowWidth: function() {
          var children = this.getChildren();
          if (children.length !== 0) {
            return children[0].getElement().getBoundingClientRect().width;
          }
          return 0;
        },

        /**
         * Get the height of a Row
         * @return {number} row height or 1;
         */
        getRowHeight: function() {
          var children = this.getChildren();
          if (children.length !== 0) {
            return children[0].getElement().getBoundingClientRect().height;
          }
          return 0;
        },

        /**
         * @param {number} size - size of the dataset
         * @param {number} pageSize - viewport size
         * @param {number} offset - viewport offset
         */
        updateContentPosition: function(size, pageSize, offset) {
          this._paginationWidget.updateContentPosition(size, pageSize, offset);
        },

        /**
         * Changes current row
         * @param {number} row - current row
         * @publicdoc
         */
        setCurrentRow: function(row) {
          this._currentRow = row;
          var children = this.getChildren();
          var length = children.length;
          for (var i = 0; i < length; ++i) {
            var rowWidget = children[i];
            rowWidget.setCurrent(i === row);
          }
        },

        /**
         * Returns current row
         * @returns {number} current row
         * @publicdoc
         */
        getCurrentRow: function() {
          return this._currentRow;
        },

        /**
         * Defines the highlight color of rows, used for selected rows
         * @param {string} color - CSS color
         */
        setHighlightColor: function(color) {

          if (this._highlightColor !== color) {
            this._highlightColor = color;

            color = (color === null ? null : color + " !important");
            this.setStyle({
              selector: this._highlightCurrentRowCssSelector,
              appliesOnRoot: true
            }, {
              "background-color": color
            });

            this.setStyle({
              selector: this._highlightCurrentCellCssSelector,
              appliesOnRoot: true
            }, {
              "background-color": color
            });
          }
        },

        /**
         * Defines the highlighted text color of current row
         * @param {string} color - CSS color
         */
        setHighlightTextColor: function(color) {

          if (this._highlightTextColor !== color) {
            this._highlightTextColor = color;

            color = (color === null ? null : color + " !important");
            this.setStyle({
              selector: this._highlightCurrentCellCssSelector,
              appliesOnRoot: true
            }, {
              "color": color,
              "fill": color
            });
          }
        },

        /**
         * Indicates if the current row must be highlighted
         * @param {boolean} b - true if must be highlighted
         */
        setHighlightCurrentRow: function(b) {
          this._highlightCurrentRow = b;
        },

        /**
         * Check if the current row is highlighted
         * @returns {?boolean} true if current row is highlighted
         */
        isHighlightCurrentRow: function() {
          return this._highlightCurrentRow;
        },

        /**
         * Indicates if the current cell must be highlighted
         * @param {boolean} b - true if it must be highlighted
         */
        setHighlightCurrentCell: function(b) {
          this._highlightCurrentCell = b;
        },

        /**
         * Check if the current cell is highlighted
         * @returns {?boolean} true if current cell is highlighted
         */
        isHighlightCurrentCell: function() {
          return this._highlightCurrentCell;
        },

        /**
         * Update highlight row and cell
         */
        updateHighlight: function() {
          this.setCurrentRow(this._currentRow);
        },

        /**
         * @return {classes.PaginationWidget} the pagination widget
         */
        getPaginationWidget: function() {
          return this._paginationWidget;
        },

        /**
         * Set how children will align
         * @param {string} alignment
         */
        setItemsAlignment: function(alignment) {
          if (this._containerElement) {
            this._containerElement.style.justifyContent = {
              start: "flex-start",
              left: "flex-start",
              center: "center",
              right: "flex-end",
              end: "flex-end"
            } [alignment] || "flex-start";
          }
        }
      };
    });
    cls.WidgetFactory.registerBuilder('ScrollGrid[customWidget=pagedScrollGrid]', cls.PagedScrollGridWidget);
    cls.WidgetFactory.registerBuilder('StretchableScrollGrid[customWidget=pagedScrollGrid]', cls.PagedScrollGridWidget);
  });
;
"use strict";

modulum('PageTitleWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Page title in folder widget.
     * @class PageTitleWidget
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.PageTitleWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.PageTitleWidget.prototype */ {
        __name: "PageTitleWidget",

        /** @type {classes.ImageWidget} */
        _image: null,
        /** @type {HTMLElement} */
        _titleElement: null,
        /** @type {HTMLElement} */
        _actionsContainerElement: null,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          this._ignoreLayout = true;
          $super._initElement.call(this);
          this._titleElement = this._element.getElementsByClassName("mt-tab-title-text")[0];
          this._actionsContainerElement = this._element.getElementsByClassName("mt-tab-title-actions")[0];
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          // no layout
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._actionsContainerElement = null;
          this._titleElement = null;
          if (this._image) {
            this._image.destroy();
            this._image = null;
          }
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          this.emit(context.constants.widgetEvents.click, domEvent);
          return true;
        },

        /**
         * Set the page title text
         * @param {string} text the text to display
         * @publicdoc
         */
        setText: function(text) {
          var title = text.replace(/&(.)/g, "$1");
          this._setTextContent(title, "_titleElement");
          if (!this.getTitle()) { // fallback if no title defined
            this.setTitle(title);
          }
        },

        /**
         * Set the dom title of the pageTitle widget
         * @param {string} title - text to display as title
         */
        setTitle: function(title) {
          this.domAttributesMutator(function() {
            this._titleElement.title = title;
          }.bind(this));
        },

        /**
         * Get the dom title of the pageTitle widget
         * @return {string} text displayed as title
         */
        getTitle: function() {
          return this._titleElement.title;
        },

        /**
         * Get the page title text
         * @returns {string} the text displayed
         * @publicdoc
         */
        getText: function() {
          return this._titleElement.textContent;
        },

        /**
         * Get the action container element
         * @return {HTMLElement} the action container
         */
        getActionsContainerElement: function() {
          return this._actionsContainerElement;
        },

        /**
         * Define an image to display next to the title
         * @param {string} image the URL of the displayed image or a font-image URL: font:[fontname]:[character]:[color]
         * @publicdoc
         */
        setImage: function(image) {
          if (!this._image) {
            var opts = this.getBuildParameters();
            opts.ignoreLayout = true;
            this._image = cls.WidgetFactory.createWidget("ImageWidget", opts);
            this._element.prependChild(this._image.getElement());
          }
          this._image.setHidden(true);
          if (image && image !== "") {
            this._image.setSrc(image);
            this._image.setHidden(false);
            if (!this._image.getTitle()) {
              this.domAttributesMutator(function() {
                this._image.setTitle(this._titleElement.title);
              }.bind(this));
            }
          }
        },

        /**
         * Get the image displayed next to the title
         * @returns {?string} the URL of the displayed image or a font-image URL: font:[fontname]:[character]:[color]
         * @publicdoc
         */
        getImage: function() {
          if (this._image) {
            return this._image.getSrc();
          }
          return null;
        },

        /**
         * Set the tab to be the current one
         * @param {boolean} current displays the current tab indicator
         * @publicdoc
         */
        setCurrent: function(current) {
          this._element.toggleClass("mt-tab-current", current);
          this.setAriaAttribute("selected", current.toString());
        },

        /**
         * Check if the tab is the current one
         * @returns {boolean} true if the current tab indicator is displayed
         * @publicdoc
         */
        isCurrent: function() {
          return this._element.hasClass("mt-tab-current");
        },

        /**
         * Define the position of the collapser icon
         * @param {string} pos - could be 'left' or 'right' (default)
         */
        setCollapserPosition: function(pos) {
          this.addClass("collapser-position-" + pos);
        }
      };
    });
    cls.WidgetFactory.registerBuilder('PageTitle', cls.PageTitleWidget);
  });
;
"use strict";

modulum('PageWidget', ['WidgetGroupBase'],
  function(context, cls) {

    /**
     * Page widget.
     * @class PageWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     * @publicdoc Widgets
     */
    cls.PageWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.PageWidget.prototype */ {
        __name: "PageWidget",

        /**
         * The title widget
         * @type {classes.PageTitleWidget}
         */
        _title: null,
        /** @function */
        _clickHandler: null,
        /** @function */
        _onActivationHandler: null,
        /** @function */
        _pageActivateHandler: null,
        /** @function */
        _pageDisableHandler: null,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          this._title = cls.WidgetFactory.createWidget("PageTitle", this.getBuildParameters());
          this._clickHandler = this._title.when(context.constants.widgetEvents.click, function(event) {
            var folderWidget = this.getParentWidget();
            if (folderWidget) {
              folderWidget.onTitleClick(this);
              this.emit(context.constants.widgetEvents.click, event);
            }
          }.bind(this));
          this._onActivationHandler = this.when(context.constants.widgetEvents.ready, this._onActivation.bind(this));
          this.setAriaAttribute("labelledby", this._title.getRootClassName());
        },
        /**
         * @inheritDoc
         */
        _initLayout: function() {
          this._layoutInformation = new cls.PageLayoutInformation(this);
          this._layoutEngine = new cls.PageLayoutEngine(this);
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._pageActivateHandler) {
            this._pageActivateHandler();
            this._pageActivateHandler = null;
          }
          if (this._pageDisableHandler) {
            this._pageDisableHandler();
            this._pageDisableHandler = null;
          }
          if (this._onActivationHandler) {
            this._onActivationHandler();
            this._onActivationHandler = null;
          }
          if (this._clickHandler) {
            this._clickHandler();
            this._clickHandler = null;
          }
          this._title.destroy();
          this._title = null;

          $super.destroy.call(this);
        },

        activate: function() {
          this.emit(context.constants.widgetEvents.activate);
        },

        onActivate: function(hook) {
          return this.when(context.constants.widgetEvents.activate, hook);
        },

        disable: function() {
          this.emit(context.constants.widgetEvents.disable);
        },

        onDisable: function(hook) {
          return this.when(context.constants.widgetEvents.disable, hook);
        },

        _onActivation: function(event, widget, parentPageWidget) {
          if (parentPageWidget) {
            this._pageActivateHandler = parentPageWidget.onActivate(this.activate.bind(this));
            this._pageDisableHandler = parentPageWidget.onDisable(this.disable.bind(this));
          }
        },

        /**
         * Returns index of the pager in the parent folder
         * @returns {number} index of the page in the folder
         */
        getPageIndex: function() {
          var parent = this.getParentWidget();
          if (!!parent) {
            return parent.getChildren().indexOf(this);
          }
          return -1;
        },

        /**
         * @returns {classes.PageTitleWidget} the title widget
         */
        getTitleWidget: function() {
          return this._title;
        },

        /**
         * @inheritDoc
         */
        addChildWidget: function(widget, options) {
          if (this._children.length !== 0) {
            throw "A page can only contain a single child";
          }
          $super.addChildWidget.call(this, widget, options);
        },

        /**
         * @param {string} text the text to display in the header
         */
        setText: function(text) {
          this._title.setText(text);
        },

        /**
         * @returns {string} the text to display in the header
         */
        getText: function() {
          return this._title.getText();
        },

        /**
         * @param {string} title the text to display in the title
         */
        setTitle: function(title) {
          this._title.setTitle(title);
        },

        /**
         * @return {string} the title of the page
         */
        getTitle: function() {
          return this._title.getTitle();
        },

        /**
         * @param {string} image the URL of the image or a font-image URL: font:[fontname]:[character]:[color] to display in the header
         */
        setImage: function(image) {
          this._title.setImage(image);
        },

        /**
         * @returns {string} the URL of the displayed image or a font-image URL: font:[fontname]:[character]:[color]
         */
        getImage: function() {
          return this._title.getImage();
        },
        /**
         * @inheritDoc
         */
        setHidden: function(hidden) {
          if (this._hidden !== hidden) {
            this.getParentWidget().emit(context.constants.widgetEvents.pageVisibility);
          }

          $super.setHidden.call(this, hidden);

          this._title.setHidden(hidden);
          // if current is hidden, we need to display another one
          if (this.getParentWidget().getCurrentPage() === this && this.isHidden()) {
            // if focused node is inside a folder page, display that one otherwise display next not hidden page.
            this.getParentWidget().updateCurrentPage();
          }

        },

        /**
         * Add the widget in the DOM
         */
        addPageInDom: function() {
          if (this._replacerElement && this._replacerElement.parentNode) {
            this._replacerElement.parentNode.replaceChild(this.getElement(), this._replacerElement);
          }
        },

        /**
         * Remove widget from DOM and replace it by an empty DIV
         */
        removePageFromDom: function() {
          if (!this._replacerElement) {
            this._replacerElement = document.createElement("div");
            this._replacerElement.setAttribute("tabindex", "0");
          }
          if (this.getElement() && this.getElement().parentNode) {
            this.getElement().parentNode.replaceChild(this._replacerElement, this.getElement());
          }
        },

        /**
         * @inheritDoc
         */
        isVisible: function() {
          return this.getParentWidget().getCurrentPage() === this && !this.isHidden();
        },
        /**
         * @inheritDoc
         */
        isLayoutMeasureable: function(deep) {
          return true;
        }
      };
    });
    cls.WidgetFactory.registerBuilder('Page', cls.PageWidget);
  });
;
"use strict";

modulum('PaginationWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Pagination buttons for a specified range
     * @class PaginationWidget
     * @memberOf classes
     * @extends classes.WidgetBase
     * @publicdoc
     */
    cls.PaginationWidget = context.oo.Class(cls.WidgetBase, function($super) {

      return /** @lends classes.PaginationWidget.prototype */ {
        __name: "PaginationWidget",

        /** @type {number} */
        _pageSize: 0,
        /** @type {number} */
        _size: 0,
        /** @type {number} */
        _offset: 0,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          this._ignoreLayout = true;
          $super._initElement.call(this);
          this._navigationPrevPage = this._element.children[0];
          this._navigationPrevPage.on('click.NavigationPrevPage', this._navigatePrevPage.bind(this));
          this._navigationNextPage = this._element.children[1];
          this._navigationNextPage.on('click.NavigationNextPage', this._navigateNextPage.bind(this));
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._clearNavigationButtons();
          this._navigationPrevPage.off('click.NavigationPrevPage');
          this._navigationNextPage.off('click.NavigationNextPage');
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          // No layout used
        },

        /**
         * Updates the pagination content
         */
        _update: function() {
          var i = 0;
          if (this._pageSize === 0) {
            // not initialized yet
            this._navigationPrevPage.toggleClass('disabled', false);
            this._navigationNextPage.toggleClass('disabled', false);
            return;
          }
          this._clearNavigationButtons();
          var pageCount = Math.ceil(this._size / this._pageSize);
          var current = Math.floor(this._offset / this._pageSize);
          if (pageCount <= 10) {
            for (i = 0; i < pageCount; ++i) {
              this._createNavigationButton(i, current);
            }
          } else {
            var maxButtons = 3;
            this._createNavigationButton(0, current);
            if (current < maxButtons - 1) {
              for (i = 1; i < maxButtons; ++i) {
                this._createNavigationButton(i, current);
              }
              this._createNavigationEllipsis();
            } else if (current > pageCount - maxButtons) {
              this._createNavigationEllipsis();
              for (i = pageCount - maxButtons - 1; i < pageCount - 1; ++i) {
                this._createNavigationButton(i, current);
              }
            } else {
              this._createNavigationEllipsis();
              var n = Math.floor(maxButtons / 2);
              for (i = current - n; i <= current + n; ++i) {
                this._createNavigationButton(i, current);
              }
              this._createNavigationEllipsis();
            }
            this._createNavigationButton(pageCount - 1, current);
          }
          this._navigationPrevPage.toggleClass('disabled', current === 0);
          this._navigationNextPage.toggleClass('disabled', current === pageCount - 1);
        },

        /**
         * Add a navigation button with index inside
         * @param {number} index - page linked to this button
         * @param {number} current - current page
         * @private
         */
        _createNavigationButton: function(index, current) {
          var span = document.createElement('span');
          span.addClass("navbutton");
          span.textContent = "" + (index + 1);
          if (index === current) {
            span.addClass('current');
          }
          span.on('click.NavigatePage', this._navigatePage.bind(this, index));
          this._element.insertBefore(span, this._navigationNextPage);
        },

        /**
         * Add ellipsis (...) to the navigation bar
         * @private
         */
        _createNavigationEllipsis: function() {
          var span = document.createElement('span');
          span.textContent = '\u2026';
          this._element.insertBefore(span, this._navigationNextPage);
        },

        /**
         * Handler to switch to previous page
         * @param {Object} event - DOM event
         */
        _navigatePrevPage: function(event) {
          if (!this._navigationPrevPage.hasClass('disabled')) {
            var offset = Math.max(0, this._offset - this._pageSize);
            this.emit(context.constants.widgetEvents.offset, offset);
          }
        },

        /**
         * Handler to switch to next page
         * @param {Object} event - DOM event
         */
        _navigateNextPage: function(event) {
          if (!this._navigationNextPage.hasClass('disabled')) {
            var maxOffset = Math.floor(this._size / this._pageSize) * this._pageSize;
            var offset = Math.min(maxOffset, this._offset + this._pageSize);
            this.emit(context.constants.widgetEvents.offset, offset);
          }
        },

        /**
         * Handler to switch to a given page
         * @param {number} index - page number to switch to
         * @param {Object} event - DOM event
         */
        _navigatePage: function(index, event) {
          var offset = index * this._pageSize;
          this.emit(context.constants.widgetEvents.offset, offset);
        },

        /**
         * Unregister all navigation callbacks
         * @private
         */
        _clearNavigationButtons: function() {
          var children = this._element.children;
          while (children.length > 2) {
            // Remove ellipsis
            var elt = children[1];
            elt.off('click.NavigatePage');
            this._element.removeChild(elt);
          }
        },

        /**
         * @param {number} size - size of the dataset
         * @param {number} pageSize - viewport size
         * @param {number} offset - viewport offset
         */
        updateContentPosition: function(size, pageSize, offset) {
          this._size = size;
          this._pageSize = pageSize;
          this._offset = offset;
          this._update();
        }
      };
    });
    cls.WidgetFactory.registerBuilder('Pagination', cls.PaginationWidget);
  });
;
"use strict";

modulum('RowBoundDecoratorWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * RowBound decorator.
     * @class RowBoundDecoratorWidget
     * @memberOf classes
     * @extends classes.WidgetBase
     * @publicdoc
     */
    cls.RowBoundDecoratorWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.RowBoundDecoratorWidget.prototype */ {
        __name: "RowBoundDecoratorWidget",

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {

          var rowBoundIconElement = this._element.getElementsByTagName('i')[0];
          var rowBoundContainerWidget = this.getTableWidgetBase();
          if (!rowBoundContainerWidget && this.getParentWidget().isInstanceOf(cls.StretchableScrollGridLineWidget)) {
            rowBoundContainerWidget = this.getParentWidget().getParentWidget();
          }

          if (rowBoundContainerWidget && domEvent.target.isElementOrChildOf(rowBoundIconElement)) {
            // request focus
            if (this.getParentWidget().requestFocus) {
              this.getParentWidget().requestFocus(domEvent);
            }

            // request open rowbound
            var rowBoundWidget = rowBoundContainerWidget.getRowBoundWidget();
            rowBoundWidget.parentElement = rowBoundIconElement;
            rowBoundWidget.reverseX = true;
            rowBoundWidget.emit(context.constants.widgetEvents.contextMenu);
            return false;
          }
          return true;
        },
      };
    });
    cls.WidgetFactory.registerBuilder('RowBoundDecorator', cls.RowBoundDecoratorWidget);
  });
;
"use strict";

modulum('ScrollGridWidget', ['WidgetGridLayoutBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Scroll Grid widget.
     * @class ScrollGridWidget
     * @memberOf classes
     * @extends classes.WidgetGridLayoutBase
     * @publicdoc
     */
    cls.ScrollGridWidget = context.oo.Class(cls.GridWidget, function($super) {
      return /** @lends classes.ScrollGridWidget.prototype */ {
        $static: /** @lends classes.ScrollGridWidget */ {
          /** Generic click events handler */
          _onClick: function(event) {
            this.emit(context.constants.widgetEvents.click, event);
            if (!this._rowActionTriggerByDoubleClick && event.target !== this._containerElement) {
              this.emit(context.constants.widgetEvents.rowAction, event);
            }
          },
          _onDblClick: function(event) {
            if (this._rowActionTriggerByDoubleClick && event.target !== this._containerElement) {
              this.emit(context.constants.widgetEvents.rowAction, event);
            }
          },
        },
        __name: "ScrollGridWidget",

        /** @type {classes.ScrollWidget} */
        _scrollWidget: null,
        /** @type boolean */
        _rowActionTriggerByDoubleClick: true,
        /** @type {classes.UserInterfaceWidget} */
        _uiWidget: null,
        /** @type {classes.FolderWidgetBase} */
        _folderPageWidget: null,

        /** Handlers */
        /** @function */
        _uiActivateHandler: null,
        /** @function */
        _pageActivateHandler: null,

        /**
         * @constructs
         * @param {*} opts - Options passed to the constructor
         */
        constructor: function(opts) {
          opts = opts || {};
          this._uiWidget = opts.uiWidget;
          this._folderPageWidget = opts.folderPageWidget;

          $super.constructor.call(this, opts);
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          this._scrollWidget = cls.WidgetFactory.createWidget("Scroll", this.getBuildParameters());
          this.addChildWidget(this._scrollWidget, {
            noDOMInsert: true
          });
          this._element.appendChild(this._scrollWidget.getElement());

          this._uiActivateHandler = this._uiWidget.onActivate(this.refreshScroll.bind(this, true));
          if (this._folderPageWidget) {
            this._pageActivateHandler = this._folderPageWidget.onActivate(this.refreshScroll.bind(this));
          }
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          this._layoutInformation = new cls.LayoutInformation(this);
          this._layoutEngine = new cls.ScrollGridLayoutEngine(this);
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          // ScrollWidget is owned directly by this widget no matter if gridChildrenInParent is set
          this._rerouteChildren = false;
          this._element.removeChild(this._scrollWidget.getElement());
          this._scrollWidget.destroy();
          this._scrollWidget = null;
          this._uiWidget = null;
          this._folderPageWidget = null;
          if (this._uiActivateHandler) {
            this._uiActivateHandler();
            this._uiActivateHandler = null;
          }
          if (this._pageActivateHandler) {
            this._pageActivateHandler();
            this._pageActivateHandler = null;
          }

          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          cls.ScrollGridWidget._onClick.call(this, domEvent);
          return true;
        },

        /**
         * @inheritDoc
         */
        manageMouseDblClick: function(domEvent) {
          cls.ScrollGridWidget._onDblClick.call(this, domEvent);
          return true;
        },

        /**
         * @inheritDoc
         */
        _listChildrenToMoveWhenGridChildrenInParent: function() {
          return this._children.filter(function(item) {
            return item !== this._scrollWidget;
          }.bind(this));
        },

        /**
         * Indicates how the row action must be triggered.
         * @param {boolean} b - true if action is triggered by double click (else it is single click)
         */
        setRowActionTriggerByDoubleClick: function(b) {
          this._rowActionTriggerByDoubleClick = b;
        },

        /** Returns the scroll widget
         * @returns {classes.ScrollWidget} Scroll widget
         */
        getScrollWidget: function() {
          return this._scrollWidget;
        },

        /**
         * Returns the row height in pixels
         * @returns {number} row height
         * @publicdoc
         */
        getRowHeight: function() {
          return this._layoutInformation.getMeasured().getHeight(true) / Math.max(1, this._scrollWidget.getPageSize());
        },

        /**
         * Returns scrollable area DOM Element
         * @returns {HTMLElement} scrollable area DOM Element
         */
        getScrollableArea: function() {
          return this._scrollWidget.getElement();
        },

        /**
         * Defines the scroll grid pageSize
         * @param {number} pageSize - page size
         */
        setPageSize: function(pageSize) {
          this._scrollWidget.setPageSize(pageSize);
        },

        /**
         * Defines the scroll grid size (total number of row)
         * @param {number} size - size value
         */
        setSize: function(size) {
          this._scrollWidget.setSize(size);
        },

        /**
         * Defines the scroll grid offset
         * @param {number} offset - offset value
         */
        setOffset: function(offset) {
          this._scrollWidget.setOffset(offset);
        },

        /**
         * Sets the total height of the widget (pixels)
         * @param {number} size - total height
         */
        setTotalHeight: function(size) {
          this._scrollWidget.setTotalHeight(size);
        },

        /**
         * Refresh scroll widget
         */
        refreshScroll: function(force) {
          this._scrollWidget.setLineHeight(this.getRowHeight());
          this._scrollWidget.refreshScroll(force);
        },

        /**
         * Defines the highlighted text color of rows, used for selected rows
         * @param {string} color - CSS color
         */
        setHighlightTextColor: function(color) {},

        /**
         * Defines the highlight color of rows, used for selected rows
         * @param {string} color - CSS color
         */
        setHighlightColor: function(color) {},

        /**
         * @param highlight false to disable current row highlighting
         */
        setHighlightCurrentRow: function(highlight) {
          this._element.toggleClass("nohighlight", !highlight);
        },

        /**
         * Update highlight row and cell
         */
        updateHighlight: function() {}
      };
    });
    cls.WidgetFactory.registerBuilder('ScrollGrid', cls.ScrollGridWidget);
  });
;
"use strict";

modulum('SpacerItemWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * SpacerItem widget.
     * @class SpacerItemWidget
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.SpacerItemWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.SpacerItemWidget.prototype */ {
        __name: "SpacerItemWidget",

        _initLayout: function() {
          this._layoutInformation = new cls.LayoutInformation(this);
          this._layoutEngine = new cls.LeafLayoutEngine(this);

          this._layoutInformation.setXStretched(false);
          this._layoutInformation.setYStretched(false);
          this._layoutInformation.setSizeHint(0, 0);
          this._layoutInformation.setMinimal(0, 0);
        }
      };
    });
    cls.WidgetFactory.registerBuilder('SpacerItem', cls.SpacerItemWidget);
  });
;
"use strict";

modulum('SplitterWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Splitter widget.
     * @class SplitterWidget
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.SplitterWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.SplitterWidget.prototype */ {
        __name: "SplitterWidget",

        _canSplit: false,
        _pagePosition: 0,
        _resizerDragPosition: 0,
        _isDragging: false,
        _splitInfo: null,
        _dragHandle: null,
        _forcedDefault: false,
        /**
         * the split holder
         * @type HTMLElement
         */
        _splitHolder: null,

        _initLayout: function() {
          this._layoutInformation = new cls.LayoutInformation(this);
          this._layoutEngine = new cls.LeafLayoutEngine(this);
          this._layoutEngine._shouldFillHeight = true;
          this._layoutInformation.setMaximal(8, 8);
          this._layoutInformation.setMinimal(8, 8);
          this._layoutInformation.setMeasured(8, 8);
        },

        _initElement: function() {
          $super._initElement.call(this);
          this._dragHandle = this._element.getElementsByClassName("firefox_placekeeper")[0];
          this._element.setAttribute("draggable", "true");
          this._element.on("dragstart.SplitterWidget", this._onDragStart.bind(this));
          this._element.on("dragend.SplitterWidget", this._onDragEnd.bind(this));
          this._element.on("drag.SplitterWidget", this._onDrag.bind(this));

          //handle touch events
          this._element.on("touchstart.SplitterWidget", this._onTouchStart.bind(this));
          this._element.on('touchend.SplitterWidget', this._onTouchEnd.bind(this));
          this._element.on('touchmove.SplitterWidget', this._onTouchMove.bind(this));

          if (window.browserInfo.isIE || window.browserInfo.isEdge) {
            this._element.on("mousedown.SplitterWidget", function() {
              this._element.style.opacity = 0;
            }.bind(this));
            this._element.on("mouseup.SplitterWidget", function() {
              this._element.style.opacity = "";
            }.bind(this));
          }
          this._splitHolder = document.createElement("div");
          this._splitHolder.className = "gbc_SplitterWidget_splitholder";
        },
        destroy: function() {
          this._element.off("dragstart.SplitterWidget");
          this._element.off("dragend.SplitterWidget");
          this._element.off("drag.SplitterWidget");
          if (window.browserInfo.isIE || window.browserInfo.isEdge) {
            this._element.off("mousedown.SplitterWidget");
            this._element.off("mouseup.SplitterWidget");
          }
          $super.destroy.call(this);

        },
        _onDragOver: function(evt) {
          evt.preventCancelableDefault();
        },
        _onDragStart: function(evt) {
          if (this._canSplit) {
            this._element.parentNode.style.zIndex = 99999;
            this._splitHolder.style.zIndex = 99998;
            this._splitHolder.style.display = "block";
            this.getParentWidget().getElement().on("dragover.SplitterWidget", this._onDragOver.bind(this));
            this._splitHolder.on("dragover.SplitterWidget", this._onDragOver.bind(this));
            this._isDragging = true;
            if (window.browserInfo.isFirefox) {
              evt.dataTransfer.setData('text', ''); // for Firefox compatibility
            }
            if (evt.dataTransfer.setDragImage) {
              evt.dataTransfer.setDragImage(this._dragHandle, 0, 0);
            }
            evt.dataTransfer.effectAllowed = "move";
            this._updateResizerDrag(evt);
            this.emit(context.constants.widgetEvents.splitterStart);
          } else {
            evt.preventCancelableDefault();
          }
          return false;
        },
        _updateResizerDrag: function(evt) {

        },
        _onDragEnd: function(evt) {
          this._element.style.zIndex = "";
          this._splitHolder.style.zIndex = "";
          this._splitHolder.style.display = "";
          this._splitHolder.off("dragover.SplitterWidget");
          this.getParentWidget().getElement().off("dragover.SplitterWidget");
          this._isDragging = false;
          if (window.browserInfo.isIE || window.browserInfo.isEdge) {
            this._element.style.opacity = "";
          }
          this.emit(context.constants.widgetEvents.splitterEnd);
        },
        _onDrag: function(evt) {
          if (this._isDragging) {
            var delta = this._pagePosition - this._resizerDragPosition;
            this.updateSplits(delta);
          }
        },

        _onTouchStart: function(evt) {
          if (this._canSplit) {
            this._element.parentNode.style.zIndex = 99999;
            this._splitHolder.style.zIndex = 99998;
            this._splitHolder.style.display = "block";
            this._isDragging = true;
            this._updateResizerDrag(evt);
            this.emit(context.constants.widgetEvents.splitterStart);
          } else {
            evt.preventCancelableDefault();
          }
          return false;
        },

        _onTouchEnd: function() {
          this._element.style.zIndex = "";
          this._splitHolder.style.zIndex = "";
          this._splitHolder.style.display = "";
          this._isDragging = false;
          if (window.browserInfo.isIE || window.browserInfo.isEdge) {
            this._element.style.opacity = "";
          }
          this.emit(context.constants.widgetEvents.splitterEnd);
        },

        _onTouchMove: function(evt) {
          if (this._isDragging) {
            var delta = this._pagePosition - this._splitStartPos;
            this.updateSplits(delta);
          }
        },

        _setDOMAttachedOrDetached: function() {
          if (this._element.parentNode) {
            this._element.parentNode.parentNode.appendChild(this._splitHolder);
          } else {
            this._splitHolder.remove();
          }
        },
        activateSplitter: function(canSplit) {
          this._canSplit = !!canSplit;
          this._element.toggleClass("canSplit", !!canSplit);
        },
        isReversed: function() {
          return this._parentWidget.isReversed();
        },
        updateSplits: function(delta) {
          if (!Number.isNaN(delta)) {
            this.emit(context.constants.widgetEvents.splitter, delta);
          }
        }
      };
    });
    cls.WidgetFactory.registerBuilder('Splitter', cls.SplitterWidget);
  });
;
"use strict";

modulum('StackGroupWidget', ['StackLayoutWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Group widget.
     * @class StackGroupWidget
     * @memberOf classes
     * @extends classes.StackLayoutWidgetBase
     */
    cls.StackGroupWidget = context.oo.Class(cls.StackLayoutWidgetBase, function($super) {
      return /** @lends classes.StackGroupWidget.prototype */ {
        __name: "StackGroupWidget",
        /**
         * @type {classes.GroupTitleWidget}
         */
        _title: null,

        /**
         * @type {HandleRegistration}
         */
        _titleClickHandler: null,

        /**
         * flag to determine if group is collapsible
         * @type {boolean}
         */
        _isCollapsible: false,

        /**
         * @type {{formName:string, id:string}}
         */
        _groupIdentifier: null,
        /**
         * set the stored settings identifier
         * @param {{formName:string, id:string}} id
         */
        setGroupIdentifier: function(id) {
          this._groupIdentifier = id;
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          this._title = cls.WidgetFactory.createWidget("GroupTitle", this.getBuildParameters());
          this._titleClickHandler = this._title.when(context.constants.widgetEvents.click, this._onTitleClick.bind(this));
          this._groupWidgetContent = this._element.getElementsByClassName("gbc_GroupWidgetContent")[0];
          this._groupWidgetContent.prependChild(this._title.getElement());
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          this._layoutInformation = new cls.LayoutInformation(this);
          this._layoutEngine = new cls.StackGroupLayoutEngine(this);
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._titleClickHandler) {
            this._titleClickHandler();
            this._titleClickHandler = null;
          }

          if (this._title) {
            this._title.destroy();
            this._title = null;
          }

          this._groupWidgetContent = null;
          $super.destroy.call(this);
        },
        /**
         * @param {string} text text describing the group content
         */
        setText: function(text) {
          this._title.setText(text);
          this.getLayoutEngine().forceMeasurement();
          this.getLayoutEngine().invalidateMeasure();
        },

        /**
         * @returns {string} text describing the group content
         */
        getText: function() {
          return this._title.getText();
        },
        /**
         * when group title is clicked
         * @private
         */
        _onTitleClick: function() {
          if (this._isCollapsible) {
            this._updateCollapsedState();
            this.emit(context.constants.widgetEvents.toggleClick);
          }
        },
        /**
         * Set the group collapsible
         * @param {boolean} collapsible
         */
        setCollapsible: function(collapsible) {
          this._isCollapsible = Boolean(collapsible);
          this._title.setCollapsible(this._isCollapsible);
          if (this._isCollapsible) {
            this.setCollapsed(Boolean(context.StoredSettingsService
              .getGroupCollapsedState(this._groupIdentifier.formName, this._groupIdentifier.id)));
          }
        },

        /**
         * set the collapsed state
         * @param {boolean} collapsed the collapsed state
         */
        setCollapsed: function(collapsed) {
          var result = false;
          if (this._isCollapsible) {
            if (this._title.isCollapsed() !== Boolean(collapsed)) {
              this._title.setCollapsed(collapsed);
              this._updateCollapsedState();
              result = true;
            }
          }
          return result;
        },

        /**
         * update the layout engine collapsed information
         * @private
         */
        _updateCollapsedState: function() {
          this._layoutEngine._willRenderContent = !this._title.isCollapsed();
          this._containerElement.toggleClass("hidden", this._title.isCollapsed());
          context.StoredSettingsService.setGroupCollapsedState(this._groupIdentifier.formName,
            this._groupIdentifier.id, Boolean(this._title.isCollapsed()));
          this.getLayoutEngine().forceMeasurement();
          this.getLayoutEngine().invalidateMeasure();
        }
      };
    });
    cls.WidgetFactory.registerBuilder('Stack Group', cls.StackGroupWidget);
  });
;
"use strict";

modulum('StackLabelWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * StackLabel widget.
     * @class StackLabelWidget
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.StackLabelWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.StackLabelWidget.prototype */ {
        __name: "StackLabelWidget",

        _text: null,
        _textElement: null,

        _initLayout: function() {
          this._layoutInformation = new cls.LayoutInformation(this);
          this._layoutEngine = new cls.LeafLayoutEngine(this);
        },

        _initElement: function() {
          $super._initElement.call(this);
          this._textElement = this.getElement();
          this.setHidden(true);
        },
        destroy: function() {
          $super.destroy.call(this);
        },
        setText: function(text) {
          this._setTextContent(text, "_textElement");
          this._text = text;
          this.setHidden(!text);
        },
        setHidden: function(hidden) {
          $super.setHidden.call(this, hidden || !this._text);
        }
      };
    });
    cls.WidgetFactory.registerBuilder('StackLabel', cls.StackLabelWidget);
  });
;
"use strict";

modulum('StackLayoutWidgetBase', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class StackLayoutWidgetBase
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     */
    cls.StackLayoutWidgetBase = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.StackLayoutWidgetBase.prototype */ {
        __name: "StackLayoutWidgetBase",

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          this._element.addClass("g_StackLayoutEngine");
        },

        _initLayout: function() {
          this._layoutInformation = new cls.LayoutInformation(this);
          this._layoutEngine = new cls.StackLayoutEngine(this);
        },

        _addChildWidgetToDom: function(widget, position) {
          var widgetHost = document.createElement('div');
          widgetHost.addClass('g_StackElement');
          widget.getLayoutInformation().setHostElement(widgetHost);
          var stackLabel = cls.WidgetFactory.createWidget("StackLabel", this.getBuildParameters());
          widgetHost.appendChild(stackLabel._element);
          widget.getLayoutInformation()._stackLabel = stackLabel;
          widgetHost.appendChild(widget._element);
          this.getLayoutEngine().registerChild(widget, position);
          widgetHost.insertAt(position, this._containerElement);
        },

        _removeChildWidgetFromDom: function(widget) {
          this.getLayoutEngine().unregisterChild(widget);
          var info = widget.getLayoutInformation(),
            host = info && info.getHostElement(),
            label = info && info._stackLabel;
          if (label) {
            label.destroy();
            info._stackLabel = null;
          }
          if (host && host.parentNode === this._containerElement) {
            widget._element.remove();
            host.remove();
            host = null;
          }
        },

        setStackLabelText: function(widget, text) {
          var info = widget.getLayoutInformation(),
            label = info && info._stackLabel;
          if (label) {
            label.setText(text);
          }
        }
      };
    });
  });
;
"use strict";

modulum('StackWidget', ['StackLayoutWidgetBase'],
  function(context, cls) {

    /**
     * Base class for widget group.
     * @class StackWidget
     * @memberOf classes
     * @extends classes.StackLayoutWidgetBase
     */
    cls.StackWidget = context.oo.Class(cls.StackLayoutWidgetBase, function($super) {
      return /** @lends classes.StackWidget.prototype */ {
        __name: "StackWidget"
      };
    });
    cls.WidgetFactory.registerBuilder('Stack', cls.StackWidget);
  });
;
"use strict";

modulum('StretchableScrollGridLineWidget', ['GridWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Stretchable scroll grid line widget.
     * @class StretchableScrollGridLineWidget
     * @memberOf classes
     * @extends classes.GridWidget
     * @publicdoc
     */
    cls.StretchableScrollGridLineWidget = context.oo.Class(cls.GridWidget, function($super) {

      return /** @lends classes.StretchableScrollGridLineWidget.prototype */ {
        __name: "StretchableScrollGridLineWidget",

        /** @type boolean */
        _current: false,

        /** @type classes.RowBoundDecoratorWidget */
        _rowBoundDecoratorWidget: null,

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._rowBoundDecoratorWidget) {
            this._rowBoundDecoratorWidget.destroy();
            this._rowBoundDecoratorWidget = null;
          }
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          this.emit(context.constants.widgetEvents.click, domEvent);
          return true;
        },

        /**
         * @inheritDoc
         */
        manageMouseDblClick: function(domEvent) {
          this.emit(context.constants.widgetEvents.doubleClick, domEvent);
          return true;
        },

        /**
         * Request focus for this row
         * @param {*} domEvent - dom event object
         */
        requestFocus: function(domEvent) {
          this.emit(context.constants.widgetEvents.click, domEvent);
        },

        /**
         * Sets if the row is the current one
         * @param {boolean} current - true if row is the current one, false otherwise
         * @publicdoc
         */
        setCurrent: function(current) {
          if (this._current !== current) {
            this._current = current;
            if (!!current) {
              this._element.addClass("currentRow");
              this._children.forEach(function(w) {
                w.addClass("currentRow");
              });
            } else {
              this._element.removeClass("currentRow");
              this._children.forEach(function(w) {
                w.removeClass("currentRow");
              });
            }
          }

          var parent = this.getParentWidget();
          if (parent) {
            this._element.toggleClass("highlight", parent.isHighlightCurrentRow());
            this._element.toggleClass("nohighlight", !parent.isHighlightCurrentRow());
          }
        },

        /**
         * @inheritDoc
         */
        addChildWidget: function(widget, options) {
          $super.addChildWidget.call(this, widget, options);
          widget.removeClass("gbc_WidgetBase_standalone");
          widget.addClass("gbc_WidgetBase_in_array");
        },

        /**
         * Creates and adds rowBound decorator element to DOM
         */
        addRowBoundDecorator: function() {
          this._rowBoundDecoratorWidget = cls.WidgetFactory.createWidget("RowBoundDecorator", this.getBuildParameters());
          this._rowBoundDecoratorWidget.setParentWidget(this);
          this._element.appendChild(this._rowBoundDecoratorWidget.getElement());
        }
      };
    });
    cls.WidgetFactory.registerBuilder('StretchableScrollGridLine', cls.StretchableScrollGridLineWidget);
  });
;
"use strict";

modulum('StretchableScrollGridWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Stretchable scroll grid widget.
     * @class StretchableScrollGridWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     * @publicdoc
     */
    cls.StretchableScrollGridWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {

      return /** @lends classes.StretchableScrollGridWidget.prototype */ {
        __name: "StretchableScrollGridWidget",
        /** @type {?number} */
        _pageSize: null,
        /** @type {?number} */
        _size: null,
        /** @type {?number} */
        _offset: null,
        /** @type {?number} */
        lastSentOffset: null,
        /** @type {boolean} */
        _rowActionTriggerByDoubleClick: true,
        /** @type {number} */
        _rowHeight: 0,
        /** @type {number} */
        _currentRow: 0,
        /** @type {boolean} */
        _focusOnField: false,

        /** Handlers */
        /** @type {classes.UserInterfaceWidget} */
        _uiWidget: null,
        /** @type {classes.FolderWidgetBase} */
        _folderPageWidget: null,
        /** @function */
        _uiActivateHandler: null,
        /** @function */
        _pageActivateHandler: null,

        /** styles */
        _highlightColor: null,
        _highlightTextColor: null,
        _highlightCurrentRow: null,
        _highlightCurrentRowCssSelector: ":not(.disabled) .gbc_StretchableScrollGridLineWidget.highlight.currentRow",
        _highlightCurrentCellCssSelector: ":not(.disabled) .gbc_StretchableScrollGridLineWidget .g_GridElement >.currentRow",
        _highlightCurrentCell: null,

        /** @type {classes.ContextMenuWidget} */
        _rowBoundWidget: null,

        /** @type {boolean} */
        _hasReduceFilter: false,

        /** @type {Number} **/
        _firstPageSize: null,

        /**
         * @constructs
         * @param {*} opts - Options passed to the constructor
         */
        constructor: function(opts) {
          opts = opts || {};
          this._uiWidget = opts.uiWidget;
          this._folderPageWidget = opts.folderPageWidget;

          $super.constructor.call(this, opts);
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          this._layoutInformation = new cls.LayoutInformation(this);
          this._layoutEngine = new cls.StretchableScrollLayoutEngine(this);
          this._layoutInformation.getStretched().setDefaultX(true);
          this._layoutInformation.getStretched().setDefaultY(true);
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);

          this._element.on('scroll.StretchableScrollGridWidget', function(event) {
            this.emit(context.constants.widgetEvents.scroll, event, this.getRowHeight());
          }.bind(this));
          this._uiActivateHandler = this._uiWidget.onActivate(this.updateVerticalScroll.bind(this, true));
          if (this._folderPageWidget) {
            this._pageActivateHandler = this._folderPageWidget.onActivate(this.updateVerticalScroll.bind(this, true));
          }
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._uiActivateHandler) {
            this._uiActivateHandler();
            this._uiActivateHandler = null;
          }
          if (this._pageActivateHandler) {
            this._pageActivateHandler();
            this._pageActivateHandler = null;
          }
          this._element.off('scroll.StretchableScrollGridWidget');

          this._rowBoundWidget = null;
          this._uiWidget = null;
          this._folderPageWidget = null;
          this.destroyChildren();
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          cls.ScrollGridWidget._onClick.call(this, domEvent);
          return true;
        },

        /**
         * @inheritDoc
         */
        manageMouseDblClick: function(domEvent) {
          cls.ScrollGridWidget._onDblClick.call(this, domEvent);
          return true;
        },

        /**
         * @inheritDoc
         */
        addChildWidget: function(widget, options) {
          if (widget.isInstanceOf(cls.StretchableScrollGridLineWidget)) {
            $super.addChildWidget.call(this, widget, options);
            if (this.hasRowBound()) {
              widget.addRowBoundDecorator();
            }
          } else if (widget.isInstanceOf(cls.ContextMenuWidget)) {
            // Rowbound menu
            this._rowBoundWidget = widget;
            this._rowBoundWidget.setParentWidget(this);
          }
        },

        /**
         * Indicates how the row action must be triggered.
         * @param {boolean} b - true if action is triggered by double click (else it is single click)
         */
        setRowActionTriggerByDoubleClick: function(b) {
          this._rowActionTriggerByDoubleClick = b;
        },

        /**
         * Defines if focus in on a field or (default) on a row
         * @param {boolean} focusOnField - true if focus on field activated
         */
        setFocusOnField: function(focusOnField) {
          if (this._focusOnField !== focusOnField) {
            this._focusOnField = focusOnField;
            this.updateHighlight();
          }
        },

        /**
         * Returns if focus is on a field (by default focus is on a row)
         * @returns {boolean} true if focus on field activated
         */
        hasFocusOnField: function() {
          return this._focusOnField;
        },

        /**
         * @returns {number} scroll grid data area height
         */
        getDataAreaHeight: function() {
          return this.getLayoutInformation().getAvailable().getHeight();
        },

        /**
         * Returns scrollable area DOM Element
         * @returns {HTMLElement} scrollable area DOM Element
         */
        getScrollableArea: function() {
          return this.getElement();
        },

        /**
         * Returns the row height in pixels
         * @returns {number} row height
         * @publicdoc
         */
        getRowHeight: function() {
          if (this._rowHeight === 0 && this.getChildren().length !== 0) {
            this._rowHeight = this.getChildren()[0]._element.getBoundingClientRect().height;
          }
          return this._rowHeight;
        },

        /**
         * Defines the scroll grid pageSize
         * @param {number} pageSize - page size
         */
        setPageSize: function(pageSize) {
          this._pageSize = pageSize;
        },

        /**
         * Defines the scroll grid size (total number of row)
         * @param {number} size - size value
         */
        setSize: function(size) {
          this._size = size;
        },

        /**
         * Defines the scroll grid offset
         * @param {number} offset - offset value
         */
        setOffset: function(offset) {
          this._offset = offset;
        },

        /**
         * Update vertical scroll
         * @param {boolean} forceScroll - true to force scrolling
         */
        updateVerticalScroll: function(forceScroll) {
          this.updateContentPosition(this._size, this._pageSize, this._offset, forceScroll);
        },

        /**
         * Sets vertical scroll parameters
         * BEWARE this code should be the same as TableWidget::updateContentPosition
         * @param {?number} size
         * @param {?number} pageSize
         * @param {?number} offset
         * @param {boolean} forceScroll
         */
        updateContentPosition: function(size, pageSize, offset, forceScroll) {
          this.setSize(size);
          this._pageSize = pageSize;

          var top = offset * this.getRowHeight();
          var height = (size - offset) * this.getRowHeight();

          this.setStyle("> .containerElement", {
            "margin-top": top + "px",
            "height": height + "px"
          });

          if (!!forceScroll || (this.lastSentOffset === null || this.lastSentOffset === offset) && offset !== this._offset) {
            this._offset = offset;
            // need to do this because to scroll we need to wait the style "height" set just before is really applied in the dom
            this.afterDomMutator(function() {
              this.getScrollableArea().scrollTop = top;
            }.bind(this));
          }

          this.lastSentOffset = null;
        },

        /**
         * Change current row
         * @param {number} row - new current row
         */
        setCurrentRow: function(row) {
          this._currentRow = row;
          var children = this.getChildren();
          var length = children.length;
          for (var i = 0; i < length; ++i) {
            var rowWidget = children[i];
            rowWidget.setCurrent(i === row);
          }
        },

        /**
         * @returns {number} the current row
         */
        getCurrentRow: function() {
          return this._currentRow;
        },

        /**
         * Defines the highlight color of rows, used for selected rows
         * @param {string} color - CSS color
         */
        setHighlightColor: function(color) {

          if (this._highlightColor !== color) {
            this._highlightColor = color;

            color = (color === null ? null : color + " !important");
            this.setStyle({
              selector: this._highlightCurrentRowCssSelector,
              appliesOnRoot: true
            }, {
              "background-color": color
            });

            this.setStyle({
              selector: this._highlightCurrentCellCssSelector,
              appliesOnRoot: true
            }, {
              "background-color": color
            });
          }
        },

        /**
         * Defines the highlighted text color of rows, used for selected rows
         * @param {string} color - CSS color
         */
        setHighlightTextColor: function(color) {

          if (this._highlightTextColor !== color) {
            this._highlightTextColor = color;

            color = (color === null ? null : color + " !important");
            this.setStyle({
              selector: this._highlightCurrentCellCssSelector,
              appliesOnRoot: true
            }, {
              "color": color,
              "fill": color
            });
          }
        },

        /**
         * Indicates if the current row must be highlighted
         * @param {boolean} b - true if current row must be highlighted
         */
        setHighlightCurrentRow: function(b) {
          this._highlightCurrentRow = b;
        },

        /**
         * Return if the current row must be highlighted
         * @returns {?boolean} true if current row must be highlighted
         * @publicdoc
         */
        isHighlightCurrentRow: function() {
          return this._highlightCurrentRow;
        },

        /**
         * Indicates if the current cell must be highlighted
         * @param {boolean} b - true if current cell must be highlighted
         */
        setHighlightCurrentCell: function(b) {
          this._highlightCurrentCell = b;
        },

        /**
         * Return if the current cell must be highlighted
         * @returns {?boolean} true if current cell must be highlighted
         * @publicdoc
         */
        isHighlightCurrentCell: function() {
          return this._highlightCurrentCell;
        },

        /**
         * Update highlight row and cell
         */
        updateHighlight: function() {
          this.setCurrentRow(this._currentRow);
        },

        /**
         * Returns rowBound widget
         * @returns {classes.ContextMenuWidget} rowBound
         */
        getRowBoundWidget: function() {
          return this._rowBoundWidget;
        },

        /**
         * Returns if rowBound is activated
         * @returns {boolean} rowBound activated ?
         */
        hasRowBound: function() {
          return this._rowBoundWidget !== null;
        },

        /**
         * Indicates if the scrollgrid can have a reduce filter
         * @param {boolean} b - true if table can have a reduce filter
         */
        setReduceFilter: function(b) {
          this._hasReduceFilter = b;
        },

        /**
         * Return if the scrollgrid can have a reduce filter
         * @returns {boolean} true if table can have a reduce filter
         */
        hasReduceFilter: function() {
          return this._hasReduceFilter;
        },

        /**
         * Set how children will align
         * @param {string} alignment
         */
        setItemsAlignment: function(alignment) {
          if (this._containerElement) {
            this._containerElement.style.alignItems = {
              start: "flex-start",
              left: "flex-start",
              center: "center",
              stretch: "stretch",
              right: "flex-end",
              end: "flex-end"
            } [alignment] || "stretch";
          }
        }

      };
    });
    cls.WidgetFactory.registerBuilder('StretchableScrollGrid', cls.StretchableScrollGridWidget);
  });
;
"use strict";

modulum('TabbedApplicationCloseWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class TabbedApplicationCloseWidget
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.TabbedApplicationCloseWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.TabbedApplicationCloseWidget.prototype */ {
        __name: "TabbedApplicationCloseWidget",
        _activated: false,
        _processing: false,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          this._ignoreLayout = true;
          $super._initElement.call(this);
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          // no layout
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          if (!this._processing) {
            this.emit(context.constants.widgetEvents.click);
          }
          return false;
        },

        setActive: function(active) {
          this._active = active;
          this._element.toggleClass("gbc-disabled", !active);
        },

        setHidden: function(hidden) {
          this._element.toggleClass("gbc-hidden", !!hidden);
        },

        onClick: function(hook) {
          return this.when(context.constants.widgetEvents.click, hook);
        },

        _setProcessingStyle: function(processing) {
          this._processing = !!processing;
          if (this._element) {
            if (processing) {
              this._element.setAttribute("processing", "processing");
            } else {
              this._element.removeAttribute("processing");
            }
          }
        }
      };
    });
    cls.WidgetFactory.registerBuilder('TabbedApplicationClose', cls.TabbedApplicationCloseWidget);
  });
;
"use strict";

modulum('TabbedApplicationHostMenuWindowCloseWidget', ['ApplicationHostMenuWindowCloseWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class TabbedApplicationHostMenuWindowCloseWidget
     * @memberOf classes
     * @extends classes.ApplicationHostMenuWindowCloseWidget
     */
    cls.TabbedApplicationHostMenuWindowCloseWidget = context.oo.Class(cls.ApplicationHostMenuWindowCloseWidget, function($super) {
      return /** @lends classes.TabbedApplicationHostMenuWindowCloseWidget.prototype */ {
        __name: "TabbedApplicationHostMenuWindowCloseWidget",
        setActive: function(active) {
          this._active = active;
          this._element.toggleClass("gbc-disabled", !active);
        },
        setHidden: function(hidden) {
          this._element.toggleClass("gbc-hidden", !!hidden);
        }
      };
    });
    cls.WidgetFactory.registerBuilder('TabbedApplicationHostWindowCloseMenu', cls.TabbedApplicationHostMenuWindowCloseWidget);
  });
;
"use strict";

modulum('TabbedContainerWidget', ['FolderWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Tabbed container widget.
     * @class TabbedContainerWidget
     * @memberOf classes
     * @extends classes.FolderWidget
     */
    cls.TabbedContainerWidget = context.oo.Class(cls.FolderWidget, function($super) {
      return /** @lends classes.TabbedContainerWidget.prototype */ {
        __name: "TabbedContainerWidget",
        __templateName: "FolderWidget",

        /**
         * @type {HandleRegistration}
         */
        _browserResizeHandler: null,
        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);

          this._browserResizeHandler = context.HostService.onScreenResize(this.updateScrollersVisibility.bind(this));
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._browserResizeHandler) {
            this._browserResizeHandler();
            this._browserResizeHandler = null;
          }
          this.destroyChildren();
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          this.setTabPosition("top");
          this._layoutInformation = new cls.FolderLayoutInformation(this);
          this._layoutEngine = new cls.TabbedContainerLayoutEngine(this);
        },

        /**
         * @inheritDoc
         */
        onTitleClick: function(page) {
          this.setCurrentPage(page);
        },

        /**
         * @inheritDoc
         */
        _getAllocatedSize: function(isHorizontal) {
          if (this.getParentWidget()) {
            var info = this.getParentWidget().getLayoutInformation();
            return info.getRawMeasure()[isHorizontal ? "getWidth" : "getHeight"]();
          }
          return 0;
        }
      };
    });
    cls.WidgetFactory.registerBuilder('TabbedContainer', cls.TabbedContainerWidget);
  });
;
"use strict";

modulum('TableColumnAggregateWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Table column aggregate.
     * @class TableColumnAggregateWidget
     * @memberOf classes
     * @extends classes.WidgetBase
     * @publicdoc
     */
    cls.TableColumnAggregateWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.TableColumnAggregateWidget.prototype */ {
        __name: "TableColumnAggregateWidget",

        _textElement: null,

        /**
         * Current text aligned used
         * @type {?string}
         */
        _textAlign: null,

        /**
         * @constructs
         * @param {*} opts - Options passed to the constructor
         */
        constructor: function(opts) {
          opts = (opts || {});
          opts.inTable = true;
          $super.constructor.call(this, opts);
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          this._textElement = this._element.getElementsByClassName("gbc_TableAggregateText")[0];
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          // no layout
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._textElement = null;
          $super.destroy.call(this);
        },

        /**
         * Sets text displayed
         * @param {string} text - the text to display
         * @publicdoc
         */
        setText: function(text) {
          var tableColumn = this.getParentWidget();
          if (tableColumn.getChildren().length > 0) {
            var item = tableColumn.getColumnItem(0);
            var widget = item.getChildren().length > 0 ? item.getChildren()[0] : null;
            if (widget && widget.getFormat) { // use same date format as first widget of column
              text = cls.DateTimeHelper.toDbDateFormat(text, widget.getFormat());
            }
          }
          this._setTextContent(text, "_textElement");
        },

        /**
         * Returns text displayed
         * @returns {string} the text to display
         * @publicdoc
         */
        getText: function() {
          return this._textElement.textContent;
        },

        /**
         * Set text alignment
         * @param {string} align - (left, center, right)
         */
        setTextAlign: function(align) {
          this._textAlign = align;
          this.setStyle(".gbc_TableAggregateText", {
            "text-align": align
          });
        },

        /**
         * Computes aggregate width
         * @param {number} aggregateWidth - aggregate width (contains al previous column which have no aggregate) (pixels)
         */
        computeWidth: function(aggregateWidth) {

          var tableColumn = this.getParentWidget();
          if (tableColumn.getWidth() === null) {
            return; // no need to compute aggregate width if column width is not measured
          }

          this.setStyle({
            "width": aggregateWidth + "px"
          });

          // remove borders
          this.setStyle(".gbc_TableAggregateText", {
            "border-left": null,
            "border-right": null,
            "margin-left": null
          });

          var isRightTextAlign = (this._textAlign === "right");
          var isCenterTextAlign = (this._textAlign === "center");
          var isLeftTextAlign = (this._textAlign === "left" || this._textAlign === null);

          if (isLeftTextAlign || isCenterTextAlign) {
            this.setStyle(".gbc_TableAggregateText", {
              "margin-left": (aggregateWidth - tableColumn.getWidth()) + "px",
            });
          }

          var borderColor = context.ThemeService.getValue("gbc-TableWidget-inner-border-color");
          if (isRightTextAlign) {
            this.setStyle(".gbc_TableAggregateText", {
              "border-right": "solid 1px " + borderColor
            });
          } else if (isLeftTextAlign && tableColumn.getOrderedColumnIndex() > 0) { // don't put left border on first column
            this.setStyle(".gbc_TableAggregateText", {
              "border-left": "solid 1px " + borderColor
            });
          }
        },

        /**
         * Returns aggregate width style
         * @returns {string} aggregate width (ex:"42px")
         */
        getWidthStyle: function() {
          return this.getStyle("width");
        },

        /**
         * Sets index order of aggregate
         * @param {number} index - order index
         */
        setOrder: function(index) {
          this.setStyle({
            "order": index
          });
        }

      };
    });
    cls.WidgetFactory.registerBuilder('TableColumnAggregate', cls.TableColumnAggregateWidget);
  });
;
"use strict";

modulum('TableColumnItemWidget', ['WidgetGroupBase'],
  function(context, cls) {

    /**
     * Table column widget.
     * @class TableColumnItemWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     * @publicdoc
     */
    cls.TableColumnItemWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.TableColumnItemWidget.prototype */ {
        __name: "TableColumnItemWidget",

        _treeAnchor: null,
        /**
         * @type {classes.ImageWidget}
         */
        _imageWidget: null,
        /**
         * @type {Function}
         */
        _imageClickHandler: null,
        /**
         * @type {HTMLElement}
         */
        _imageSpanElement: null,
        _dndEnabled: false,
        _currentImagePath: null,

        _current: false,
        _clientSelected: false,

        /**
         * @constructs
         * @param {*} opts - Options passed to the constructor
         */
        constructor: function(opts) {
          opts = (opts || {});
          var isTreeItem = opts.isTreeItem;
          opts.inTable = true;
          $super.constructor.call(this, opts);

          if (isTreeItem) {
            this._treeAnchor = document.createElement("span");
            this._treeAnchor.addClass("gbc_TreeAnchor");
            this._element.prependChild(this._treeAnchor);
            this._element.onDoubleTap("TreeAnchor", this.manageMouseClick.bind(this)); // TODO this is for why ?
            this.setLeaf(true);
          }
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          // no layout
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._treeAnchor) {
            this._element.offDoubleTap("TreeAnchor");
          }
          if (this._imageClickHandler) {
            this._imageClickHandler();
            this._imageClickHandler = null;
          }
          if (this._imageWidget) {
            this._imageWidget.destroy();
            this._imageWidget = null;
          }
          $super.destroy.call(this);
        },

        /**
         * Request focus for this row (keep current column)
         * @param {*} domEvent - dom event object
         */
        requestFocus: function(domEvent) {
          var tableWidget = this.getTableWidgetBase();
          if (tableWidget) {
            var widget = tableWidget.getWidgetAt(tableWidget.getCurrentColumn(), this.getItemIndex());
            tableWidget.requestFocusFromWidget(widget, domEvent);
          }
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          if (domEvent.target === this._treeAnchor) { // click on tree anchor
            var index = this.getItemIndex();
            this.getParentWidget().emit(context.constants.widgetEvents.toggleClick, index);
            return false;
          }
          return true;
        },

        /**
         * @inheritDoc
         */
        manageMouseDblClick: function(domEvent) {
          if (domEvent.target === this._treeAnchor) { // double click on tree anchor
            return false;
          }
          return true;
        },

        /**
         * @inheritDoc
         */
        addChildWidget: function(widget, options) {
          if (this._children.length !== 0) {
            throw "A item only contain a single child";
          }
          $super.addChildWidget.call(this, widget, options);
        },

        /**
         * @inheritDoc
         */
        setBackgroundColor: function(color) {
          if (this._backgroundColor !== color) {
            this._backgroundColor = color;
            this.setStyle({
              "background-color": !!color && !this._ignoreBackgroundColor ? color : null
            });
          }
        },

        /**
         * Enable drag and drop
         * @param {boolean} b - true to enable
         */
        setDndEnabled: function(b) {
          if (this._dndEnabled !== b) {
            this._dndEnabled = b;
            if (b) {
              this._element.setAttribute("draggable", "true");
            } else {
              this._element.removeAttribute("draggable");
            }
          }
        },

        /**
         * Check if item is tree item
         * @returns {boolean} true if the element is a tree item, false otherwise
         * @publicdoc
         */
        isTreeItem: function() {
          return !!this._treeAnchor;
        },

        /**
         * Sets if item is a leaf of tree
         * @param {boolean} leaf - true if the item is a leaf item, false otherwise
         */
        setLeaf: function(leaf) {
          if (this.isTreeItem()) {
            this.setAriaExpanded(null);
            if (leaf) {
              this._treeAnchor.removeClass("treeExpanded");
              this._treeAnchor.removeClass("treeCollapsed");
            }
            this._treeAnchor.toggleClass("treeLeaf", leaf);

          }
        },

        /**
         * Checks if item is tree leaf item
         * @returns {boolean} leaf true if the item is a leaf item, false otherwise
         * @publicdoc
         */
        isLeaf: function() {
          return this.isTreeItem() && this._treeAnchor.hasClass("treeLeaf");
        },

        /**
         * Expands or collapse tree item
         * @param {boolean} expanded - true if the item should be expanded, false otherwise
         */
        setExpanded: function(expanded) {
          if (this.isTreeItem() && !this.isLeaf()) {
            this.setAriaExpanded(expanded);
            this._treeAnchor.toggleClass("treeExpanded", "treeCollapsed", expanded);

            var qaElement = this.getContainerElement().querySelector("[data-gqa-name]");
            if (qaElement) {
              qaElement.setAttribute('data-gqa-expanded', expanded.toString());
            }
          }
        },

        setAriaExpanded: function(expanded) {
          this.setAriaAttribute("expanded", expanded);
          if (this._children[0]) {
            this._children[0].setAriaAttribute("expanded", expanded);
          }
        },

        /**
         * Checks if tree item is expanded
         * @returns {boolean} true if the item is expanded, false otherwise
         * @publicdoc
         */
        isExpanded: function() {
          return this.isTreeItem();
        },

        /**
         * @inheritDoc
         */
        isReversed: function() {
          // executed on table column
          return this._parentWidget.isReversed();
        },

        /**
         * Updates visibility depending on the number of visible rows defined in the parent TableWidget
         */
        updateVisibility: function() {
          var visibleRows = this.getParentWidget().getParentWidget().getVisibleRows();
          this.setHidden(this.getItemIndex() >= visibleRows);
        },

        /**
         * Sets tree item depth
         * @param {number} depth - item depth
         */
        setDepth: function(depth) {
          var depthObj = {};
          depthObj["padding-" + this.getStart()] = depth + 'em';
          this.setStyle(depthObj);
        },

        /**
         * Get tree item depth
         * @returns {number} item depth
         */
        getDepth: function() {
          var depth = this.getStyle('padding-left');
          if (depth) {
            return parseInt(depth, 10);
          }
          return 0;
        },

        /**
         * Sets if it is part of current row
         * @param {boolean} current - true if the item is part of the current line, false otherwise
         */
        setCurrent: function(current) {
          if (this._current !== current) {
            this._current = current;
            if (!!current) {
              this._element.addClass("currentRow");
              this._children[0].addClass("currentRow");
            } else {
              this._element.removeClass("currentRow");
              this._children[0].removeClass("currentRow");
            }
            this.setAriaAttribute("labeledby", this._children[0].getRootClassName());
            this.setAriaSelection();

          }
        },

        /**
         * Sets image item
         * @param {string} path - image path
         * @publicdoc
         */
        setImage: function(path) {
          if (this._currentImagePath !== path) {
            if (path && path !== "") {

              if (!this._imageSpanElement) {
                this._imageSpanElement = document.createElement("span");
                this._imageSpanElement.addClass("gbc_TableItemImage");
                this._element.insertBefore(this._imageSpanElement, this.getContainerElement());
              }

              if (!this._imageWidget) {

                var opts = this.getBuildParameters();
                opts.inTable = true;
                this._imageWidget = cls.WidgetFactory.createWidget("ImageWidget", opts);
                this._imageWidget.setParentWidget(this);
                this._imageClickHandler = this._imageWidget.when(context.constants.widgetEvents.click, function(event) {
                  this.getTableWidgetBase().requestFocusFromWidget(this._children[0], event);
                }.bind(this));
                this._imageSpanElement.prependChild(this._imageWidget.getElement());
              }
              this._imageSpanElement.addClass("visibleImage");
              this._imageWidget.setSrc(path);
              this._imageWidget.setHidden(false);
            } else if (this._imageWidget) {
              this._imageSpanElement.removeClass("visibleImage");
              this._imageWidget.setHidden(true);
            }
            this._currentImagePath = path;
          }
        },

        /**
         * Checks if item is part of current row
         * @returns {boolean} true if the item is part of the current line, false otherwise
         * @publicdoc
         */
        isCurrent: function() {
          return this._element.hasClass("currentRow");
        },

        /**
         * Sets if item is selected
         * @param {boolean} selected - true if the item should be selected, false otherwise
         */
        setSelected: function(selected) {
          var children = this.getChildren();
          if (children.length !== 0) {
            children[0].setIgnoreBackgroundColor(!!selected);
          }
          this._element.toggleClass("selectedRow", !!selected);
        },

        /**
         * Checks if item is selected
         * @returns {boolean} true if the row item is selected, false otherwise
         */
        isSelected: function() {
          return this._element.hasClass("selectedRow");
        },

        /**
         * Checks if item is client selected
         * @returns {boolean} true if the row item is client selected, false otherwise
         */
        isClientSelected: function() {
          return this._clientSelected;
        },

        /**
         * Sets if item is client selected
         * @param {boolean} selected - true if the item is client selected, false otherwise
         */
        setClientSelected: function(selected) {
          this._clientSelected = selected;
        },

        /**
         * Returns index of the item in the parent column
         * @returns {number} index of the item in the column
         * @publicdoc
         */
        getItemIndex: function() {
          var parent = this.getParentWidget();
          if (!!parent) {
            return parent.getChildren().indexOf(this);
          }
          return -1;
        },

        /**
         * Handle dragStart event
         * @param {Object} evt - dragstart event
         */
        onDragStart: function(evt) {
          if (window.browserInfo.isFirefox) { // Firefox 1.0+
            try {
              evt.dataTransfer.setData('text/plain', ''); // for Firefox compatibility
            } catch (ex) {
              console.error("evt.dataTransfer.setData('text/plain', ''); not supported");
            }
          }
          var tableColumn = this.getParentWidget();
          tableColumn.emit(gbc.constants.widgetEvents.tableDragStart, this.getItemIndex(), evt);
        },

        /**
         * Handle dragEnd event
         */
        onDragEnd: function() {
          var tableColumn = this.getParentWidget();
          tableColumn.emit(gbc.constants.widgetEvents.tableDragEnd);
        },

        /**
         * Handle dragOver event
         * @param {Object} evt - dragover event
         */
        onDragOver: function(evt) {
          var tableColumn = this.getParentWidget();
          tableColumn.emit(gbc.constants.widgetEvents.tableDragOver, this.getItemIndex(), evt);
        },

        /**
         * Handle dragLeave event
         * @param {Object} evt - dragleave event
         */
        onDragLeave: function(evt) {
          var tableColumn = this.getParentWidget();
          tableColumn.emit(gbc.constants.widgetEvents.tableDragLeave, this.getItemIndex(), evt);
        },

        /**
         * Handle dragEnter event
         * @param {Object} evt - dragenter event
         */
        onDragEnter: function(evt) {
          var tableColumn = this.getParentWidget();
          tableColumn.emit(gbc.constants.widgetEvents.tableDragEnter, this.getItemIndex(), evt);
        },

        /**
         * Handle drop event
         */
        onDrop: function() {
          var tableColumn = this.getParentWidget();
          tableColumn.emit(gbc.constants.widgetEvents.tableDrop, this.getItemIndex());
        },

        /**
         * @inheritDoc
         */
        isLayoutMeasureable: function(deep) {
          return true;
        }
      };
    });
    cls.WidgetFactory.registerBuilder('TableColumnItem', cls.TableColumnItemWidget);
  });
;
"use strict";

modulum('TableColumnRowBoundWidget', ['TableColumnWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Table column rowbound.
     * @class TableColumnRowBoundWidget
     * @memberOf classes
     * @extends classes.TableColumnWidget
     * @publicdoc
     */
    cls.TableColumnRowBoundWidget = context.oo.Class(cls.TableColumnWidget, function($super) {
      return /** @lends classes.TableColumnRowBoundWidget.prototype */ {
        __name: "TableColumnRowBoundWidget",
        __templateName: "TableColumnWidget",

        $static: /** @lends classes.TableColumnRowBoundWidget */ {
          minWidth: 24
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);

          this.getTitleWidget().onReorderingDrop = Function.noop; // disable drop on this column
          this.getTitleWidget().onReorderingDragOver = Function.noop; // disable drag over on this column
          this.getTitleWidget()._buildContextMenu = Function.noop; // disable contextmenu
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          var children = this.getChildren();
          if (children) {
            for (var i = children.length - 1; i > -1; i--) {
              var currentChildren = children[i];
              currentChildren.destroyChildren(); // manually destroy RowBoundDecorator
              currentChildren.destroy();
              currentChildren = null;
            }
          }
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        updateRowsVisibility: function() {
          var visibleRows = this.getParentWidget().getVisibleRows();
          var children = this.getChildren();

          // create RowBoundDecorators for each visible row
          while (children.length < visibleRows) {
            var rowBoundDecorator = cls.WidgetFactory.createWidget("RowBoundDecorator", this.getBuildParameters());
            this.addChildWidget(rowBoundDecorator);
          }

          $super.updateRowsVisibility.call(this);
        },

        /**
         * @inheritDoc
         */
        measureSize: function() {},

        /**
         * @inheritDoc
         */
        setWidth: function(width) {
          width = Math.max(width, cls.TableColumnRowBoundWidget.minWidth);
          $super.setWidth.call(this, width);
        },

        /**
         * @inheritDoc
         */
        isMovable: function() {
          return false;
        },

        /**
         * @inheritDoc
         */
        isSizable: function() {
          return false;
        },

        /**
         * @inheritDoc
         */
        isAlwaysVisible: function() {
          return true;
        }

      };
    });
    cls.WidgetFactory.registerBuilder('TableColumnRowBound', cls.TableColumnRowBoundWidget);
  });
;
"use strict";

modulum('TableColumnTitleWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Table column title widget.
     * @class TableColumnTitleWidget
     * @memberOf classes
     * @extends classes.WidgetBase
     * @publicdoc
     */
    cls.TableColumnTitleWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.TableColumnTitleWidget.prototype */ {
        __name: "TableColumnTitleWidget",

        _resizerDragX: null,
        /**
         * the contextmenu widget
         * @type {classes.ContextMenuWidget}
         */
        _contextMenu: null,
        _autoAlignment: false,

        _sortIconElement: null,
        _sortGlyph: null,

        /**
         * @constructs
         * @param {*} opts - Options passed to the constructor
         */
        constructor: function(opts) {
          opts = (opts || {});
          opts.inTable = true;
          $super.constructor.call(this, opts);
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          // no layout
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._contextMenu) {
            this._contextMenu.destroyChildren();
            this._contextMenu.destroy();
            this._contextMenu = null;
          }
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageMouseRightClick: function(domEvent) {
          if (domEvent.shiftKey) {
            return false;
          }
          domEvent.preventCancelableDefault();
          this._buildContextMenu(domEvent);

          return false;
        },

        /**
         * Shortcut to open the contextMenu at a given x position
         * @param {Number?} xPos - horizontal position
         */
        showContextMenu: function(xPos) {
          this._buildContextMenu(null, xPos);
        },

        /**
         * Build context menu and show it
         */
        _buildContextMenu: function(domEvent, xPos) {
          if (this._contextMenu) {
            this._contextMenu.destroyChildren();
            this._contextMenu.destroy();
            this._contextMenu = null;
          }
          var table = this.getTableWidget();
          if (table) {
            var opts = this.getBuildParameters();
            opts.inTable = false; // contextmenu is not really in the table, it is outside
            opts.ignoreLayout = true;

            this._contextMenu = cls.WidgetFactory.createWidget("ContextMenu", opts);
            this._contextMenu.allowMultipleChoices(true);
            this._contextMenu.setParentWidget(this);
            this._contextMenu.setColor(table.getColor());
            this._contextMenu.setBackgroundColor(table.getBackgroundColor());

            this._contextMenu.onClose(function() {
              this.afterDomMutator(function() {
                if (this._contextMenu) {
                  this._contextMenu.destroyChildren();
                  this._contextMenu.destroy();
                  this._contextMenu = null;
                }
              }.bind(this));
            }.bind(this), true);

            if (domEvent && domEvent.touches && domEvent.touches[0]) {
              this._contextMenu.x = domEvent.touches[0].clientX;
            } else if (window.event) {
              this._contextMenu.x = window.event.clientX;
            } else {
              this._contextMenu.x = xPos;
            }

            var columns = table.getColumns();
            var tableColumn = this.getParentWidget();

            // Hide/show columns
            var hideShowFunc = function(columnTitle) {
              if (!this.isUnhidable()) {
                this.emit(gbc.constants.widgetEvents.tableShowHideCol, "toggle");
              }

              // refocus UI widget to keep typeahead key processing & drodown manage keys active
              if (columnTitle && columnTitle._contextMenu && columnTitle._contextMenu.isVisible()) {
                var uiWidget = columnTitle.getUserInterfaceWidget();
                if (uiWidget) {
                  uiWidget.getElement().domFocus();
                }
              }
            };

            // Be sure that the last checkbox is always check (cannot hide all columns)
            var checkLast = function(checkWidget, columnTitle) {
              var children = columnTitle.getContextMenu().getChildren();
              var checkCount = children.filter(function(c) {
                if (c._tc) {
                  c.setEnabled(!c._tc.isUnhidable());
                  if (c.isInstanceOf(cls.CheckBoxWidget) && c.getValue()) {
                    return c;
                  }
                }
              });
              if (checkCount.length === 1) {
                checkCount[0].setEnabled(false);
              }
            };

            for (var i = 0; i < columns.length; i++) {
              var tc = columns[i];
              if (!tc.isAlwaysHidden() && !tc.isAlwaysVisible()) {
                var check = cls.WidgetFactory.createWidget("CheckBox", opts);
                check._tc = tc;
                check.setEnabled(!tc.isUnhidable());
                check.setText(tc.getTitleWidget().getText());
                check.setValue(!tc.isHidden());
                checkLast(check, this);
                check.when(context.constants.widgetEvents.click, checkLast.bind(tc, check, this));
                this._contextMenu.addChildWidget(check, {
                  clickCallback: hideShowFunc.bind(tc, this)
                });
              }
            }

            this._contextMenu.addSeparator();

            // Show all columns action
            var showAllColumnsLabel = cls.WidgetFactory.createWidget("Label", opts);
            showAllColumnsLabel.setValue(i18next.t("gwc.contextMenu.showAllColumns"));
            showAllColumnsLabel.addClass("gbc_showAllColumns_action");
            this._contextMenu.addChildWidget(showAllColumnsLabel, {
              clickCallback: function() {
                var columns = this.getTableWidget().getColumns();
                for (var i = 0; i < columns.length; i++) {
                  var tc = columns[i];
                  if (!tc.isAlwaysHidden() && !tc.isUnhidable()) {
                    tc.emit(gbc.constants.widgetEvents.tableShowHideCol, "show");
                  }
                }
              }.bind(this)
            });

            // hide other columns action
            var hideOtherColumnsLabel = cls.WidgetFactory.createWidget("Label", opts);
            hideOtherColumnsLabel.setValue(i18next.t("gwc.contextMenu.hideAllButSelected"));
            hideOtherColumnsLabel.addClass("gbc_hideAllButSelected_action");
            this._contextMenu.addChildWidget(hideOtherColumnsLabel, {
              clickCallback: function() {
                var columns = this.getTableWidget().getColumns();
                for (var i = 0; i < columns.length; i++) {
                  var tc = columns[i];
                  if (!tc.isAlwaysHidden() && !tc.isUnhidable() && tc !== this.getParentWidget()) {
                    tc.emit(gbc.constants.widgetEvents.tableShowHideCol, "hide");
                  }
                }
                // we hide other columns but we must show current column
                this.getParentWidget().emit(gbc.constants.widgetEvents.tableShowHideCol, "show");
              }.bind(this)
            });

            // AutoFit column width based on values
            var autoFitAllColumnsLabel = cls.WidgetFactory.createWidget("Label", opts);
            autoFitAllColumnsLabel.setValue(i18next.t("gwc.contextMenu.autoFitAllColumns"));
            autoFitAllColumnsLabel.addClass("gbc_autoFitAllColumns_action");
            this._contextMenu.addChildWidget(autoFitAllColumnsLabel, {
              clickCallback: function() {
                this.getTableWidget().autoFitAllColumns();
              }.bind(this)
            });

            // Fit column width so all columns visible
            // Example: if table width = 600px and there are two columns currently 100 and 200px
            // then this will set width of columns to 200 and 400 px respectively
            var fitToViewAllColumnsLabel = cls.WidgetFactory.createWidget("Label", opts);
            fitToViewAllColumnsLabel.setValue(i18next.t("gwc.contextMenu.fitToViewAllColumns"));
            fitToViewAllColumnsLabel.addClass("gbc_fitToViewAllColumns_action");
            this._contextMenu.addChildWidget(fitToViewAllColumnsLabel, {
              clickCallback: function() {
                this.getTableWidget().fitToViewAllColumns();
              }.bind(this)
            });

            this._contextMenu.addSeparator();

            // Reset to default action
            var resetDefaultLabel = cls.WidgetFactory.createWidget("Label", opts);
            resetDefaultLabel.setValue(i18next.t("gwc.contextMenu.restoreDefaultSettings"));
            resetDefaultLabel.addClass("gbc_restoreColumnSort_action");
            this._contextMenu.addChildWidget(resetDefaultLabel, {
              clickCallback: function() {
                table.emit(context.constants.widgetEvents.tableResetToDefault);
              }.bind(this)
            });

            // Reset sort order action
            var resetLabel = cls.WidgetFactory.createWidget("Label", opts);
            resetLabel.setValue(i18next.t("gwc.contextMenu.restoreColumnSort"));
            resetLabel.addClass("gbc_restoreColumnSort_action");
            this._contextMenu.addChildWidget(resetLabel, {
              clickCallback: function() {
                tableColumn.emit(context.constants.widgetEvents.tableHeaderClick, "reset");
              }.bind(this)
            });

            //Frozen columns
            if (table.isFrozenTable()) {
              this._contextMenu.addSeparator();

              var leftFrozenLabel = cls.WidgetFactory.createWidget("Label", opts);
              var rightFrozenLabel = cls.WidgetFactory.createWidget("Label", opts);
              var unfreezeLabel = cls.WidgetFactory.createWidget("Label", opts);
              var freezeIndex = 0;
              var columnCount = 0;

              leftFrozenLabel.setValue(i18next.t("gwc.contextMenu.freezeLeft"));
              rightFrozenLabel.setValue(i18next.t("gwc.contextMenu.freezeRight"));
              unfreezeLabel.setValue(i18next.t("gwc.contextMenu.unfreezeAll"));

              leftFrozenLabel.addClass("gbc_freezeLeft_action");
              rightFrozenLabel.addClass("gbc_freezeRight_action");
              unfreezeLabel.addClass("gbc_unfreezeAll_action");

              this._contextMenu.addChildWidget((this.isReversed() ? rightFrozenLabel : leftFrozenLabel), {
                clickCallback: function() {
                  freezeIndex = tableColumn.getOrderedColumnIndex() + 1;
                  table.setLeftFrozenColumns(freezeIndex);
                  table.emit(gbc.constants.widgetEvents.tableLeftFrozen, freezeIndex);
                }.bind(this)
              });
              this._contextMenu.addChildWidget((this.isReversed() ? leftFrozenLabel : rightFrozenLabel), {
                clickCallback: function() {
                  columnCount = columns.length;
                  freezeIndex = tableColumn.getOrderedColumnIndex();
                  table.setRightFrozenColumns(columnCount - freezeIndex);
                  table.emit(gbc.constants.widgetEvents.tableRightFrozen, columnCount - freezeIndex);
                }.bind(this)
              });
              this._contextMenu.addChildWidget(unfreezeLabel, {
                clickCallback: function() {
                  table.setLeftFrozenColumns(0);
                  table.setRightFrozenColumns(0);
                  table.emit(gbc.constants.widgetEvents.tableLeftFrozen, 0);
                  table.emit(gbc.constants.widgetEvents.tableRightFrozen, 0);
                }.bind(this)
              });
            }

            this._element.domFocus(null, table.getElement());
            // beware setFocus should not raise a scroll event (it will immediatly close contextmenu)
            this._contextMenu.show();
          }
        },

        /**
         * @inheritDoc
         */
        managePriorityKeyDown: function(keyString, domKeyEvent, repeat) {
          var keyProcessed = false;
          if (this._contextMenu.isVisible()) {
            keyProcessed = this._contextMenu.managePriorityKeyDown(keyString, domKeyEvent, repeat);
          }
          return keyProcessed;
        },

        /**
         * Returns the element used to resize the column
         * @returns {HTMLElement} the resizer element
         * @publicdoc
         */
        getResizer: function() {
          return this._element.getElementsByClassName("resizer")[0];
        },

        /**
         * Returns the element containing the text
         * @returns {HTMLElement} the headerText element
         * @publicdoc
         */
        getHeaderText: function() {
          return this._element.getElementsByClassName("headerText")[0];
        },

        /**
         * Returns the contextmenu widget
         * @returns {classes.ContextMenuWidget} the context menu widget
         */
        getContextMenu: function() {
          return this._contextMenu;
        },

        /**
         * Returns element containing the sort icon
         * @returns {HTMLElement} the sortIcon element
         */
        getSortIconElement: function() {
          return this._sortIconElement;
        },

        /**
         * Returns the parent table widget
         * @returns {classes.TableWidget} the table widget
         */
        getTableWidget: function() {
          return this._parentWidget._parentWidget;
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          if (domEvent.target.hasClass("headerText")) { // click on header text
            this.getParentWidget().emit(context.constants.widgetEvents.tableHeaderClick);
          }

          return false;
        },

        /**
         * Handle resizer double click event
         */
        onResizerDoubleClick: function() {
          this.getParentWidget().autoSetWidth();
        },

        /**
         * Handle resizer dragStart event on resizer element
         * @param {Object} evt dragstart event
         */
        onResizerDragStart: function(evt) {
          if (window.browserInfo.isFirefox) { // Firefox 1.0+
            try {
              evt.dataTransfer.setData('text/plain', ''); // for Firefox compatibility
            } catch (ex) {
              console.error("evt.dataTransfer.setData('text/plain', ''); not supported");
            }
          }
          if (this.getParentWidget().isSizable()) {
            this.getTableWidget()._dndMode = "columnResizing";
            this.getParentWidget().getElement().addClass("resizing");
            this._resizerDragX = evt.clientX || evt.screenX;
          } else {
            evt.preventCancelableDefault();
          }
        },

        /**
         * Handle resizer drag event on resizer element
         */
        onResizerDrag: function() {
          if (this.getTableWidget()._dndMode === "columnResizing") {
            if (!this._resizerDragX || !this.getTableWidget()._dndMouseDragX) {
              return;
            }
            var size = this.getTableWidget()._dndMouseDragX - this._resizerDragX;
            var initialWidth = this.getParentWidget().getWidth();

            var newWidth = initialWidth + size;
            if (this.isReversed()) {
              newWidth = initialWidth - size;
            }
            if (newWidth > 30) {
              this._resizerDragX = this.getTableWidget()._dndMouseDragX;
              this.getParentWidget().setWidthFromUserInteraction(newWidth);
            }
          }
        },

        /**
         * Handle resizer dragEnd event on resizer element
         * @param {Object} evt dragend event
         */
        onResizerDragEnd: function(evt) {
          var tc = this.getParentWidget();
          tc._element.removeClass("resizing");

          this._resizerDragX = null;
          evt.preventCancelableDefault();

          this.getTableWidget()._dndMode = null;

          // Save stored settings
          var width = tc.getWidth();
          this.getParentWidget().setWidthFromUserInteraction(width);
        },

        /**
         * Handle reordering dragStart event
         * @param {Object} evt dragstart event
         */
        onReorderingDragStart: function(evt) {
          if (window.browserInfo.isFirefox) { // Firefox 1.0+
            try {
              evt.dataTransfer.setData('text/plain', ''); // for Firefox compatibility
            } catch (ex) {
              console.error("evt.dataTransfer.setData('text/plain', ''); not supported");
            }
          }

          if (this.getParentWidget().isMovable()) {
            this.getTableWidget()._dndMode = "columnReordering";
            this.getTableWidget()._dndDraggedColumnWidget = this.getParentWidget();
          } else {
            evt.preventCancelableDefault();
          }
        },

        /**
         * Handle reordering dragEnd event
         * @param {Object} evt dragend event
         */
        onReorderingDragEnd: function(evt) {
          if (this.getTableWidget()._dndReorderingDragOverWidget !== null) {
            this.getTableWidget()._dndReorderingDragOverWidget.getElement()
              .removeClass("reordering_left").removeClass("reordering_right");
            this.getTableWidget()._dndReorderingDragOverWidget = null;
          }
          // When releasing the drag, remove all noDrop classes
          var allNoDrop = this.getTableWidget().getElement().querySelectorAll(".noDrop");
          for (var i = 0; i < allNoDrop.length; i++) {
            allNoDrop[i].removeClass("noDrop");
          }
          this.getTableWidget()._noDrop = {
            "left": false,
            "right": false,
            "center": false
          };
          this.getTableWidget()._dndMode = null;
          this.getTableWidget()._dndDraggedColumnWidget = null;
        },

        /**
         * Handle reordering drop event
         */
        onReorderingDrop: function() {
          if (this.getTableWidget()._dndMode === "columnReordering") {
            if (this.getTableWidget()._dndReorderingDragOverWidget &&
              this.getTableWidget()._dndDraggedColumnWidget !== this.getTableWidget()._dndReorderingDragOverWidget) {

              this.reorderColumns(
                this.getTableWidget()._dndDraggedColumnWidget, this.getTableWidget()._dndReorderingDragOverWidget);
            }
          }
        },

        /**
         * Reorder columns
         * @param {classes.TableColumnWidget} draggedColumn - dragged column
         * @param {classes.TableColumnWidget} dropColumn - drop column
         */
        reorderColumns: function(draggedColumn, dropColumn) {
          var tableWidget = this.getTableWidget();
          tableWidget.resetOrderedColumns();
          var orderedColumns = tableWidget.getOrderedColumns();
          var newOrderedColumns = orderedColumns.slice();

          var dragColIndex = newOrderedColumns.indexOf(draggedColumn);
          var dropColIndex = newOrderedColumns.indexOf(dropColumn);

          newOrderedColumns.removeAt(dragColIndex);
          newOrderedColumns.insert(this.getTableWidget()._dndDraggedColumnWidget, dropColIndex);

          for (var i = 0; i < newOrderedColumns.length; i++) {
            var col = newOrderedColumns[i];
            col.emit(context.constants.widgetEvents.tableOrderColumn, i + 1);
            col.setOrder(i);
          }
        },

        /**
         * Handle reordering dragOver event
         * @param {Object} evt - dragover event
         */
        onReorderingDragOver: function(evt) {

          if (this.getTableWidget()._dndMode === "columnReordering") {

            var lastReorderingDragOverColumnWidget = this.getTableWidget()._dndReorderingDragOverWidget;
            if (lastReorderingDragOverColumnWidget !== this.getParentWidget()) {

              if (lastReorderingDragOverColumnWidget !== null) {
                lastReorderingDragOverColumnWidget.getElement()
                  .removeClass("reordering_left").removeClass("reordering_right");
              }
              this.getTableWidget()._dndReorderingDragOverWidget = this.getParentWidget();
            }

            var overIndex = this.getParentWidget().getOrderedColumnIndex();
            var startIndex = this.getTableWidget()._dndDraggedColumnWidget.getOrderedColumnIndex();

            // Make a visual difference to "show" that it's not permitted to drop frozen columns in other containers
            if (evt.currentTarget && evt.currentTarget.hasClass("gbc_TableLeftColumnsHeaders")) {
              //noDrop on gbc_TableColumnsHeaders or gbc_TableRightColumnsHeaders
              if (!this.getTableWidget()._noDrop.left) {
                this.getTableWidget().getRightColumnsContainer().addClass("noDrop");
                this.getTableWidget().getRightColumnsHeaders().addClass("noDrop");
                this.getTableWidget().getColumnsContainer().addClass("noDrop");
                this.getTableWidget().getColumnsHeaders().addClass("noDrop");
                this.getTableWidget()._noDrop = {
                  "left": false,
                  "right": true,
                  "center": true
                };
              }
            } else if (evt.currentTarget && evt.currentTarget.hasClass("gbc_TableRightColumnsHeaders")) {
              //noDrop on gbc_TableColumnsHeaders or gbc_TableLeftColumnsHeaders
              if (!this.getTableWidget()._noDrop.right) {
                this.getTableWidget().getLeftColumnsContainer().addClass("noDrop");
                this.getTableWidget().getLeftColumnsHeaders().addClass("noDrop");
                this.getTableWidget().getColumnsContainer().addClass("noDrop");
                this.getTableWidget().getColumnsHeaders().addClass("noDrop");
                this.getTableWidget()._noDrop = {
                  "left": true,
                  "right": false,
                  "center": true
                };
              }
            } else if (evt.currentTarget && evt.currentTarget.hasClass("gbc_TableColumnsHeaders")) {
              if (!this.getTableWidget()._noDrop.center) {
                this.getTableWidget().getLeftColumnsContainer().addClass("noDrop");
                this.getTableWidget().getLeftColumnsHeaders().addClass("noDrop");
                this.getTableWidget().getRightColumnsContainer().addClass("noDrop");
                this.getTableWidget().getRightColumnsHeaders().addClass("noDrop");
                this.getTableWidget()._noDrop = {
                  "left": true,
                  "right": true,
                  "center": false
                };
              }
            }
            this.getParentWidget().getElement().addClass(overIndex >= startIndex ? "reordering_right" : "reordering_left");
          }
        },

        /**
         * Handle reordering dragLeave event
         */
        onReorderingDragLeave: function() {
          if (this.getTableWidget()._dndMode === "columnReordering") {
            this.getParentWidget().getElement().removeClass("reordering_left").removeClass("reordering_right");
            this.getTableWidget()._dndReorderingDragOverWidget = null;
          }
        },

        /**
         * Sets column title text
         * @param {string} text - the title text
         * @publicdoc
         */
        setText: function(text) {
          this._setTextContent(text, function() {
            return this._element.getElementsByClassName("headerText")[0];
          }.bind(this));
          var tableWidget = this.getTableWidget();
          if (tableWidget) {
            tableWidget.synchronizeHeadersHeight();
          }
        },

        /**
         * Returns column title text
         * @returns {string} the title text
         * @publicdoc
         */
        getText: function() {
          return this._element.getElementsByClassName("headerText")[0].textContent;
        },

        /**
         * Sets title width
         * @param {number} width - title width (pixels)
         * @publicdoc
         */
        setWidth: function(width) {
          this.setStyle({
            "width": width + "px"
          });
        },

        /**
         * Returns title width style
         * @returns {string} title width (ex:"42px")
         */
        getWidthStyle: function() {
          return this.getStyle("width");
        },

        /**
         * Sets the sort decorator caret.
         * @param {string} sortType - "asc", "desc" or ""
         */
        setSortDecorator: function(sortType) {

          var glyphClass = "hidden";
          if (sortType === "asc") {
            glyphClass = "caret-up";
          }
          if (sortType === "desc") {
            glyphClass = "caret-down";
          }

          if (!this._sortIconElement && glyphClass !== "hidden") {
            this._sortIconElement = document.createElement("span");
            this._sortIconElement.addClass("sortIcon");
            this._element.prependChild(this._sortIconElement);
          }

          if (this._sortIconElement) {
            this._sortIconElement.removeClass(this._sortGlyph);
            this._sortIconElement.addClass(glyphClass);
          }

          this._sortGlyph = glyphClass;
        },

        /**
         * Sets index order of title
         * @param {number} index - order index
         */
        setOrder: function(index) {
          this.setStyle({
            "order": index
          });
        },

        /**
         * @inheritDoc
         */
        hasFocus: function() {
          // TODO explain why ?
          return true;
        },

        /**
         * Set text alignment
         * @param {string} alignment - (left, center, right, auto)
         */
        setTextAlign: function(alignment) {
          if (alignment === "auto") {
            this._autoAlignment = true;
          } else {
            this.setStyle(" .headerText", {
              "text-align": alignment
            });
          }
        },

        /**
         * @return {boolean} true if text should be auto aligned
         */
        isAutoTextAlignement: function() {
          return this._autoAlignment;
        },

        /**
         * @inheritDoc
         */
        isReversed: function() {
          return this._parentWidget._parentWidget.isReversed();
        },

        /**
         * @inheritDoc
         */
        shouldShowApplicationContextMenu: function() {
          return false;
        }
      };
    });
    cls.WidgetFactory.registerBuilder('TableColumnTitle', cls.TableColumnTitleWidget);
  });
;
"use strict";

modulum('TableColumnWidget', ['WidgetGroupBase'],
  function(context, cls) {

    /**
     * Table column widget.
     * @class TableColumnWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     * @publicdoc
     */
    cls.TableColumnWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.TableColumnWidget.prototype */ {
        __name: "TableColumnWidget",
        __dataContentPlaceholderSelector: ".gbc_dataContentPlaceholder",

        /**
         * the title widget
         * @type {classes.TableColumnTitleWidget}
         */
        _title: null,
        /**
         * the aggregate widget
         * @type {classes.TableColumnAggregateWidget}
         */
        _aggregate: null,
        /**
         * is parent widget a tree view
         * @type {boolean}
         */
        _isTreeView: false,
        /**
         * is column always visible
         * @type {boolean}
         */
        _isUnhidable: false,
        /**
         * is column draggable/movable
         * @type {boolean}
         */
        _isMovable: true,
        /**
         * is column resizable
         * @type {boolean}
         */
        _isSizable: true,
        /**
         * is column always hidden
         * @type {boolean}
         */
        _alwaysHidden: false,
        /**
         * column order
         * @type {number}
         */
        _order: -1,
        /**
         * is current focused column
         * @type {boolean}
         */
        _current: false,
        /**
         * is drag & drop enabled
         * @type {boolean}
         */
        _dndItemEnabled: false,
        /**
         * is column detached from dom
         * @type {boolean}
         */
        _itemsDetachedFromDom: false,
        /**
         * column width (store settings or measured)
         * @type {number}
         */
        _width: null,
        /**
         * column width from store settings
         * @type {number}
         */
        _defaultWidth: null,
        /**
         * column measured width
         * @type {number}
         */
        _initialWidth: null,
        /**
         * is column left frozen
         * @type {boolean}
         */
        _isLeftFrozen: false,
        /**
         * is column right frozen
         * @type {boolean}
         */
        _isRightFrozen: false,
        /**
         * is column first child item measured (flag used for layout engine)
         * @type {boolean}
         */
        _firstWidgetMeasured: false,

        /**
         * @constructs
         * @param {*} opts - Options passed to the constructor
         */
        constructor: function(opts) {
          opts = opts || {};
          opts.inTable = true;
          this._isTreeView = opts.isTreeView;
          $super.constructor.call(this, opts);
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          this._layoutInformation = new cls.LayoutInformation(this);
          this._layoutEngine = new cls.TableColumnLayoutEngine(this);
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          this._title = cls.WidgetFactory.createWidget("TableColumnTitle", this.getBuildParameters());
          this._title.setParentWidget(this);
        },

        /**
         * @inheritDoc
         */
        resetLayout: function() {
          this._firstWidgetMeasured = false;
          this._width = null;
          this.attachItemsToDom();
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._title.destroy();
          this._title = null;
          if (this._aggregate) {
            this._aggregate.destroy();
            this._aggregate = null;
          }
          this.destroyChildren();
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {

          if (domEvent.target.hasClass("gbc_TableAfterLastItemZone")) { // click on afterLastItemZone
            this.emit(context.constants.widgetEvents.tableColumnAfterLastItemClick);
            return false;
          }
          if (!this.getParentWidget().isRowActionTriggerByDoubleClick()) {
            this.emit(context.constants.widgetEvents.rowAction);
            return false;
          }
          return true;
        },

        /**
         * @inheritDoc
         */
        addChildWidget: function(widget, options) {
          options = options || {};

          var opts = this.getBuildParameters();
          opts.isTreeItem = this._isTreeView;
          var tableColumnItem = cls.WidgetFactory.createWidget("TableColumnItem", opts);
          tableColumnItem.setDndEnabled(this._dndItemEnabled);
          tableColumnItem.addChildWidget(widget);

          $super.addChildWidget.call(this, tableColumnItem, options);

          if (this.getParentWidget()) {
            // if first widget has not been measured need to relayout to measure it
            if (!this._firstWidgetMeasured) {
              this.resetMeasure();
              if (this.getParentWidget().resetMeasure) {
                this.getParentWidget().resetMeasure();
              }

            }
            // Set the current row
            tableColumnItem.setCurrent(tableColumnItem.getItemIndex() === this.getParentWidget().getCurrentRow());
          }
        },

        /**
         * Invalidate measure to force width & row height measure in next layout cycle
         */
        resetMeasure: function() {
          this.getLayoutEngine().forceMeasurement();
          this.getLayoutEngine().invalidateMeasure();
        },

        /**
         * @inheritDoc
         */
        removeChildWidget: function(widget) {
          var item = widget.getParentWidget() !== this ? widget.getParentWidget() : widget;
          $super.removeChildWidget.call(this, item);
        },

        /**
         *  Remove all items (container element) from DOM
         */
        detachItemsFromDom: function() {
          if (this._itemsDetachedFromDom === false) {
            this._itemsDetachedFromDom = true;
            this.getContainerElement().remove();
          }
        },

        /**
         * Attach all items (container element) to DOM
         */
        attachItemsToDom: function() {
          if (this._itemsDetachedFromDom === true) {
            this._itemsDetachedFromDom = false;
            this.getContainerElement().insertAt(0, this.getElement());
          }
        },

        /**
         * Returns true if column is a tree
         * @returns {boolean} true if is a tree
         * @publicdoc
         */
        isTreeView: function() {
          return this._isTreeView;
        },

        /**
         * Indicates if table has frozen columns
         * @returns {boolean} returns true if table has frozen columns
         * @publicdoc
         */
        isFrozen: function() {
          return this._isLeftFrozen === true || this._isRightFrozen === true;
        },

        /**
         * Indicates if table column is left frozen
         * @returns {boolean} returns true if column is left frozen
         * @publicdoc
         */
        isLeftFrozen: function() {
          return this._isLeftFrozen === true;
        },

        /**
         * Indicates if table column is right frozen
         * @returns {boolean} returns true if column is right frozen
         * @publicdoc
         */
        isRightFrozen: function() {
          return this._isRightFrozen === true;
        },

        /**
         * @returns {number} returns 0 if unfrozen, 1 if left frozen and 2 if right frozen
         */
        getFrozenIndex: function() {
          return this.isFrozen() ? (this.isLeftFrozen() ? 1 : 2) : 0;
        },

        /**
         * Sets if the column must be always hidden
         * @param {boolean} b - is always hidden ?
         * @publicdoc
         */
        setAlwaysHidden: function(b) {
          this._alwaysHidden = b;
        },

        /**
         * Returns true if column must be always hidden
         * @returns {boolean} true if column is always hidden
         * @publicdoc
         */
        isAlwaysHidden: function() {
          return this._alwaysHidden;
        },

        /**
         * Returns true if column must be always visible
         * @returns {boolean} true if column is always visible
         * @publicdoc
         */
        isAlwaysVisible: function() {
          return false;
        },

        /**
         * Sets if the column can be moved by the user
         * @param {boolean} b - is movable ?
         * @publicdoc
         */
        setMovable: function(b) {
          this._isMovable = b;
        },

        /**
         * Returns true if column is movable
         * @returns {boolean} true if column is movable
         * @publicdoc
         */
        isMovable: function() {
          return this._isMovable;
        },

        /**
         * Sets if the column can be sized by the user
         * @param {boolean} b - is sizable ?
         * @publicdoc
         */
        setSizable: function(b) {
          if (this._isSizable !== b) {
            this._isSizable = b;
            if (b) {
              this.getTitleWidget().getResizer().removeClass("unresizable");
            } else {
              this.getTitleWidget().getResizer().addClass("unresizable");
            }
          }
        },

        /**
         * Returns true if column is sizable
         * @returns {boolean} true il column is sizable
         * @publicdoc
         */
        isSizable: function() {
          return this._isSizable;
        },

        /**
         * Sets if the column can be hidden by the user
         * @param {boolean} b - is not hiddable ?
         */
        setUnhidable: function(b) {
          this._isUnhidable = b;
        },

        /**
         * Returns true if column is unhidable
         * @returns {boolean} true if column is unhidable
         */
        isUnhidable: function() {
          return this._isUnhidable;
        },

        /**
         * Update aggregate width
         */
        updateAggregateWidth: function() {
          // search column which contain an aggregate
          var tableWidget = this.getParentWidget();
          if (!!tableWidget && tableWidget.hasFooter()) {
            var columns = tableWidget.getOrderedColumns();
            for (var i = this.getOrderedColumnIndex(); i < columns.length; i++) {
              var col = columns[i];
              if (!!col.getAggregateWidget() && !col.isHidden()) {
                this.afterDomMutator(function(col) {
                  col.setAggregate(col.getAggregateWidget().getText());
                }.bind(this, col));
                break;
              }
            }
          } else if (!!this.getAggregateWidget()) {
            this.afterDomMutator(function() {
              this.setAggregate(this.getAggregateWidget().getText());
            }.bind(this));
          }
        },

        /**
         * Set/add an aggregate cell
         * @param text - aggregate text & value
         * @param width -
         */
        setAggregate: function(text, width) {
          var tableWidget = this.getParentWidget();
          if (text !== "") {
            if (!this._aggregate) {
              this._aggregate = cls.WidgetFactory.createWidget("TableColumnAggregate", this.getBuildParameters());
              this._aggregate.setParentWidget(this);
              var footer = null;
              if (this._isLeftFrozen) {
                footer = tableWidget.getLeftColumnsFooter();
              } else if (this._isRightFrozen) {
                footer = tableWidget.getRightColumnsFooter();
              } else {
                footer = tableWidget.getColumnsFooter();
              }
              if (!!footer) {
                footer.appendChild(this._aggregate.getElement());
                tableWidget.setHasFooter(true);
              }
            }

            this._aggregate.setText(text);
            this._aggregate.setHidden(this.isHidden());

            var aggregateWidth = this.getWidth();

            if (!width) {
              var columns = tableWidget.getOrderedColumns();
              for (var i = this.getOrderedColumnIndex() - 1; i >= 0; i--) {
                var col = columns[i];
                if (col._aggregate === null && col.getFrozenIndex() === this.getFrozenIndex()) {
                  if (!col.isHidden()) {
                    aggregateWidth += col.getWidth();
                  }
                } else {
                  if (!col.isHidden()) {
                    break;
                  }
                }
              }
            } else {
              aggregateWidth = width;
            }
            this._aggregate.computeWidth(aggregateWidth);

          } else {
            if (this._aggregate) {
              this._aggregate.setText(text);
            }
          }
        },

        /**
         * Returns index of the column in the parent table (vm aui index)
         * @returns {number} index of the column in the table
         * @publicdoc
         */
        getColumnIndex: function() {
          var parent = this.getParentWidget();
          if (!!parent) {
            return parent.getColumns().indexOf(this);
          }
          return -1;
        },

        /**
         * Returns index of the column in the parent table (visual index)
         * @returns {number} index of the column in the table
         * @publicdoc
         */
        getOrderedColumnIndex: function() {
          var parent = this.getParentWidget();
          if (!!parent) {
            return parent.getOrderedColumns().indexOf(this);
          }
          return -1;
        },

        /**
         * Returns column item at the specied index (row)
         * @param {number} index - index of the item (row)
         * @returns {classes.TableColumnItemWidget} item widget
         * @publicdoc
         */
        getColumnItem: function(index) {
          return this._children[index];
        },

        /**
         * Returns title widget of the column
         * @returns {classes.TableColumnTitleWidget} the title widget
         * @publicdoc
         */
        getTitleWidget: function() {
          return this._title;
        },

        /**
         * Returns aggregate widget of the column
         * @returns {classes.TableColumnAggregateWidget} the aggregate widget
         */
        getAggregateWidget: function() {
          return this._aggregate;
        },

        /**
         * Sets column text (title)
         * @param {string} text - the text to display
         * @publicdoc
         */
        setText: function(text) {
          this.getTitleWidget().setText(text);
        },

        /**
         * Returns column text (title)
         * @returns {string} the column text
         * @publicdoc
         */
        getText: function() {
          return this.getTitleWidget().getText();
        },

        /**
         * Set text alignment
         * @param {string} align - (left, center, right)
         */
        setTextAlign: function(align) {

          if (this._textAlign !== align) {
            this._textAlign = align;

            var titleWidget = this.getTitleWidget();

            if (titleWidget.isAutoTextAlignement()) {
              titleWidget.setTextAlign(align);
            }

            if (!!this._aggregate) {
              this._aggregate.setTextAlign(align);
            }
          }
        },

        /**
         * Sets the width of column
         * @param {number} width - column width (pixels)
         * @publicdoc
         */
        setWidth: function(width) {
          width = Math.round(width);
          if (this._width !== width) {
            this._width = width;
            this.setStyle({
              "width": width + "px !important"
            });
            this.getTitleWidget().setWidth(width);
            this.updateAggregateWidth();
          }
        },

        /**
         * Set width ( from a user interaction)
         * @param {number} width - column width (pixels)
         */
        setWidthFromUserInteraction: function(width) {
          this.setWidth(width);
          this.emit(gbc.constants.widgetEvents.tableResizeCol, width);
          this.getParentWidget().autoSetLastColumnWidthToFillEmptySpace();
          this.getParentWidget()._updateVisibleColumnsInDom();
        },

        /**
         * Returns column width (pixels)
         * @returns {?number} column width
         * @publicdoc
         */
        getWidth: function() {
          return this._width;
        },

        /**
         * Set measured column width as initial
         * @param {?number} width - column width (pixels)
         * @publicdoc
         */
        setInitialWidth: function(width) {
          this._initialWidth = width;
        },

        /**
         * Returns measured column width
         * @returns {?number} initial column width
         * @publicdoc
         */
        getInitialWidth: function() {
          return this._initialWidth;
        },

        /**
         * Set the default column width from store settings
         * @param {?number} width - column width (pixels)
         * @publicdoc
         */
        setDefaultWidth: function(width) {
          this._defaultWidth = width;
        },

        /**
         * Return the column default width defined in store settings
         * @returns {?number} default column width
         * @publicdoc
         */
        getDefaultWidth: function() {
          return this._defaultWidth;
        },

        /**
         * Reset width column (set with to initial width)
         * @publicdoc
         */
        resetWidth: function() {
          this.setWidth(this._initialWidth);
        },

        /**
         * Returns column width style
         * @returns {string} column width (ex:"42px")
         */
        getWidthStyle: function() {
          return this.getStyle("width");
        },

        /**
         * Sets index order of column
         * @param {number} index - order index
         */
        setOrder: function(index) {
          this.setStyle({
            "order": index
          });
          this._order = index;

          this.getTitleWidget().setOrder(index);
          if (!!this._aggregate) {
            this._aggregate.setOrder(index);
          }

          var tableWidget = this.getParentWidget();
          if (tableWidget) {
            tableWidget.resetOrderedColumns();
            tableWidget.updateAllAggregate();
          }
        },

        /**
         * Returns index order of column
         * @returns {number} order index
         * @publicdoc
         */
        getOrder: function() {
          return this._order;
        },

        /**
         * Changes current row
         * @param {number} row - current row
         */
        setCurrentRow: function(row) {
          var children = this.getChildren();
          var length = children.length;
          for (var i = 0; i < length; ++i) {
            var tableColumnItem = children[i];
            tableColumnItem.setCurrent(i === row);

            var tableWidget = this.getParentWidget();
            if (tableWidget) {
              this.getElement().toggleClass("highlight", tableWidget.isHighlightCurrentRow());
              this.getElement().toggleClass("nohighlight", !tableWidget.isHighlightCurrentRow());
            }
          }
        },

        /**
         * Defines if column is the current or not
         * @param {boolean} current - true if the column is the current one, false otherwise
         */
        setCurrent: function(current) {
          if (this._current !== current) {
            this._current = !!current;
            this.getElement().toggleClass("currentColumn", !!current);
          }

          if (this._current) {
            var tableWidget = this.getParentWidget();
            if (tableWidget) {
              this.getElement().toggleClass("highlight", tableWidget.isHighlightCurrentCell());
              this.getElement().toggleClass("nohighlight", !tableWidget.isHighlightCurrentCell());
            }
            this.attachItemsToDom(); // current should be always attached to DOM
          }

        },

        /**
         * Check if column is current one
         * @returns {boolean}  true if the column is the current one, false otherwise
         * @publicdoc
         */
        isCurrent: function() {
          return this._current;
        },

        /**
         * Updates rows visibility depending on the number of visible rows defined in the parent TableWidget
         */
        updateRowsVisibility: function() {
          var visibleRows = this.getParentWidget().getVisibleRows();
          var children = this.getChildren();
          for (var i = 0; i < children.length; ++i) {
            var tableColumnItemWidget = children[i];
            tableColumnItemWidget.setHidden(i >= visibleRows);
          }
        },

        /**
         * Sets if the a row is selected (mrs)
         * @param {number} row - index of the row
         * @param {boolean} selected - true if the row should be selected, false otherwise
         */
        setRowSelected: function(row, selected) {
          var children = this.getChildren();
          if (row < children.length) {
            children[row].setSelected(selected);
          }
        },

        /**
         * Check if a row is selected
         * @param {number} row - index of the row
         * @returns {boolean} true if the row is selected, false otherwise
         */
        isRowSelected: function(row) {
          var children = this.getChildren();
          if (row < children.length) {
            return children[row].isSelected();
          }
          return false;
        },

        /**
         * @inheritDoc
         */
        setHidden: function(state) {
          if (this.isHidden() !== state) { // optimization : do not recalculate when no state change
            $super.setHidden.call(this, state);
            //hide title as well
            this.getTitleWidget().setHidden(state);
            //hide aggregate as well too
            if (!!this._aggregate) {
              this._aggregate.setHidden(state);
            }
            var tableWidget = this.getParentWidget();
            if (tableWidget) {
              tableWidget.updateAllAggregate();
              tableWidget.synchronizeHeadersHeight();
            }
          }
        },

        /**
         * Returns afterLastItemZone element
         * @returns {HTMLElement} afterLastItemZone element
         */
        getAfterLastItemZone: function() {
          return this._element.getElementsByClassName("gbc_TableAfterLastItemZone")[0];
        },

        /**
         * Returns widget at the specified row
         * @param {number} row - row of item
         * @returns {classes.WidgetBase} widget
         * @publicdoc
         */
        getWidgetAt: function(row) {
          return this.getChildren()[row] &&
            this.getChildren()[row].getChildren() &&
            this.getChildren()[row].getChildren()[0];
        },

        /**
         * Auto set width according to max length of column values
         */
        autoSetWidth: function() {
          if (this.isSizable() && !this.isHidden()) {
            var children = this.getChildren();
            var width = null;
            var widget = null;
            var tableColumnItemWidget = null;
            var i = 0;

            // measure title width
            var titleWidget = this.getTitleWidget();
            titleWidget.getElement().addClass("g_TableMeasuring");
            var maxWidth = titleWidget.getElement().getBoundingClientRect().width;
            titleWidget.getElement().removeClass("g_TableMeasuring");

            // measure widgets width
            if (children.length > 0) {
              var firstWidget = children[0].getChildren()[0];
              var measureDataElement = firstWidget.getLayoutEngine().getDataContentMeasureElement();
              var hasInputElement = firstWidget.getElement().getElementsByTagName("input").length > 0;
              // if widgets are inputs, use the first charMeasurer to measure to search the larger
              if (hasInputElement && !!measureDataElement) {
                this.getElement().addClass("g_measuring");
                firstWidget.getElement().addClass("g_TableMeasuring");
                var initialContent = measureDataElement.textContent;

                for (i = 0; i < children.length; ++i) {
                  tableColumnItemWidget = children[i];
                  widget = tableColumnItemWidget.getChildren()[0];
                  measureDataElement.textContent = widget.getValue();
                  width = firstWidget.getElement().getBoundingClientRect().width;
                  if (width > maxWidth) {
                    maxWidth = width;
                  }
                }
                measureDataElement.textContent = initialContent;
                firstWidget.getElement().removeClass("g_TableMeasuring");
                this.getElement().removeClass("g_measuring");
              }
              // if widgets are not inputs, measure each widget and keep the larger size
              else {
                for (i = 0; i < children.length; ++i) {
                  tableColumnItemWidget = children[i];
                  widget = tableColumnItemWidget.getChildren()[0];

                  widget.getElement().addClass("g_TableMeasuring");
                  width = widget.getElement().getBoundingClientRect().width;
                  widget.getElement().removeClass("g_TableMeasuring");

                  if (width > maxWidth) {
                    maxWidth = width;
                  }
                }
              }
            }
            this.setWidthFromUserInteraction(maxWidth);
          }
        },

        /**
         * Enable Dnd of items
         * @param {boolean} b
         */
        setDndItemEnabled: function(b) {
          if (this._dndItemEnabled !== b) {

            this._dndItemEnabled = b;
            var items = this.getChildren();
            for (var j = 0; j < items.length; j++) {
              var item = items[j];
              item.setDndEnabled(b);
            }
          }
        },

        /**
         * Handle drop event
         */
        onDropAfterLastItem: function() {
          this.emit(gbc.constants.widgetEvents.tableDrop, this.getParentWidget().getVisibleRows());
        },

        /**
         * Handle dragOver event
         * @param {Object} evt - dragover event
         */
        onDragOverAfterLastItem: function(evt) {
          this.emit(gbc.constants.widgetEvents.tableDragOver, this.getParentWidget().getVisibleRows(), evt);
        }
      };
    });
    cls.WidgetFactory.registerBuilder('TableColumn', cls.TableColumnWidget);
  });
;
"use strict";

modulum('TableWidget', ['TableWidgetBase'],
  function(context, cls) {

    /**
     * Table widget.
     *
     * @class TableWidget
     * @memberOf classes
     * @extends classes.TableWidgetBase
     * @publicdoc Widgets
     */
    cls.TableWidget = context.oo.Class(cls.TableWidgetBase, function($super) {
      return /** @lends classes.TableWidget.prototype */ {
        __name: "TableWidget",

        _stylingContext: "widget",

        $static: /** @lends classes.TableWidget */ {
          defaultRowHeight: 14
        },

        _lastClickDate: null, // date of the last click event
        _lastClickTarget: null, // target of the click event
        _currentColumn: 0,
        _orderedColumns: null,
        _addOnlyVisibleColumnsToDom: true, // to enable/disable this optimization
        _layoutDone: false,
        _hasFooter: false,
        _firstDisplay: true,
        _needToUpdateVerticalScroll: false,
        _focusOnField: false,
        _requestSynchronizeHeadersHeight: false,

        /** @type classes.TableColumnRowBoundWidget */
        _rowBoundColumnWidget: null,

        /** Item client selection */
        _defaultItemSelection: false,
        _firstItemSelected: null,
        _itemSelectionInProgress: false,
        _itemSelectionHasChanged: false,
        _itemSelectionElement: null,

        /** DOM Elements */
        _leftContainerElement: null,
        _rightContainerElement: null,
        _columnsContainerElement: null,
        _leftColumnsContainer: null,
        _rightColumnsContainer: null,
        _columnsHeaders: null,
        _leftColumnsHeaders: null,
        _rightColumnsHeaders: null,
        _columnsFooter: null,
        _rightScrollAreaElement: null,
        _leftScrollAreaElement: null,
        _replacerElement: null,
        _aggregateGlobalTextElement: null,

        /** @type boolean */
        _scrollAreaNoUserScroll: false,
        /** @type boolean */
        _rightScrollAreaNoUserScroll: false,
        /** @type boolean */
        _scrollAreaResetScrollTopFromPrevious: false,
        /**
         * unique unbind id part generator
         * @type {number}
         */
        _uniqueScrollUnbindId: 0,
        /**
         * Map with all active scrolls
         * @type {Map<string, Element>}
         */
        _activeUniqueIdScrolls: null,

        /** frozen table attributes */
        _frozenTable: false,
        _leftFrozenColumns: 0,
        _rightFrozenColumns: 0,

        /** scroll attributes */
        /** @type number */
        _previousScrollLeftValue: 0,
        /** @type number */
        _previousScrollTopValue: 0,
        lastSentOffset: null,

        /** Dnd attributes */
        _dndItemEnabled: false,
        _dndMode: null,
        _dndMouseDragX: null, // mouse X position when dragging (ugly hack for FF because drag event does not contain mouse coordinates)
        _dndReorderingDragOverWidget: null,
        _dndDraggedColumnWidget: null,
        _noDrop: null,

        /** styles */
        _highlightCurrentCell: null,
        _showGrid: null,
        _headerAlignment: null,
        _headerHidden: null,
        _resizeFillsEmptySpace: false,
        _columnResizeFillsEmptySpace: null,

        /**
         * @constructs
         * @param {*} opts - Options passed to the constructor
         */
        constructor: function(opts) {
          this._noDrop = {
            "left": false,
            "right": false,
            "center": false
          };

          $super.constructor.call(this, opts);
        },

        /**
         * Prevent default on dragover, to remove forbidden icon on drag
         * @param {Object} event - DOM event
         * @private
         */
        _preventDefault: function(event) {
          this._dndMouseDragX = event.clientX || event.screenX; // Fix for FF
          if (!!this._dndMode) {
            event.preventCancelableDefault();
          }
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);

          this.setRowHeight(cls.TableWidget.defaultRowHeight);
          this._activeUniqueIdScrolls = new Map();

          //drag events
          this.getColumnsHeaders().on("dragover.TableWidget", this._preventDefault.bind(this));
          this.getLeftColumnsHeaders().on("dragover.TableWidget", this._preventDefault.bind(this));
          this.getRightColumnsHeaders().on("dragover.TableWidget", this._preventDefault.bind(this));

          //left container events
          this.getLeftColumnsHeaders()
            .on("drop.TableWidget", this._onHeaderDrop.bind(this))
            .on("dragstart.TableWidget", this._onHeaderDragStart.bind(this))
            .on("dragend.TableWidget", this._onHeaderDragEnd.bind(this))
            .on("drag.TableWidget", this._onHeaderDrag.throttle(5).bind(this))
            .on("dragover.TableWidget", this._onHeaderDragOver.bind(this))
            .on("dragleave.TableWidget", this._onHeaderDragLeave.bind(this))
            .onLongTouch('longTouch.TableWidget', this._onLongTouch.bind(this))
            .onDoubleTap("TableWidget", this._onHeaderDoubleClick.bind(this));

          this.getLeftColumnsContainer()
            .onDoubleTap("TableWidget", this._onDoubleClick.bind(this));

          //right container events
          this.getRightColumnsHeaders()
            .on("drop.TableWidget", this._onHeaderDrop.bind(this))
            .on("dragstart.TableWidget", this._onHeaderDragStart.bind(this))
            .on("dragend.TableWidget", this._onHeaderDragEnd.bind(this))
            .on("drag.TableWidget", this._onHeaderDrag.throttle(5).bind(this))
            .on("dragover.TableWidget", this._onHeaderDragOver.bind(this))
            .on("dragleave.TableWidget", this._onHeaderDragLeave.bind(this))
            .onLongTouch('longTouch.TableWidget', this._onLongTouch.bind(this))
            .onDoubleTap("TableWidget", this._onHeaderDoubleClick.bind(this));

          this.getRightColumnsContainer()
            .onDoubleTap("TableWidget", this._onDoubleClick.bind(this));

          //main container events
          this.getColumnsHeaders()
            .on("drop.TableWidget", this._onHeaderDrop.bind(this))
            .on("dragstart.TableWidget", this._onHeaderDragStart.bind(this))
            .on("dragend.TableWidget", this._onHeaderDragEnd.bind(this))
            .on("drag.TableWidget", this._onHeaderDrag.throttle(5).bind(this))
            .on("dragover.TableWidget", this._onHeaderDragOver.bind(this))
            .on("dragleave.TableWidget", this._onHeaderDragLeave.bind(this))
            .onLongTouch('longTouch.TableWidget', this._onLongTouch.bind(this))
            .onDoubleTap("TableWidget", this._onHeaderDoubleClick.bind(this));

          this.getColumnsContainer()
            .onDoubleTap("TableWidget", this._onDoubleClick.bind(this));

          // Scroll events
          this.getScrollableArea().on('scroll.TableWidget', this._onScroll.bind(this));
          this.getLeftScrollableArea().on('scroll.TableWidget', this._onScrollOnLeftColumns.bind(this));
          this.getRightScrollableArea().on('scroll.TableWidget', this._onScrollOnRightColumns.bind(this));

          // client select items events
          this.getElement()
            .on("mousedown.TableWidget", this._onItemMouseDown.bind(this))
            .on("mouseup.TableWidget", this._onItemMouseUp.bind(this))
            .on("mouseleave.TableWidget", this._onItemMouseLeave.bind(this));

          this.setStyle(".gbc_TableColumnsHeaders", {
            "margin-right": window.scrollBarSize + "px"
          });
          this.setStyle(".gbc_TableColumnsFooter, .gbc_TableLeftColumnsFooter, .gbc_TableRightColumnsFooter", {
            "margin-bottom": window.scrollBarSize + "px"
          });
          this._updateFooterWidth();

        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          this._layoutInformation = new cls.LayoutInformation(this);
          this._layoutInformation.shouldFillStack = true;
          this._layoutEngine = new cls.TableLayoutEngine(this);

          this._layoutEngine.onLayoutApplied(this._layoutApplied.bind(this));
          this._layoutInformation.getStretched().setDefaultX(true);
          this._layoutInformation.getStretched().setDefaultY(true);

          var minPageSize = parseInt(context.ThemeService.getValue("gbc-TableWidget-min-page-size"), 10);
          this._layoutEngine.setMinPageSize(isNaN(minPageSize) ? 1 : minPageSize);
          var minWidth = parseInt(context.ThemeService.getValue("gbc-TableWidget-min-width"), 10);
          this._layoutEngine.setMinWidth(isNaN(minWidth) ? 60 : minWidth);
        },

        /**
         * Invalidate measure to force width & row height measure in next layout cycle
         */
        resetMeasure: function() {
          this.getLayoutEngine().forceMeasurement();
          this.getLayoutEngine().invalidateMeasure();
          if (this.getLayoutEngine().invalidatePreferredSize) {
            this.getLayoutEngine().invalidatePreferredSize();
          }
        },

        /**
         * @inheritDoc
         */
        destroy: function() {

          //drag events
          this.getColumnsHeaders().off("dragover.TableWidget");
          this.getLeftColumnsHeaders().off("dragover.TableWidget");
          this.getRightColumnsHeaders().off("dragover.TableWidget");

          //left container events
          this.getLeftColumnsHeaders().off("drop.TableWidget");
          this.getLeftColumnsHeaders().off("dragstart.TableWidget");
          this.getLeftColumnsHeaders().off("dragend.TableWidget");
          this.getLeftColumnsHeaders().off("drag.TableWidget");
          this.getLeftColumnsHeaders().off("dragover.TableWidget");
          this.getLeftColumnsHeaders().off("dragleave.TableWidget");
          this.getLeftColumnsHeaders().offLongTouch('longTouch.TableWidget');
          this.getLeftColumnsHeaders().offDoubleTap("TableWidget");

          this.getLeftColumnsContainer().offDoubleTap("TableWidget");

          //right container events
          this.getRightColumnsHeaders().off("drop.TableWidget");
          this.getRightColumnsHeaders().off("dragstart.TableWidget");
          this.getRightColumnsHeaders().off("dragend.TableWidget");
          this.getRightColumnsHeaders().off("drag.TableWidget");
          this.getRightColumnsHeaders().off("dragover.TableWidget");
          this.getRightColumnsHeaders().off("dragleave.TableWidget");
          this.getRightColumnsHeaders().offLongTouch('longTouch.TableWidget');
          this.getRightColumnsHeaders().offDoubleTap("TableWidget");

          this.getRightColumnsContainer().offDoubleTap("TableWidget");

          //main container events
          this.getColumnsHeaders().off("drop.TableWidget");
          this.getColumnsHeaders().off("dragstart.TableWidget");
          this.getColumnsHeaders().off("dragend.TableWidget");
          this.getColumnsHeaders().off("drag.TableWidget");
          this.getColumnsHeaders().off("dragover.TableWidget");
          this.getColumnsHeaders().off("dragleave.TableWidget");
          this.getColumnsHeaders().offLongTouch('longTouch.TableWidget');
          this.getColumnsHeaders().offDoubleTap("TableWidget");

          this.getColumnsContainer().offDoubleTap("TableWidget");

          // Scroll events
          this.getScrollableArea().off('scroll.TableWidget');
          this.getLeftScrollableArea().off('scroll.TableWidget');
          this.getRightScrollableArea().off('scroll.TableWidget');

          if (this._activeUniqueIdScrolls) {
            this._activeUniqueIdScrolls.forEach(function(domElement, id) {
              domElement.off(id);
            }, this);
            this._activeUniqueIdScrolls.clear();
            this._activeUniqueIdScrolls = null;
          }

          if (this._rowBoundColumnWidget) {
            this._rowBoundColumnWidget.destroy();
            this._rowBoundColumnWidget = null;
          }

          // client select items events
          this.getElement().off("mousedown.TableWidget");
          this.getElement().off("mouseup.TableWidget");
          this.getElement().off("mousemove.TableWidget");
          this.getElement().off("mouseleave.TableWidget");

          if (this._dndItemEnabled) {
            var columnsContainer = this.getColumnsContainer();
            columnsContainer.off("dragstart.TableWidget");
            columnsContainer.off("dragend.TableWidget");
            columnsContainer.off("dragover.TableWidget");
            columnsContainer.off("drop.TableWidget");
            columnsContainer.off("dragleave.TableWidget");
            columnsContainer.off("dragenter.TableWidget");
          }

          this._columnsHeaders = null;
          this._leftContainerElement = null;
          this._rightContainerElement = null;
          this._columnsContainerElement = null;
          this._leftColumnsContainer = null;
          this._rightColumnsContainer = null;
          this._leftColumnsHeaders = null;
          this._rightColumnsHeaders = null;
          this._columnsFooter = null;
          this._leftColumnsFooter = null;
          this._rightColumnsFooter = null;
          this._rightScrollAreaElement = null;
          this._leftScrollAreaElement = null;
          this._aggregateGlobalTextElement = null;
          this._orderedColumns = null;
          this._lastClickDate = null;
          this._lastClickTarget = null;

          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageKeyDown: function(keyString, domKeyEvent, repeat) {
          var keyProcessed = false;

          if (this.isDisplayMode()) {
            if (!!domKeyEvent) {
              var key = cls.KeyboardApplicationService.keymap[domKeyEvent.which];
              keyProcessed = true;
              switch (key) {
                case "down":
                  this.emit(context.constants.widgetEvents.keyArrowDown, domKeyEvent);
                  break;
                case "up":
                  this.emit(context.constants.widgetEvents.keyArrowUp, domKeyEvent);
                  break;
                case "left":
                  this.emit(context.constants.widgetEvents.keyArrowLeft, domKeyEvent);
                  break;
                case "right":
                  this.emit(context.constants.widgetEvents.keyArrowRight, domKeyEvent);
                  break;
                case "pageup":
                  this.emit(context.constants.widgetEvents.keyPageUp, domKeyEvent);
                  break;
                case "pagedown":
                  this.emit(context.constants.widgetEvents.keyPageDown, domKeyEvent);
                  break;
                case "home":
                  this.emit(context.constants.widgetEvents.keyHome, domKeyEvent);
                  break;
                case "end":
                  this.emit(context.constants.widgetEvents.keyEnd, domKeyEvent);
                  break;
                case "space":
                  this.emit(context.constants.widgetEvents.keySpace, domKeyEvent);
                  break;
                default:
                  keyProcessed = false;
              }
            }

            if (keyString === "ctrl+a" || keyString === "meta+a") {
              this.emit(context.constants.widgetEvents.selectAll);
              keyProcessed = true;
            }
          }

          if (keyProcessed) {
            return true;
          } else {
            return $super.manageKeyDown.call(this, keyString, domKeyEvent, repeat);
          }
        },

        /**
         * @inheritDoc
         */
        managePriorityKeyDown: function(keyString, domKeyEvent, repeat) {
          var keyProcessed = false;

          // manage CTRL+C case
          if (keyString === "ctrl+c" || keyString === "meta+c") {
            if (this.hasItemsSelected()) { // copy selection
              this._copySelectionInClipboard();
              keyProcessed = true;
            } else if (this.isDisplayMode()) { // copy current row
              this.emit(context.constants.widgetEvents.copy);
              keyProcessed = true;
            }
          }

          if (keyProcessed) {
            return true;
          } else {
            return $super.managePriorityKeyDown.call(this, keyString, domKeyEvent, repeat);
          }
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          if (!domEvent.target.parent("gbc_TableColumnWidget")) { // request focus only if click is outside a column
            this.emit(context.constants.widgetEvents.requestFocus);
          }
          return true;
        },

        /**
         * @inheritDoc
         */
        manageMouseDblClick: function(domEvent) {
          var target = domEvent.target;

          // click on headers
          var isHeaderDblClick = target.isElementOrChildOf(this.getColumnsHeaders()) ||
            target.isElementOrChildOf(this.getLeftColumnsHeaders()) || target.isElementOrChildOf(this.getRightColumnsHeaders());

          if (isHeaderDblClick) {
            this._onHeaderDoubleClick(domEvent);
            return false;
          }

          // click on columns
          var isColumnsContainerClick = target.isElementOrChildOf(this.getColumnsContainer()) ||
            target.isElementOrChildOf(this.getLeftColumnsContainer()) || target.isElementOrChildOf(this.getRightColumnsContainer());

          if (isColumnsContainerClick) {
            this._onDoubleClick(domEvent);
            return false;
          }

          return true;
        },

        /**
         * @inheritDoc
         */
        setEnabled: function(enabled) {
          if (this._enabled !== enabled) {
            $super.setEnabled.call(this, enabled);

            this._resetItemsSelection();
            this.updateVerticalScroll(enabled);
          }
        },

        /**
         * @inheritDoc
         */
        setAriaSelection: function() {
          // Do nothing to override this: table role cannot have aria-selected
        },

        /**
         * @inheritDoc
         */
        setBackgroundColor: function(color) {
          $super.setBackgroundColor.call(this, color);
          this.setStyle('.gbc_TableColumnsHeaders, .gbc_TableLeftColumnsHeaders, .gbc_TableRightColumnsHeaders', {
            "background-color": !!color && !this._ignoreBackgroundColor ? color : null
          });
        },

        /**
         * @inheritDoc
         */
        setFocus: function(fromMouse) {
          if (this.isElementInDOM()) {
            this.domFocus(fromMouse);
          } else {
            var uiWidget = this.getUserInterfaceWidget();
            if (uiWidget) {
              uiWidget.getElement().domFocus();
            }
          }
          $super.setFocus.call(this, fromMouse);
        },

        /**
         * @inheritDoc
         */
        resetLayout: function() {
          $super.resetLayout.call(this);
          this._layoutDone = false;
        },

        /**
         * Call when layout is finished
         */
        _layoutApplied: function() {
          if (this.isElementInDOM()) {
            this._layoutDone = true;

            // if table is visible and was already active

            this._updateVisibleColumnsInDom(); // remove not visible column content
            this.updateVerticalScroll(this._needToUpdateVerticalScroll);
            this._needToUpdateVerticalScroll = false;

            if (this._requestSynchronizeHeadersHeight) {
              this._requestSynchronizeHeadersHeight = false;
              this.synchronizeHeadersHeight();
            }

            this.autoSetLastColumnWidthToFillEmptySpace();
          }
        },

        /**
         * @inheritDoc
         */
        requestFocusFromWidget: function(widget, event) {

          // check if click is second click of a double click
          var isDoubleClick = (new Date() - this._lastClickDate) < 350 && (this._lastClickTarget === event.target);
          this._lastClickDate = new Date();
          this._lastClickTarget = event.target;

          // if event !== click request focus
          // if table has not the focus, widget request focus
          var mustSendFocusRequest = !this.hasVMFocus() || (event.type !== "click");
          // if event is a click and there is no change in the item selection, widget request focus
          mustSendFocusRequest = mustSendFocusRequest || (this._itemSelectionHasChanged === false);
          // else no request focus

          // if click is the second click of a double click not request focus
          if (isDoubleClick) {
            this._lastClickDate = null;
            this._lastClickTarget = null;
            mustSendFocusRequest = false;
          }

          if (mustSendFocusRequest) {
            $super.requestFocusFromWidget.call(this, widget, event);
          }
        },

        /**
         * Auto set last column width
         */
        autoSetLastColumnWidthToFillEmptySpace: function() {
          if (this._resizeFillsEmptySpace) {

            var lastVisibleColumn = this.getLastOrderedColumn(true);

            if (this._columnResizeFillsEmptySpace && this._columnResizeFillsEmptySpace !== lastVisibleColumn) {
              this._columnResizeFillsEmptySpace.resetWidth();
              this._columnResizeFillsEmptySpace.setSizable(true);
            }
            this._columnResizeFillsEmptySpace = lastVisibleColumn;

            this._columnResizeFillsEmptySpace.resetWidth();
            this._columnResizeFillsEmptySpace.setSizable(false);

            var visibleColumnsWidth = this.getVisibleColumnsWidth();
            var tableWidth = this.getDataAreaWidth();

            var emptySpaceWidth = tableWidth - visibleColumnsWidth;
            if (emptySpaceWidth >= 0) {
              this._columnResizeFillsEmptySpace.setWidth(this._columnResizeFillsEmptySpace.getWidth() + emptySpaceWidth, true);
            }
          }
        },

        /**
         * Update the list of columns which are in the DOM according to visibility
         */
        _updateVisibleColumnsInDom: function() {

          if (!this._addOnlyVisibleColumnsToDom) {
            return;
          }
          var isLayouted = this._layoutInformation && this._layoutDone;
          if (!isLayouted) {
            return;
          }
          var isVisible = this.isElementInDOM() && this.isVisibleRecursively();
          if (!isVisible) {
            return;
          }
          var offset = this.getScrollableArea().scrollLeft;
          var columns = this.getOrderedColumns();
          var tableWidth = this._layoutInformation.getAllocated().getWidth();
          var currentWidth = 0;
          var extraVisibleColumnAttached = false;
          for (var i = 0; i < columns.length; i++) {

            var col = columns[i];
            if (col.isFrozen() === false && col.isHidden() === false) {
              var colWidth = col.getWidth();

              if (col.isCurrent()) {
                col.attachItemsToDom(); // current column should be always in the dom
              }
              // Detach columns which are not visible at left
              else if (offset > (currentWidth + colWidth)) {
                col.detachItemsFromDom();
              }
              // Detach columns which are not visible at right
              else if ((currentWidth - offset) > tableWidth) {
                if (extraVisibleColumnAttached) {
                  col.detachItemsFromDom();
                } else {
                  extraVisibleColumnAttached = true;
                  col.attachItemsToDom();
                }
              } else {
                col.attachItemsToDom();
              }
              currentWidth += colWidth;
            } else {
              if (col.isHidden()) {
                col.detachItemsFromDom();
              } else {
                col.attachItemsToDom();
              }
            }
          }
        },

        /**
         * @inheritDoc
         */
        addChildWidget: function(widget, options) {

          if (widget.isInstanceOf(cls.TableColumnWidget)) {
            this._addChildTableColumn(widget, options);
          } else if (widget.isInstanceOf(cls.ContextMenuWidget)) {
            // Add rowbound menu
            $super.addChildWidget.call(this, widget, options);

            // create rowbound column and add it
            if (this._rowBoundColumnWidget === null) {
              this._rowBoundColumnWidget = cls.WidgetFactory.createWidget("TableColumnRowBound", this.getBuildParameters());
              this._addChildTableColumn(this._rowBoundColumnWidget, options);
            }
            // rowbound column which is the last, should always fills empty space
            this.setResizeFillsEmptySpace(true);
            this._rowBoundColumnWidget.setHidden(false);
          }

          this.resetOrderedColumns();
          this.updateFrozenColumns();
          this._requestSynchronizeHeadersHeight = true;
        },

        /**
         * Add and init table column as table child
         * @param {classes.TableColumnWidget} columnWidget - columns to be added
         * @param options - options addChildWidget
         */
        _addChildTableColumn: function(columnWidget, options) {
          // Set Table as parent
          columnWidget.setParentWidget(this, {
            noLayoutInvalidation: true
          });
          this.getColumnsHeaders().appendChild(columnWidget.getTitleWidget().getElement());
          columnWidget.setCurrentRow(this._currentRow);
          columnWidget.setOrder(this.getColumns().length);
          $super.addChildWidget.call(this, columnWidget, options);
        },

        /**
         * @inheritDoc
         */
        removeChildWidget: function(widget) {
          $super.removeChildWidget.call(this, widget);
          if (widget.isInstanceOf(cls.ContextMenuWidget)) {
            this.setResizeFillsEmptySpace(false);
            // hide rowbound column when it is not used
            if (this._rowBoundColumnWidget) {
              this._rowBoundColumnWidget.setHidden(true);
            }
          }
          this.resetOrderedColumns();
        },

        /**
         * Set sorted column an type
         * @param sortType - sort type "asc" or "desc" (empty string for no sort)
         * @param sortColumn - column sorted (-1 for no sort)
         */
        setSort: function(sortType, sortColumn) {
          var columns = this.getColumns();

          for (var i = 0; i < columns.length; i++) {
            if (i === sortColumn) {
              columns[i].getTitleWidget().setSortDecorator(sortType);
            } else {
              if (columns[i].getTitleWidget) {
                columns[i].getTitleWidget().setSortDecorator("");
              }
            }
          }
        },

        /**
         * @inheritDoc
         */
        isTreeView: function() {
          var firstColumn = this.getColumns()[0];
          return firstColumn && firstColumn._isTreeView;
        },

        /**
         * Returns if current row is visible
         * @returns {boolean} true if current row is visible
         * @publicdoc
         */
        isCurrentRowVisible: function() {
          return this._currentRow >= 0 && this._currentRow <= this._pageSize;
        },

        /**
         * Returns column widgets (vm aui tree order)
         * @returns {classes.TableColumnWidget[]} array of column widgets
         * @publicdoc
         */
        getColumns: function() {
          return this.getChildren();
        },

        /**
         * Reset cache of ordered columns.
         */
        resetOrderedColumns: function() {
          this._orderedColumns = null;
        },

        /**
         * Returns column widgets (visual order)
         * @returns {classes.TableColumnWidget[]} array of column widgets
         * @publicdoc
         */
        getOrderedColumns: function() {
          var columns = this.getColumns();
          if (this._orderedColumns === null || columns.length !== this._orderedColumns.length) {
            var children = columns.slice();
            children.sort(function(a, b) {
              return a.getOrder() - b.getOrder();
            });
            this._orderedColumns = children;
          }
          return this._orderedColumns;
        },

        /**
         * Returns last ordered column
         * @param {boolean} visible - if true return the last visible ordered columns
         * @returns {classes.TableColumnWidget} last column widget
         * @publicdoc
         */
        getLastOrderedColumn: function(visible) {
          var columns = this.getOrderedColumns();
          for (var i = columns.length - 1; i >= 0; i--) {
            var currentColumn = columns[i];
            if (!visible || !currentColumn.isHidden()) {
              return currentColumn;
            }
          }
          return null;
        },

        /**
         * Returns the width of all visible columns
         * @returns {number} columns width
         */
        getVisibleColumnsWidth: function() {
          var visibleColumnsWidth = 0;
          var columns = this.getOrderedColumns();
          for (var i = 0; i < columns.length; i++) {
            var currentColumn = columns[i];
            if (!currentColumn.isHidden()) {
              visibleColumnsWidth += currentColumn.getWidth();
            }
          }
          return visibleColumnsWidth;
        },

        /**
         * @inheritDoc
         */
        setRowHeight: function(height) {
          this._rowHeight = Math.round(height);
          this.setStyle(" .gbc_TableColumnItemWidget", {
            "height": this._rowHeight + "px"
          });
          this.setStyle(" .gbc_TableColumnItemWidget .gbc_TableItemImage", {
            "width": this._rowHeight + "px",
            "height": this._rowHeight + "px"
          });
          this.updateVerticalScroll(true); // refresh vertical scroll if row height has changed
        },

        /**
         * @inheritDoc
         */
        setCurrentRow: function(row, ensureRowVisible) {
          this._currentRow = row;
          var columns = this.getColumns();

          // if item is partially visible need to scroll, it must be entirely visible
          var scrollIntoView = (!!ensureRowVisible && this._layoutDone);

          for (var i = 0; i < columns.length; i++) {
            var col = columns[i];
            col.setCurrentRow(row);
          }

          if (scrollIntoView) {
            this._scrollAreaNoUserScroll = true;
            this._rightScrollAreaNoUserScroll = true;
            var id = "scroll.unbindScroll" + (++this._uniqueScrollUnbindId);
            this._activeUniqueIdScrolls.set(id, this.getScrollableArea());
            this.getScrollableArea().on(id, function(id) {
              this._previousScrollTopValue = this.getScrollableArea().scrollTop;
              this._previousScrollLeftValue = this.getScrollableArea().scrollLeft;

              this.getScrollableArea().off(id);
              this._activeUniqueIdScrolls.delete(id);

              this._scrollAreaNoUserScroll = false;
              this._rightScrollAreaNoUserScroll = false;
            }.bind(this, id));
            this.getScrollableArea().scrollTop = (this._offset * this.getRowHeight());
          }
        },

        /**
         * Change current column
         * @param {number} col - new current column
         */
        setCurrentColumn: function(col) {
          this._currentColumn = col;
          var columns = this.getColumns();
          for (var i = 0; i < columns.length; i++) {
            if (columns[i].setCurrent) {
              columns[i].setCurrent(i === col);
            }
          }
        },

        /** Returns current column
         * @returns {number} current column
         */
        getCurrentColumn: function() {
          return this._currentColumn;
        },

        /**
         * Returns the current widget
         * @returns {classes.WidgetBase} current widget
         * @publicdoc
         */
        getCurrentWidget: function() {
          if (this.isCurrentRowVisible()) {
            return this.getWidgetAt(this._currentColumn, this._currentRow);
          }
          return null;
        },

        /**
         * Returns the widget at the specified column/row
         * @param {number} column - column index
         * @param {number} row - row index
         * @returns {classes.WidgetBase} item widget
         * @publicdoc
         */
        getWidgetAt: function(column, row) {
          return this.getColumns()[column].getWidgetAt(row);
        },

        /**
         * @inheritDoc
         */
        setVisibleRows: function(visibleRows) {
          if (this._visibleRows !== visibleRows) {
            this._visibleRows = visibleRows;
            var columns = this.getColumns();
            for (var i = 0; i < columns.length; i++) {
              var tableColumn = columns[i];
              if (tableColumn.updateRowsVisibility) {
                tableColumn.updateRowsVisibility();
              }
            }
          }
        },

        /**
         * @param {boolean} enable - true if the table should allow multi-row selection, false otherwise
         */
        setMultiRowSelectionEnabled: function(enable) {
          this._element.toggleClass("multiRowSelection", !!enable);
        },

        /**
         * Returns if multi-row selection is enabled
         * @returns {boolean} true if the table allow multi-row selection, false otherwise
         * @publicdoc
         */
        isMultiRowSelectionEnabled: function() {
          return this._element.hasClass("multiRowSelection");
        },

        /**
         * Sets the specified row is selected
         * @param {number} row - index of the row
         * @param {boolean} selected - true if the row should be selected, false otherwise
         */
        setRowSelected: function(row, selected) {
          var columns = this.getColumns();
          for (var i = 0; i < columns.length; i++) {
            var tableColumn = columns[i];
            tableColumn.setRowSelected(row, selected);
          }
        },

        /**
         * Returns if the specified row is selected
         * @param {number} row - index of the row
         * @returns {boolean} true if the row is selected, false otherwise
         */
        isRowSelected: function(row) {
          var columns = this.getColumns();
          if (!!columns.length) {
            return columns[row].isRowSelected(row);
          }
          return false;
        },

        /**
         * Defines if focus in on a field (table item) or (default) on a row
         * @param {boolean} focusOnField - true if focus on field activated
         */
        setFocusOnField: function(focusOnField) {
          this._focusOnField = focusOnField;
        },

        /**
         * Returns if focus is on a field (table item) (by default focus is on a row)
         * @returns {boolean} true if focus on field activated
         */
        hasFocusOnField: function() {
          return this._focusOnField;
        },

        /**
         * Set the same heights for all headers (left, middle, right)
         */
        synchronizeHeadersHeight: function() {
          if (this._frozenTable && this._layoutDone) {

            var height = -1;
            var leftHeight = -1;
            var rightHeight = -1;

            if (this.hasLeftFrozenColumns() || this.hasRightFrozenColumns()) {
              this.getColumnsHeaders().addClass("g_TableMeasuring");
              height = this.getColumnsHeaders().clientHeight;
              this.getColumnsHeaders().removeClass("g_TableMeasuring");
            }
            if (this.hasLeftFrozenColumns()) {
              this.getLeftColumnsHeaders().addClass("g_TableMeasuring");
              leftHeight = this.getLeftColumnsHeaders().clientHeight;
              this.getLeftColumnsHeaders().removeClass("g_TableMeasuring");
            }
            if (this.hasRightFrozenColumns()) {
              this.getRightColumnsHeaders().addClass("g_TableMeasuring");
              rightHeight = this.getRightColumnsHeaders().clientHeight;
              this.getRightColumnsHeaders().removeClass("g_TableMeasuring");
            }

            var headerHeight = Math.max(height, leftHeight, rightHeight);
            if (headerHeight > 0) {

              this.setStyle(".gbc_TableColumnsHeaders", {
                "height": headerHeight + "px"
              });
              if (this.hasLeftFrozenColumns()) {
                this.setStyle(".gbc_TableLeftColumnsHeaders", {
                  "height": headerHeight + "px"
                });
              }
              if (this.hasRightFrozenColumns()) {
                this.setStyle(".gbc_TableRightColumnsHeaders", {
                  "height": headerHeight + "px"
                });
              }
            }
            // need to measure table
            this.getLayoutEngine().forceMeasurement();
            this.getLayoutEngine().invalidateMeasure();
          }
        },

        /**
         * @inheritDoc
         */
        buildExtraContextMenuActions: function(contextMenu) {

          contextMenu.addAction("copyRow", i18next.t("gwc.contextMenu.copyRow"), null, "Ctrl+C", {
            clickCallback: function() {
              contextMenu.hide();
              this._copyCurrentRowInClipboard();
            }.bind(this)
          }, true);

          if (this.isMultiRowSelectionEnabled()) {
            contextMenu.addAction("selectAll", i18next.t("gwc.contextMenu.selectAll"), "font:FontAwesome.ttf:f0ea", "Ctrl+A", {
              clickCallback: function() {
                contextMenu.hide();
                this.emit(context.constants.widgetEvents.selectAll);
              }.bind(this)
            }, true);
          }

        },

        /**
         * @inheritDoc
         */
        flash: function() {
          this.addClass("flash");
          this._registerTimeout(function() {
            this.removeClass("flash");
          }.bind(this), 50);
        },

        /**
         * Auto fit all column widths
         */
        autoFitAllColumns: function() {
          var columns = this.getColumns();
          for (var i = 0; i < columns.length; i++) {
            var tc = columns[i];
            tc.autoSetWidth();
          }
        },

        /**
         * Auto fit column widths so all columns visible.
         */
        fitToViewAllColumns: function() {
          // phase 1 work out total
          var columns = this.getColumns();
          var totalAvail = this.getDataAreaWidth();
          var totalCurrent = 0;
          var tc = null,
            i = 0;
          for (i = 0; i < columns.length; i++) {
            tc = columns[i];
            if (!tc.isHidden()) {
              if (tc.isSizable()) {
                totalCurrent = totalCurrent + tc.getWidth();
              } else {
                totalAvail = totalAvail - tc.getWidth();
              }
            }
          }
          // phase 2 set column width in proportion to space available
          var newTotal = 0;
          if (totalCurrent > 0) {
            for (i = 0; i < columns.length; i++) {
              tc = columns[i];
              if (!tc.isHidden() && tc.isSizable()) {
                var w = Math.round(tc.getWidth() * (totalAvail / totalCurrent));
                newTotal = newTotal + w;
                if (newTotal > totalAvail) {
                  w = w - (newTotal - totalAvail); // to be sure that the total of width is not > totalAvail
                }
                tc.setWidthFromUserInteraction(w);
              }
            }
          }
        },

        // ============== START - FOOTER/AGGREGATE FUNCTIONS ===================

        /**
         * Defines if the footer element is needed (used to display aggregate)
         * @param {boolean} b - true to display footer, false to hide it
         */
        setHasFooter: function(b) {
          if (this._hasFooter !== b) {
            this._hasFooter = b;
            this.getColumnsFooter().toggleClass("hidden", !b);
            if (b) {
              this.updateAllAggregate(); // need to update all aggregate
            }
            // need to measure table
            this.getLayoutEngine().forceMeasurement();
            this.getLayoutEngine().invalidateMeasure();
          }
        },

        /**
         * Returns if table has a footer (used for aggregate)
         * @returns {boolean} true if footer is visible
         */
        hasFooter: function() {
          return this._hasFooter;
        },

        /**
         * Update all aggregates
         */
        updateAllAggregate: function() {
          if (this.hasFooter()) {
            // search column which contain an aggregate
            this.resetOrderedColumns();
            var columns = this.getOrderedColumns();
            var firstAggregate = null;
            var aggregateWidth = 0;
            var frozenIndex = null;
            for (var i = 0; i < columns.length; i++) {
              var col = columns[i];
              if (frozenIndex === null) {
                frozenIndex = col.getFrozenIndex();
              }
              var agg = col.getAggregateWidget();

              // for each frozen group (left, right or none), we calculate width of aggregate
              if (col.getFrozenIndex() !== frozenIndex) {
                frozenIndex = col.getFrozenIndex();
                aggregateWidth = 0;
              }
              if (!col.isHidden()) {
                aggregateWidth += col.getWidth();
              }
              if (!!agg) {
                if (aggregateWidth) {
                  this.afterDomMutator(function(col, aggregateWidth) {
                    col.setAggregate(col.getAggregateWidget().getText(), aggregateWidth);
                  }.bind(this, col,
                    aggregateWidth)); // pass values as parameters since we are in a loop (otherwise we get only last column values)
                }
                aggregateWidth = 0;

                // first global text has always to be set in the left part of the table
                if (!firstAggregate && !agg.isHidden()) {
                  firstAggregate = agg;
                }
              }

            }

            // Add globalText element to first aggregate widget
            if (firstAggregate) {
              this.getAggregateGlobalTextElement().remove();
              firstAggregate.getElement().prependChild(this.getAggregateGlobalTextElement());
            }
          }
        },

        /**
         * Global text for aggregates
         * @param {string} text - global aggregate text
         */
        setAggregateGlobalText: function(text) {
          if (!this._aggregateGlobalTextElement) {
            this._aggregateGlobalTextElement = document.createElement("div");
            this._aggregateGlobalTextElement.addClass("gbc_TableAggregateGlobalText");
          }
          this._aggregateGlobalTextElement.textContent = text;
        },
        // ============== END - FOOTER/AGGREGATE FUNCTIONS ===================

        // ============== START - SCROLL FUNCTIONS ===================

        /**
         * Returns if vertical scroll bar is at end
         * @returns {boolean} true if vertical Scroll bar is at end
         */
        isVerticalScrollAtEnd: function() {
          var scrollArea = this.getScrollableArea();
          return (scrollArea.scrollTop + scrollArea.clientHeight) === scrollArea.scrollHeight;
        },

        /**
         * Do native vertical scroll
         * @param {number} value - new scroll value
         * @param {boolean} delta - if true, value is added to old scroll value
         * @param {boolean} [force] - if true, consider the scroll as a user input scroll (especially wheel on left frozen columns)
         */
        doScroll: function(value, delta, force) {
          var isTableVisible = this.isVisibleRecursively();
          if (isTableVisible) {
            var top = value;
            if (delta) {
              top = (this.getScrollableArea().scrollTop + value);
            }
            if (this.hasRightFrozenColumns()) {
              this.setRightScrollableAreaScrollTop(top, force);
            } else {
              this.setScrollableAreaScrollTop(top, force);
            }
          } else {
            this._needToUpdateVerticalScroll = true;
          }
        },

        /**
         * Do a horizontal scrolling (column by column)
         * @param {string} direction - "left" or "right"
         */
        doHorizontalScroll: function(direction) {
          var scrollArea = this.getScrollableArea();
          var scrollPos = scrollArea.scrollLeft;
          var columns = this.getOrderedColumns();
          var width = 0;
          for (var i = 0; i < columns.length; i++) {
            var col = columns[i];
            if (col.isFrozen() === false && col.isHidden() === false) {
              var colWidth = col.getWidth();

              var isScrollAtStartColumn = (Math.abs(scrollPos - width) <= 2);
              var isScrollAtEndColumn = (Math.abs(scrollPos - (width + colWidth)) <= 2);
              if ((isScrollAtStartColumn || scrollPos > width) && (isScrollAtEndColumn || scrollPos < width + colWidth)) {
                if (isScrollAtStartColumn && direction === "right") {
                  scrollPos = width + colWidth;
                  direction = "left";
                } else if (isScrollAtEndColumn && direction === "right") {
                  scrollPos = width + colWidth;
                } else {
                  scrollArea.scrollLeft = direction === "right" ? width + colWidth : width;
                  break;
                }
              }
              width += colWidth;
            }
          }
        },

        /**
         * Called when a mousewheel is done
         * @param {Object} event - mousewheel event
         */
        _onMouseWheel: function(event) {
          if (this.isEnabled()) {
            this.doScroll(event.deltaY, true, true);
          }
        },

        /**
         * Called when a scroll is done
         * @param {Object} event - scroll event
         */
        _onScroll: function(event) {

          var targetScrollTop = event.target.scrollTop;
          var targetScrollLeft = event.target.scrollLeft;

          // manage horizontal scroll
          if (this._previousScrollLeftValue !== targetScrollLeft) {
            this._previousScrollLeftValue = targetScrollLeft;
            this.afterDomMutator(function() {
              // Update visible columns
              if (this._throttleUpdateVisibleColumnsInDom) {
                this._clearTimeout(this._throttleUpdateVisibleColumnsInDom);
              }
              this._throttleUpdateVisibleColumnsInDom = this._registerTimeout(function() {
                this._throttleUpdateVisibleColumnsInDom = null;

                // after add/remove a column in DOM, we must block vertical scroll
                this._scrollAreaNoUserScroll = true;
                this._scrollAreaResetScrollTopFromPrevious = true;

                this._updateVisibleColumnsInDom();

                // unblock vertical scroll after two requestAnimationFrame
                // to be sure scroll is done after add/remove column in DOM
                this.afterDomMutator(function() {
                  this.afterDomMutator(function() {
                    this._scrollAreaNoUserScroll = false;
                    this._scrollAreaResetScrollTopFromPrevious = false;
                  }.bind(this));
                }.bind(this));

              }.bind(this), 10);

              // Synchronize Columns headers horizontal scroll
              var scrollLeft = this.getScrollableArea().scrollLeft;
              this.getColumnsHeaders().scrollLeft = scrollLeft;

              // Synchronize columns footer horizontal scroll
              if (this.hasFooter()) {
                this.getColumnsFooter().scrollLeft = scrollLeft;
              }
            }.bind(this));
          }

          // reset items selection after each scroll change
          this._resetItemsSelection();

          if (this._scrollAreaNoUserScroll) {
            // if scroll is not done by user ignore it
            this._scrollAreaNoUserScroll = false;
            if (this._scrollAreaResetScrollTopFromPrevious) {
              // reset to previous value of scroll to block no user scroll
              this._scrollAreaResetScrollTopFromPrevious = false;
              this.getScrollableArea().scrollTop = this._previousScrollTopValue;
            }
            return true;
          }

          // manage vertical scroll
          if (this._previousScrollTopValue !== targetScrollTop) {
            this._previousScrollTopValue = targetScrollTop;
            this.afterDomMutator(function() {
              if (!this.hasRightFrozenColumns()) {
                // Emit scroll event for vertical scrolling
                this.emit(context.constants.widgetEvents.scroll, event, this.getRowHeight());

                var scrollTop = this.getScrollableArea().scrollTop;
                this.setLeftScrollableAreaScrollTop(scrollTop);
                this.setRightScrollableAreaScrollTop(scrollTop);
              }
            }.bind(this));
          }
        },

        /**
         * Called when a scroll is done on left frozen columns
         * @param {Object} event - scroll event
         */
        _onScrollOnLeftColumns: function(event) {
          // Synchronize Columns headers and footers horizontal scroll
          this.afterDomMutator(function() {
            if (event.target) {
              this.getLeftColumnsHeaders().scrollLeft = event.target.scrollLeft;
              if (this.hasFooter()) {
                this.getLeftColumnsFooter().scrollLeft = event.target.scrollLeft;
              }
            }
          }.bind(this));
        },

        /**
         * Called when a scroll is done on right frozen columns
         * @param {Object} event - scroll event
         */
        _onScrollOnRightColumns: function(event) {
          // Synchronize Columns headers and footers horizontal scroll
          this.afterDomMutator(function() {
            if (event.target) {
              this.getRightColumnsHeaders().scrollLeft = event.target.scrollLeft;
              if (this.hasFooter()) {
                this.getRightColumnsFooter().scrollLeft = event.target.scrollLeft;
              }

              if (this.hasRightFrozenColumns()) {
                // Emit scroll event for vertical scrolling
                this.emit(context.constants.widgetEvents.scroll, event, this.getRowHeight());

                var scrollTop = event.target.scrollTop;
                this.setLeftScrollableAreaScrollTop(scrollTop);
                this.setScrollableAreaScrollTop(scrollTop);
              }
            }
          }.bind(this));

          if (this._rightScrollAreaNoUserScroll) {
            this._rightScrollAreaNoUserScroll = false;
            return true;
          }

          // Manage vertical scroll only if there is right frozen columns
          if (this.hasRightFrozenColumns()) {
            this.afterDomMutator(function() {
              if (event.target) {

                // Emit scroll event for vertical scrolling
                this.emit(context.constants.widgetEvents.scroll, event, this.getRowHeight());

                var scrollTop = event.target.scrollTop;
                this.setLeftScrollableAreaScrollTop(scrollTop);
                this.setScrollableAreaScrollTop(scrollTop);
              }
            }.bind(this));
          }
        },

        /**
         * @inheritDoc
         */
        updateContentPosition: function(size, pageSize, offset, forceScroll) {

          if (size !== null) {
            this.setSize(size);
            if (this._pageSize !== pageSize) {
              this._pageSize = pageSize;
              this._resetItemsSelection(); // reset items selection after pageSize change
            }

            var top = offset * this.getRowHeight();
            var rowCount = (size - offset + (this.isInputMode() ? 1 :
              0)); // in input one extra line for user to click after last line
            var height = rowCount * this.getRowHeight() + (this.hasFooter() ? this.getColumnsFooter().clientHeight : 0);
            if (size <
              pageSize) { // Height should be always greater than getDataAreaHeight to display correctly gbc_TableAfterLastItemZone
              height = Math.max(Math.floor(this.getDataAreaHeight() - 2),
                height); // -2 to be sure that container is smaller than scrollarea
            }

            this.setStyle({
              selector: ".gbc_TableColumnsContainer"
            }, {
              "margin-top": top + "px",
              "height": height + "px"
            });

            if (this.hasLeftFrozenColumns()) {
              this.setStyle({
                preSelector: ".g_measured ",
                selector: ".gbc_TableLeftColumnsContainer"
              }, {
                "margin-top": top + "px",
                "height": height + "px"
              });
            }

            if (this.hasRightFrozenColumns()) {
              this.setStyle({
                preSelector: ".g_measured ",
                selector: ".gbc_TableRightColumnsContainer"
              }, {
                "margin-top": top + "px",
                "height": height + "px"
              });
            }

            // if offset is different or if scrolltop value of current scrollarea is different too different from calculated value
            // need to rest scrolltop of scrollablearea
            if (!!forceScroll || (this.lastSentOffset === null || this.lastSentOffset === offset) && offset !== this._offset) {
              this._offset = offset;
              // need to do this because to scroll we need to wait the style "height" set just before is really applied in the dom
              this.afterDomMutator(function() {
                this.doScroll(top, false);
              }.bind(this));
            }
            this.lastSentOffset = null;
          }
        },

        /**
         * set scroll top to the main area
         * @param {number} top - the scrollTop to apply
         * @param {boolean} [force] - if true, consider the scroll as a user input scroll (especially wheel on left frozen columns)
         * @param {boolean} [synchronizing] -
         */
        setScrollableAreaScrollTop: function(top, force, synchronizing) {
          if (this.getScrollableArea().scrollTop !== top) {
            var id = "scroll.unbindScroll" + (++this._uniqueScrollUnbindId);
            this._activeUniqueIdScrolls.set(id, this.getScrollableArea());

            this._scrollAreaNoUserScroll = !force;
            this.getScrollableArea().on(id, function(id) {
              this._previousScrollTopValue = this.getScrollableArea().scrollTop;
              this._previousScrollLeftValue = this.getScrollableArea().scrollLeft;

              this.getScrollableArea().off(id);
              this._activeUniqueIdScrolls.delete(id);

              this._scrollAreaNoUserScroll = false;
            }.bind(this, id));
            this.getScrollableArea().scrollTop = top;
            if (!synchronizing) {
              this.setLeftScrollableAreaScrollTop(top, true);
              this.setRightScrollableAreaScrollTop(top, false, true);
            }
          }
        },

        /**
         * set scroll top to the right area
         * @param {number} top - the scrollTop to apply
         * @param {boolean} [synchronizing] -
         */
        setLeftScrollableAreaScrollTop: function(top, synchronizing) {
          if (this.getLeftScrollableArea().scrollTop !== top) {
            this.getLeftScrollableArea().scrollTop = top;
            if (!synchronizing) {
              this.setScrollableAreaScrollTop(top, false, true);
              this.setRightScrollableAreaScrollTop(top, false, true);
            }
          }
        },

        /**
         * Set scroll top to the right area
         * @param {number} top the scrollTop to apply
         * @param {boolean} [force] - if true, consider the scroll as a user input scroll (especially wheel on left frozen columns)
         * @param {boolean} [synchronizing] -
         */
        setRightScrollableAreaScrollTop: function(top, force, synchronizing) {
          if (this.getRightScrollableArea().scrollTop !== top) {
            var id = "scroll.unbindScroll" + (++this._uniqueScrollUnbindId);
            this._activeUniqueIdScrolls.set(id, this.getRightScrollableArea());

            this._rightScrollAreaNoUserScroll = !force;
            this.getRightScrollableArea().on(id, function(id) {
              this.getRightScrollableArea().off(id);
              this._activeUniqueIdScrolls.delete(id);

              this._rightScrollAreaNoUserScroll = false;
            }.bind(this, id));
            this.getRightScrollableArea().scrollTop = top;
            if (!synchronizing) {
              this.setLeftScrollableAreaScrollTop(top, true);
              this.setScrollableAreaScrollTop(top, false, true);
            }
          }
        },
        // ============== END - SCROLL FUNCTIONS =====================

        // ============== START - FROZEN COLUMNS FUNCTIONS ===================
        /**
         * Update frozen columns.
         */
        updateFrozenColumns: function() {

          if (this._frozenTable) {
            this._renderFrozenColumns();

            this.getScrollableArea().off('wheel.TableWidget');
            this.getLeftScrollableArea().off('wheel.TableWidget');
            this.getRightScrollableArea().off('wheel.TableWidget');

            if (this.hasLeftFrozenColumns()) {
              this.getLeftScrollableArea().on('wheel.TableWidget', this._onMouseWheel.bind(this));
            }

            if (this.hasRightFrozenColumns()) {
              this.getScrollableArea().on('wheel.TableWidget', this._onMouseWheel.bind(this));

              this.setStyle(".gbc_TableColumnsHeaders", {
                "margin-right": 0
              });
              this.setStyle(".gbc_TableRightColumnsHeaders", {
                "margin-right": window.scrollBarSize + "px"
              });

              this.setStyle(".gbc_TableScrollArea", {
                "overflow-y": "hidden"
              });
            } else {
              this.setStyle(".gbc_TableRightColumnsHeaders", {
                "margin-right": 0
              });
              this.setStyle(".gbc_TableColumnsHeaders", {
                "margin-right": window.scrollBarSize + "px"
              });
              this.setStyle(".gbc_TableScrollArea", {
                "overflow-y": "scroll"
              });
            }

            this.getLeftContainer().toggleClass("hidden", !this.hasLeftFrozenColumns());
            this.getRightContainer().toggleClass("hidden", !this.hasRightFrozenColumns());

            this._updateFooterWidth();
            this.updateVerticalScroll();
            this.domAttributesMutator(function() {
              this.afterDomMutator(function() {
                var scrollTop = this.getScrollableArea().scrollTop;
                this.setLeftScrollableAreaScrollTop(scrollTop);
                this.setRightScrollableAreaScrollTop(scrollTop);
              }.bind(this));
            }.bind(this));

            this.synchronizeHeadersHeight();
            this.updateAllAggregate();
          }
        },

        _updateFooterWidth: function() {
          if (this.hasRightFrozenColumns()) {
            this.setStyle(".gbc_TableRightColumnsFooter", {
              "width": "calc(100% - " + window.scrollBarSize + "px)"
            });
            this.setStyle(".gbc_TableColumnsFooter", {
              "width": "100%"
            });
          } else {
            this.setStyle(".gbc_TableColumnsFooter", {
              "width": "calc(100% - " + window.scrollBarSize + "px)"
            });
            this.setStyle(".gbc_TableRightColumnsFooter", {
              "width": "100%"
            });
          }
        },

        /**
         * Returns true if table has left frozen columns
         * @returns {boolean} true if there are left frozen columns
         * @publicdoc
         */
        hasLeftFrozenColumns: function() {
          return (this._leftFrozenColumns > 0);
        },

        /**
         * Returns true if table has right frozen columns
         * @returns {boolean} true if there are right frozen columns
         * @publicdoc
         */
        hasRightFrozenColumns: function() {
          return (this._rightFrozenColumns > 0);
        },

        /**
         * Render frozen columns.
         */
        _renderFrozenColumns: function() {

          if (this._frozenTable) {
            var columns = this.getOrderedColumns();

            for (var i = 0; i < columns.length; i++) {
              var currentColumn = columns[i];
              if (i < this._leftFrozenColumns) {
                currentColumn._isLeftFrozen = true;
                currentColumn._isRightFrozen = false;
                this.getLeftColumnsContainer().appendChild(currentColumn.getElement());
                this.getLeftColumnsHeaders().appendChild(currentColumn.getTitleWidget().getElement());
                if (currentColumn._aggregate) {
                  this.getLeftColumnsFooter().appendChild(currentColumn._aggregate.getElement());
                }
              } else if (columns.length - i <= this._rightFrozenColumns) {
                currentColumn._isRightFrozen = true;
                currentColumn._isLeftFrozen = false;
                this.getRightColumnsContainer().appendChild(currentColumn.getElement());
                this.getRightColumnsHeaders().appendChild(currentColumn.getTitleWidget().getElement());
                if (currentColumn._aggregate) {
                  this.getRightColumnsFooter().appendChild(currentColumn._aggregate.getElement());
                }
              } else {
                currentColumn._isLeftFrozen = false;
                currentColumn._isRightFrozen = false;
                this.getColumnsContainer().appendChild(currentColumn.getElement());
                this.getColumnsHeaders().appendChild(currentColumn.getTitleWidget().getElement());
                if (currentColumn._aggregate) {
                  this.getColumnsFooter().appendChild(currentColumn._aggregate.getElement());
                }
              }
            }
            this._updateVisibleColumnsInDom();
          }
        },

        /**
         * Returns true if table can have frozen columns
         * @returns {boolean} true if table can have frozen columns
         * @publicdoc
         */
        isFrozenTable: function() {
          return this._frozenTable;
        },

        /**
         * Sets if table can contains frozen table.
         * @param {boolean} frozen - true if table can have frozen columns
         */
        setFrozenTable: function(frozen) {
          if (this._frozenTable !== frozen) {
            this._frozenTable = frozen;
            this.updateFrozenColumns();
          }
        },

        /**
         * Sets the number of left frozen columns.
         * @param {number} n - number of left frozen columns
         * @publicdoc
         */
        setLeftFrozenColumns: function(n) {
          if (this._leftFrozenColumns !== n) {
            this._leftFrozenColumns = n;
            this.updateFrozenColumns();
          }
        },

        /**
         * Sets the number of right frozen columns.
         * @param {number} n - number of right frozen columns
         * @publicdoc
         */
        setRightFrozenColumns: function(n) {
          if (this._rightFrozenColumns !== n) {
            this._rightFrozenColumns = n;
            this.updateFrozenColumns();
          }
        },

        /**
         * Returns number of left frozen columns
         * @returns {number} number of left frozen columns
         * @publicdoc
         */
        getLeftFrozenColumns: function() {
          return this._leftFrozenColumns;
        },

        /**
         * Returns number of right frozen columns
         * @returns {number} number of right frozen columns
         * @publicdoc
         */
        getRightFrozenColumns: function() {
          return this._rightFrozenColumns;
        },
        // ============== END - FROZEN COLUMNS FUNCTIONS =====================

        // ============== START - STYLE FUNCTIONS ===================
        /**
         * Hide/Show column headers
         * @param {boolean} hidden - true if header must be hidden
         */
        setHeaderHidden: function(hidden) {
          if (this._headerHidden !== hidden) {
            this._headerHidden = hidden;
            this.getColumnsHeaders().toggleClass("hidden", !!hidden);
            this.getLeftColumnsHeaders().toggleClass("hidden", !!hidden);
            this.getRightColumnsHeaders().toggleClass("hidden", !!hidden);
          }
        },

        /**
         * Show/hide table grid
         * @param {boolean} showGrid - if true always show grid
         */
        setShowGrid: function(showGrid) {
          if (this._showGrid !== showGrid) {
            this._showGrid = showGrid;
            this._element.toggleClass("showGrid", !!showGrid);
          }
        },

        /**
         * Set header columns alignment
         * @param {string} alignment - (default, left, center, right, auto)
         */
        setHeaderAlignment: function(alignment) {
          if (this._headerAlignment !== alignment) {
            this._headerAlignment = alignment;
            var columns = this.getColumns();
            for (var i = 0; i < columns.length; i++) {
              var col = columns[i];
              col.getTitleWidget().setTextAlign(alignment);
            }
          }
        },

        /**
         * @inheritDoc
         */
        setHighlightColor: function(color) {
          if (this._highlightColor !== color) {
            this._highlightColor = color;

            color = (color === null ? null : color + " !important");

            this.setStyle({
              selector: ":not(.disabled) .highlight .gbc_TableColumnItemWidget.currentRow",
              appliesOnRoot: true
            }, {
              "background-color": color
            });
          }
        },

        /**
         * @inheritDoc
         */
        setHighlightTextColor: function(color) {
          if (this._highlightTextColor !== color) {
            this._highlightTextColor = color;

            this.setStyle({
              selector: ":not(.disabled) .highlight .gbc_TableColumnItemWidget.currentRow",
              appliesOnRoot: true
            }, {
              "color": color === null ? null : color + " !important",
              "fill": color === null ? null : color + " !important"
            });
          }
        },

        /**
         * Indicates if the current cell must be highlighted in a table
         * @param {boolean} b - true if current cell must be highlighted
         */
        setHighlightCurrentCell: function(b) {
          this._highlightCurrentCell = b;
        },

        /**
         * Return if the current cell must be highlighted
         * @returns {?boolean} true if current cell must be highlighted
         * @publicdoc
         */
        isHighlightCurrentCell: function() {
          return this._highlightCurrentCell;
        },

        /**
         * Update highlight row and cell
         */
        updateHighlight: function() {
          this.setCurrentRow(this._currentRow);
          this.setCurrentColumn(this._currentColumn);
        },

        /**
         * Indicates if the last visible column should fill the empty space.
         * @param {boolean} b - true if last column fills empty space
         */
        setResizeFillsEmptySpace: function(b) {
          this._resizeFillsEmptySpace = b || this
            .hasRowBound(); // when rowbound last column which is rowbound always takes all the empty space
          if (!this._resizeFillsEmptySpace) {
            this._columnResizeFillsEmptySpace = null;
          }
        },

        /**
         * Indicates if the last visible column should fill the empty space.
         * @return {boolean} true if last column fills empty space
         * @publicdoc
         */
        isResizeFillsEmptySpace: function() {
          return this._resizeFillsEmptySpace;
        },
        // ============== END - STYLE FUNCTIONS =====================

        // ============== START - HEADER Event/DnD FUNCTIONS ===================

        /**
         * Handle double click on header
         * @param {Object} evt - dblclick event
         */
        _onHeaderDoubleClick: function(evt) {
          if (evt.target.hasClass("resizer")) { // double click on resizer
            var columnTitleWidget = gbc.WidgetService.getWidgetFromElement(evt.target, "gbc_TableColumnTitleWidget");
            if (!!columnTitleWidget) {
              columnTitleWidget.onResizerDoubleClick(evt);
            }
          }
        },

        /**
         * Handle reordering drop event
         * @param {Object} evt - rop event
         */
        _onHeaderDrop: function(evt) {
          var columnTitleWidget = gbc.WidgetService.getWidgetFromElement(evt.target, "gbc_TableColumnTitleWidget");
          if (!!columnTitleWidget) {
            columnTitleWidget.onReorderingDrop(evt);
          } else if (this._dndMode === "columnReordering") {
            if (this._dndReorderingDragOverWidget === null) { // it means user drop column on the header but after the last column
              var orderedColumns = this.getOrderedColumns();
              this._dndDraggedColumnWidget.getTitleWidget().reorderColumns(this._dndDraggedColumnWidget, orderedColumns[
                orderedColumns.length - 1]);
            }
          }
        },

        /**
         * Handle drag start on header
         * @param {Object} evt - dragstart event
         */
        _onHeaderDragStart: function(evt) {
          var columnTitleWidget = gbc.WidgetService.getWidgetFromElement(evt.target, "gbc_TableColumnTitleWidget");
          if (!columnTitleWidget) {
            return;
          }

          if (evt.target.hasClass("resizer")) { // drag start on resizer
            columnTitleWidget.onResizerDragStart(evt);
          } else if (evt.target.hasClass("headerText")) { // drag start on headerText
            columnTitleWidget.onReorderingDragStart(evt);
          }
        },

        /**
         * Handle drag start on header
         * @param {Object} evt - dragend event
         */
        _onHeaderDragEnd: function(evt) {
          var columnTitleWidget = gbc.WidgetService.getWidgetFromElement(evt.target, "gbc_TableColumnTitleWidget");
          if (!columnTitleWidget || !evt.target.hasClass) {
            return;
          }

          if (evt.target.hasClass("resizer")) { // drag end on resizer
            columnTitleWidget.onResizerDragEnd(evt);
          } else if (evt.target.hasClass("headerText")) { // drag end on headerText
            columnTitleWidget.onReorderingDragEnd(evt);
          }
        },

        /**
         * Handle drag over on header
         * @param {Object} evt - dragover event
         */
        _onHeaderDragOver: function(evt) {
          var columnTitleWidget = gbc.WidgetService.getWidgetFromElement(evt.target, "gbc_TableColumnTitleWidget");
          if (!columnTitleWidget) {
            return;
          }
          columnTitleWidget.onReorderingDragOver(evt);
        },

        /**
         * Handle drag leave on header
         * @param {Object} evt - drag leave event
         */
        _onHeaderDragLeave: function(evt) {
          var columnTitleWidget = gbc.WidgetService.getWidgetFromElement(evt.target, "gbc_TableColumnTitleWidget");
          if (!columnTitleWidget) {
            return;
          }
          columnTitleWidget.onReorderingDragLeave(evt);
        },

        /**
         * Handle drag start on header
         * @param {Object} evt - drag start event
         */
        _onHeaderDrag: function(evt) {
          if (evt.target.hasClass && evt.target.hasClass("resizer")) { // drag start on resizer
            var columnTitleWidget = gbc.WidgetService.getWidgetFromElement(evt.target, "gbc_TableColumnTitleWidget");
            if (!!columnTitleWidget) {
              columnTitleWidget.onResizerDrag(evt);
            }
          }
        },

        // ============== END - HEADER Event/DnD FUNCTIONS ===================

        // ============== START - ITEMS CLIENT SELECTION FUNCTIONS ===================

        /**
         * Set if item selection is the default behavior (disable dnd in this case)
         * @param {boolean} b
         */
        setDefaultItemSelection: function(b) {
          this._defaultItemSelection = b;
          if (b === true) {
            this.setDndItemEnabled(false);
          }
        },

        /**
         * Check if this mouse event can allow item selection
         * @param {Object} evt - mouse event
         * @returns {boolean}
         */
        _isEventAllowItemSelection: function(evt) {
          return (this.isDisplayMode() && (evt.ctrlKey || evt.metaKey || this._defaultItemSelection)) || (this.isInputMode() && (
            evt.ctrlKey ||
            evt.metaKey || (this._defaultItemSelection &&
              !this._enabled)));
        },

        /**
         * Returns true if there are some items selected
         * @returns {boolean} true if there are some items selected
         */
        hasItemsSelected: function() {
          if (this._itemSelectionElement === null) {
            return false;
          }
          return !(this._itemSelectionElement.hasClass("hidden"));
        },

        /**
         * Reset items selection
         */
        _resetItemsSelection: function() {
          if (this._firstItemSelected !== null) {
            this._itemSelectionInProgress = false;
            this._firstItemSelected = null;
            if (this._itemSelectionElement) {
              this._itemSelectionElement.addClass("hidden");
            }
            this._setItemSelection(false);
          }
        },

        // Store mouse move prev positions
        _itemSelectionMouseMovePrevX: 0,
        _itemSelectionMouseMovePrevY: 0,

        /**
         * Handle mouseDown event for table items
         * @param {Object} evt - mousedown event
         */
        _onItemMouseDown: function(evt) {

          this._itemSelectionMouseMovePrevX = evt.screenX;
          this._itemSelectionMouseMovePrevY = evt.screenY;

          var itemWidget = gbc.WidgetService.getWidgetFromElement(evt.target, "gbc_TableColumnItemWidget");

          this._resetItemsSelection();

          // Start item selection
          if (!!itemWidget && this._isEventAllowItemSelection(evt)) {

            // To avoid text selection in input array
            evt.stopPropagation();
            evt.preventCancelableDefault();

            // Create selection rect element
            if (this._itemSelectionElement === null) {
              this._itemSelectionElement = document.createElement("span");
              this._itemSelectionElement.addClass("gbc_TableItemSelectionArea");
              this._itemSelectionElement.addClass("hidden");
              this._element.appendChild(this._itemSelectionElement);
            }
            this._itemSelectionInProgress = true;
            this._firstItemSelected = itemWidget;

            // bind mousemove event
            this.getElement().on("mousemove.TableWidget", this._onItemMouseMove.bind(this));

            // disable dnd
            this._temporaryEnabledDndOnItem(false, this._firstItemSelected);
          }
        },

        /**
         * Stop item selection in progress
         * @param {Object} evt - mouse event
         */
        _stopInProgressItemSelection: function(evt) {
          this._itemSelectionInProgress = false;
          if (this._isEventAllowItemSelection(evt)) {
            // re-enable dnd
            this._temporaryEnabledDndOnItem(this._dndItemEnabled, this._firstItemSelected);
          }
        },

        /**
         * Handle mouseUp event for table items
         * @param {Object} evt - mouseup event
         */
        _onItemMouseUp: function(evt) {

          // unbind mousemove event
          this.getElement().off("mousemove.TableWidget");

          this._itemSelectionMouseMovePrevX = 0;
          this._itemSelectionMouseMovePrevY = 0;

          this._stopInProgressItemSelection(evt);
        },

        /**
         * Handle mouseLeave event for table items
         * @param {Object} evt - mouseleave event
         */
        _onItemMouseLeave: function(evt) {
          this._stopInProgressItemSelection(evt);
        },

        /**
         * Handle mouseMove event for table items
         * @param {Object} evt - mousemove event
         */
        _onItemMouseMove: function(evt) {
          var movementX = (this._itemSelectionMouseMovePrevX ? evt.screenX - this._itemSelectionMouseMovePrevX : 0);
          var movementY = (this._itemSelectionMouseMovePrevY ? evt.screenY - this._itemSelectionMouseMovePrevY : 0);

          if (Math.abs(movementX) > 1 || Math.abs(movementY) > 1) { // execute code only if movement > 1px
            if (this._itemSelectionInProgress && this._isEventAllowItemSelection(evt)) {
              var itemWidget = gbc.WidgetService.getWidgetFromElement(evt.target, "gbc_TableColumnItemWidget");
              if (!!itemWidget) {
                if (this._firstItemSelected !== null) {
                  this._setItemSelection(true, this._firstItemSelected, itemWidget);
                }
              }
            }
          }

          this._itemSelectionMouseMovePrevX = evt.screenX;
          this._itemSelectionMouseMovePrevY = evt.screenY;
        },

        /**
         * Copy current items selection in the clipboard
         */
        _copySelectionInClipboard: function() {
          var rows = [];
          var rowIndex;

          var orderedColumns = this.getOrderedColumns();
          for (var i = 0; i < orderedColumns.length; i++) {
            var col = orderedColumns[i];

            rowIndex = 0;
            for (var j = 0; j < col.getChildren().length; j++) {
              var item = col.getChildren()[j];

              if (item.isClientSelected()) {

                var text = item.getChildren()[0].getClipboardValue() + "\t";
                if (rows.length <= rowIndex) {
                  rows.push(text);
                } else {
                  rows[rowIndex] += text;
                }
                rowIndex++;
              }
            }
          }
          for (i = 0; i < rows.length; ++i) {
            rows[i] = rows[i].substring(0, rows[i].length - 1);
          }
          cls.ClipboardHelper.copyTo(rows.join("\r\n"), this._element);
        },

        /**
         * Copy current row items in the clipboard
         */
        _copyCurrentRowInClipboard: function() {
          var row = "";

          var orderedColumns = this.getOrderedColumns();
          for (var i = 0; i < orderedColumns.length; i++) {
            var col = orderedColumns[i];
            if (!col.isHidden()) {
              if (this._currentRow >= 0 && this._currentRow < col.getChildren().length) {
                var item = col.getChildren()[this._currentRow];
                row += item.getChildren()[0].getClipboardValue();
                if (i < orderedColumns.length - 1) {
                  row += '\t';
                }
              }
            }
          }

          cls.ClipboardHelper.copyTo(row, this._element);
        },

        /**
         * Copy current cell item in the clipboard
         */
        _copyCurrentCellInClipboard: function() {
          var cell = "";
          var col = this.getColumns()[this._currentColumn];

          if (this._currentRow >= 0 && this._currentRow < col.getChildren().length) {
            var item = col.getChildren()[this._currentRow];
            cell = item.getChildren()[0].getClipboardValue();
          }

          cls.ClipboardHelper.copyTo(cell, this._element);
        },

        /**
         * Select items
         * @param {boolean} b - true/false select or unselect items
         * @param {classes.TableColumnItemWidget} [startSelectedItem]
         * @param {classes.TableColumnItemWidget} [endSelectedItem]
         */
        _setItemSelection: function(b, startSelectedItem, endSelectedItem) {

          var realStartRow = -1;
          var realEndRow = -1;
          var realStartCol = -1;
          var realEndCol = -1;

          this._itemSelectionHasChanged = false;

          if (b && !!startSelectedItem && !!endSelectedItem) {

            var startCol = startSelectedItem.getParentWidget().getOrderedColumnIndex();
            var startRow = startSelectedItem.getItemIndex();
            var endCol = !endSelectedItem ? startCol : endSelectedItem.getParentWidget().getOrderedColumnIndex();
            var endRow = !endSelectedItem ? startRow : endSelectedItem.getItemIndex();

            realStartRow = (startRow < endRow) ? startRow : endRow;
            realEndRow = (startRow < endRow) ? endRow : startRow;
            realStartCol = (startCol < endCol) ? startCol : endCol;
            realEndCol = (startCol < endCol) ? endCol : startCol;

            var mostLeftItem = (realStartCol === startCol) ? startSelectedItem : endSelectedItem;
            var mostRightItem = (realStartCol === startCol) ? endSelectedItem : startSelectedItem;
            var left = mostLeftItem.getElement().getBoundingClientRect().left;
            var right = mostRightItem.getElement().getBoundingClientRect().right;

            var mostTopItem = (realStartRow === startRow) ? startSelectedItem : endSelectedItem;
            var mostBottomItem = (realStartRow === startRow) ? endSelectedItem : startSelectedItem;
            var top = mostTopItem.getElement().getBoundingClientRect().top;
            var bottom = mostBottomItem.getElement().getBoundingClientRect().bottom;
            var tableTop = this.getElement().getBoundingClientRect().top;
            var tableLeft = this.getElement().getBoundingClientRect().left;

            this.setStyle(".gbc_TableItemSelectionArea", {
              "left": (left - tableLeft) + "px",
              "top": (top - tableTop) + "px",
              "width": (right - left) + "px",
              "height": (bottom - top) + "px"
            });

            this._itemSelectionElement.removeClass("hidden");
            this._itemSelectionHasChanged = true;
          }

          for (var i = 0; i < this.getOrderedColumns().length; i++) {
            var col = this.getOrderedColumns()[i];
            for (var j = 0; j < col.getChildren().length; j++) {
              var item = col.getChildren()[j];

              var select = (b && i >= realStartCol && i <= realEndCol && j >= realStartRow && j <= realEndRow);
              item.setClientSelected(select);
            }
          }
        },

        /**
         * Enable or disable Dnd on a item
         * @param {boolean} b - true/false enable/disable Dnd on item
         * @param {classes.TableColumnItemWidget} item
         */
        _temporaryEnabledDndOnItem: function(b, item) {
          if (item) {
            item.setDndEnabled(b);

            if (b) {
              this.getColumnsContainer().setAttribute("draggable", "true");
            } else {
              this.getColumnsContainer().removeAttribute("draggable");
            }
          }
        },
        // ============== END - ITEMS CLIENT SELECTION FUNCTIONS ===================

        // ============== START - ITEMS DnD FUNCTIONS ===================
        /**
         * Enable Dnd of items
         * @param {boolean} b
         */
        setDndItemEnabled: function(b) {
          if (b && this._defaultItemSelection) {
            return; // no dnd if default is item selection
          }

          if (this._dndItemEnabled !== b) {
            this._dndItemEnabled = b;

            var columns = this.getColumns();
            for (var i = 0; i < columns.length; i++) {
              columns[i].setDndItemEnabled(b);
            }

            var columnsContainer = this.getColumnsContainer();
            if (b) {
              columnsContainer.setAttribute("draggable", "true");
              columnsContainer.on("dragstart.TableWidget", this._onItemDragStart.bind(this));
              columnsContainer.on("dragend.TableWidget", this._onItemDragEnd.bind(this));
              columnsContainer.on("dragover.TableWidget", this._onItemDragOver.bind(this));
              columnsContainer.on("drop.TableWidget", this._onItemDrop.bind(this));
              columnsContainer.on("dragleave.TableWidget", this._onItemDragLeave.bind(this));
              columnsContainer.on("dragenter.TableWidget", this._onItemDragEnter.bind(this));
            } else {
              columnsContainer.removeAttribute("draggable");
              columnsContainer.off("dragstart.TableWidget");
              columnsContainer.off("dragend.TableWidget");
              columnsContainer.off("dragover.TableWidget");
              columnsContainer.off("drop.TableWidget");
              columnsContainer.off("dragleave.TableWidget");
              columnsContainer.off("dragenter.TableWidget");
            }
          }
        },

        /**
         * Handle dragStart event for table items
         * @param {Object} evt - dragstart event
         */
        _onItemDragStart: function(evt) {
          var itemWidget = gbc.WidgetService.getWidgetFromElement(evt.target, "gbc_TableColumnItemWidget");
          if (!!itemWidget) {
            itemWidget.onDragStart(evt);
          }
        },
        /**
         * Handle dragEnd event for table items
         * @param {Object} evt - dragend event
         */
        _onItemDragEnd: function(evt) {
          var itemWidget = gbc.WidgetService.getWidgetFromElement(evt.target, "gbc_TableColumnItemWidget");
          if (!!itemWidget) {
            itemWidget.onDragEnd(evt);
          }
        },
        /**
         * Handle dragOver event for table items
         * @param {Object} evt - dragover event
         */
        _onItemDragOver: function(evt) {
          var itemWidget = gbc.WidgetService.getWidgetFromElement(evt.target, "gbc_TableColumnItemWidget");
          if (!!itemWidget) {
            itemWidget.onDragOver(evt);
          } else {
            if (evt.target.hasClass("gbc_TableAfterLastItemZone")) {
              var columnWidget = gbc.WidgetService.getWidgetFromElement(evt.target, "gbc_TableColumnWidget");
              columnWidget.onDragOverAfterLastItem(evt);
            }
          }
        },
        /**
         * Handle drop event for table items
         * @param {Object} evt - drop event
         */
        _onItemDrop: function(evt) {
          var itemWidget = gbc.WidgetService.getWidgetFromElement(evt.target, "gbc_TableColumnItemWidget");
          if (!!itemWidget) {
            itemWidget.onDrop(evt);
          } else {
            if (evt.target.hasClass("gbc_TableAfterLastItemZone")) {
              var columnWidget = gbc.WidgetService.getWidgetFromElement(evt.target, "gbc_TableColumnWidget");
              columnWidget.onDropAfterLastItem(evt);
            }
          }
        },
        /**
         * Handle dragLeave event for table items
         * @param {Object} evt - dragleave event
         */
        _onItemDragLeave: function(evt) {
          var itemWidget = gbc.WidgetService.getWidgetFromElement(evt.target, "gbc_TableColumnItemWidget");
          if (!!itemWidget) {
            itemWidget.onDragLeave(evt);
          }
        },
        /**
         * Handle dragEnter event for table items
         * @param {Object} evt - dragenter event
         */
        _onItemDragEnter: function(evt) {
          var itemWidget = gbc.WidgetService.getWidgetFromElement(evt.target, "gbc_TableColumnItemWidget");
          if (!!itemWidget) {
            itemWidget.onDragEnter(evt);
          }
        },
        // ============== END - ITEMS DnD FUNCTIONS =====================

        // ============== START - Other Event handler FUNCTIONS ===================

        /**
         * Handle double click event
         * @param {Object} evt - dblclick event
         */
        _onDoubleClick: function(evt) {
          var columnWidget = gbc.WidgetService.getWidgetFromElement(evt.target, "gbc_TableColumnWidget");
          if (!columnWidget) {
            return;
          }
          if (this.isRowActionTriggerByDoubleClick()) {
            columnWidget.emit(context.constants.widgetEvents.rowAction);
          }
        },

        /**
         * Handle long touch event
         * @param {*} evt
         */
        _onLongTouch: function(evt) {
          var columnTitleWidget = gbc.WidgetService.getWidgetFromElement(evt.target, "gbc_TableColumnTitleWidget");
          if (!!columnTitleWidget) {
            columnTitleWidget.manageMouseRightClick(evt);
          } else {
            $super.manageMouseRightClick.call(this, evt);
          }
        },
        // ============== END - Other Event handler FUNCTIONS ===================

        // ============== START - DOM ELEMENT GETTERS ===================
        /**
         * Returns left container DOM Element (contains left frozen columns/headers/footers elements)
         * @returns {HTMLElement} left container DOM Element
         * @publicdoc
         */
        getLeftContainer: function() {
          if (!this._leftContainerElement) {
            this._leftContainerElement = this._element.getElementsByClassName("gbc_TableLeftContainer")[0];
          }
          return this._leftContainerElement;
        },

        /**
         * Returns right container DOM Element (contains right frozen columns/headers/footers elements)
         * @returns {HTMLElement} right container DOM Element
         * @publicdoc
         */
        getRightContainer: function() {
          if (!this._rightContainerElement) {
            this._rightContainerElement = this._element.getElementsByClassName("gbc_TableRightContainer")[0];
          }
          return this._rightContainerElement;
        },

        /**
         * Returns columns container DOM Element
         * @returns {HTMLElement} columns container DOM Element
         * @publicdoc
         */
        getColumnsContainer: function() {
          if (!this._columnsContainerElement) {
            this._columnsContainerElement = this._element.getElementsByClassName("gbc_TableColumnsContainer")[0];
          }
          return this._columnsContainerElement;
        },

        /**
         * Returns left frozen columns container DOM Element
         * @returns {HTMLElement} left frozen columns container DOM Element
         * @publicdoc
         */
        getLeftColumnsContainer: function() {
          if (!this._leftColumnsContainer) {
            this._leftColumnsContainer = this._element.getElementsByClassName("gbc_TableLeftColumnsContainer")[0];
          }
          return this._leftColumnsContainer;
        },

        /**
         * Returns right frozen columns container DOM Element
         * @returns {HTMLElement} right frozen columns container DOM Element
         * @publicdoc
         */
        getRightColumnsContainer: function() {
          if (!this._rightColumnsContainer) {
            this._rightColumnsContainer = this._element.getElementsByClassName("gbc_TableRightColumnsContainer")[0];
          }
          return this._rightColumnsContainer;
        },

        /**
         * Returns columns headers DOM Element
         * @returns {HTMLElement} columns headers DOM Element
         * @publicdoc
         */
        getColumnsHeaders: function() {
          if (!this._columnsHeaders) {
            this._columnsHeaders = this._element.getElementsByClassName("gbc_TableColumnsHeaders")[0];
          }
          return this._columnsHeaders;
        },

        /**
         * Returns left frozen columns headers DOM Element
         * @returns {HTMLElement} left frozen columns headers DOM Element
         * @publicdoc
         */
        getLeftColumnsHeaders: function() {
          if (!this._leftColumnsHeaders) {
            this._leftColumnsHeaders = this._element.getElementsByClassName("gbc_TableLeftColumnsHeaders")[0];
          }
          return this._leftColumnsHeaders;
        },

        /**
         * Returns right frozen columns headers DOM Element
         * @returns {HTMLElement} right frozen columns headers DOM Element
         * @publicdoc
         */
        getRightColumnsHeaders: function() {
          if (!this._rightColumnsHeaders) {
            this._rightColumnsHeaders = this._element.getElementsByClassName("gbc_TableRightColumnsHeaders")[0];
          }
          return this._rightColumnsHeaders;
        },

        /**
         * Returns columns footer DOM Element
         * @returns {HTMLElement} columns footer DOM Element
         * @publicdoc
         */
        getColumnsFooter: function() {
          if (!this._columnsFooter) {
            this._columnsFooter = this.getElement().getElementsByClassName("gbc_TableColumnsFooter")[0];
          }
          return this._columnsFooter;
        },

        /**
         * Returns left columns footer DOM Element
         * @returns {HTMLElement} left columns footer DOM Element
         * @publicdoc
         */
        getLeftColumnsFooter: function() {
          if (!this._leftColumnsFooter) {
            this._leftColumnsFooter = this.getElement().getElementsByClassName("gbc_TableLeftColumnsFooter")[0];
          }
          return this._leftColumnsFooter;
        },

        /**
         * Returns right columns footer DOM Element
         * @returns {HTMLElement} right columns footer DOM Element
         * @publicdoc
         */
        getRightColumnsFooter: function() {
          if (!this._rightColumnsFooter) {
            this._rightColumnsFooter = this.getElement().getElementsByClassName("gbc_TableRightColumnsFooter")[0];
          }
          return this._rightColumnsFooter;
        },

        /**
         * @inheritDoc
         */
        getScrollableArea: function() {
          if (!this._scrollAreaElement) {
            this._scrollAreaElement = this._element.getElementsByClassName("gbc_TableScrollArea")[0];
          }
          return this._scrollAreaElement;
        },

        /**
         * Returns right frozen columns scrollable area DOM Element
         * @returns {HTMLElement} right frozen columns scrollable area DOM Element
         */
        getRightScrollableArea: function() {
          if (!this._rightScrollAreaElement) {
            this._rightScrollAreaElement = this._element.getElementsByClassName("gbc_TableRightScrollArea")[0];
          }
          return this._rightScrollAreaElement;
        },

        /**
         * Returns left frozen columns scrollable area DOM Element
         * @returns {HTMLElement} left frozen columns scrollable area DOM Element
         */
        getLeftScrollableArea: function() {
          if (!this._leftScrollAreaElement) {
            this._leftScrollAreaElement = this._element.getElementsByClassName("gbc_TableLeftScrollArea")[0];
          }
          return this._leftScrollAreaElement;
        },

        /**
         * Returns aggregate global text DOM Element
         * @returns {HTMLElement} aggregate global text DOM Element
         */
        getAggregateGlobalTextElement: function() {
          return this._aggregateGlobalTextElement;
        }

        // ============== END - DOM ELEMENT GETTERS =====================
      };
    });
    cls.WidgetFactory.registerBuilder('Table', cls.TableWidget);
  });
;
"use strict";

modulum('TableWidgetBase', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * TableWidgetBase widget (abstract class for TableWidget & ListViewWidget).
     * @class TableWidgetBase
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     * @publicdoc
     */
    cls.TableWidgetBase = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.TableWidgetBase.prototype */ {
        __name: "TableWidgetBase",

        /** @type {boolean} */
        __virtual: true,

        /** @type {number} */
        _currentRow: 0,
        /** @type {number} */
        _size: 0,
        /** @type {number} */
        _offset: 0,
        /** @type {number} */
        _pageSize: 0,
        /** @type {?number} */
        _firstPageSize: null,
        /** @type {boolean} */
        _fixedPageSize: false,
        /** @type {number} */
        _visibleRows: 0,

        /** @type {boolean} */
        _inputMode: false,
        /** @type {number} */
        _rowHeight: 0,

        /** @type {?boolean} */
        _rowActionTriggerByDoubleClick: true,
        /** @type {?string} */
        _highlightColor: null,
        /** @type {?string} */
        _highlightTextColor: null,
        /** @type {?boolean} */
        _highlightCurrentRow: null,
        /** @type {classes.UserInterfaceWidget} */
        _uiWidget: null,
        /** @type {classes.FolderWidgetBase} */
        _folderPageWidget: null,

        /** Handlers */
        /** @function */
        _uiActivateHandler: null,
        /** @function */
        _pageActivateHandler: null,

        /** @type {HTMLElement} */
        _scrollAreaElement: null,

        /** @type {classes.ContextMenuWidget} */
        _rowBoundWidget: null,

        /** @type {boolean} */
        _hasReduceFilter: false,

        /**
         * @constructs
         * @param {*} opts - Options passed to the constructor
         */
        constructor: function(opts) {
          opts = opts || {};
          this._uiWidget = opts.uiWidget;
          this._folderPageWidget = opts.folderPageWidget;

          $super.constructor.call(this, opts);
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._uiActivateHandler) {
            this._uiActivateHandler();
            this._uiActivateHandler = null;
          }
          if (this._pageActivateHandler) {
            this._pageActivateHandler();
            this._pageActivateHandler = null;
          }
          this._uiWidget = null;
          this._folderPageWidget = null;
          this._scrollAreaElement = null;
          this._rowBoundWidget = null;

          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          this.setFocusable(true);

          this._uiActivateHandler = this._uiWidget.onActivate(this.updateVerticalScroll.bind(this, true));
          if (this._folderPageWidget) {
            this._pageActivateHandler = this._folderPageWidget.onActivate(this.updateVerticalScroll.bind(this, true));
          }
        },

        /**
         * @inheritDoc
         */
        resetLayout: function() {
          $super.resetLayout.call(this);
          this._rowHeight = 0;
        },

        /**
         * @inheritDoc
         */
        managePriorityKeyDown: function(keyString, domKeyEvent, repeat) {
          var keyProcessed = false;
          if (this._rowBoundWidget && this._rowBoundWidget.isVisible()) {
            keyProcessed = this._rowBoundWidget.managePriorityKeyDown(keyString, domKeyEvent, repeat);
          }
          return keyProcessed;
        },

        /**
         * @inheritDoc
         */
        addChildWidget: function(widget, options) {
          if (widget.isInstanceOf(cls.ContextMenuWidget)) {
            // Rowbound menu
            this._rowBoundWidget = widget;
            this._rowBoundWidget.setParentWidget(this);
          } else {
            $super.addChildWidget.call(this, widget, options);
          }
        },

        /**
         * @inheritDoc
         */
        removeChildWidget: function(widget) {
          $super.removeChildWidget.call(this, widget);

          if (widget.isInstanceOf(cls.ContextMenuWidget)) {
            this._rowBoundWidget = null;
          }
        },

        /**
         * Set the DOM focus to the widget
         * @param {boolean} [noScroll] - if true try to disable auto scroll
         * @publicdoc
         */
        domFocus: function(noScroll) {
          if (this._element) {
            if (!noScroll) {
              this._element.domFocus();
            } else {
              // try to not scroll when focus
              this._element.domFocus(null, this.getFormWidget().getContainerElement());
            }
          }
        },

        /**
         * Change current row
         * @param {number} row - new current row
         * @param {boolean} [ensureRowVisible] - if true scroll to be sure row is visible (useful when first row is partially visible)
         */
        setCurrentRow: function(row, ensureRowVisible) {
          // TO BE IMPLEMENTED
        },

        /**
         * Returns current row
         * @returns {number} current row
         * @publicdoc
         */
        getCurrentRow: function() {
          return this._currentRow;
        },

        /**
         * Defines the table pageSize
         * @param {number} pageSize - page size
         */
        setPageSize: function(pageSize) {
          this._setFirstPageSize(pageSize);
          this._pageSize = pageSize;
        },

        /**
         * Keep the first pageSize
         * @param {number} pageSize - page size
         */
        _setFirstPageSize: function(pageSize) {
          if (this._firstPageSize === null) {
            this._firstPageSize = pageSize;
          }
        },

        /**
         * Returns page size
         * @returns {?number} the page size
         * @publicdoc
         */
        getPageSize: function() {
          return this._pageSize;
        },

        /**
         * Defines if pageSize is fixed
         * @param {boolean} fixed - true if page size is fixed
         */
        setFixedPageSize: function(fixed) {
          if (this._fixedPageSize !== fixed) {
            this._fixedPageSize = fixed;
            this._layoutInformation.getStretched().setDefaultY(true);
          }
        },

        /**
         * Returns if pageSize is fixed
         * @returns {boolean} true if pageSize is fixed
         * @publicdoc
         */
        isFixedPageSize: function() {
          return this._fixedPageSize;
        },

        /**
         * Returns table size
         * @returns {number} the table size
         * @publicdoc
         */
        getSize: function() {
          return this._size;
        },

        /**
         * Defines the table size (total number of row)
         * @param {number} size - size value
         */
        setSize: function(size) {
          this._size = size;
        },

        /**
         * Defines the table offset
         * @param {number} offset - offset value
         */
        setOffset: function(offset) {
          this._offset = offset;
        },

        /**
         * Returns table offset
         * @returns {number} the table offset
         * @publicdoc
         */
        getOffset: function() {
          return this._offset;
        },

        /**
         * Sets the number of visible rows
         * @param {number} visibleRows - number of visible rows
         */
        setVisibleRows: function(visibleRows) {
          this._visibleRows = visibleRows;
        },

        /**
         * Returns number of visible rows
         * @returns {number} the number of visible rows
         */
        getVisibleRows: function() {
          return this._visibleRows;
        },

        /**
         * Sets if table is in "input" mode.
         * @param {boolean} b - input mode
         * @publicdoc
         */
        setInputMode: function(b) {
          if (this._inputMode !== b) {
            this._inputMode = b;
            this._element.toggleClass("inputMode", !!b);
          }
        },

        /**
         * Returns if table is in input mode.
         * @returns {boolean} true if input mode
         * @publicdoc
         */
        isInputMode: function() {
          return this._inputMode;
        },

        /**
         * Returns if table is in display mode.
         * @returns {boolean} true if display mode
         * @publicdoc
         */
        isDisplayMode: function() {
          return !this._inputMode;
        },

        /**
         * Sets the height of rows
         * @param {number} height - row height (pixels)
         * @publicdoc
         */
        setRowHeight: function(height) {
          this._rowHeight = height;
        },

        /**
         * Returns the row height in pixels
         * @returns {number} row height
         * @publicdoc
         */
        getRowHeight: function() {
          return this._rowHeight;
        },

        /**
         * Call when a widget in the table request the focus
         * @param {classes.WidgetBase} widget - widget that request focus
         * @param {Object} event - event that request focus
         */
        requestFocusFromWidget: function(widget, event) {
          widget.emit(context.constants.widgetEvents.requestFocus, event);
        },

        /**
         * @returns {number} table data area height
         */
        getDataAreaHeight: function() {
          return this.getLayoutInformation().getAllocated().getHeight() - this.getLayoutInformation().getDecorating().getHeight();
        },

        /**
         * @returns {number} table data area width
         */
        getDataAreaWidth: function() {
          return this.getLayoutInformation().getAllocated().getWidth() - this.getLayoutInformation().getDecorating().getWidth();
        },

        /**
         * Indicates how the row action must be triggered.
         * @param {boolean} b - true if action is triggered by double click (else it is single click)
         */
        setRowActionTriggerByDoubleClick: function(b) {
          this._rowActionTriggerByDoubleClick = b;
        },

        /**
         * Indicates how the row action must be triggered.
         * @returns {boolean} true if action is triggered by double click (else it is single click)
         */
        isRowActionTriggerByDoubleClick: function() {
          return this._rowActionTriggerByDoubleClick;
        },

        /**
         * Defines the highlight color of rows for the table
         * @param {string} color - CSS color
         */
        setHighlightColor: function(color) {
          // TO BE IMPLEMENTED
        },

        /**
         * Defines the highlighted text color of rows for the table
         * @param {string} color - CSS color
         */
        setHighlightTextColor: function(color) {
          // TO BE IMPLEMENTED
        },

        /**
         * Indicates if the current row must be highlighted
         * @param {boolean} b - true if current row must be highlighted
         */
        setHighlightCurrentRow: function(b) {
          this._highlightCurrentRow = b;
        },

        /**
         * Return if the current row must be highlighted
         * @returns {?boolean} true if current row must be highlighted
         * @publicdoc
         */
        isHighlightCurrentRow: function() {
          return this._highlightCurrentRow;
        },

        /**
         * Update vertical scroll
         * @param {boolean} [forceScroll] - true to force scrolling
         */
        updateVerticalScroll: function(forceScroll) {
          this.updateContentPosition(this._size, this._pageSize, this._offset, forceScroll);
        },

        /**
         * Sets vertical scroll parameters
         * BEWARE this code should be the same as ScrollGridWidget::updateContentPosition
         * @param {?number} size
         * @param {?number} pageSize
         * @param {?number} offset
         * @param {boolean} forceScroll
         */
        updateContentPosition: function(size, pageSize, offset, forceScroll) {
          // TO BE IMPLEMENTED
        },

        /**
         * Returns scrollable area DOM Element
         * @returns {HTMLElement} scrollable area DOM Element
         */
        getScrollableArea: function() {
          // TO BE IMPLEMENTED
        },

        /**
         * Returns rowBound widget
         * @returns {classes.ContextMenuWidget} rowBound
         */
        getRowBoundWidget: function() {
          return this._rowBoundWidget;
        },

        /**
         * Returns if rowBound is activated
         * @returns {boolean} rowBound activated ?
         */
        hasRowBound: function() {
          return this._rowBoundWidget !== null;
        },

        /**
         * Indicates if the table can have a reduce filter
         * @param {boolean} b - true if table can have a reduce filter
         */
        setReduceFilter: function(b) {
          this._hasReduceFilter = b;
        },

        /**
         * Return if the table can have a reduce filter
         * @returns {boolean} true if table can have a reduce filter
         */
        hasReduceFilter: function() {
          return this._hasReduceFilter;
        },

        /**
         * Returns if table is a tree
         * @returns {boolean} true if table is a tree
         * @publicdoc
         */
        isTreeView: function() {
          return false;
        },
      };
    });
  });
;
"use strict";

modulum('TraditionalScreenWidget', ['WidgetGridLayoutBase'],
  function(context, cls) {

    /**
     * Base class for widget group.
     * @class TraditionalScreenWidget
     * @memberOf classes
     * @extends classes.WidgetGridLayoutBase
     */
    cls.TraditionalScreenWidget = context.oo.Class(cls.WidgetGridLayoutBase, function($super) {
      return /** @lends classes.TraditionalScreenWidget.prototype */ {
        __name: "TraditionalScreenWidget",

        _initLayout: function() {
          this._layoutInformation = new cls.LayoutInformation(this);
          this._layoutEngine = new cls.TraditionalLayoutEngine(this);
        }
      };
    });
    cls.WidgetFactory.registerBuilder('TraditionalScreen', cls.TraditionalScreenWidget);
  });
;
"use strict";

modulum('TraditionalWindowContainerWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Base class for widgets.
     * @class TraditionalWindowContainerWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     */
    cls.TraditionalWindowContainerWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.TraditionalWindowContainerWidget.prototype */ {
        __name: "TraditionalWindowContainerWidget",

        constructor: function(opts) {
          $super.constructor.call(this, opts);
        }
      };
    });
    cls.WidgetFactory.registerBuilder('TraditionalWindowContainer', cls.TraditionalWindowContainerWidget);
  });
;
"use strict";

modulum('TraditionalWindowWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Base class for widgets.
     * @class TraditionalWindowWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     */
    cls.TraditionalWindowWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.TraditionalWindowWidget.prototype */ {
        __name: "TraditionalWindowWidget",

        constructor: function(opts) {
          $super.constructor.call(this, opts);
        }

      };
    });
    cls.WidgetFactory.registerBuilder('TraditionalWindow', cls.TraditionalWindowWidget);
  });
;
"use strict";

modulum('UserInterfaceWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * UserInterface widget.
     * @class UserInterfaceWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     * @publicdoc Widgets
     */
    cls.UserInterfaceWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.UserInterfaceWidget.prototype */ {
        __name: "UserInterfaceWidget",

        $static: {
          startMenuPosition: 'gStartMenuPosition'
        },

        _text: "",
        _image: null,
        _topMenuContainer: null,
        _toolBarContainer: null,
        _startMenuWidget: null,
        _startMenuContainer: null,
        _sidebarWidget: null,
        _traditionalWindowContainer: null,
        /** @type {?number} */
        _currentWindowIdRef: null,
        /**
         * VM Focused widget
         * @type {classes.WidgetBase}
         */
        _vmFocusedWidget: null,
        /**
         * VM Previously Focused widget
         * @type {classes.WidgetBase}
         */
        _vmPreviouslyFocusedWidget: null,
        /**
         * Client focused widget
         * @type {classes.WidgetBase}
         */
        _focusedWidget: null,
        /**
         * Previously Focused widget
         * @type {classes.WidgetBase}
         */
        _previouslyFocusedWidget: null,

        _dbDate: "MDY4/", // default format
        _unBindLayoutHandler: null,
        _activeWindow: null,
        _errorMessageWidget: null,

        /** @type {Node} */
        _chromeBarContainer: null,
        /** @type {classes.ChromeBarWidget} */
        _chromeBar: null,

        /**
         * Typeahead
         */
        _isBufferingKeys: null,

        _browserResizeHandler: null,
        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          this._chromeBarContainer = this._element.getElementsByClassName("gbc_chromeBarContainer")[0];
          this._topMenuContainer = this._element.getElementsByClassName("gbc_topMenuContainer")[0];
          this._toolBarContainer = this._element.getElementsByClassName("gbc_toolBarContainer")[0];
          this._startMenuContainer = this._element.getElementsByClassName("gbc_startMenuContainer")[0];
          this._errorMessageWidget = cls.WidgetFactory.createWidget("Message", this.getBuildParameters());
          this._errorMessageWidget.setHidden(true);

          if (!gbc.ThemeService.getValue("theme-legacy-topbar")) {
            this._chromeBar = cls.WidgetFactory.createWidget("ChromeBar", this.getBuildParameters());
            var appHost = context.HostService.getApplicationHostWidget();
            this._chromeBar.when(context.constants.widgetEvents.toggleClick, appHost.showSidebar.bind(appHost));
            this.addChromeBar();
          }
          this._browserResizeHandler = context.HostService.onScreenResize(function() {
            this.getLayoutEngine().forceMeasurement();
            this.getLayoutInformation().invalidateMeasure();
          }.bind(this));
        },
        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._browserResizeHandler) {
            this._browserResizeHandler();
            this._browserResizeHandler = null;
          }
          this._topMenuContainer = null;
          this._toolBarContainer = null;
          this._startMenuContainer = null;
          if (this._unBindLayoutHandler) {
            this._unBindLayoutHandler();
            this._unBindLayoutHandler = null;
          }
          this._chromeBarContainer = null;
          if (this._chromeBar) {
            this._chromeBar.destroy();
            this._chromeBar = null;
          }
          this._errorMessageWidget.destroy();
          this._errorMessageWidget = null;
          this._vmFocusedWidget = null;
          this._focusedWidget = null;
          $super.destroy.call(this);
          this._startMenuWidget = null;
        },
        /**
         * @inheritDoc
         */
        _initLayout: function() {
          this._layoutInformation = new cls.LayoutInformation(this);
          this._layoutEngine = new cls.UserInterfaceLayoutEngine(this);
          this._unBindLayoutHandler = this._layoutEngine.onLayoutApplied(this._onLayoutApplied.bind(this));
        },

        _onLayoutApplied: function() {
          if (this.getContainerElement().children.length > 1) {
            for (var i = 0; i < this.getChildren().length; i++) {
              var current = this.getChildren()[i];
              if (this._canBeRemoved(current)) {
                current.getElement().remove();
              }
            }
          }

          if (this._unBindLayoutHandler) {
            this._unBindLayoutHandler();
            this._unBindLayoutHandler = null;
          }
        },

        _canBeRemoved: function(widget) {
          return widget instanceof cls.WindowWidget &&
            (context.HostService.getCurrentWindow() &&
              widget !== context.HostService.getCurrentWindow()) &&
            !widget._forceVisible;
        },

        getSidebarWidget: function() {
          return this._sidebarWidget;
        },
        setSidebarWidget: function(widget) {
          this._sidebarWidget = widget;
        },
        getMessageWidget: function() {
          return this._errorMessageWidget;
        },

        /**
         * Get the chromebar widget if any
         * @return {*|null}
         */
        getChromeBarWidget: function() {
          return this._chromeBar;
        },

        /**
         * @inheritDoc
         */
        addChildWidget: function(widget, options) {
          $super.addChildWidget.call(this, widget, options);
          if (widget instanceof cls.WindowWidget && !!this.getSidebarWidget()) {
            this.getSidebarWidget().addChildWidget(widget.getSidebarWidget());
          }
          if (options && !options.noDOMInsert) {
            this._syncCurrentWindow();
          }
        },

        /**
         * @inheritDoc
         * @param {classes.ApplicationWidget} widget
         */
        removeChildWidget: function(widget) {
          if (widget instanceof cls.WindowWidget && !!this.getSidebarWidget()) {
            this.getSidebarWidget().removeChildWidget(widget.getSidebarWidget());
          }
          $super.removeChildWidget.call(this, widget);
        },

        addTopMenu: function(widget, order) {
          widget.setOrder(order);
          if (widget.getParentWidget() === null) {
            this.addChildWidget(widget, {
              noDOMInsert: true
            });
          }
          widget.getElement().insertAt(order, this._topMenuContainer);
        },

        /**
         * Add the chromebar to the dom
         */
        addChromeBar: function() {
          if (this._chromeBar) {
            this.addChildWidget(this._chromeBar, {
              noDOMInsert: true
            });
            this._chromeBarContainer.appendChild(this._chromeBar.getElement());
          }
        },

        addStartMenu: function(widget) {
          this._startMenuWidget = widget;
          this._startMenuContainer.appendChild(widget.getElement());
        },

        getStartMenuWidget: function() {
          return this._startMenuWidget;
        },

        /**
         * Add a toolbar in the good container
         * @param widget
         * @param order
         * @param widgetContainer
         * @param chromeBar
         */
        addToolBar: function(widget, order, widgetContainer, chromeBar) {
          widget.setOrder(order);
          if (widget.getParentWidget() === null) {
            this.addChildWidget(widget, {
              noDOMInsert: true
            });
          }
          //add it to the chromebar if any
          if (chromeBar) {
            chromeBar.addToolBar(widget, order);
          } else {
            this._toolBarContainer.appendChild(widget._element);
          }

        },
        /**
         * Sets the current window
         * @param windowIdRef
         */
        setCurrentWindowId: function(windowIdRef) {
          var currentChanged = this._currentWindowIdRef !== windowIdRef;
          if (currentChanged) {
            this._currentWindowIdRef = windowIdRef;
            this._syncCurrentWindow();
          }
        },

        _syncCurrentWindow: function() {
          var currentWin = this.getCurrentWindow();
          if (currentWin) {

            currentWin._sidebarItemWidget.setCurrent();
            context.HostService.setDisplayedWindow(currentWin);

            this.getLayoutEngine().invalidateAllocatedSpace();
            this.emit(cls.UserInterfaceWidget.startMenuPosition, currentWin._auiTag);
          }
        },
        /**
         * @returns {classes.WindowWidget} the current window
         */
        getCurrentWindow: function() {
          var i;
          var win = null;
          for (i = 0; i < this.getChildren().length; ++i) {
            win = this.getChildren()[i];
            if (!!this._currentWindowIdRef && win._auiTag === this._currentWindowIdRef) {
              return win;
            }
          }
          // If no window has been found, return the traditional window container
          for (i = 0; i < this.getChildren().length; ++i) {
            win = this.getChildren()[i];
            if (win.hasClass("gbc_TraditionalContainerWindow")) {
              return win;
            }
          }
          return null;
        },

        /**
         * @inheritDoc
         */
        setFocus: function(fromMouse) {
          $super.setFocus.call(this, fromMouse);
          this.getElement().domFocus();
        },

        /**
         * Set VM focused widget
         * @param {classes.WidgetBase} widget - widget which gains VM focus
         */
        setVMFocusedWidget: function(widget) {
          this._vmPreviouslyFocusedWidget = this._vmFocusedWidget;
          if (this._vmFocusedWidget !== widget) {
            if (this._vmFocusedWidget) {
              this._vmFocusedWidget.loseVMFocus();
            }
            this._vmFocusedWidget = widget;
          }
        },

        /**
         * Set client focused widget
         * @param {classes.WidgetBase} widget - widget which gains client focus
         */
        setFocusedWidget: function(widget) {
          this._previouslyFocusedWidget = this._focusedWidget;
          if (this._focusedWidget && this._focusedWidget !== widget) {
            if (this._focusedWidget.getElement()) {
              this._focusedWidget.getElement().removeClass("gbc_Focus");
              this._focusedWidget.loseFocus();
            }
          }
          if (!this._focusedWidget || this._focusedWidget !== widget) {
            this._focusedWidget = widget;
            if (this._focusedWidget.getElement()) {
              this._focusedWidget.getElement().addClass("gbc_Focus");
            }
          }
        },

        /**
         * @returns {classes.WidgetBase} current focused widget (by VM)
         */
        getVMFocusedWidget: function() {
          return this._vmFocusedWidget;
        },

        /**
         * @returns {boolean} true if current focused widget changed (by VM)
         */
        hasVMFocusedWidgetChanged: function() {
          return this._vmFocusedWidget !== this._vmPreviouslyFocusedWidget;
        },

        /**
         * @returns {boolean} true if current focused widget changed
         */
        hasFocusedWidgetChanged: function() {
          return this._focusedWidget !== this._previouslyFocusedWidget;
        },

        /**
         * @returns {classes.WidgetBase} current focused widget (by VM)
         */
        getFocusedWidget: function() {
          return this._focusedWidget;
        },
        /**
         * @param {string} text The window title
         */
        setText: function(text) {
          this._text = text;
        },
        /**
         * @returns {string} The window title
         */
        getText: function() {
          return this._text;
        },

        setImage: function(image) {
          this._image = image;
          this.getSidebarWidget().setApplicationIcon(image);
        },

        getImage: function() {
          return this._image;
        },

        getDbDateFormat: function() {
          return this._dbDate;
        },

        setDbDateFormat: function(format) {
          this._dbDate = format;
        },

        getTraditionalWindowContainer: function() {
          if (!this._traditionalWindowContainer) {
            this._traditionalWindowContainer = cls.WidgetFactory.createWidget("TraditionalWindowContainer", this
              .getBuildParameters());
          }
          return this._traditionalWindowContainer;
        },

        removeTraditionalWindowContainer: function() {
          if (this._traditionalWindowContainer) {
            this.removeChildWidget(this._traditionalWindowContainer);
            this._traditionalWindowContainer = null;
          }
        },
        isLayoutTerminator: function() {
          return true;
        },
        activate: function() {
          this.emit(context.constants.widgetEvents.activate);
        },

        onActivate: function(hook) {
          return this.when(context.constants.widgetEvents.activate, hook);
        },
        onDisable: function(hook) {
          return this.when(context.constants.widgetEvents.disable, hook);
        },

        /**
         * @inheritDoc
         */
        setBackgroundColor: function(color) {
          $super.setBackgroundColor.call(this, color);
          this.setStyle('> .gbc_barsContainer', {
            "background-color": !!color && !this._ignoreBackgroundColor ? color : null
          });
        },

        /**
         * Show/hide filter item in chromebar
         * @param {boolean} visible - true if item must be visible
         * @param {String} [filterValue] - initial filter value
         */
        showChromeBarFilterMenuItem: function(visible, filterValue) {
          if (this._chromeBar) {
            this._chromeBar.showFilterMenuItem(visible, filterValue);
          }
        },
      };
    });
    cls.WidgetFactory.registerBuilder('UserInterface', cls.UserInterfaceWidget);
  });
;
"use strict";

modulum('VBoxSplitterWidget', ['SplitterWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Splitter widget.
     * @class VBoxSplitterWidget
     * @memberOf classes
     * @extends classes.SplitterWidget
     */
    cls.VBoxSplitterWidget = context.oo.Class(cls.SplitterWidget, function($super) {
      return /** @lends classes.VBoxSplitterWidget.prototype */ {
        __name: "VBoxSplitterWidget",
        __templateName: "SplitterWidget",
        _initElement: function() {
          $super._initElement.call(this);
          this._element.addClass("gbc_SplitterWidget");
        },
        _initLayout: function() {
          $super._initLayout.call(this);
          this._layoutInformation.setMaximal(cls.Size.maximal, 8);
        },
        _onDragOver: function(evt) {
          $super._onDragOver.call(this, evt);
          this._pagePosition = evt.pageY;
        },
        _updateResizerDrag: function(evt) {
          this._pagePosition = evt.pageY;
          this._resizerDragPosition = evt.pageY;
        },

        // Touch only
        _onTouchStart: function(evt) {
          this._splitStartPos = evt.touches[0].clientY;
          $super._onTouchStart.call(this, evt);
        },

        _onTouchMove: function(evt) {
          this._pagePosition = evt.touches[0].clientY;
          $super._onTouchMove.call(this, evt);
        },

      };
    });
    cls.WidgetFactory.registerBuilder('VBoxSplitter', cls.VBoxSplitterWidget);
  });
;
"use strict";

modulum('VBoxWidget', ['BoxWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * VBox widget
     * @publicdoc Widgets
     * @class VBoxWidget
     * @memberOf classes
     * @extends classes.BoxWidget
     */
    cls.VBoxWidget = context.oo.Class(cls.BoxWidget, function($super) {
      return /** @lends classes.VBoxWidget.prototype */ {
        __name: "VBoxWidget",
        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          this._element.addClass("g_VBoxLayoutEngine");
        },
        /**
         * @inheritDoc
         */
        _initLayout: function() {
          this._layoutInformation = new cls.LayoutInformation(this);
          this._layoutEngine = new cls.VBoxLayoutEngine(this);
        },
        /**
         * @inheritDoc
         */
        _createSplitter: function() {
          return cls.WidgetFactory.createWidget("VBoxSplitter", this.getBuildParameters());
        }
      };
    });
    cls.WidgetFactory.registerBuilder('VBox', cls.VBoxWidget);
    cls.WidgetFactory.registerBuilder('HBox[customWidget=vbox]', cls.VBoxWidget);
  });
;
"use strict";

modulum('WindowWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Base class for widgets.
     * @class WindowWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     * @publicdoc
     */
    cls.WindowWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.WindowWidget.prototype */ {
        __name: "WindowWidget",
        /**
         * @type {classes.ModalWidget}
         */
        _modalWidget: null,

        /**
         * title
         * @type {?string}
         */
        _text: null,
        /**
         * window icon
         * @type {?string}
         */
        _image: null,
        /** @type {classes.SessionSidebarWindowItemWidget} */
        _sidebarItemWidget: null,
        _topMenus: null,
        /** @type {classes.TopMenuWidget} */
        _activeTopMenuWidget: null,
        /** @type {classes.MenuWidget} */
        _menuWidget: null,
        /** @type {classes.ToolBarWidget} */
        _toolBarWidget: null,
        /** @type {classes.TabbedContainerWidget} */
        _tabbedContainerWidget: null,
        _closeHostMenuOnClickHandler: null,
        _menuContainerTop: null,
        _menuContainerBottom: null,
        _menuContainerLeft: null,
        _menuContainerRight: null,
        _menuContainerMiddle: null,
        _toolBarContainer: null,
        _topMenuContainer: null,
        _windowContent: null,
        _toolBarPosition: "top",
        _toolBarInWindow: false, // define if the toolbar is directly in the window or if it is in the global toolbar
        _startMenuType: null,
        _actionsEnabled: false,
        _disabled: false,
        _position: null,
        _positionClass: "gbc_WindowWidget_position_default",
        _processing: false,
        _messageWidget: null,
        /** @type {?number} */
        _parentWindowId: null,

        /**
         * @type {boolean}
         */
        isModal: false,

        /**
         * @constructs
         * @param {Object} opts - Options passed to the constructor
         * @publicdoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          this._sidebarItemWidget = cls.WidgetFactory.createWidget("SessionSidebarWindowItem", this.getBuildParameters());
          this._sidebarItemWidget.setWindowWidget(this);
          this._menuContainerTop = this._element.getElementsByClassName("gbc_WindowMenuContainerTop")[0];

          this._menuContainerBottom = this._element.getElementsByClassName("gbc_WindowMenuContainerBottom")[0];
          this._menuContainerLeft = this._element.getElementsByClassName("gbc_WindowMenuContainerLeft")[0];
          this._menuContainerRight = this._element.getElementsByClassName("gbc_WindowMenuContainerRight")[0];
          this._menuContainerMiddle = this._element.getElementsByClassName("gbc_WindowMenuContainerMiddle")[0];

          this._toolBarContainer = this._element.getElementsByClassName("gbc_WindowToolbarContainer")[0];
          this._topMenuContainer = this._element.getElementsByClassName("gbc_WindowTopMenuContainer")[0];
          this._windowContent = this._element.getElementsByClassName("gbc_WindowContent")[0];

          this._messageWidget = cls.WidgetFactory.createWidget("Message", this.getBuildParameters());
          this._messageWidget.setHidden(true);

          this._topMenus = [];

          context.HostService.registerClosableWindow(this, opts);
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._position = null;
          if (context.HostService.getCurrentWindow() === this) {
            context.HostService.setCurrentWindow(null);
          }
          if (this.getParentWidget() && this.getParentWidget()._activeWindow === this) {
            this.getParentWidget()._activeWindow = null;
          }
          if (this._modalWidget) {
            this._modalWidget.hide();
            this._modalWidget.destroy();
            this._modalWidget = null;
          }

          this._menuContainerTop = null;
          this._menuContainerBottom = null;
          this._menuContainerLeft = null;
          this._menuContainerRight = null;
          this._menuContainerMiddle = null;
          this._toolBarContainer = null;
          this._topMenuContainer = null;
          this._windowContent = null;
          this._messageWidget.destroy();
          this._messageWidget = null;
          this._topMenus.length = 0;
          this._activeTopMenuWidget = null;
          this._menuWidget = null;
          this._toolBarWidget = null;

          if (this._tabbedContainerWidget) {
            this.removeChildWidget(this._tabbedContainerWidget);
            this._tabbedContainerWidget = null;
          }

          context.HostService.unregisterClosableWindow(this);

          $super.destroy.call(this);

          this._sidebarItemWidget.destroy();
          this._sidebarItemWidget = null;

          gbc.InitService.emit(gbc.constants.widgetEvents.onBeforeUnload); // Store stored settings before leaving
        },

        /**
         * emit window close event
         */
        _emitClose: function() {
          if (!this._processing) {
            this.emit(context.constants.widgetEvents.close);
          }
        },
        /**
         * set the window title
         * @param {string} text window title
         * @publicdoc
         */
        setText: function(text) {
          this._text = text;
          if (this._modalWidget) {
            this._modalWidget.setHeader(text);
          }
        },

        /**
         * get the window title
         * @publicdoc
         * @returns {string} window title
         */
        getText: function() {
          return this._text;
        },

        /**
         * set the window icon
         * @publicdoc
         * @param {string} image the image to set
         */
        setImage: function(image) {
          this._image = image;
          this.getSidebarWidget().setWindowIcon(image);
          if (this._modalWidget) {
            this._modalWidget.setImage(image);
          }
        },

        /**
         * get the window icon
         * @publicdoc
         * @return {?string} the icon
         */
        getImage: function() {
          return this._image;
        },

        /**
         * get the window's message widget
         * @publicdoc
         * @return {classes.MessageWidget} the window's message widget
         */
        getMessageWidget: function() {
          return this._messageWidget;
        },

        /**
         * enable window contents
         */
        unfreeze: function() {
          this._disabled = false;
          this.enableActions();
          if (this._modalWidget) {
            this._modalWidget._element.removeClass("hidden");
          }
          this._sidebarItemWidget.setFrozen(false);
          this.emit(gbc.constants.widgetEvents.unfrozen);
        },
        /**
         * disable window contents
         */
        freeze: function() {
          this._disabled = true;
          this.disableActions();
          if (this._sidebarItemWidget) {
            this._sidebarItemWidget.setFrozen(true);
          }
          if (this._modalWidget) {
            this._modalWidget._element.addClass("hidden");
          }
          this.emit(gbc.constants.widgetEvents.frozen);
        },

        /**
         *
         * @param hidden {boolean} true if the widget is hidden, false otherwise
         */
        setHidden: function(hidden) {
          if (this._modalWidget) {
            this._modalWidget.hide();
          }
          if (this._activeTopMenuWidget) {
            this._activeTopMenuWidget.setHidden(hidden);
          }
          if (this._toolBarWidget) {
            this._toolBarWidget.setHidden(hidden || this._toolBarPosition === "none");
          }
          this.getLayoutEngine().changeHidden(hidden);
        },

        /**
         * Defines the menu to be displayed as a modal one
         * @private
         */
        setAsModal: function() {
          if (!this._modalWidget) {
            this._modalWidget = cls.WidgetFactory.createWidget("Modal", this.getBuildParameters());
            this._modalWidget.setReverse(this.isReversed());
            this._modalWidget.addClass('gbc_ModalWindowDialog');
            this._modalWidget.addClass('g_needLayout');
            this.getParentWidget().getContainerElement().appendChild(this._modalWidget.getElement());
            this._modalWidget._closeButton.on("click.ModalWidget", function() {
              this._emitClose();
            }.bind(this));
            this._modalWidget.setClosable(false);
          }
          this._modalWidget.setHeader(this.getText());
          this._modalWidget.setImage(this.getImage());
          this._modalWidget.setContent(this.getElement());
          this._modalWidget.setBackgroundColor(this._backgroundColor);
          this.isModal = true;

          this._modalWidget.show();
          return this._modalWidget;
        },

        /**
         *
         * @return {classes.ModalWidget}
         */
        getModal: function() {
          return this._modalWidget;
        },
        /**
         * Right window menu container
         * @return {Element}
         */
        getWindowMenuContainerRight: function() {
          return this._menuContainerRight;
        },
        /**
         * Main window container which holds menus + forms
         * @return {Element}
         */
        getWindowMiddleContainer: function() {
          return this._menuContainerMiddle;
        },
        /**
         *
         * @private
         * @param rtl
         */
        setReverse: function(rtl) {
          $super.setReverse.call(this, rtl);
          if (this._modalWidget) {
            this._modalWidget.setReverse(rtl);
          }
        },

        /**
         * Set position of the window based on position 4ST attribute.
         * At the moment, only a modal window will be affected by this attribute, a normal window is always displayed full screen.
         * For the modal window, by default it's centered. If 4ST is set to 'field', pos parameter is referent widget.
         * @private
         * @param pos {string|classes.WidgetBase}
         */
        setPosition: function(pos) {
          var isPosString = typeof(pos) === "string";
          var isPosField = pos && pos.isInstanceOf && pos.isInstanceOf(cls.WidgetBase);
          this._element.removeClass(this._positionClass);
          this._positionClass = "gbc_WindowWidget_position_" + (isPosString ? pos : "center");
          this._element.addClass(this._positionClass);
          // setting position to field without having windowType to modal makes no sense,
          // it's considered as modal by GDC but not by HTMLv1.
          if (isPosField && this._modalWidget) {
            var rect = pos.getElement().getBoundingClientRect(),
              appRect = pos.getApplicationWidget().getElement().getBoundingClientRect(),
              chromeBar = pos.getApplicationWidget().getUserInterfaceWidget().getChromeBarWidget(),
              chromeBarRect = chromeBar && chromeBar.getElement()
              .getBoundingClientRect(); // Taking care of chromebar height in placement if any

            this._modalWidget._setAsMoved(
              this.isReversed() ? appRect.right - rect.right : rect.left - appRect.left,
              rect.top + rect.height - appRect.top - (chromeBarRect ? chromeBarRect.height : 0)
            );
          }
        },

        /**
         * @inheritDoc
         */
        setNoBorder: function(noBorder) {
          $super.setNoBorder.call(this, noBorder);
          if (this._modalWidget) {
            this._modalWidget.setHeaderHidden(noBorder);
          }
        },

        /**
         * @returns {boolean} true if the widget is hidden, false otherwise
         */
        isHidden: function() {
          return !this._element;
        },
        /**
         *
         * @private
         * @return {classes.SessionSidebarWindowItemWidget}
         */
        getSidebarWidget: function() {
          return this._sidebarItemWidget;
        },
        /**
         * @private
         * @param hook
         */
        onClose: function(hook) {
          this.when(gbc.constants.widgetEvents.close, hook);
        },
        /**
         * @private
         * @param closable
         */
        setClosable: function(closable) {
          if (this.isModal && this._modalWidget) {
            this._modalWidget.setClosable(!!closable);
            context.HostService.setClosableWindowActionActive(this, false);
          } else {
            context.HostService.setClosableWindowActionActive(this, closable);
          }
        },

        /**
         * Enable actions of the window
         */
        enableActions: function() {
          context.HostService.setClosableWindowActionHidden(this, false);
          this._actionsEnabled = true;
        },

        /**
         * Disable actions of the window
         */
        disableActions: function() {
          context.HostService.setClosableWindowActionHidden(this, true);
          this._actionsEnabled = false;
        },

        /**
         *
         * @private
         * @param path
         */
        setBackgroundImage: function(path) {
          if (path) {
            this.setStyle({
              "background-image": "url('" + path + "')"
            });
          } else {
            this.setStyle({
              "background-image": null
            });
          }
        },

        /**
         * @inheritDoc
         */
        setBackgroundColor: function(color) {
          $super.setBackgroundColor.call(this, color);
          if (this._modalWidget) {
            this._modalWidget.setBackgroundColor(color);
          }
        },

        /**
         * @param {classes.TabbedContainerWidget} tabbedContainer
         */
        addTabbedContainer: function(tabbedContainer) {
          this._tabbedContainerWidget = tabbedContainer;
          this.addChildWidget(tabbedContainer);
        },

        /**
         * @private
         * @param {classes.TopMenuWidget} topMenu
         * @param order
         * @param topMenuContainer
         */
        addTopMenu: function(topMenu, order, topMenuContainer) {
          this.addChildWidget(topMenu, {
            noDOMInsert: true
          });
          if (this._activeTopMenuWidget) {
            this._activeTopMenuWidget.setHidden(true);
          }
          this._topMenus.push(topMenu);
          this._activeTopMenuWidget = topMenu;
          if (topMenuContainer !== this) {
            topMenuContainer.addTopMenu(this._activeTopMenuWidget, order);
          } else {
            this._topMenuContainer.appendChild(this._activeTopMenuWidget.getElement());
          }
          this._activeTopMenuWidget.setHidden(false);
        },

        /**
         *
         * @private
         * @param topMenu
         */
        removeTopMenu: function(topMenu) {
          this._topMenus.remove(topMenu);
          if (this._activeTopMenuWidget === topMenu) {
            this._activeTopMenuWidget.setHidden(true);
            this._activeTopMenuWidget = this._topMenus.length ? this._topMenus[this._topMenus.length - 1] : null;
            if (this._activeTopMenuWidget) {
              this._activeTopMenuWidget.setHidden(false);
            }

          }
        },

        /**
         *
         * @private
         * @param container
         * @return {null}
         */
        getMenuContainer: function(container) {
          switch (container) {
            case "top":
              return this._menuContainerTop;
            case "bottom":
              return this._menuContainerBottom;
            case "left":
              return this._menuContainerLeft;
            case "right":
              return this._menuContainerRight;
            default:
              return null;
          }
        },

        /**
         * Add a toolbar to the window
         * @private
         * @param toolBar
         * @param order
         * @param toolBarContainer
         * @param {classes.ChromeBarWidget?} chromeBar - if any chrome is used, pass it here
         */
        addToolBar: function(toolBar, order, toolBarContainer, chromeBar) {
          this.addChildWidget(toolBar, {
            noDOMInsert: true
          });
          this._toolBarWidget = toolBar;
          this._toolBarWidget.setHidden(!this.isVisible() || this._toolBarPosition === "none");

          // Add it to the chromebar if any
          if (chromeBar) {
            chromeBar.addToolBar(this._toolBarWidget, order);
          } else {
            this._toolBarContainer.appendChild(this._toolBarWidget.getElement());
          }
        },

        /**
         *
         * @return {null}
         */
        getMenuContainers: function() {
          return {
            top: this._menuContainerTop,
            bottom: this._menuContainerBottom,
            left: this._menuContainerLeft,
            right: this._menuContainerRight
          };
        },

        /**
         * @private
         * @param toolBar
         */
        removeToolBar: function(toolBar) {
          if (this._toolBarWidget === toolBar) {
            this._toolBarWidget = null;
          }
        },

        /**
         * Add a menu to the window
         * @private
         * @param widget
         */
        addMenu: function(widget) {
          this._menuWidget = widget;
          this.addChildWidget(widget, {
            noDOMInsert: true
          });
        },

        /**
         * @private
         * @param position
         */
        setToolBarPosition: function(position) {
          // only TOP and  value are supported
          this._toolBarPosition = position;
          var visible = (position !== "none");

          if (this._toolBarWidget) {
            this._toolBarWidget.setHidden(!visible);
          }

          this._toolBarContainer.toggleClass("hidden", !visible);
        },

        /**
         * @private
         * @param type
         */
        setStartMenuType: function(type) {
          this._startMenuType = type;
        },

        /**
         * @private
         */
        getStartMenuType: function() {
          return this._startMenuType;
        },

        /**
         *
         * @param processing
         * @private
         */
        _setProcessingStyle: function(processing) {
          this._processing = processing;
          context.HostService.setClosableWindowActionProcessing(this, processing);
        },

        /**
         * Set the parent window identifier
         * @param {number} parentWindowId identifier o17f the parent window
         */
        setParentWindowId: function(parentWindowId) {
          this._parentWindowId = parentWindowId;
        },

        /**
         * Get the parent window identifier
         * @return {number} - the id of the parent window
         */
        getParentWindowId: function() {
          return this._parentWindowId;
        }

      };
    });
    cls.WidgetFactory.registerBuilder('Window', cls.WindowWidget);
  });
;
"use strict";

modulum('DummyButtonEditWidget', ['ButtonEditWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * ButtonEdit widget.
     * @class DummyButtonEditWidget
     * @memberOf classes
     * @extends classes.ButtonEditWidget
     */
    cls.DummyButtonEditWidget = context.oo.Class(cls.ButtonEditWidget, function($super) {
      return /** @lends classes.DummyButtonEditWidget.prototype */ {
        __name: "DummyButtonEditWidget",
        __templateName: "ButtonEditWidget",

        /**
         * @param {number} maxlength maximum number of characters allowed in the field
         */
        setMaxLength: function(maxlength) {

        },

        /**
         * @param {boolean} isPassword true if the widget should be in 'password' mode, false otherwise
         */
        setIsPassword: function(isPassword) {

        },

        /**
         * All input widgets in constructs are left aligned (because of search criteria)
         */
        setTextAlign: function(align) {
          this._edit.setTextAlign(this.getStart());
        }
      };
    });
    cls.WidgetFactory.registerBuilder('DummyButtonEdit', cls.DummyButtonEditWidget);
  });
;
"use strict";

modulum('DummyDateEditWidget', ['DateEditWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * DummyDateEdit widget.
     * @class DummyDateEditWidget
     * @memberOf classes
     * @extends classes.DateEditWidget
     */
    cls.DummyDateEditWidget = context.oo.Class(cls.DateEditWidget, function($super) {
      return /** @lends classes.DummyDateEditWidget.prototype */ {
        __name: "DummyDateEditWidget",
        __templateName: "DateEditWidget",
        _unboundField: null,

        _initElement: function(datetime) {
          $super._initElement.call(this, datetime);
          this._unboundField = document.createElement("div");
        },

        destroy: function() {
          $super.destroy.call(this);
          this._unboundField = null;
        },

        _onIconClick: function(event) {
          this._dropDown.getElement().appendChild(this._picker.el);
          $super._onIconClick.call(this, event);
        },

        _getPickerConf: function() {
          var pickerConf = $super._getPickerConf.call(this);
          pickerConf.field = this._unboundField;
          return pickerConf;
        },

        /**
         * @inheritDoc
         */
        setDate: function(date) {
          $super.setDate.call(this, date);

          // manually set date to unbound input field on dropdown opening
          if (this._dropDown.isVisible()) {
            var formattedDate = this.getDate();
            if (formattedDate !== this.getValue()) {
              this._inputElement.value = formattedDate;
            }
          }
        },

        // -- Calendar type specific functions --

        _onDateSelect: function(date) {
          this.setValue(context.moment(date).format(this._displayFormat));
          $super._onDateSelect.call(this, date);
        },

        /**
         * All input widgets in constructs are left aligned (because of search criteria)
         */
        setTextAlign: function(align) {
          this.setStyle("input", {
            "text-align": this.getStart()
          });
        }

      };
    });
    cls.WidgetFactory.registerBuilder('DummyDateEdit', cls.DummyDateEditWidget);
  });
;
"use strict";

modulum('DummyDateTimeEditWidget', ['DateTimeEditWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * DummyDateTimeEdit widget.
     * @class DummyDateTimeEditWidget
     * @memberOf classes
     * @extends classes.DateTimeEditWidget
     */
    cls.DummyDateTimeEditWidget = context.oo.Class(cls.DateTimeEditWidget, function($super) {
      return /** @lends classes.DummyDateTimeEditWidget.prototype */ {
        __name: "DummyDateTimeEditWidget",
        __templateName: "DateTimeEditWidget",
        _unboundField: null,

        _initElement: function(datetime) {
          $super._initElement.call(this, datetime);
          this._displayFormat = "YYYY-MM-DD HH:mm:ss";
          this._unboundField = document.createElement("div");
        },

        destroy: function() {
          $super.destroy.call(this);
          this._unboundField = null;
        },

        _onIconClick: function(event) {
          this._dropDown.getElement().appendChild(this._picker.el);
          $super._onIconClick.call(this, event);
        },

        _getPickerConf: function() {
          var pickerConf = $super._getPickerConf.call(this);
          pickerConf.field = this._unboundField;
          return pickerConf;
        },

        /**
         * @inheritDoc
         */
        setDate: function(date) {
          $super.setDate.call(this, date);

          // manually set date to unbound input field on dropdown opening
          if (this._dropDown.isVisible()) {
            var formattedDate = this.getDate();
            if (formattedDate !== this.getValue()) {
              this._inputElement.value = formattedDate;
            }
          }
        },

        // -- Calendar type specific functions --

        _onDateSelect: function(date) {
          this.setValue(context.moment(date).format(this._displayFormat));
          $super._onDateSelect.call(this, date);
        },

        /**
         * All input widgets in constructs are left aligned (because of search criteria)
         */
        setTextAlign: function(align) {
          this.setStyle("input", {
            "text-align": this.getStart()
          });
        }
      };
    });
    cls.WidgetFactory.registerBuilder('DummyDateTimeEdit', cls.DummyDateTimeEditWidget);
  });
;
"use strict";

modulum('DummyEditWidget', ['EditWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Edit widget.
     * @class DummyEditWidget
     * @memberOf classes
     * @extends classes.EditWidget
     */
    cls.DummyEditWidget = context.oo.Class(cls.EditWidget, function($super) {
      return /** @lends classes.DummyEditWidget.prototype */ {
        __name: "DummyEditWidget",
        __dataContentPlaceholderSelector: cls.WidgetBase.selfDataContent,

        _initLayout: function() {
          this._layoutInformation = new cls.LayoutInformation(this);
          this._layoutEngine = new cls.LeafLayoutEngine(this);
          this._layoutInformation._fixedSizePolicyForceMeasure = true;
        },

        _initElement: function() {
          $super._initElement.call(this);
          this._element.addClass("gbc_EditWidget");
        },

        /**
         * @inheritDoc
         */
        setReadOnly: function(readonly) {

        },

        /**
         * @inheritDoc
         */
        isReadOnly: function() {
          return !!this._element.getAttribute("readonly");
        },

        /**
         * @param {number} maxlength maximum number of characters allowed in the field
         */
        setMaxLength: function(maxlength) {

        },

        /**
         * @returns {number} the maximum number of characters allowed in the field
         */
        getMaxLength: function() {
          this._element.getIntAttribute("maxlength");
        },

        /**
         * @param {boolean} isPassword true if the widget should be in 'password' mode, false otherwise
         */
        setIsPassword: function(isPassword) {

        },

        /**
         * @returns {boolean} true if the widget is in 'password' mode, false otherwise
         */
        isPassword: function() {
          return this._element.getAttribute("type") === "password";
        },

        /**
         * Used to manage the keyboardHint.
         * @param {string} valType the type attribute value to set
         */
        setType: function(valType) {

        },

        /**
         * @returns {string} this Edit current type
         */
        getType: function() {
          return this._element.getAttribute("type");
        },

        /**
         * @inheritDoc
         */
        setFocus: function(fromMouse) {
          this._inputElement.domFocus();
          $super.setFocus.call(this, fromMouse);
        },

        /**
         * Set current display format to use on each set value
         * @param {string} format - display format
         * @publicdoc
         */
        setDisplayFormat: function(format) {
          this._displayFormat = format;
        },

        /**
         * Get the display format if any
         * @return {?string} the display format
         * @publicdoc
         */
        getDisplayFormat: function() {
          return this._displayFormat;
        },

        /**
         * @param {boolean} enabled true if the widget allows user interaction, false otherwise.
         */
        setEnabled: function(enabled) {
          $super.setEnabled.call(this, enabled);
        }
      };
    });
    cls.WidgetFactory.registerBuilder('DummyEdit', cls.DummyEditWidget);
  });
;
"use strict";

modulum('DummyRadioGroupWidget', ['RadioGroupWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * RadioGroup widget.
     * @class DummyRadioGroupWidget
     * @memberOf classes
     * @extends classes.RadioGroupWidget
     */
    cls.DummyRadioGroupWidget = context.oo.Class(cls.RadioGroupWidget, function($super) {
      return /** @lends classes.DummyRadioGroupWidget.prototype */ {
        __name: "DummyRadioGroupWidget",
        __templateName: "RadioGroupWidget",

        /**
         * @inheritDoc
         */
        getValue: function() {
          var value = "",
            children = this._element.childrenExcept(this.__charMeasurer);
          for (var i = 0; i < children.length; ++i) {
            var item = children[i];
            if (item.getElementsByClassName("zmdi")[0].hasClass('checked')) {
              if (value.length !== 0) {
                value += '|';
              }
              value += item.getAttribute('data-value');
            }
          }
          return value;
        },

        /**
         * @inheritDoc
         */
        _setValue: function(value) {
          var values = ("" + value).split('|'),
            children = this._element.childrenExcept(this.__charMeasurer);
          for (var i = 0; i < children.length; ++i) {
            var item = children[i],
              checkedElement = item.getElementsByClassName('zmdi')[0];
            // Reset radio checked
            if (values.indexOf(item.getAttribute("data-value")) !== -1) {
              checkedElement.addClass('checked');
              checkedElement.removeClass("unchecked");
            } else {
              checkedElement.addClass('unchecked');
              checkedElement.removeClass("checked");
            }
          }
          this.setEditing(this.getValue() !== this._oldValue);
        },

        /**
         * @param {number} index the value to display
         * @param {boolean} doSetValue
         * @private
         */
        _prepareValue: function(index, doSetValue) {
          if (this.isEnabled()) {
            this._updateVisualAim();
            var children = this._element.childrenExcept(this.__charMeasurer);
            if (doSetValue) {
              var item = children[index].getElementsByClassName('zmdi')[0];
              item.toggleClass('checked', !item.hasClass('checked'));
              this.emit(context.constants.widgetEvents.change, false);
            }
          }
        }
      };
    });
    cls.WidgetFactory.registerBuilder('DummyRadioGroup', cls.DummyRadioGroupWidget);
  });
;
"use strict";

modulum('DummySpinEditWidget', ['SpinEditWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * SpinEdit widget.
     * @class DummySpinEditWidget
     * @memberOf classes
     * @extends classes.SpinEditWidget
     */
    cls.DummySpinEditWidget = context.oo.Class(cls.SpinEditWidget, function($super) {
      return /** @lends classes.DummySpinEditWidget.prototype */ {
        __name: "DummySpinEditWidget",
        __templateName: "SpinEditWidget",

        /**
         * @inheritDoc
         */
        _processKey: function(event, keyString) {

        },

        /**
         * @inheritDoc
         */
        getValue: function() {
          var value = parseInt(this._inputElement.value, 10);
          var isDefined = Object.isNumber(value) && !Object.isNaN(value);
          return isDefined ? value : this._inputElement.value;
        },

        /**
         * All input widgets in constructs are left aligned (because of search criteria)
         */
        setTextAlign: function(align) {
          this.setStyle("input", {
            "text-align": this.getStart()
          });
        },

      };
    });
    cls.WidgetFactory.registerBuilder('DummySpinEdit', cls.DummySpinEditWidget);
  });
;
"use strict";

modulum('DummyTextEditWidget', ['TextEditWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * TextEdit widget.
     * @class DummyTextEditWidget
     * @memberOf classes
     * @extends classes.TextEditWidget
     */
    cls.DummyTextEditWidget = context.oo.Class(cls.TextEditWidget, function($super) {
      return /** @lends classes.DummyTextEditWidget.prototype */ {
        __name: "DummyTextEditWidget",
        __dataContentPlaceholderSelector: cls.WidgetBase.selfDataContent,

        _initLayout: function() {
          this._layoutInformation = new cls.LayoutInformation(this);
          this._layoutInformation.shouldFillStack = true;
          this._layoutEngine = new cls.LeafLayoutEngine(this);
          this._layoutInformation.forcedMinimalWidth = 20;
          this._layoutInformation.forcedMinimalHeight = 20;
        },

        setHtmlControl: function(jcontrol) {
          jcontrol.innerHTML = this.getValue();
          this._inputElement.replaceWith(jcontrol);
          this._hasHTMLContent = true;
          this._inputElement = jcontrol;
        },

        /**
         * @inheritDoc
         */
        _setValue: function(value, fromVM) {
          this._inputElement.value = value;
        },

        /**
         * @inheritDoc
         */
        setReadOnly: function(readonly) {
          $super.setReadOnly.call(this, readonly);
          this._setInputReadOnly(readonly);
        },

        /**
         * @param {number} maxlength maximum number of characters allowed in the field
         */
        setMaxLength: function(maxlength) {

        },

        /**
         * All input widgets in constructs are left aligned (because of search criteria)
         */
        setTextAlign: function(align) {
          this.setStyle({
            "text-align": this.getStart()
          });
        }
      };
    });
    cls.WidgetFactory.registerBuilder('DummyTextEdit', cls.DummyTextEditWidget);
  });
;
"use strict";

modulum('DummyTimeEditWidget', ['TimeEditWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * TimeEdit widget.
     * @class DummyTimeEditWidget
     * @memberOf classes
     * @extends classes.TimeEditWidget
     */
    cls.DummyTimeEditWidget = context.oo.Class(cls.TimeEditWidget, function($super) {
      return /** @lends classes.DummyTimeEditWidget.prototype */ {
        __name: "DummyTimeEditWidget",
        __templateName: "TimeEditWidget",

        /**
         * @inheritDoc
         */
        manageKeyDown: function(keyString, domKeyEvent, repeat) {
          var keyProcessed = false;

          if (this.isEnabled() && !this.isReadOnly()) {

            keyProcessed = true;
            switch (keyString) {
              case "down":
                this._updateCurrentGroup();
                this._decrease();
                this.emit(context.constants.widgetEvents.change, false, true);
                break;
              case "up":
                this._updateCurrentGroup();
                this._increase();
                this.emit(context.constants.widgetEvents.change, false, true);
                break;
              case this.getStart():
              case this.getEnd():
                this._updateCurrentGroup();
                keyProcessed = false; // let the default behavior, just update current group
                break;
              case "ctrl+" + this.getEnd():
                //Update current group of time being selected
                this._moveGroup(1);
                this._updateSelection();
                break;
              case "ctrl+" + this.getStart():
                this._moveGroup(-1);
                this._updateSelection();
                break;
              default:
                keyProcessed = this._processKey(domKeyEvent, keyString);
            }
          }

          return keyProcessed;
        },

        /**
         * @inheritDoc
         */
        _processKey: function(event, keyString) {

        },

        /**
         * All input widgets in constructs are left aligned (because of search criteria)
         */
        setTextAlign: function(align) {
          this.setStyle("input", {
            "text-align": this.getStart()
          });
        },
        _onClick: function(event) {
          this._onRequestFocus(event); // request focus
        },

        /**
         * Sets cursor positions
         * @param {number} cursor - start cursor position
         * @param {number} cursor2 - end cursor position
         * @publicdoc
         */
        setCursors: function(cursor, cursor2) {
          if (!cursor2) {
            cursor2 = cursor;
          }
          if (cursor2 && cursor2 < 0) {
            cursor2 = this.getValue() && this.getValue().length || 0;
          }
          this._currentCursors.start = cursor;
          this._currentCursors.end = cursor2;

          this._inputElement.setCursorPosition(cursor, cursor2);
        },

        /**
         * Get cursors
         * @return {{start: number, end: number}} object with cursors
         * @publicdoc
         */
        getCursors: function() {
          var cursors = {
            start: 0,
            end: 0
          };
          if (this._inputElement && this._inputElement.value) {
            try {
              cursors.start = this._inputElement.selectionStart;
              cursors.end = this._inputElement.selectionEnd;
            } catch (ignore) {
              // Some input types don't allow cursor manipulation
            }
          }
          return cursors;
        }

      };
    });
    cls.WidgetFactory.registerBuilder('DummyTimeEdit', cls.DummyTimeEditWidget);
  });
;
'use strict';

modulum('DateEditWidgetBase', ['FieldWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * DateEdit widget Base class.
     * @class DateEditWidgetBase
     * @memberOf classes
     * @extends classes.FieldWidgetBase
     * @publicdoc Widgets
     */
    cls.DateEditWidgetBase = context.oo.Class(cls.FieldWidgetBase, function($super) {
      return /** @lends classes.DateEditWidgetBase.prototype */ {
        __name: 'DateEditWidgetBase',

        /**
         * @inheritDoc
         */
        __dataContentPlaceholderSelector: '.gbc_dataContentPlaceholder',

        /**
         * Format used to display dates of the calendar
         * @type {?string}
         */
        _displayFormat: null,

        /**
         * Get list of sorted days depending of first day of the week which is defined
         * @type {Array}
         */
        _sortedDays: null,

        /**
         * Callback function used to disable days of calendar (framework api)
         * @type {function}
         */
        _disableDayFn: null,

        /**
         * Chinese format for date
         * @type {boolean}
         */
        _useMingGuoYears: false,

        /**
         * Current date momentjs object of the widget
         * @type {Object}
         */
        _dateObj: null,

        /**
         * Last valid date
         * @type {?string}
         */
        _validValue: null,

        /**
         * Indicates if current date of the calendar has been validated by user
         * @type {boolean}
         */
        _mustValid: false,
        /**
         * Max length of the input field
         * @type {number}
         */
        _maxLength: -1,
        /**
         * To detect if we selected a date using keyboard or mouse
         * @type {boolean}
         */
        _keyPressed: false,
        /**
         * Save last clicked date value. Needed to detect double click
         * @type {?string}
         */
        _lastClickValue: null,
        /**
         * Widget icon used to display/hide calendar
         * @type {HTMLElement}
         */
        _pikerIcon: null,

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          if (!this._ignoreLayout) {
            this._layoutInformation = new cls.LayoutInformation(this);
            this._layoutEngine = new cls.LeafLayoutEngine(this);
            this._layoutInformation.setSingleLineContentOnly(true);
            this._layoutInformation.setReservedDecorationSpace(2);
          }
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          if (this._displayFormat === null) {
            this._displayFormat = 'MM/DD/YYYY'; //default format
          }

          this._inputElement = this._element.getElementsByTagName('input')[0];
          this._pikerIcon = this._element.getElementsByTagName('i')[0];

          this._inputElement.on('input.DateEditWidgetBase', this._onInput.bind(this));
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._pikerIcon = null;
          if (this._inputElement) {
            this._inputElement.off('input.DateEditWidgetBase');
            this._inputElement.remove();
            this._inputElement = null;
          }

          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        setTextAlign: function(align) {
          this.setStyle('input', {
            'text-align': align
          });
        },

        /**
         * @inheritDoc
         */
        getTextAlign: function() {
          return this.getStyle('input', 'text-align');
        },

        /**
         * Reset input field with last valid date
         */
        setLastValidValue: function() {
          if (this._inputElement) {
            this._inputElement.value = this._validValue;
          }
        },

        /**
         * @inheritDoc
         */
        setReadOnly: function(readonly) {
          $super.setReadOnly.call(this, readonly);
          this._setInputReadOnly(readonly);
        },

        /**
         * Set input readonly attribute if it doesn't have focus or is noentry.
         * @param {boolean} readonly - true to set the edit part as read-only, false otherwise
         */
        _setInputReadOnly: function(readonly) {
          if (readonly) {
            this._inputElement.setAttribute('readonly', 'readonly');
            if (window.browserInfo.isIE || window.browserInfo.isEdge) {
              this._inputElement.removeAttribute('contentEditable');
            }
          } else {
            this._inputElement.removeAttribute('readonly');
            if (window.browserInfo.isIE || window.browserInfo.isEdge) {
              // need to add this to be sure that user can enter text in the field
              // even if setCursorPosition is called before
              this._inputElement.setAttribute('contentEditable', 'true');
            }
          }
        },

        /**
         * Get the current dateedit value
         * @returns {string} the displayed value
         */
        getValue: function() {
          return this._inputElement.value;
        },

        /**
         * @inheritDoc
         */
        setValue: function(dateString, fromVM) {
          $super.setValue.call(this, dateString, fromVM);
          this.setDate(dateString);
        },

        /**
         * Return the current Date object
         * @returns {Object} returns current momentjs date object
         * @publicdoc
         */
        getDate: function() {
          return this._dateObj ? this._dateObj.format(this._displayFormat) : null;
        },

        /**
         * Generate momentjs date object from a string and set it for both the calendar component and the input field
         * @param {string} date - date value in string format
         * @publicdoc
         */
        setDate: function(date) {
          // created date object based on received value using known format (for datepicker)
          if (this._useMingGuoYears) { // Convert Ming Guo year to 4 digit years for datepicker
            var str = cls.DateTimeHelper.mingGuoToGregorianYears(date);
            this._dateObj = context.moment(str, this._displayFormat);
          } else {
            this._dateObj = context.moment(date, this._displayFormat);
          }

          // set non formatted value to input (already formatted by VM depending)
          if (this.getValue() !== date) {
            this._inputElement.value = date;
          }
        },

        /**
         * Set a specified format of date. Default is MM/DD/YYYY
         * @param {string} format - date format used to display and send date to the VM.
         * @publicdoc
         */
        setFormat: function(format) {
          var years = format && format.match(/Y/g);
          if (years && years.length === 3) { // Ming Guo format
            this._useMingGuoYears = true;
            format = format.replace('YYY', 'YYYY');
          }
          if (this._displayFormat !== format) {
            this._displayFormat = format;
          }
        },

        /**
         * Return date format
         * @returns {string} the date format
         * @publicdoc
         */
        getFormat: function() {
          return this._displayFormat;
        },

        /**
         * Get cursors
         * @return {{start: number, end: number}} object with cursors
         * @publicdoc
         */
        getCursors: function() {
          var cursors = {
            start: 0,
            end: 0
          };
          if (this._inputElement && this._inputElement.value) {
            try {
              cursors.start = this._inputElement.selectionStart;
              cursors.end = this._inputElement.selectionEnd;
            } catch (ignore) {
              // Some input types don't allow cursor manipulation
            }
          }
          return cursors;
        },

        /** Place the cursor at the given position,
         * @param {number} cursor - first cursor position
         * @param {number=} cursor2 - second cursor position
         * @publicdoc
         */
        setCursors: function(cursor, cursor2) {
          if (!cursor2) {
            cursor2 = cursor;
          }
          if (cursor2 && cursor2 < 0) {
            cursor2 = this.getValue() && this.getValue().length || 0;
          }
          this._inputElement.setCursorPosition(cursor, cursor2);
        },

        /**
         * @inheritDoc
         */
        setTitle: function(title) {
          this._inputElement.setAttribute('title', title);
        },

        /**
         * @inheritDoc
         */
        getTitle: function() {
          return this._inputElement.getAttribute('title');
        },

        /**
         * @inheritDoc
         */
        setFocus: function(fromMouse) {
          $super.setFocus.call(this, fromMouse);
          this._inputElement.domFocus();
        },

        /**
         * @inheritDoc
         */
        setEnabled: function(enabled) {
          $super.setEnabled.call(this, enabled);
          this._setInputReadOnly(!enabled);
        },

        /**
         * Define the maximum number of characters allowed
         * @param {number} maxlength - maximum number of characters allowed in the field
         * @publicdoc
         */
        setMaxLength: function(maxlength) {
          if (maxlength) {
            this._maxLength = maxlength;
            this._setElementAttribute('maxlength', maxlength, "_inputElement");
          }
        },

        /**
         * Get the maximum number of characters allowed
         * @returns {number} the maximum number of characters allowed in the field
         * @publicdoc
         */
        getMaxLength: function() {
          return this._maxLength;
        },

        /**
         * Defines a different image for the icon of the DateEdit
         * @param {string} icon - src of the image
         */
        setButtonIcon: function(icon) {
          if (!!icon) {
            var img = cls.WidgetFactory.createWidget('ImageWidget', this.getBuildParameters());
            var imgElem = img.getElement();
            img.setSrc(context.__wrapper.wrapResourcePath(icon));
            img.setTitle("Open picker");
            this._pikerIcon.classList.remove('zmdi', 'zmdi-calendar-blank', 'zmdi-calendar-clock');
            this.domAttributesMutator(function() {
              this._pikerIcon.innerHTML = imgElem.innerHTML;
              img.destroy();
            }.bind(this));
          }
        }
      };
    });
  });
;
'use strict';

modulum('DateTimeEditWidgetBase', ['DateEditWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * DateTimeEdit widget Base.
     * @class DateTimeEditWidgetBase
     * @memberOf classes
     * @extends classes.DateEditWidgetBase
     * @publicdoc Widgets
     */
    cls.DateTimeEditWidgetBase = context.oo.Class(cls.DateEditWidgetBase, function($super) {
      return /** @lends classes.DateTimeEditWidgetBase.prototype */ {
        __name: 'DateTimeEditWidgetBase',
        /**
         * @inheritDoc
         */
        __dataContentPlaceholderSelector: '.gbc_dataContentPlaceholder',
        /**
         * Active/disable seconds for the widget. By default yes.
         * @type {boolean}
         */
        _showSeconds: false,
        /**
         * @inheritDoc
         */
        _displayFormat: null,
        /**
         * @inheritDoc
         */
        _maxLength: -1,

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          if (!this._ignoreLayout) {
            this._layoutInformation = new cls.LayoutInformation(this);
            this._layoutEngine = new cls.LeafLayoutEngine(this);
            this._layoutInformation.setSingleLineContentOnly(true);
          }
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this, true);
          // default datetime format
          this._displayFormat = 'MM/DD/YYYY HH:mm:ss';
        },

        /**
         * @inheritDoc
         */
        setFormat: function(format) {
          this._displayFormat = format;
          this._showSeconds = !!(format && ~format.toLowerCase().indexOf('s'));
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          $super.destroy.call(this);
        }

      };
    });
  });
;
'use strict';

modulum('SpinEditWidgetBase', ['FieldWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * SpinEdit widget Base class.
     * @class SpinEditWidgetBase
     * @memberOf classes
     * @extends classes.FieldWidgetBase
     * @publicdoc Widgets
     */
    cls.SpinEditWidgetBase = context.oo.Class(cls.FieldWidgetBase, function($super) {
      return /** @lends classes.SpinEditWidgetBase.prototype */ {
        __name: 'SpinEditWidgetBase',

        /**
         * Redefine where the data is located
         * @type {string}
         */
        __dataContentPlaceholderSelector: '.gbc_dataContentPlaceholder',

        /**
         * Up arrow element
         * @type {Element}
         */
        _upArrow: null,

        /**
         * Down arrow element
         * @type {Element}
         */
        _downArrow: null,

        /**
         * Maximum number of characters allowed. By default -1 indicates no limit.
         * @type {number}
         */
        _maxLength: -1,

        /**
         * Step of value increment/decrement.
         * @type {number}
         */
        _step: 1,

        /**
         * Minimum value of the spinedit
         * @type {?number}
         */
        _min: null,

        /**
         * Maximum value of the spinedit
         * @type {?number}
         */
        _max: null,

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          if (!this._ignoreLayout) {
            this._layoutInformation = new cls.LayoutInformation(this);
            this._layoutEngine = new cls.LeafLayoutEngine(this);
            this._layoutInformation.setSingleLineContentOnly(true);
          }
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          this._inputElement = this._element.getElementsByTagName('input')[0];
          this._upArrow = this._element.getElementsByClassName('up')[0];
          this._downArrow = this._element.getElementsByClassName('down')[0];

          this._inputElement.on('input.SpinEditWidget', this._onInput.bind(this));
          // Manage requestFocus during selection of text
          this._inputElement.on('mousedown.SpinEditWidget', cls.WidgetBase._onSelect.bind(this));
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._inputElement.off('input.SpinEditWidget');
          this._inputElement.off('mousedown.SpinEditWidget');
          $super.destroy.call(this);
        },

        /**
         * Process one key event
         * @param {Object} event
         * @param {string} keyString
         * @returns {boolean} true if key has been processed, false otherwise
         */
        _processKey: function(event, keyString) {
          var isModifier = cls.KeyboardHelper.isSpecialCommand(keyString);
          var isValid = !isModifier && cls.KeyboardHelper.isDecimal(event.gbcKey) && !this._isMaxLength();

          if (isValid) {
            var value = this._inputElement.value;
            var start = this._inputElement.selectionStart;
            var end = this._inputElement.selectionEnd;
            if (end !== start) {
              value = '';
            }
            isValid = cls.KeyboardHelper.validateNumber(value, start, event.gbcKey, this._min, this._max);
          }
          if (!isValid && !isModifier) {
            event.preventCancelableDefault();
            return true;
          }
          return false;
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {

          this._onRequestFocus(domEvent); // request focus

          var target = domEvent.target;
          if (target.isElementOrChildOf(this._upArrow)) {
            this._onUpIcon(domEvent);
          } else if (target.isElementOrChildOf(this._downArrow)) {
            this._onDownIcon(domEvent);
          }

          return true;
        },

        /**
         * @inheritDoc
         */
        manageKeyUp: function(keyString, domKeyEvent) {
          $super.manageKeyUp.call(this, keyString, domKeyEvent);
          this.emit(context.constants.widgetEvents.change, true);
          this.emit(context.constants.widgetEvents.keyUp, domKeyEvent, true);
        },

        /**
         * @inheritDoc
         */
        setValue: function(value, fromVM) {
          $super.setValue.call(this, value, fromVM);
          this._inputElement.value = value;
          this.setAriaAttribute("valuenow", value);
        },

        /**
         * @inheritDoc
         */
        getValue: function() {
          var value = parseInt(this._inputElement.value, 10);
          var isDefined = Object.isNumber(value) && !Object.isNaN(value);
          return isDefined ? value : '';
        },

        /**
         * Handler called when arrow up icon has been touched/click
         * @param {UIEvent} evt - DOM event
         */
        _onUpIcon: function(evt) {
          if (this.isEnabled() && !this.isReadOnly()) {
            this._increase();
            this.emit(context.constants.widgetEvents.change, false);
          }
        },

        /**
         * Handler called when arrow down icon has been touched/click
         * @param {UIEvent} evt - DOM event
         */
        _onDownIcon: function(evt) {
          if (this.isEnabled() && !this.isReadOnly()) {
            this._decrease();
            this.emit(context.constants.widgetEvents.change, false);
          }
        },

        /**
         * Update value
         * @param {number} factor - value to add
         */
        _updateValue: function(factor) {
          if (factor > 0) {
            this._increase(factor);
          } else if (factor < 0) {
            this._decrease(Math.abs(factor));
          }
        },

        /**
         * @inheritDoc
         */
        validateValue: function() {
          var valid = true;
          if (this._min && this.getValue() < this._min) {
            valid = false;
          }
          if (this._max && this.getValue() > this._max) {
            valid = false;
          }
          return valid;
        },

        /**
         * Increase value
         * @param {number} [factor=1] - value to add (default is 1)
         */
        _increase: function(factor) {
          var curVal = parseInt(!!this.getValue() ? this.getValue() : this._oldValue, 10);
          if (this._max && curVal > this._max) {
            this.setValue(this._max);
          }
          if (this._min && curVal < this._min) {
            this.setValue(this._min);
          } else {
            var newVal = (this._step * (factor && Object.isNumber(factor) ? factor : 1));
            newVal = !!curVal ? newVal + curVal : newVal;
            if (Object.isNumber(this._max) && newVal > this._max) {
              newVal = this._max;
            }
            this.setEditing(this._oldValue !== newVal);
            this.setValue(newVal);
          }
        },

        /**
         * Decrease value
         * @param {number} [factor=1] - value to remove (default is 1)
         */
        _decrease: function(factor) {
          var curVal = parseInt(!!this.getValue() ? this.getValue() : this._oldValue, 10);
          if (this._min && curVal < this._min) {
            this.setValue(this._min);
          } else if (this._max && curVal > this._max) {
            this.setValue(this._max);
          } else {
            var newVal = (this._step * (factor && Object.isNumber(factor) ? factor : 1));
            newVal = !!curVal ? curVal - newVal : -newVal;
            if (Object.isNumber(this._min) && newVal < this._min) {
              newVal = this._min;
            }
            this.setEditing(this._oldValue !== newVal);
            this.setValue(newVal);
          }
        },

        /**
         * Define the minimum possible value
         * @param {number} min - the minimum value
         * @publicdoc
         */
        setMin: function(min) {
          if (Object.isNumber(min)) {
            this._min = min;
          }
          this.setAriaAttribute("valuemin", min);
        },

        /**
         * Get minimum possible value
         * @returns {number} the minimum value
         * @publicdoc
         */
        getMin: function() {
          return this._min;
        },

        /**
         * Define the maximum possible value
         * @param {number} max - the maximum value
         * @publicdoc
         */
        setMax: function(max) {
          if (Object.isNumber(max)) {
            this._max = max;
          }
          this.setAriaAttribute("valuemax", max);
        },

        /**
         * Get maximum possible value
         * @returns {number} the maximum value
         * @publicdoc
         */
        getMax: function() {
          return this._max;
        },

        /**
         * Define the spinedit step when increasing or decreasing value
         * @param {number} step - the step value
         * @publicdoc
         */
        setStep: function(step) {
          var s = step && parseInt(step, 10);
          if (!s || Number.isNaN(s)) {
            s = 1;
          }
          this._step = s;
        },

        /**
         * Get spinedit step when increasing or decreasing value
         * @returns {number} the step value
         * @publicdoc
         */
        getStep: function() {
          return this._step;
        },

        /**
         * Returns if max length of the widget has been reached
         * @returns {boolean} return true if max length is reached in input element
         */
        _isMaxLength: function() {
          return this._maxLength !== -1 && this._inputElement.value.length >= this._maxLength &&
            this._inputElement.selectionStart === this._inputElement.selectionEnd;
        },

        /**
         * Define the maximum number of characters allowed
         * @param {number} maxlength - maximum number of characters allowed in the field
         * @publicdoc
         */
        setMaxLength: function(maxlength) {
          if (maxlength) {
            this._maxLength = maxlength;
          }
        },

        /**
         * Get the maximum number of characters allowed
         * @returns {number} the maximum number of characters allowed in the field
         * @publicdoc
         */
        getMaxLength: function() {
          return this._maxLength;
        },

        /**
         * @inheritDoc
         */
        setReadOnly: function(readonly) {
          $super.setReadOnly.call(this, readonly);
          this._setInputReadOnly(readonly);
        },

        /**
         * Set input readonly attribute if it doesn't have focus or is noentry.
         * @param {boolean} readonly - true to set the edit part as read-only, false otherwise
         */
        _setInputReadOnly: function(readonly) {
          if (readonly) {
            this._inputElement.setAttribute('readonly', 'readonly');
          } else {
            this._inputElement.removeAttribute('readonly');
          }
        },

        /**
         * @inheritDoc
         */
        setFocus: function(fromMouse) {
          this._inputElement.domFocus();
          $super.setFocus.call(this, fromMouse);
        },

        /**
         * @inheritDoc
         */
        setTitle: function(title) {
          $super.setTitle.call(this, title);
          this._inputElement.setAttribute('title', title);
        },

        /**
         * @inheritDoc
         */
        getTitle: function() {
          return this._inputElement.getAttribute('title');
        },

        /** Place the cursor at the given position,
         * @param {number} cursor - first cursor position
         * @param {number=} cursor2 - second cursor position
         * @publicdoc
         */
        setCursors: function(cursor, cursor2) {
          if (!cursor2) {
            cursor2 = cursor;
          }
          if (cursor2 && cursor2 < 0) {
            cursor2 = ('' + this.getValue()).length;
          }
          this._inputElement.setCursorPosition(cursor, cursor2);
        },

        /**
         * Get cursors
         * @return {{start: number, end: number}} object with cursors
         * @publicdoc
         */
        getCursors: function() {
          var cursors = {
            start: 0,
            end: 0
          };
          if (this._inputElement && this._inputElement.value) {
            try {
              cursors.start = this._inputElement.selectionStart;
              cursors.end = this._inputElement.selectionEnd;
            } catch (ignore) {
              // Some input types don't allow cursor manipulation
            }
          }
          return cursors;
        },

        /**
         * @inheritDoc
         */
        setEnabled: function(enabled) {
          $super.setEnabled.call(this, enabled);
          this._setInputReadOnly(!enabled);
        },

        /**
         * @inheritDoc
         */
        setFontWeight: function(weight) {
          this.setStyle('input', {
            'font-weight': weight
          });
        },

        /**
         * @inheritDoc
         */
        getFontWeight: function() {
          return this.getStyle('input', 'font-weight');
        },

        /**
         * @inheritDoc
         */
        setFontStyle: function(style) {
          this.setStyle('input', {
            'font-style': style
          });
        },

        /**
         * @inheritDoc
         */
        getFontStyle: function() {
          return this.getStyle('input', 'font-style');
        },

        /**
         * @inheritDoc
         */
        setTextAlign: function(align) {
          this.setStyle('input', {
            'text-align': align
          });
        },

        /**
         * @inheritDoc
         */
        getTextAlign: function() {
          return this.getStyle('input', 'text-align');
        },

        /**
         * @inheritDoc
         */
        getTextDecoration: function() {
          return this.getStyle('input', 'text-decoration');
        },

        /**
         * @inheritDoc
         */
        setTextDecoration: function(decoration) {
          this.setStyle('input', {
            'text-decoration': decoration
          });
        },

        /**
         * overrided since aria-required is not valid on spinbutton role
         * @inheritDoc
         */
        setRequired: function(required) {
          $super.setRequired.call(this, required);
          this.setAriaAttribute("required", null);
        },
      };
    });
  });
;
'use strict';

modulum('TimeEditWidgetBase', ['FieldWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * TimeEdit widget Base class.
     * @class TimeEditWidgetBase
     * @memberOf classes
     * @extends classes.FieldWidgetBase
     * @publicdoc Widgets
     */
    cls.TimeEditWidgetBase = context.oo.Class(cls.FieldWidgetBase, function($super) {
      return /** @lends classes.TimeEditWidgetBase.prototype */ {
        __name: 'TimeEditWidgetBase',

        /**
         * Active/disable seconds for the widget. By default yes.
         * @type {boolean}
         */
        _useSeconds: true,

        /**
         * Redefine where the data is located
         * @type {string}
         */
        __dataContentPlaceholderSelector: '.gbc_dataContentPlaceholder',

        /**
         * Maximum number of characters allowed. By default -1 indicates no limit.
         * @type {number}
         */
        _maxLength: -1,

        /**
         * Format of TIMEEDIT (hh:mm or hh:mm:ss)
         * @type {string}
         */
        _displayFormat: null,

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          this.setFocusable(true);
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          if (!this._ignoreLayout) {
            this._layoutInformation = new cls.LayoutInformation(this);
            this._layoutEngine = new cls.LeafLayoutEngine(this);
            this._layoutInformation.setSingleLineContentOnly(true);
          }
        },

        /**
         * @inheritDoc
         */
        setTextAlign: function(align) {
          $super.setTextAlign.call(this, align);
          this.setStyle('input', {
            'text-align': align
          });
        },

        /**
         * @inheritDoc
         */
        getTextDecoration: function() {
          return this.getStyle('input', 'text-decoration');
        },

        /**
         * @inheritDoc
         */
        setTextDecoration: function(decoration) {
          this.setStyle('input', {
            'text-decoration': decoration
          });
        },

        /**
         * @inheritDoc
         */
        setTitle: function(title) {
          this._inputElement.setAttribute('title', title);
        },

        /**
         * @inheritDoc
         */
        getTitle: function() {
          return this._inputElement.getAttribute('title');
        },

        /**
         * @inheritDoc
         */
        setValue: function(value, fromVM) {
          $super.setValue.call(this, value, fromVM);
          if (this.getValue() !== value) {
            this._inputElement.value = value;
            this._setTimeAccuracy(value);
          }
        },

        /**
         * Detect if seconds are defined in value or in format and set class variable
         * @param value
         * @private
         */
        _setTimeAccuracy: function(value) {
          var groups = value.split(':');
          if (groups.length === 1) { // no ':'' detected, we look for varType
            this._useSeconds = !this.getDisplayFormat() || !this.getDisplayFormat().endsWith("MINUTE");
          } else {
            this._useSeconds = groups.length === 3;
          }
        },

        /**
         * @inheritDoc
         */
        getValue: function() {
          return this._inputElement.value;
        },

        /**
         * @inheritDoc
         */
        setEnabled: function(enabled) {
          $super.setEnabled.call(this, enabled);
          this._setInputReadOnly(!enabled);
        },

        /**
         * @inheritDoc
         */
        setReadOnly: function(readonly) {
          $super.setReadOnly.call(this, readonly);
          this._setInputReadOnly(readonly);
        },

        /**
         * Set input readonly attribute if it doesn't have focus or is noentry.
         * @param {boolean} readonly - true to set the edit part as read-only, false otherwise
         */
        _setInputReadOnly: function(readonly) {
          if (readonly) {
            this._inputElement.setAttribute('readonly', 'readonly');
          } else {
            this._inputElement.removeAttribute('readonly');
          }
        },

        /**
         * @inheritDoc
         */
        setFocus: function(fromMouse) {
          $super.setFocus.call(this, fromMouse);
          this._inputElement.domFocus();
        },

        /**
         * Returns if max length of the widget has been reached
         * @returns {boolean} return true if max length is reached in input element
         */
        _isMaxLength: function() {
          return this._maxLength !== -1 && this._inputElement.value.length >= this._maxLength &&
            this._inputElement.selectionStart === this._inputElement.selectionEnd;
        },

        /**
         * Define the maximum number of characters allowed
         * @param {number} maxlength - maximum number of characters allowed in the field
         * @publicdoc
         */
        setMaxLength: function(maxlength) {
          if (maxlength) {
            this._maxLength = maxlength;
            this._setElementAttribute('maxlength', maxlength, "_inputElement");
          }
        },

        /**
         * Get the maximum number of characters allowed
         * @returns {number} the maximum number of characters allowed in the field
         * @publicdoc
         */
        getMaxLength: function() {
          return this._maxLength;
        },

        /**
         * Get the timeedit format (hh:mm or hh:mm:ss)
         * @return {?string} timeedit format
         * @publicdoc
         */
        getDisplayFormat: function() {
          return this._displayFormat;
        },

        /**
         * Set timeedit format (hh:mm or hh:mm:ss)
         * @param {string} format - format
         * @publicdoc
         */
        setDisplayFormat: function(format) {
          this._displayFormat = format;
          this._setTimeAccuracy(this.getValue());
        }
      };
    });
  });
;
'use strict';

modulum('ButtonEditWidget', ['FieldWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * ButtonEdit widget.
     * @class ButtonEditWidget
     * @memberOf classes
     * @extends classes.FieldWidgetBase
     * @publicdoc Widgets
     */
    cls.ButtonEditWidget = context.oo.Class(cls.FieldWidgetBase, function($super) {
      return /** @lends classes.ButtonEditWidget.prototype */ {
        __name: 'ButtonEditWidget',
        /**
         * Edit part of the widget
         * @type {classes.EditWidget}
         */
        _edit: null,

        /**
         * Button part of the widget
         * @type {classes.ButtonWidget}
         */
        _button: null,

        /**
         * Redefine where the data is located
         * @type {string}
         */
        __dataContentPlaceholderSelector: '.gbc_dataContentPlaceholder',

        /**
         * Handler for click
         * @function
         */
        _clickHandler: null,

        /**
         * Handler for focus
         * @function
         */
        _focusHandler: null,

        /**
         * Handler for blur
         * @function
         */
        _blurHandler: null,

        /**
         * Handler for change
         * @function
         */
        _changeHandler: null,

        /**
         * Handler for image ready
         * @function
         */
        _imageReadyHandler: null,

        /**
         * Flag to manage if button has been clicked
         * @type {boolean}
         */
        _buttonClicked: false,

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          this.setFocusable(true);
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          if (!this._ignoreLayout) {
            this._layoutInformation = new cls.LayoutInformation(this);
            this._layoutEngine = new cls.LeafLayoutEngine(this);
            this._layoutInformation.setReservedDecorationSpace(2);
          }
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);

          this._edit = cls.WidgetFactory.createWidget('EditWidget', this.getBuildParameters());
          this._button = cls.WidgetFactory.createWidget('ButtonWidget', this.getBuildParameters());
          // layout engine can be null if _ignoreLayout is true, which happens for widget being in table and not in first row. (cf constructor of WidgetBase)
          // in that case, we do not want to measure image once loaded
          if (!this._ignoreLayout) {
            this._imageReadyHandler = this._button.when(context.constants.widgetEvents.ready, this._imageLoaded.bind(this));
          }
          this._element.appendChild(this._edit.getElement());
          this._element.appendChild(this._button.getElement());
          this._edit.setParentWidget(this);
          this._button.setParentWidget(this);
          this._clickHandler = this._button.when(context.constants.widgetEvents.click, this._onButtonClick.bind(this));
          this._focusHandler = this._edit.when(context.constants.widgetEvents.requestFocus, this._onEditRequestFocus.bind(this));
          this._blurHandler = this._edit.when(context.constants.widgetEvents.blur, this._onEditBlur.bind(this));
          this._changeHandler = this._edit.when(context.constants.widgetEvents.change, this._onEditChange.bind(this));
        },

        /**
         * Handler called when the button image is loaded
         */
        _imageLoaded: function(event, src) {
          this._layoutEngine.invalidateMeasure();
          this.emit(context.constants.widgetEvents.ready);
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._clickHandler();
          this._clickHandler = null;
          this._focusHandler();
          this._focusHandler = null;
          this._blurHandler();
          this._blurHandler = null;
          this._changeHandler();
          this._changeHandler = null;
          this._edit.destroy();
          this._edit = null;
          this._button.destroy();
          this._button = null;
          if (this._completerWidget) {
            this._completerWidget.destroy();
            this._completerWidget = null;
          }
          if (this._imageReadyHandler) {
            this._imageReadyHandler();
            this._imageReadyHandler = null;
          }
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        managePriorityKeyDown: function(keyString, domKeyEvent, repeat) {
          return this._edit.managePriorityKeyDown(keyString, domKeyEvent, repeat);
        },

        /**
         * @inheritDoc
         */
        manageKeyDown: function(keyString, domKeyEvent, repeat) {
          return this._edit.manageKeyDown(keyString, domKeyEvent, repeat);
        },

        /**
         * @inheritDoc
         */
        manageKeyUp: function(keyString, domKeyEvent) {
          this._edit.manageKeyUp(keyString, domKeyEvent);

          this.emit(context.constants.widgetEvents.keyUp, domKeyEvent, true);
        },

        /**
         * Handler when click on button
         * @param {Object} event - DOM event
         * @param sender
         * @param domEvent
         */
        _onButtonClick: function(event, sender, domEvent) {
          if (this.isEnabled()) {
            this.emit(context.constants.widgetEvents.requestFocus, domEvent);
            this.emit(context.constants.widgetEvents.click, domEvent, !this.hasDOMFocus());
          }
        },

        /**
         * Handler when focus is requested
         * @param event
         * @param sender
         * @param domEvent
         */
        _onEditRequestFocus: function(event, sender, domEvent) {
          this.emit(context.constants.widgetEvents.requestFocus, domEvent);
        },

        /**
         * Handler when edit is blured
         * @param event
         * @param sender
         * @param domEvent
         */
        _onEditBlur: function(event, sender, domEvent) {
          this.emit(context.constants.widgetEvents.blur, domEvent);
        },

        /**
         * Handler when edit content changes
         * @param event
         * @param sender
         * @param isTextEntry
         */
        _onEditChange: function(event, sender, isTextEntry) {
          this.emit(context.constants.widgetEvents.change, isTextEntry);
        },

        /**
         * Get the input field of the widget
         * @return {HTMLElement} The input element
         * @publicdoc
         */
        getInputElement: function() {
          return this._edit.getInputElement();
        },

        /**
         * @inheritDoc
         */
        setTitle: function(title) {
          this._edit.setTitle(title);
        },

        /**
         * Defines the action title
         * @param {string} title - title related to this action
         */
        setActionTitle: function(title) {
          if (title && title.length <= 0) {
            this._button.setTitle(this.getTitle());
          } else {
            this._button.setTitle(title);
          }
        },

        /**
         * @inheritDoc
         */
        getTitle: function() {
          return this._edit.getTitle();
        },

        /**
         * @inheritDoc
         */
        setReadOnly: function(readonly) {
          this._edit.setReadOnly(readonly);
        },

        /**
         * @inheritDoc
         */
        isReadOnly: function() {
          return this._edit.isReadOnly();
        },

        /**
         * Define the maximum number of characters allowed
         * @param {number} maxlength - maximum number of characters allowed in the field
         * @publicdoc
         */
        setMaxLength: function(maxlength) {
          this._edit.setMaxLength(maxlength);
        },

        /**
         * Get the maximum number of characters allowed
         * @returns {number} the maximum number of characters allowed in the field
         * @publicdoc
         */
        getMaxLength: function() {
          return this._edit.getMaxLength();
        },

        /**
         * @inheritDoc
         */
        setTextAlign: function(align) {
          this._edit.setTextAlign(align);
        },

        /**
         * @inheritDoc
         */
        getTextAlign: function() {
          return this._edit.getTextAlign();
        },

        /**
         * When cursor2 === cursor, it is a simple cursor set
         * @param {number} cursor - starting cursor position
         * @param {number} cursor2 - ending cursor position
         * @publicdoc
         */
        setCursors: function(cursor, cursor2) {
          if (this._edit) {
            this._edit.setCursors(cursor, cursor2);
          }
        },

        /**
         * Get cursors
         * @return {{start: number, end: number}} object with cursors
         * @publicdoc
         */
        getCursors: function() {
          return this._edit.getCursors();
        },

        /**
         * Get the display format of the edit part
         * @return {string} the display format
         * @publicdoc
         */
        getDisplayFormat: function() {
          return this._edit.getDisplayFormat();
        },

        /**
         * Set the display format of the edit part
         * @param {string} format the display format
         * @publicdoc
         */
        setDisplayFormat: function(format) {
          this._edit.setDisplayFormat(format);
        },

        /**
         * @inheritDoc
         */
        setValue: function(value, fromVM) {
          this._edit.setValue(value, fromVM);
        },

        /**
         * @inheritDoc
         */
        getValue: function() {
          return this._edit.getValue();
        },

        /**
         * Set the image of the button part
         * @param {string} image - URL of the image to display
         * @publicdoc
         */
        setImage: function(image) {
          this._button.setImage(image);
        },

        /**
         * Get the image of the button part
         * @returns {string} the URL of the image displayed in the button part
         * @publicdoc
         */
        getImage: function() {
          return this._button.getImage();
        },

        /**
         * Defines the widget as autoscalable
         * @param {boolean} enabled the wanted state
         * @publicdoc
         */
        setAutoScale: function(enabled) {
          this._button.setAutoScale(enabled);
        },

        /**
         * @inheritDoc
         */
        setEnabled: function(enabled) {
          $super.setEnabled.call(this, enabled);
          this._edit.setEnabled(enabled);
        },

        /**
         * @inheritDoc
         */
        isEnabled: function() {
          return this._edit.isEnabled();
        },
        /**
         * Enable the button
         * @param {boolean} enabled - true if the button should be enabled, false otherwise
         * @publicdoc
         */
        setButtonEnabled: function(enabled) {
          this._button.setEnabled(enabled);
        },

        /**
         * returns whether or not the button is enabled
         * @returns {boolean} true if the button is enabled, false otherwise
         * @publicdoc
         */
        isButtonEnabled: function() {
          return this._button.isEnabled();
        },

        /**
         * sets 'password' mode
         * @param {boolean} isPassword - true if the widget should be in 'password' mode, false otherwise
         * @publicdoc
         */
        setIsPassword: function(isPassword) {
          this._edit.setIsPassword(isPassword);
        },

        /**
         * returns whether or not the widget should be in 'password' mode
         * @returns {boolean} true if the widget is in 'password' mode, false otherwise
         * @publicdoc
         */
        isPassword: function() {
          return this._edit.isPassword();
        },

        /**
         * Used to manage the keyboardHint.
         * @param {string} valType - the type attribute value to set
         * @publicdoc
         */
        setType: function(valType) {
          this._edit.setType(valType);
        },

        /**
         * Get the keyboardHint method
         * @returns {string} this Edit current type
         * @publicdoc
         */
        getType: function() {
          return this._edit.getType();
        },

        /**
         * @inheritDoc
         */
        setFocus: function(fromMouse) {
          if (this._edit.getInputElement()) {
            this._edit.getInputElement().domFocus();
          }
          this.getUserInterfaceWidget().setFocusedWidget(this); // TODO why don't call super.setFocus ?
        },

        /**
         * @inheritDoc
         */
        flash: function() {
          if (this._edit) {
            this._edit.flash();
          }
        },

        /**
         * Get the Completer widget
         * @return {classes.CompleterWidget}
         */
        getCompleterWidget: function() {
          return this._edit.getCompleterWidget();
        },

        /**
         * Will add a completer to the edit
         */
        addCompleterWidget: function() {
          this._edit.addCompleterWidget();
        },

        /**
         * @inheritDoc
         */
        setColor: function(color) {
          this._edit.setColor(color);
        },

        /**
         * @inheritDoc
         */
        getColor: function() {
          return this._edit.getColor();
        },

        /**
         * @inheritDoc
         */
        getColorFromStyle: function() {
          return this._edit.getColorFromStyle();
        },

        /**
         * @inheritDoc
         */
        setBackgroundColor: function(color) {
          this._edit.setBackgroundColor(color);
        },

        /**
         * @inheritDoc
         */
        getBackgroundColor: function() {
          return this._edit.getBackgroundColor();
        },

        /**
         * @inheritDoc
         */
        setTextTransform: function(transform) {
          this._edit.setTextTransform(transform);
        },

        /**
         * @inheritDoc
         */
        removeTextTransform: function() {
          this._edit.removeTextTransform();
        },

        /**
         * @inheritDoc
         */
        getTextTransform: function() {
          return this._edit.getTextTransform();
        },

        /**
         * @inheritDoc
         */
        setEditing: function(editing) {
          if (this._edit) {
            this._edit.setEditing(editing);
          }
        },

        /**
         * @inheritDoc
         */
        getEditingTime: function() {
          return this._edit.getEditingTime();
        },

        /**
         * @inheritDoc
         */
        isEditing: function() {
          return this._edit.isEditing();
        },

        /**
         * @inheritDoc
         */
        setPlaceHolder: function(placeholder) {
          this._edit.setPlaceHolder(placeholder);
        },

        /**
         * @inheritDoc
         */
        setNotEditable: function(notEditable) {
          this._edit.setNotEditable(notEditable);
        },

        hasDOMFocus: function() {
          return this._edit.hasDOMFocus() || this._button.hasDOMFocus();
        },

        /**
         * @inheritDoc
         */
        isNotEditable: function() {
          return this._edit.isNotEditable();
        },

        /**
         * @inheritDoc
         */
        _preventEditAllowNavigation: function(evt, keyString) {
          this._edit._preventEditAllowNavigation(evt, keyString);
        }

      };
    });
    cls.WidgetFactory.registerBuilder('ButtonEdit', cls.ButtonEditWidget);
  });
;
"use strict";

modulum('ButtonWidget', ['TextWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Button widget.
     * @class ButtonWidget
     * @memberOf classes
     * @extends classes.TextWidgetBase
     * @publicdoc Widgets
     */
    cls.ButtonWidget = context.oo.Class(cls.TextWidgetBase, function($super) {
      return /** @lends classes.ButtonWidget.prototype */ {
        __name: "ButtonWidget",

        /**
         * @type {classes.ImageWidget}
         */
        _image: null,

        /**
         * @type {HTMLElement}
         */
        _textElement: null,

        /**
         * @type {HTMLElement}
         */
        _mtButton: null,

        /**
         * Type of the button (normal, link or commandLink)
         * @type {null|string}
         */
        _buttonType: null,

        /** @type {boolean} */
        _autoScale: false,

        /** @type {Object} */
        _alignment: null,

        /** @type {string|null} */
        _defaultColor: null,

        /** @function */
        _imageReadyHandler: null,
        /** @function */
        _afterLayoutHandler: null,

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          this._layoutInformation = new cls.LayoutInformation(this);
          this._layoutInformation.getSizePolicyConfig().initial._shrinkable = false;
          this._layoutInformation.getSizePolicyConfig().dynamic._shrinkable = false;
          this.getLayoutInformation()._fixedSizePolicyForceMeasure = true;
          this._layoutEngine = new cls.ButtonLayoutEngine(this);
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          this._mtButton = this._element.getElementsByClassName('mt-button')[0];
          this._textElement = this._mtButton.querySelector('.textimage span');
        },

        /**
         * Client QA code for performances testing
         * @private
         */
        actionQAReady: function() {
          if (this.__qaReadyAction) {
            this.__qaReadyAction = false;
            this.emit(context.constants.widgetEvents.click);
          }
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._imageReadyHandler) {
            this._imageReadyHandler();
            this._imageReadyHandler = null;
          }
          if (this._afterLayoutHandler) {
            this._afterLayoutHandler();
            this._afterLayoutHandler = null;
          }
          if (this._image) {
            this._image.destroy();
            this._image = null;
          }
          this._textElement = null;
          this._mtButton = null;
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          // Disable click when not clicking on text nor image
          if (this._buttonType === 'link' && (domEvent.target.tagName.toLowerCase() !== 'span' && domEvent.target.tagName
              .toLowerCase() !==
              'img')) {
            return true;
          }

          if (this.isEnabled() || this.isInterruptable()) {
            this.emit(context.constants.widgetEvents.click, domEvent);
          }
          return true;
        },

        /**
         * @inheritDoc
         */
        managePriorityKeyDown: function(keyString, domKeyEvent, repeat) {
          var keyProcessed = false;
          if (this.isEnabled()) {
            if (keyString === "space" || keyString === "enter" || keyString === "return") {
              this.emit(context.constants.widgetEvents.click, domKeyEvent);
              keyProcessed = true;
            }
          }

          if (keyProcessed) {
            return true;
          } else {
            return $super.managePriorityKeyDown.call(this, keyString, domKeyEvent, repeat);
          }
        },

        /**
         * Sets the text of the button
         * @param {string} text text to display in the button
         * @publicdoc
         */
        setText: function(text) {
          this.domAttributesMutator(function() {
            this.getElement().toggleClass('hasText', text.length !== 0);
            this._textElement.textContent = text;
          }.bind(this));

          if (this._layoutEngine) {
            if (this._layoutInformation && this._layoutInformation.getCurrentSizePolicy().isDynamic()) {
              this._layoutEngine.invalidateMeasure();
            }
          }
          // client QA code
          if (gbc.qaMode && ['qa_dialog_ready', 'qa_menu_ready'].indexOf(text) >= 0) {
            this.__qaReadyAction = true;
            if (this._afterLayoutHandler) {
              this._afterLayoutHandler();
            }
            this._afterLayoutHandler =
              context.SessionService.getCurrent().getCurrentApplication().layout.afterLayoutComplete(
                function() {
                  // event executed once : we release reference because event listener will destroy it
                  this._afterLayoutHandler = null;
                  this.actionQAReady();
                }.bind(this), true
              );
          }
        },

        /**
         * Gets the text of the button
         * @returns {string} the text displayed in the button
         * @publicdoc
         */
        getText: function() {
          return this._textElement.textContent;
        },

        /**
         * Sets the image of the button
         * @param {string} image the URL of the image to display
         * @publicdoc
         */
        setImage: function(image) {
          if (this._imageReadyHandler) {
            this._imageReadyHandler();
            this._imageReadyHandler = null;
          }
          if (image.length !== 0) {
            if (!this._image) {
              var opts = this.getBuildParameters();
              opts.inTable = false; // TODO image in button edit seem to not work correctly if inTable and buttonedit is intable
              this._image = cls.WidgetFactory.createWidget('ImageWidget', opts);
              var imageContainer = document.createElement('div');
              imageContainer.addClass('gbc_imageContainer');
              imageContainer.appendChild(this._image.getElement());
              this._mtButton.querySelector(".textimage").prependChild(imageContainer);
              this.setAutoScale(this._autoScale);
              if (this._defaultColor) {
                this._image.setDefaultColor(this._defaultColor);
              }
            }
            this._image.setSrc(image);
            this._imageReadyHandler = this._image.when(context.constants.widgetEvents.ready, this._imageLoaded.bind(this));
            this.getElement().addClass('hasImage');

            if (!this._alignment) {
              this.afterDomMutator((function() {
                // if no alignment set and no text
                if (this.getText().length <= 0) {
                  this.setStyle(".mt-button", {
                    "justify-content": "center"
                  });
                } else {
                  this.setStyle(".mt-button", {
                    "justify-content": "flex-start"
                  });
                }
              }).bind(this));

              this.setStyle(".mt-button .textimage", {
                "align-self": "center",
                "align-items": "center"
              });
            }
          } else if (this._image) {
            this._image.getElement().parentElement.remove();
            this._image.destroy();
            this._image = null;
          }
        },

        /**
         * Callback once image has finish loading
         * @private
         */
        _imageLoaded: function(event, src) {
          this._layoutEngine.invalidateMeasure();
          this.emit(context.constants.widgetEvents.ready);
        },

        /**
         * Gets the image of the button
         * @returns {?string} the URL of the displayed image
         * @publicdoc
         */
        getImage: function() {
          if (this._image) {
            return this._image.getSrc();
          }
          return null;
        },

        /**
         * Define the button as autoscaled or not
         * @param {boolean} enabled the button autoscale mode
         * @publicdoc
         */
        setAutoScale: function(enabled) {
          this._autoScale = enabled;
          if (this._image) {
            this._image.setAutoScale(this._autoScale);
            this._image.getElement().parentElement.toggleClass('gbc_autoScale', this._autoScale);
          }
        },

        /**
         * @inheritDoc
         */
        setFocus: function(fromMouse) {
          if (this.getParentWidget() && (this.getParentWidget().isDropDown || this.getParentWidget().isHidden())) {
            var uiWidget = this.getUserInterfaceWidget();
            if (uiWidget) {
              uiWidget.getElement().domFocus();
            }
          } else {
            this._mtButton.domFocus();
          }
          $super.setFocus.call(this, fromMouse);
        },

        /**
         * @inheritDoc
         */
        setEnabled: function(enabled) {
          $super.setEnabled.call(this, enabled);
          this.domAttributesMutator(function() {
            this._mtButton.toggleClass('disabled', !enabled);
          }.bind(this));
        },

        /**
         * @inheritDoc
         */
        setColor: function(color) {
          this.setStyle('.mt-button', {
            'color': !!color ? color + ' !important' : null
          });
        },

        /**
         * @inheritDoc
         */
        getColor: function() {
          return this.getStyle('.mt-button', 'color');
        },

        /**
         * Set Default color (defined by DefaultTTF)
         * @param {string} color - rgb formatted or css name
         */
        setDefaultColor: function(color) {
          this._defaultColor = color;
          if (this._image) {
            this._image.setDefaultColor(color);
          }
        },

        /**
         * @inheritDoc
         */
        setBackgroundColor: function(color) {
          this.setStyle('.mt-button', {
            'background-color': !!color ? color + ' !important' : null
          });
        },

        /**
         * @inheritDoc
         */
        getBackgroundColor: function() {
          return this.getStyle('.mt-button', 'background-color');
        },

        /**
         * Align the content of the button
         * @param {string} align the button content alignment
         * @publicdoc
         */
        setContentAlign: function(align) {
          this._element.toggleClass('content-left', align === 'left')
            .toggleClass('content-right', align === 'right');
        },

        /**
         * @inheritDoc
         */
        setTitle: function(title) {
          $super.setTitle.call(this, title);
          if (this._image) {
            this._image.setTitle(title);
          }
        },

        /**
         * Hide the button text
         * @param {boolean} textHidden the button text visibility
         * @publicdoc
         */
        setTextHidden: function(textHidden) {
          this._element.toggleClass('text-hidden', textHidden);
        },

        /**
         * Define the button type (normal, link or commandLink)
         * @param {string} buttonType the button type
         * @publicdoc
         */
        setButtonType: function(buttonType) {
          if (this._buttonType) {
            this._mtButton.removeClass('buttonType_' + this._buttonType);
            this.removeClass('buttonType_' + this._buttonType);
          }
          this._buttonType = buttonType;
          this._mtButton.addClass('buttonType_' + buttonType);
          this.addClass('buttonType_' + buttonType);
        },

        /**
         * Defines the alignment of the button text
         * @param {string} vertical - vertical position
         * @param {string} horizontal - horizontal position left, right or centered
         */
        setAlignment: function(vertical, horizontal) {
          this._alignment = {
            "vertical": vertical,
            "horizontal": horizontal
          };

          var _flex = {
            "top": "flex-start",
            "verticalCenter": "center",
            "bottom": "flex-end",
            "left": "flex-start",
            "horizontalCenter": "center",
            "right": "flex-end"
          };

          if (["left", "center", "right"].indexOf(horizontal) >= 0) {
            this.setStyle(".mt-button", {
              "justify-content": _flex[horizontal]
            });
          }

          if (["top", "verticalCenter", "bottom"].indexOf(vertical) >= 0) {
            this.setStyle(".mt-button .textimage", {
              "align-self": _flex[vertical]
            });
          }
        },
        /**
         * @inheritDoc
         */
        setInterruptable: function(interruptable) {
          $super.setInterruptable.call(this, interruptable);
          if (this._mtButton) {
            if (interruptable) {
              this._mtButton.setAttribute("interruptable", "interruptable");
            } else {
              this._mtButton.removeAttribute("interruptable");
            }
          }
        },
        /**
         * @inheritDoc
         */
        setInterruptableActive: function(isActive) {
          $super.setInterruptableActive.call(this, isActive);
          if (this._mtButton) {
            if (isActive) {
              this._mtButton.setAttribute("interruptable-active", "interruptable-active");
            } else {
              this._mtButton.removeAttribute("interruptable-active");
            }
          }
        },

        /**
         * Set the aria-current attribute instead of aria-selected to help screen-reader to know wich widget is the current one
         */
        setAriaSelection: function() {
          this.domAttributesMutator(function() {
            var currentSelected = document.querySelector('[aria-current="true"]');
            if (currentSelected) {
              currentSelected.removeAttribute('aria-current');
            }
          });
          this.setAriaAttribute('current', "true");
        },

      };
    });
    cls.WidgetFactory.registerBuilder('Button', cls.ButtonWidget);
    cls.WidgetFactory.registerBuilder('ButtonWidget', cls.ButtonWidget);
    cls.WidgetFactory.registerBuilder('Action', cls.ButtonWidget);
    cls.WidgetFactory.registerBuilder('MenuAction', cls.ButtonWidget);
  });
;
'use strict';

modulum('CheckBoxWidget', ['FieldWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Checkbox widget.
     * @class CheckBoxWidget
     * @memberOf classes
     * @extends classes.FieldWidgetBase
     * @publicdoc Widgets
     */
    cls.CheckBoxWidget = context.oo.Class(cls.FieldWidgetBase, function($super) {
      return /** @lends classes.CheckBoxWidget.prototype */ {
        __name: 'CheckBoxWidget',
        __dataContentPlaceholderSelector: cls.WidgetBase.selfDataContent,
        /**
         * @type HTMLElement
         */
        _checkboxElement: null,
        /**
         * @type HTMLElement
         */
        _labelElement: null,
        /**
         * @type {*}
         */
        _checkedValue: true,
        /**
         * @type {*}
         */
        _uncheckedValue: false,
        /**
         * @type {*}
         */
        _value: false,
        /**
         * the value of the intermediate state
         * @type {?string}
         */
        _indeterminateValue: null,
        /**
         * @type {boolean}
         */
        _notNull: true,
        /**
         * @type {boolean}
         */
        _allowNullValue: false,

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          this.setFocusable(true);
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          if (!this._ignoreLayout) {
            this._layoutInformation = new cls.LayoutInformation(this);
            this._layoutEngine = new cls.LeafLayoutEngine(this);
            this._layoutInformation.getSizePolicyConfig().initial = cls.SizePolicy.Dynamic();
            this._layoutInformation.getSizePolicyConfig().fixed = cls.SizePolicy.Dynamic();
          }
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          this._checkboxElement = this._element.getElementsByClassName('zmdi')[0];
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._checkboxElement = null;
          this._labelElement = null;
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          if (!this.isEnabled() && !this.isInTable() && !this.isInMatrix()) {
            return true; // if check disabled and not in matrix not in table --> nothing to do
          }

          this._onRequestFocus(domEvent); // request focus

          if (this.isEnabled()) {
            var value = this.getNextValue();
            this.setEditing(true);
            this.setValue(value);

            this.emit(context.constants.widgetEvents.change, false);
          }
          this.emit(context.constants.widgetEvents.click, domEvent);

          return true;
        },

        /**
         * @inheritDoc
         */
        manageKeyDown: function(keyString, domKeyEvent, repeat) {
          var keyProcessed = false;

          if (this.isEnabled()) {
            if (keyString === "space" && !repeat) {
              this.setEditing(true);
              var value = this.getNextValue();
              this.setValue(value);
              this.emit(context.constants.widgetEvents.change, false);
              keyProcessed = true;
            }
          }

          if (keyProcessed) {
            return true;
          } else {
            return $super.manageKeyDown.call(this, keyString, domKeyEvent, repeat);
          }
        },

        /**
         * Set widget mode. Useful when widget have peculiar behavior in certain mode
         * @param {string} mode the widget mode
         * @param {boolean} active the active state
         */
        setWidgetMode: function(mode, active) {
          this._allowNullValue = mode === "Construct";
        },

        /**
         * Defines a third state
         * @param {*} indeterminateValue value corresponding to the 'intermediate' state
         * @publicdoc
         */
        setIndeterminateValue: function(indeterminateValue) {
          var old = this._indeterminateValue;
          this._indeterminateValue = indeterminateValue;
          if (this.getValue() === old) {
            this.setValue(indeterminateValue);
          }
        },

        /**
         * Get the third state value
         * @returns {*} value corresponding to the 'third' state
         * @publicdoc
         */
        getIndeterminateValue: function() {
          return this._indeterminateValue;
        },

        /**
         * @returns {*} the next value in the cycle
         * @private
         */
        getNextValue: function() {
          var current = this._value;
          if (current === this._indeterminateValue ||
            ((this._notNull && !this._allowNullValue) && current === this._uncheckedValue)) {
            return this._checkedValue;
          } else if (current === this._checkedValue) {
            return this._uncheckedValue;
          } else {
            if (this._allowNullValue || !this.notNull) {
              return this._indeterminateValue;
            }
          }
        },

        /**
         * Get the text of this checkbox
         * @returns {string} the text displayed next to the button
         * @publicdoc
         */
        getText: function() {
          if (this._labelElement) {
            return this._labelElement.textContent;
          }
          return '';
        },

        /**
         * Set the text of the checkbox
         * @param {string} text - the text displayed next to the button
         * @publicdoc
         */
        setText: function(text) {
          text = !!text ? text : ''; // fix for ie & edge

          if (this._labelElement === null && text !== '') {
            this._labelElement = document.createElement('div');
            this._labelElement.addClass('label');
            this._element.getElementsByClassName('content')[0].appendChild(this._labelElement);
          }
          if (this._labelElement) {
            this.domAttributesMutator(function() {
              this._labelElement.toggleClass('notext', !text);
              this._labelElement.textContent = text;
            }.bind(this));
            if (this.getLayoutEngine()) {
              this.getLayoutEngine().forceMeasurement();
              this.getLayoutEngine().invalidateMeasure();
            }
          }
        },

        /**
         * Set the checked value
         * @param {*} checkedValue - value corresponding to the 'checked' state
         * @publicdoc
         */
        setCheckedValue: function(checkedValue) {
          var old = this._checkedValue;
          this._checkedValue = checkedValue;
          if (this.getValue() === old) {
            this.setValue(checkedValue);
          }
        },

        /**
         * Get the checked value
         * @returns {*} value corresponding to the 'checked' state
         * @publicdoc
         */
        getCheckedValue: function() {
          return this._checkedValue;
        },

        /**
         * Set unchecked value
         * @param {*} uncheckedValue - value corresponding to the 'checked' state
         * @publicdoc
         */
        setUncheckedValue: function(uncheckedValue) {
          var old = this._uncheckedValue;
          this._uncheckedValue = uncheckedValue;
          if (this.getValue() === old) {
            this.setValue(uncheckedValue);
          }
        },

        /**
         * Get unchecked value
         * @returns {*} value corresponding to the 'checked' state
         * @publicdoc
         */
        getUncheckedValue: function() {
          return this._uncheckedValue;
        },

        /**
         * @inheritDoc
         */
        getValue: function() {
          if (this._checkboxElement.hasClass('indeterminate')) {
            return this._indeterminateValue;
          } else if (this._checkboxElement.hasClass('checked')) {
            return this._checkedValue;
          } else {
            return this._uncheckedValue;
          }
        },

        /**
         * @inheritDoc
         */
        getClipboardValue: function() {
          if (this._checkboxElement.hasClass('checked')) {
            return this.getText();
          } else {
            return '';
          }
        },

        /**
         * @inheritDoc
         */
        setValue: function(value, fromVM) {
          $super.setValue.call(this, value, fromVM);
          this._value = value;
          this._checkboxElement.toggleClass('indeterminate', value === this._indeterminateValue);
          this._checkboxElement.toggleClass('checked', value === this._checkedValue);
          this._checkboxElement.toggleClass('unchecked', value !== this._checkedValue && value !== this._indeterminateValue);
          if (value === this._indeterminateValue) {
            this.setAriaAttribute("checked", "mixed");
          } else {
            this.setAriaAttribute("checked", (value === this._checkedValue).toString());
          }
        },

        /**
         * @inheritDoc
         */
        setFocus: function(fromMouse) {
          this._element.domFocus();
          $super.setFocus.call(this, fromMouse);
        },

        /**
         * @inheritDoc
         */
        setEnabled: function(enabled) {
          $super.setEnabled.call(this, enabled);
          this._checkboxElement.toggleClass('disabled', !enabled);
        }
      };
    });
    cls.WidgetFactory.registerBuilder('CheckBox', cls.CheckBoxWidget);
    cls.WidgetFactory.registerBuilder('CheckBoxWidget', cls.CheckBoxWidget);
  });
;
'use strict';

modulum('ComboBoxWidget', ['ComboBoxWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Combobox widget.
     * @class ComboBoxWidget
     * @memberOf classes
     * @extends classes.ComboBoxWidgetBase
     * @publicdoc Widgets
     */

    cls.ComboBoxWidget = context.oo.Class(cls.ComboBoxWidgetBase, function($super) {
      return /** @lends classes.ComboBoxWidget.prototype */ {
        __name: 'ComboBoxWidget',

        /** @type {string} */
        __dataContentPlaceholderSelector: '.gbc_dataContentPlaceholder',
        /** @type {classes.EditWidget}*/
        _editWidget: null,
        /** @type {classes.ListDropDownWidget} */
        _dropDown: null,
        /** @type {string} */
        _typedLetters: "",
        /** @function */
        _typedLettersCacheHandler: null,
        /** @function */
        _focusHandler: null,
        /** @function */
        _editFocusHandler: null,
        /** @function */
        _dropDownSelectHandler: null,
        /** @function */
        _visibilityChangeHandler: null,

        /** @type {HTMLElement} */
        _toggleIcon: null,

        /** @type {string} */
        _placeholderText: '',

        /** @type {string} */
        _currentValue: "",
        /** @type {string} */
        _lastVMValue: "",
        /** @type {boolean} */
        _allowMultipleValues: false,

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          if (!this._ignoreLayout) {
            this._layoutInformation = new cls.LayoutInformation(this);
            this._layoutEngine = new cls.ComboBoxLayoutEngine(this);
            this._layoutInformation.setReservedDecorationSpace(2);
            this._layoutInformation.setSingleLineContentOnly(true);
          }
        },

        /**
         * Bind all events listeners on combobox and create the combobox dropdown
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);

          this._toggleIcon = this.getElement().querySelector("i.toggle");

          this.setStyle('i.toggle', {
            'min-width': (window.scrollBarSize) + 'px',
          });

          this._editWidget = cls.WidgetFactory.createWidget('EditWidget', this.getBuildParameters());
          this._editWidget.setFocusable(false);
          this._editWidget.setParentWidget(this);
          this._element.prependChild(this._editWidget.getElement());

          this._dropDown = cls.WidgetFactory.createWidget('ListDropDown', this.getBuildParameters());
          this._dropDown.setParentWidget(this);
          this._dropDown.fallbackMaxHeight = 300;
          this._dropDown.hide();
          this._dropDownSelectHandler = this._dropDown.when(context.constants.widgetEvents.select, this._onSelectValue.bind(this));
          this._focusHandler = this.when(context.constants.widgetEvents.focus, this._onFocus.bind(this));
          this._dropDown.onClose(this._onFocus.bind(this));
          this._dropDown.onClose(this._onClose.bind(this));

          this._editWidget._inputElement.on('blur.ComboBoxWidget', this._onBlur.bind(this));
          this._editFocusHandler = this._editWidget.when(context.constants.widgetEvents.requestFocus,
            this._onEditRequestFocus.bind(this));

          this._visibilityChangeHandler = this._dropDown
            .when(context.constants.widgetEvents.visibilityChange, this._updateEditState.bind(this));

          this.setAriaAttribute("owns", this._dropDown.getRootClassName());
          this.setAriaAttribute("labelledby", this._editWidget.getRootClassName());
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._focusHandler) {
            this._focusHandler();
            this._focusHandler = null;
          }
          if (this._editFocusHandler) {
            this._editFocusHandler();
            this._editFocusHandler = null;
          }
          if (this._dropDownSelectHandler) {
            this._dropDownSelectHandler();
            this._dropDownSelectHandler = null;
          }
          if (this._visibilityChangeHandler) {
            this._visibilityChangeHandler();
            this._visibilityChangeHandler = null;
          }

          this._editWidget._inputElement.off('blur.ComboBoxWidget');

          if (this._dropDown) {
            this._dropDown.destroy();
            this._dropDown = null;
          }

          this._typedLettersCacheHandler = null;

          this._editWidget.destroy();
          this._editWidget = null;
          $super.destroy.call(this);
        },

        /**
         * Set widget mode. Useful when widget have peculiar behavior in certain mode
         * @param {string} mode the widget mode
         * @param {boolean} active the active state
         */
        setWidgetMode: function(mode, active) {
          this._allowMultipleValues = mode === "Construct";
          this._dropDown.allowMultipleChoices(this._allowMultipleValues);
          this._updateEditState();
          this._updateTextTransform();
        },

        /**
         * Returns whether or not the user should be able to input data freely
         * @return {boolean} true if user can input data
         */
        canInputText: function() {
          return $super.canInputText.call(this) && this._allowMultipleValues;
        },

        /**
         * format the value
         * @param {string} value value
         * @return {string} the formatted value
         * @private
         */
        _getFormattedValue: function(value) {
          var allResolved = true,
            values = (value || "").split("|").map(function(itemValue) {
              var found = this._dropDown.findByValue(itemValue);
              allResolved = allResolved && (!!found || itemValue === "");
              return found && found.text || itemValue;
            }.bind(this));
          if (values[0] === "") {
            values.splice(0, 1);
          }
          return allResolved ? values.join("|") : value;
        },

        /**
         * Handler when focus is requested
         * @param event
         * @param sender
         * @param domEvent
         */
        _onEditRequestFocus: function(event, sender, domEvent) {
          this.emit(context.constants.widgetEvents.requestFocus, domEvent);
        },

        /**
         * update the edit value from the widget value
         * @private
         */
        _updateEditValue: function() {
          this._editWidget.setValue(this._getFormattedValue(this._currentValue));
        },
        /**
         * update edit availability
         * @private
         */
        _updateEditState: function() {
          var readOnly = this._dropDown.isVisible() || !this.canInputText();
          this._editWidget.setReadOnly(readOnly);
          this.domAttributesMutator(function(readOnly) {
            this._editWidget._inputElement.setAttribute('contentEditable', readOnly ? 'false' : 'true');
          }.bind(this, readOnly));
        },

        /**
         * Handler once dropdown is closed
         * @private
         */
        _onClose: function() {
          this._toggleIcon.toggleClass("dd-open", this._dropDown.isVisible());
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          this._onRequestFocus(domEvent); // request focus
          if (this.isEnabled()) {
            this._dropDown.show();
            this._toggleIcon.toggleClass("dd-open", this._dropDown.isVisible());
          }
          return true;
        },

        /**
         * Focus handler
         * @private
         */
        _onFocus: function() {
          if (this._editWidget && this.isEnabled()) {
            this._editWidget.getInputElement().domFocus();
          }
        },

        /**
         * Blur handler
         * @private
         */
        _onBlur: function() {
          if (!this._dropDown.isVisible()) {
            this.emit(context.constants.widgetEvents.blur);
          } else if (!this.hasFocus()) {
            this._dropDown.hide();
          }
        },
        /**
         * when value is selected in the dropdown
         * @param event
         * @param src
         * @param value
         * @private
         */
        _onSelectValue: function(event, src, value) {
          this.setEditing(true);
          this.setValue(value);
        },

        /**
         * @inheritDoc
         */
        managePriorityKeyDown: function(keyString, domKeyEvent, repeat) {
          var keyProcessed = false;
          if (this._dropDown.isVisible()) {
            keyProcessed = this._dropDown.managePriorityKeyDown(keyString, domKeyEvent, repeat);
          }

          if (keyProcessed) {
            return true;
          } else {
            return $super.managePriorityKeyDown.call(this, keyString, domKeyEvent, repeat);
          }
        },

        /**
         * @inheritDoc
         */
        manageKeyDown: function(keyString, domKeyEvent, repeat) {
          var keyProcessed = false;

          if (this.isEnabled()) {
            // we call managePriorityKeyDown method on the closed combobox to select item using same navigation logic
            keyProcessed = this._dropDown.managePriorityKeyDown(keyString, domKeyEvent, repeat);

            if (!keyProcessed) {
              // auto item preselection by name
              keyProcessed = this._processKey(domKeyEvent, keyString);
            }
          }

          if (keyProcessed) {
            return true;
          } else {
            return $super.manageKeyDown.call(this, keyString, domKeyEvent, repeat);
          }
        },

        /**
         * Process one key event
         * @param {Object} event
         * @param {string} keyString
         * @returns {boolean} true if key has been processed, false otherwise
         * @private
         */
        _processKey: function(event, keyString) {
          if (event.which <= 0) { // arrows key (for firefox)
            return false;
          }
          var key = event.gbcKey;

          if (key.length > 1) { // we only want single char
            return false;
          }
          if (this._typedLettersCacheHandler) {
            this._clearTimeout(this._typedLettersCacheHandler);
            this._typedLettersCacheHandler = 0;
          }
          if (!this._dropDown.isVisible()) {
            if (this.canInputText()) {
              return false;
            }
          }
          var found, lastChar = key.toLocaleLowerCase(),
            repeating = this._typedLetters[this._typedLetters.length - 1] === lastChar;
          this._typedLettersCacheHandler = this._registerTimeout(this._clearTypedLettersCache.bind(this), 1000);
          if (repeating) {
            found = this._dropDown.findStartingByText(this._typedLetters, true);
            if (found && found.value === this._currentValue) {
              found = null;
            }
          }
          if (!found || !repeating) {
            this._typedLetters += lastChar;
            found = this._dropDown.findStartingByText(this._typedLetters);
          }
          if (!found) {
            this._typedLetters = lastChar;
            found = this._dropDown.findStartingByText(this._typedLetters);
          }
          if (found) {
            this._dropDown.navigateToItem(found);
            if (!this._dropDown.isVisible()) {
              this.setEditing(this._oldValue !== found.value);
              this.setValue(found.value);
            }
            return true;
          }
          return false;
        },

        /**
         * Clear the cache of typed letters
         * @private
         */
        _clearTypedLettersCache: function() {
          this._typedLettersCacheHandler = 0;
          this._typedLetters = "";
        },

        /**
         * Get the value of the dropdown list at given position
         * @param {number} pos - position in the dropdown
         * @return {*} value at given position
         * @publicdoc
         */
        getValueAtPosition: function(pos) {
          return this._dropDown.getValueAtPosition(pos);
        },

        /**
         * get the available items
         * @return {Object[]}
         */
        getItems: function() {
          return this._dropDown.getItems();
        },

        /**
         * set combobox choice(s)
         * @param {ListDropDownWidgetItem|ListDropDownWidgetItem[]} choices - a single or a list of choices
         * @publicdoc
         */
        setChoices: function(choices) {
          var list = choices;
          if (!Array.isArray(choices)) {
            list = choices ? [choices] : [];
          }
          this._dropDown.setItems(list);
          if (this._dropDown.isVisible()) {
            this._dropDown.setSelectedValues(this.getValue());
            this._dropDown.setCurrentValue(this.getValue());
          }
          this._updateSelectedValue();
          if (this._layoutEngine) {
            this._layoutEngine.invalidateMeasure();
          }
        },
        /**
         * update edit value
         * @private
         */
        _updateSelectedValue: function() {
          var selectedValue = this.isEditing() ? this._editWidget.getValue() : this._lastVMValue,
            foundInList = this._dropDown.findByValue(selectedValue);
          this._currentValue = foundInList && foundInList.value || "";
          if (!foundInList) {
            this._editWidget.setValue('');
          } else {
            this._editWidget.setValue(foundInList.text);
          }
        },

        /**
         * Display the dropdown
         * @publicdoc
         */
        showDropDown: function() {
          this.emit(context.constants.widgetEvents.requestFocus, null);
          this._dropDown.show();
        },

        toggleDropDown: function() {
          this._dropDown.toggle();
        },

        /**
         * @inheritDoc
         */
        getValue: function() {
          var editValue = this.getEditValue(),
            formattedValue = this._getFormattedValue(this._currentValue);
          return this.canInputText() && !this._dropDown.isVisible() &&
            editValue !== formattedValue ? editValue : this._currentValue || "";
        },

        /**
         * @inheritDoc
         */
        getClipboardValue: function() {
          var value = this._dropDown.getCurrentValue();
          var item = this._dropDown.findByValue(value);
          return item ? item.text : value;
        },

        /**
         * get the edit value
         * @return {string}
         */
        getEditValue: function() {
          return this._editWidget && this._editWidget.getValue() || "";
        },

        /**
         * @inheritDoc
         */
        setValue: function(value, fromVM) {
          $super.setValue.call(this, value, fromVM);
          if (fromVM) {
            if (this._editWidget) {
              this._editWidget.setEditing(false);
            }
            this._lastVMValue = value;
          }
          this._setValue(value, fromVM);
        },

        /**
         * Internal setValue used to be inherited correctly by OtherWidget
         * @param {string} value - the value
         * @param {boolean} [fromVM] - is value come from VM ?
         * @private
         */
        _setValue: function(value, fromVM) {
          var currentValue, valueChanged = false;
          if (this._allowMultipleValues) {
            if (this._dropDown.isVisible()) {
              if (fromVM) {
                this._currentValue = value;
                this._updateEditValue();
              } else {
                var values = this._currentValue === "" ? [] : this._currentValue.split("|");
                var existingIndex = values.indexOf(value);
                if (existingIndex >= 0) {
                  values.splice(existingIndex, 1);
                } else {
                  values.push(value);
                }
                values = this._dropDown.sortValues(values);
                this._currentValue = values.join("|");
                valueChanged = true;
                this._updateEditValue();
              }
              this._dropDown.setSelectedValues(this._currentValue);
            } else {
              currentValue = this._currentValue || "";
              if (currentValue !== value) {
                this._currentValue = value;
                this._dropDown.setCurrentValue(value);
                this._updateEditValue();
                valueChanged = true;
              }
              if (!fromVM && valueChanged) {
                this.emit(context.constants.widgetEvents.change, false);
              }
            }
          } else {
            currentValue = this._currentValue || "";
            if (currentValue !== value) {
              var found = this._dropDown.findByValue(value);
              this._currentValue = found && found.value || "";
              this._dropDown.setCurrentValue(this._currentValue);
              this._editWidget.setValue(found ? found.text : "");
              valueChanged = true;
            }
          }
          if (!fromVM && valueChanged) {
            this.emit(context.constants.widgetEvents.change, false);
          }
        },

        /**
         * @inheritDoc
         */
        setFocus: function(fromMouse) {
          $super.setFocus.call(this, fromMouse);
          if (this._editWidget) {
            this._editWidget.getInputElement().domFocus();
          } else {
            this._element.domFocus();
          }
        },

        /**
         * @inheritDoc
         */
        setEnabled: function(enabled) {
          $super.setEnabled.call(this, enabled);
          this._editWidget.setEnabled(enabled);
          this._updateEditState();
          this._updateEditValue();
          this._dropDown.setEnabled(enabled);
        },

        /**
         * sets the combobox as query editable
         * @param {boolean} isQueryEditable
         */
        setQueryEditable: function(isQueryEditable) {
          this._isQueryEditable = isQueryEditable;
          this._updateEditState();
          this._updateTextTransform();
        },

        /**
         * @inheritDoc
         */
        setColor: function(color) {
          $super.setColor.call(this, color);
          this._editWidget.setColor(color);
          if (this._dropDown) {
            this._dropDown.setColor(color);
          }
        },

        /**
         * @inheritDoc
         */
        getColorFromStyle: function() {
          return this._editWidget.getColorFromStyle();
        },

        /**
         * @inheritDoc
         */
        setBackgroundColor: function(color) {
          $super.setBackgroundColor.call(this, color);
          this._editWidget.setBackgroundColor(color);
          if (this._dropDown) {
            this._dropDown.setBackgroundColor(color);
          }
        },

        /**
         * @inheritDoc
         */
        setFontWeight: function(weight) {
          $super.setFontWeight.call(this, weight);
          this._editWidget.setFontWeight(weight);
        },

        /**
         * @inheritDoc
         */
        setFontStyle: function(style) {
          $super.setFontStyle.call(this, style);
          this._editWidget.setFontStyle(style);
        },

        /**
         * @inheritDoc
         */
        setTextAlign: function(align) {
          $super.setFontAlign.call(this, align);
          this._editWidget.setTextAlign(align);
        },

        /**
         * @inheritDoc
         */
        removeTextTransform: function() {
          $super.removeTextTransform.call(this);
          this._editWidget.removeTextTransform();
        },
        /**
         * @inheritDoc
         */
        _updateTextTransform: function() {
          var wantedTextTransform = this.canInputText() ? this._textTransform : "none";
          if (wantedTextTransform !== this._editWidget.getTextTransform()) {
            this._editWidget.removeTextTransform();
            this._editWidget.setTextTransform(wantedTextTransform);
          }
        },

        /**
         * @inheritDoc
         */
        setTextDecoration: function(decoration) {
          $super.setTextDecoration.call(this, decoration);
          this._editWidget.setTextDecoration(decoration);
        },

        /**
         * Handle a null item if notNull is not specified
         * @param {boolean} notNull - combobox accept notNull value?
         * @publicdoc
         */
        setNotNull: function(notNull) {
          $super.setNotNull.call(this, notNull);
          this._dropDown.setNotNull(notNull);
        },

        /**
         * @inheritDoc
         */
        setPlaceHolder: function(placeholder) {
          $super.setPlaceHolder.call(this, placeholder);
          this._editWidget.setPlaceHolder(placeholder);
        }
      };
    });
    cls.WidgetFactory.registerBuilder('ComboBox', cls.ComboBoxWidget);
    cls.WidgetFactory.registerBuilder('ComboBoxWidget', cls.ComboBoxWidget);
  });
;
'use strict';

modulum('ComboBoxWidgetBase', ['FieldWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Combobox widget base class.
     * @class ComboBoxWidgetBase
     * @memberOf classes
     * @extends classes.FieldWidgetBase
     * @publicdoc Widgets
     */

    cls.ComboBoxWidgetBase = context.oo.Class(cls.FieldWidgetBase, function($super) {
      return /** @lends classes.ComboBoxWidgetBase.prototype */ {
        __name: 'ComboBoxWidgetBase',
        /**
         * Flag for augmentedFace
         * @type {boolean}
         */
        __virtual: true,

        /**
         * Is the combobox query editable?
         * @type {boolean}
         * @protected
         */
        _isQueryEditable: null,

        /**
         * Bind all events listeners on combobox and create the combobox dropdown
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);

          this.setFocusable(true);
          this.setAriaAttribute("expanded", "false");
          this.setAriaAttribute("live", "polite");
        },

        /**
         * Set widget mode. Useful when widget have peculiar behavior in certain mode
         * @param {string} mode the widget mode
         * @param {boolean} active the active state
         */
        setWidgetMode: function(mode, active) {
          this._updateTextTransform();
        },

        /**
         * Returns whether or not the user should be able to input data freely
         * @return {boolean} true if user can input data
         */
        canInputText: function() {
          return this._isQueryEditable;
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          this._onRequestFocus(domEvent); // request focus
          return true;
        },

        /**
         * Get the value of the dropdown list at given position
         * @param {number} pos - position in the dropdown
         * @return {*} value at given position
         * @publicdoc
         */
        getValueAtPosition: function(pos) {
          return null;
        },

        /**
         * get the available items
         * @return {Object[]}
         */
        getItems: function() {
          return [];
        },

        /**
         * set combobox choice(s)
         * @param {ListDropDownWidgetItem|ListDropDownWidgetItem[]} choices - a single or a list of choices
         * @publicdoc
         */
        setChoices: function(choices) {},

        /**
         * Display the dropdown
         * @publicdoc
         */
        showDropDown: function() {},

        toggleDropDown: function() {},

        /**
         * @inheritDoc
         */
        setEnabled: function(enabled) {
          $super.setEnabled.call(this, enabled);
          this._element.toggleClass('disabled', !enabled);
        },

        /**
         * sets the combobox as query editable
         * @param {boolean} isQueryEditable
         */
        setQueryEditable: function(isQueryEditable) {
          this._isQueryEditable = isQueryEditable;
          this._updateTextTransform();
        },

        /**
         * @inheritDoc
         */
        setTextTransform: function(transform) {
          if (this._textTransform !== transform) {
            this._textTransform = transform;
            this._updateTextTransform();
          }
        },

        /**
         * @inheritDoc
         */
        getTextTransform: function() {
          return this.canInputText() ? this._textTransform : "none";
        },

        /**
         * @inheritDoc
         */
        removeTextTransform: function() {
          this._textTransform = 'none';
        },
        /**
         * update text transform behavior
         * @protected
         */
        _updateTextTransform: function() {},

        /**
         * @inheritDoc
         */
        setPlaceHolder: function(placeholder) {
          this.setAriaAttribute("placeholder", placeholder);
        }
      };
    });
  });
;
'use strict';

modulum('CommandLinkWidget', ['ButtonWidget', 'WidgetFactory'],
  function(context, cls) {
    /**
     * Button widget CommandLinkWidget.
     * @class CommandLinkWidget
     * @memberOf classes
     * @extends classes.ButtonWidget
     */
    cls.CommandLinkWidget = context.oo.Class(cls.ButtonWidget, function($super) {
      return /** @lends classes.CommandLinkWidget.prototype */ {
        __name: 'CommandLinkWidget',

        /**
         * @type {HTMLElement}
         */
        _titleElement: null,
        /**
         * @type {HTMLElement}
         */
        _commandContainer: null,
        /**
         * @type {HTMLElement}
         */
        _imageContainer: null,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          this._textElement = this._mtButton.querySelector('span.text');
          this._titleElement = this._mtButton.querySelector('span.title');
          this._commandContainer = this._mtButton.querySelector('div.command');
          this._imageContainer = this._mtButton.querySelector('.gbc_ImageContainer');
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._titleElement = null;
          this._commandContainer = null;
          this._imageContainer = null;
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        setImage: function(image) {
          if (this._imageReadyHandler) {
            this._imageReadyHandler();
            this._imageReadyHandler = null;
          }
          if (image.length !== 0) {
            if (!this._image) {
              this._image = cls.WidgetFactory.createWidget('ImageWidget', this.getBuildParameters());
              this._imageContainer.appendChild(this._image.getElement());

              this.setAutoScale(this._autoScale);
              if (this._defaultColor) {
                this._image.setDefaultColor(this._defaultColor);
              }
            }
            this._image.setSrc(image);
            this._imageReadyHandler = this._image.when(context.constants.widgetEvents.ready, this._imageLoaded.bind(this));
            this.getElement().addClass('hasImage');
          } else if (this._image) {
            this._image.getElement().parentElement.remove();
            this._image.destroy();
            this._image = null;
          }
        },

        /**
         * @inheritDoc
         */
        setTitle: function(title) {
          $super.setTitle.call(this, title);
          if (this._buttonType === 'commandLink') {
            this._titleElement.textContent = title;
          }
        }

      };
    });
    cls.WidgetFactory.registerBuilder('Button[buttonType=commandLink]', cls.CommandLinkWidget);
    cls.WidgetFactory.registerBuilder('CommandLink', cls.CommandLinkWidget);
  });
;
'use strict';

modulum('DateEditWidget', ['DateEditWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * DateEdit widget using pikaday.
     * @class DateEditWidget
     * @memberOf classes
     * @extends classes.DateEditWidgetBase
     * @publicdoc Widgets
     */
    cls.DateEditWidget = context.oo.Class(cls.DateEditWidgetBase, function($super) {
      return /** @lends classes.DateEditWidget.prototype */ {
        __name: 'DateEditWidget',

        $static: {
          /**
           * List of calendar days name
           * @type {Array.<string>}
           */
          pikaDaysList: ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday']
        },

        /**
         * Display or not the week Number
         * @type {?boolean}
         */
        _showWeekNumber: null,

        /**
         * name of the first day of the week
         * @type {string}
         */
        _firstDayOfWeek: null,

        /**
         * Get list of disabled days from calendar
         * @type {Array}
         */
        _disabledDays: null,

        /**
         * Dropdown widget which contains calendar
         * @type {classes.DropDownWidget}
         */
        _dropDown: null,

        /**
         * Button OK of the dropdown
         * @type {HTMLElement}
         */
        _buttonOk: null,

        /**
         * Button CANCEL of the dropdown
         * @type {HTMLElement}
         */
        _buttonCancel: null,

        /**
         * List of localized days visible in datepicker
         * @type {Array}
         */
        _localizedDaysList: null,

        /**
         * Reference of calendar instance (based on pikaday-time js library)
         * @type {Object}
         */
        _picker: null,

        /**
         * Type of dropdown. By default it's in a modal like style
         * @type {boolean}
         */
        _isModal: true,

        /**
         * Listen on theme change to execute a callback
         * @type {function}
         */
        _themeHandleRegistration: null,

        /**
         * Coefficient used as multiplier with defaut font-size ratio to set dropdown max height
         * @type {number}
         */
        _coeffMaxHeight: 387,
        /**
         * Last user validated value (for calendar of type modal only)
         * @type {string}
         */
        _validValue: null,
        /**
         * Check if current value needs a validation using OK button (for calendar of type modal only)
         * @type {boolean}
         */
        _mustValid: false,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);

          // create dropdown
          this._createCalendarContainer(true);

          // Manage requestFocus during selection of text
          this._inputElement.on('mousedown.DateEditWidgetBase', cls.WidgetBase._onSelect.bind(this));
        },

        /**
         * Create calendar container depending of the calendarType 4ST style attribute.
         * By default we use modal style
         * @param {boolean} isModal - true if we use modal style
         */
        _createCalendarContainer: function(isModal) {

          // destroy previous calendar container
          this._destroyCalendarContainer();

          this._dropDown = cls.WidgetFactory.createWidget('DropDown', this.getBuildParameters());
          this._dropDown.setParentWidget(this);
          this._dropDown.maxHeight = gbc.ThemeService.getValue("theme-font-size-ratio") * this._coeffMaxHeight;
          if (!this._themeHandleRegistration) {
            this._themeHandleRegistration = context.ThemeService.whenThemeChanged(function() {
              this._dropDown.maxHeight = gbc.ThemeService.getValue("theme-font-size-ratio") * this._coeffMaxHeight;
            }.bind(this));
          }

          // For some obscure reasons, iOS may not recognize pikaday library elements as children of dropdown.
          // We need to add a custom "pikaday specific" check
          this._dropDown.shouldClose = function(targetElement) {
            return !targetElement.parent(
              "pika-lendar"); // top pikaday div recognized as (wrongly!) having no parentNode under iOS mobile
          }.bind(this);

          if (isModal) { // MODAL
            // Create button which will close dropdown
            this._buttonCancel = document.createElement('span');
            this._buttonCancel.addClasses('gbc_DateEditButton', 'mt-button', 'mt-button-flat');
            this._buttonCancel.textContent = i18next.t('gwc.button.cancel');

            this._buttonOk = document.createElement('span');
            this._buttonOk.addClasses('gbc_DateEditButton', 'mt-button', 'mt-button-flat');
            this._buttonOk.textContent = i18next.t('gwc.button.ok');

            this._buttonOk.on('mousedown.DateEditWidgetBase', this._onOk.bind(this));
            this._buttonOk.on('touchend.DateEditWidgetBase', this._onOk.bind(this));

            this._buttonCancel.on('mousedown.DateEditWidgetBase', this._onCancel.bind(this));
            this._buttonCancel.on('touchend.DateEditWidgetBase', this._onCancel.bind(this));

            this._dropDown.onOpen(this._onCalendarTypeModalOpen.bind(this));
            this._dropDown.onClose(this._onCalendarTypeModalClose.bind(this));

          } else { // DIRECT CLICK
            this._dropDown.onOpen(this._onCalendarTypeDropDownOpen.bind(this));
          }
        },

        /**
         * Destroy calendar container
         * @private
         */
        _destroyCalendarContainer: function() {
          if (this._dropDown) {
            this._dropDown.destroy();
            this._dropDown = null;
          }
          if (this._buttonOk) {
            this._buttonOk.off('mousedown.DateEditWidgetBase');
            this._buttonOk.off('touchend.DateEditWidgetBase');
            this._buttonOk = null;
          }
          if (this._buttonCancel) {
            this._buttonCancel.off('mousedown.DateEditWidgetBase');
            this._buttonCancel.off('touchend.DateEditWidgetBase');
            this._buttonCancel = null;
          }
          if (this._themeHandleRegistration) {
            this._themeHandleRegistration();
            this._themeHandleRegistration = null;
          }
        },

        /**
         * @inheritDoc
         */
        destroy: function() {

          this._pikerIcon = null;

          if (this._inputElement) {
            this._inputElement.off('mousedown.DateEditWidgetBase');
            this._inputElement.remove();
            this._inputElement = null;
          }
          if (this._picker) {
            this._picker.destroy();
            this._picker = null;
          }

          this._destroyCalendarContainer();

          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        managePriorityKeyDown: function(keyString, domKeyEvent, repeat) {
          var keyProcessed = false;

          if (this.isEnabled() && this._dropDown.isVisible()) {
            var day = null;
            keyProcessed = true;
            switch (keyString) {
              case "home":
                day = context.moment(this._picker.getDate()).startOf('month').toDate();
                break;
              case "end":
                day = context.moment(this._picker.getDate()).endOf('month').toDate();
                break;
              case "left":
                day = context.moment(this._picker.getDate()).subtract(1, 'days').toDate();
                break;
              case "right":
                day = context.moment(this._picker.getDate()).add(1, 'days').toDate();
                break;
              case "up":
                day = context.moment(this._picker.getDate()).subtract(1, 'weeks').toDate();
                break;
              case "down":
                day = context.moment(this._picker.getDate()).add(1, 'weeks').toDate();
                break;
              case "pageup":
                day = context.moment(this._picker.getDate()).subtract(1, 'month').toDate();
                break;
              case "pagedown":
                day = context.moment(this._picker.getDate()).add(1, 'month').toDate();
                break;
              case "return":
              case "enter":
                this._onOk(domKeyEvent);
                break;
              case "esc":
                this._onCancel(domKeyEvent);
                break;
              case "tab":
              case "shift+tab":
                this._onCancel(domKeyEvent);
                keyProcessed = false;
                break;
              default:
                keyProcessed = false;
            }

            if (keyProcessed && day) {
              this._keyPressed = true;
              this._picker.setDate(day);
            }

            if (!keyProcessed && !this._isModal) {
              // When using dropdown style for the calendar, key pressed should close calendar
              this._mustValid = false;
              this._dropDown.hide();
            }
          }

          if (keyProcessed) {
            return true;
          } else {
            return $super.managePriorityKeyDown.call(this, keyString, domKeyEvent, repeat);
          }
        },

        /**
         * @inheritDoc
         */
        manageKeyDown: function(keyString, domKeyEvent, repeat) {
          var keyProcessed = false;

          if (this.isEnabled()) {

            keyProcessed = true;
            switch (keyString) {

              case "alt+up":
              case "alt+down":
                this._dropDown.show();
                break;

              default:
                keyProcessed = false;
            }
          }

          if (keyProcessed) {
            return true;
          } else {
            return $super.manageKeyDown.call(this, keyString, domKeyEvent, repeat);
          }
        },

        /**
         * @inheritDoc
         */
        manageKeyUp: function(keyString, domKeyEvent) {
          $super.manageKeyUp.call(this, keyString, domKeyEvent);

          this.emit(context.constants.widgetEvents.change, true);
          this.emit(context.constants.widgetEvents.keyUp, domKeyEvent, true);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {

          this._onRequestFocus(domEvent); // request focus
          if (domEvent.target.isElementOrChildOf(this._pikerIcon)) { // click on calendar icon
            // if widget already has VM focus, we need to explicitly set focus to input when clicking on dateedit icon, otherwise keyboard binding are not trapped.
            // if widget doesn't have VM focus, VM will set focus to input.
            if (this.hasVMFocus() && this.isEnabled() && !this.isModal()) {
              this._inputElement.domFocus();
            }
            if (this.isEnabled()) {
              this._dropDown.show();
            }
          }

          return true;
        },

        /**
         * Handler to validate current date and send it to VM
         * @param {Object} event - DOM event
         */
        _onOk: function(event) {
          event.preventCancelableDefault();
          event.stopPropagation();
          event.stopImmediatePropagation();
          this._mustValid = false;
          if (!this.getValue()) { // if empty field with enter key pressed on calendar, we set with date of the day
            this._inputElement.value = this.getDate();
          }
          this._dropDown.hide();
          this.setEditing(this.getValue() !== this._oldValue);
          this.emit(context.constants.widgetEvents.change, false);
        },

        /**
         * Handler which cancel date modifications and close calendar
         * @param {Object} event - DOM event
         */
        _onCancel: function(event) {
          event.preventCancelableDefault();
          event.stopPropagation();
          event.stopImmediatePropagation();
          this._dropDown.hide();
        },

        // -- Calendar type (Modal/Dropdown) specific functions --

        /**
         * Synchronize field date and picker date on calendar display
         */
        _onCalendarTypeDropDownOpen: function() {
          // init date picker with field date if possible otherwise we set current day date.
          this._dropDown.setAriaSelection();
          this.setDate(this.getValue());
        },

        /**
         * Add buttons in dropdown bellow calendar and synchronize field date and picker date on calendar display
         */
        _onCalendarTypeModalOpen: function() {
          var inputElement = this.getInputElement();
          if (inputElement) {
            inputElement.setAttribute("readonly", "readonly");
          }
          // add buttons
          if (this._dropDown) {
            this._addButtonsToPicker();
          }
          this._validValue = this.getValue();
          this._onCalendarTypeDropDownOpen();
          this._mustValid = true;
        },

        /**
         * Remove buttons from dropdown, cancel pending changes and close calendar
         */
        _onCalendarTypeModalClose: function() {
          this.setAriaSelection();
          var inputElement = this.getInputElement();
          if (inputElement) {
            inputElement.removeAttribute("readonly");
          }
          if (this._dropDown) {
            this._removeButtonsFromPicker();
          }
          if (this._mustValid) {
            this._mustValid = false;
            this.setLastValidValue();
          }
          this._validValue = null;
        },

        /**
         * Handler use to select and validate date on double click
         * @param {string} date - date to take in string format
         */
        _onDateSelect: function(date) {
          if (!this._keyPressed) {
            // if not modal or double clicked
            if (!this.isModal() || this._isDoubleClick()) {
              this.setEditing(true);
              this._doubleClick(function() {
                this.emit(context.constants.widgetEvents.change, false);
              }.bind(this));
            }
          }
          this._keyPressed = false;
        },

        /**
         * Close calendar on double click
         * @param {function} callback - function to execute on double click
         */
        _doubleClick: function(callback) {
          this._mustValid = false;
          // Under IE & Edge, double click raise click event on element behind calendar and causes issues in INPUT ARRAY
          // This unwanted behavior needs to be canceled, so we remove calendar from dom a little bit later to avoid click event to be raised.
          if (window.browserInfo.isIE || window.browserInfo.isEdge) {
            this._registerTimeout(function() {
              this._dropDown.hide();
              if (callback) {
                callback();
              }
            }.bind(this), 150);
          } else {
            this._dropDown.hide();
            if (callback) {
              callback();
            }
          }
        },

        /**
         * Detect double click
         * @returns {boolean} returns true if user double clicked
         */
        _isDoubleClick: function() {
          var inputValue = this.getValue();
          var isDoubleClick = (new Date() - this._lastClick) < 350 && this._lastClickValue === inputValue;
          this._lastClick = new Date();
          this._lastClickValue = inputValue;
          return isDoubleClick;
        },

        /**
         * Needed by picker plugin to avoid formatting before VM send value
         * @param {string} value - value given by picker plugin
         * @param {string=} format - not used by GBC
         * @return {string} the value is return as it
         * @private
         */
        _parse: function(value, format) {
          return value;
        },

        /**
         * Get configuration object used to generate calendar component using pikaday-time framework
         * @returns {Object} returns pikaday-time js library configuration object
         */
        _getPickerConf: function() {
          var pickerConf = {
            field: this._inputElement,
            bound: false,
            container: this._dropDown.getElement(),
            parse: this._parse,
            format: this._displayFormat,
            firstDay: this._firstDayOfWeek || 0,
            showWeekNumber: !!this._showWeekNumber,
            showTime: false,
            disableDayFn: this._disableDayFn,
            yearRange: 100,
            i18n: {
              previousMonth: i18next.t('gwc.date.previousMonth'),
              nextMonth: i18next.t('gwc.date.nextMonth'),
              months: this._localizedMonthsList,
              weekdays: this._localizedDaysList,
              weekdaysShort: this._localizedWeekdaysShortList,
              midnight: i18next.t('gwc.date.midnight'),
              noon: i18next.t('gwc.date.noon')
            }
          };
          if (this._useMingGuoYears) {
            pickerConf.onSelect = function(date) {
              var year = date.getFullYear();
              var mgyear = cls.DateTimeHelper.gregorianToMingGuoYears(date);
              this._inputElement.value = this.getValue().replace(year, mgyear);
              if (!this.isModal()) {
                this._dropDown.hide();
                this.emit(context.constants.widgetEvents.change, false);
              }
            }.bind(this);
          } else {
            pickerConf.onSelect = this._onDateSelect.bind(this);
          }

          return pickerConf;
        },

        /**
         * Add OK/Cancel buttons to calendar
         */
        _addButtonsToPicker: function() {
          if (this._buttonCancel && this._buttonOk) {
            this._dropDown.getElement().appendChild(this._buttonOk);
            this._dropDown.getElement().appendChild(this._buttonCancel);
          }
        },

        /**
         * Remove OK/Cancel buttons to calendar
         */
        _removeButtonsFromPicker: function() {
          if (this._buttonCancel && this._buttonOk) {
            try {
              this._dropDown.getElement().removeChild(this._buttonOk);
              this._dropDown.getElement().removeChild(this._buttonCancel);
            } catch (e) {}
          }
        },

        /**
         * Set calendar type. By default modal type (4ST style) is used.
         * @param {string} calendarType - calendar type
         * @publicdoc
         */
        setCalendarType: function(calendarType) {
          var modalStyle = calendarType !== 'dropdown';
          if (this._isModal !== modalStyle) {
            this._isModal = modalStyle;
            this._createCalendarContainer(modalStyle);
          }
        },

        /**
         * Return calendar type
         * @returns {boolean} true if calendar has modal style
         * @publicdoc
         */
        isModal: function() {
          return this._isModal;
        },

        /**
         * Create the calendar object component and bind it on the input field
         * @publicdoc
         */
        initDatePicker: function() {
          this._localizedDaysList = i18next.t('gwc.date.dayList').split(',');
          this._localizedMonthsList = i18next.t('gwc.date.monthList').split(',');
          this._localizedWeekdaysShortList = i18next.t('gwc.date.weekdaysShort').split(',');

          if (this._picker) {
            this._picker.destroy();
          }
          var pickerConf = this._getPickerConf();
          this._picker = new Pikaday(pickerConf);
          if (!this.isModal()) {
            this._picker.bound = true;
          }
          if (this._picker._onKeyChange) { // remove unwanted native pikaday library event
            document.removeEventListener('keydown', this._picker._onKeyChange, false);
          }
          if (this._dateObj) {
            this._picker.setMoment(this._dateObj, true);
          }

          if (this._disabledDays && this._sortedDays) {
            for (var i = 0; i < this._disabledDays.length; i++) {
              var index = this._sortedDays.indexOf(this._disabledDays[i]) + (this._showWeekNumber ? 1 : 0);
              this._picker.el.addClass("disabled" + index);
            }
          }
        },

        /**
         * Define first day of the week of the calendar
         * @param {string} firstDayOfWeek - Localized name of the day to set as first day of the week
         * @publicdoc
         */
        setFirstDayOfWeek: function(firstDayOfWeek) {
          if (firstDayOfWeek) {
            var dayList = cls.DateEditWidget.pikaDaysList;
            // var capitalized = firstDayOfWeek.charAt(0).toUpperCase() + firstDayOfWeek.slice(1);
            this._firstDayOfWeek = dayList.indexOf(firstDayOfWeek);
          } else {
            this._firstDayOfWeek = moment.localeData(context.StoredSettingsService.getLanguage()).firstDayOfWeek();
          }
          if (this._firstDayOfWeek >= 0) {
            var end = cls.DateEditWidget.pikaDaysList.slice(0, this._firstDayOfWeek);
            this._sortedDays = cls.DateEditWidget.pikaDaysList.slice(this._firstDayOfWeek);
            this._sortedDays = this._sortedDays.concat(end);
          }
        },

        /**
         * Returns first day of the week name
         * @returns {string} English name of the currently set first day of the week
         * @publicdoc
         */
        getFirstDayOfWeek: function() {
          var dayList = cls.DateEditWidget.pikaDaysList;
          return dayList[this._firstDayOfWeek];
        },

        /**
         * Return calendar disabled days list
         * @returns {Array} Array of days that are disabled
         * @publicdoc
         */
        getDisabledDays: function() {
          return this._disabledDays;
        },

        /**
         * Define disabled day of the calendar
         * @param {string} disabledDays - names separated with whitespace
         * @publicdoc
         */
        setDisabledDays: function(disabledDays) {
          if (!disabledDays) {
            disabledDays = "saturday sunday";
          }
          // name of disabled days
          var daysOffList = disabledDays.split(' ');
          this._disabledDays = daysOffList;
        },

        /**
         * Generate momentjs date object from a string and set it for both the calendar component and the input field
         * @param {string} date - date value in string format
         * @publicdoc
         */
        setDate: function(date) {
          $super.setDate.call(this, date);

          // on dropdown opening, check if date is valid and set the calendar with it
          if (this._dropDown.isVisible()) {
            var dateObj = this.getDate();
            if (!dateObj || dateObj === 'Invalid date') { // if invalid date, we set with current day date
              this._dateObj = context.moment();
            }
            if (this._picker) {
              this._picker.setMoment(this._dateObj, true);
            }
          }
        },

        /**
         * Display or hide week number
         * @param {boolean} show - if true display week number, hide otherwise
         * @publicdoc
         */
        showWeekNumber: function(show) {
          this._showWeekNumber = show;
        },

        /**
         * @inheritDoc
         */
        setEnabled: function(enabled) {
          $super.setEnabled.call(this, enabled);
          if (enabled && !this._picker) { // if first time we enable datepicker, we initialize it
            this.initDatePicker();
          }
          if (this._dropDown) {
            this._dropDown.setEnabled(enabled);
          }
          this._setInputReadOnly(!enabled);
        },
      };
    });
    cls.WidgetFactory.registerBuilder('DateEdit', cls.DateEditWidget);
  });
;
'use strict';

modulum('DateTimeEditWidget', ['DateEditWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * DateTimeEdit widget.
     * @class DateTimeEditWidget
     * @memberOf classes
     * @extends classes.DateEditWidget
     * @publicdoc Widgets
     */
    cls.DateTimeEditWidget = context.oo.Class(cls.DateEditWidget, function($super) {
      return /** @lends classes.DateTimeEditWidget.prototype */ {
        __name: 'DateTimeEditWidget',

        /**
         * Override dateedit max height coeff
         */
        _coeffMaxHeight: 425,

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          if (!this._ignoreLayout) {
            this._layoutInformation = new cls.LayoutInformation(this);
            this._layoutEngine = new cls.LeafLayoutEngine(this);
            this._layoutInformation.setSingleLineContentOnly(true);
          }
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this, true);
          // default datetime format
          this._displayFormat = 'MM/DD/YYYY HH:mm:ss';
        },

        /**
         * @inheritDoc
         */
        _getPickerConf: function() {
          var pickerConf = $super._getPickerConf.call(this);
          pickerConf.showTime = true;
          pickerConf.showSeconds = this._showSeconds;
          return pickerConf;
        },

        /**
         * @inheritDoc
         */
        setFormat: function(format) {
          $super.setFormat.call(this, format);
          this._showSeconds = !!~format.toLowerCase().indexOf('s');
          if (this._picker) {
            this._picker.destroy();
          }
          this.initDatePicker();
        }

      };
    });
    cls.WidgetFactory.registerBuilder('DateTimeEdit', cls.DateTimeEditWidget);
  });
;
"use strict";

modulum('DeprecatedFileUploadEditWidget', ['EditWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * DeprecatedFileUploadEdit widget.
     * @class DeprecatedFileUploadEditWidget
     * @memberOf classes
     * @extends classes.EditWidget
     */
    cls.DeprecatedFileUploadEditWidget = context.oo.Class(cls.EditWidget, function($super) {
      return /** @lends classes.DeprecatedFileUploadEditWidget.prototype */ {
        __name: "DeprecatedFileUploadEditWidget",
        __templateName: "EditWidget",
        _initElement: function() {
          $super._initElement.call(this);
          this.setEnabled();
          $super.setValue.call(this, "DEPRECATED: The style='FileUpload' is not supported by GBC. Please use fgl_getfile().");
        },
        setValue: function() {

        },
        setEnabled: function(enabled) {
          $super.setEnabled.call(this, false);
        }
      };
    });
    cls.WidgetFactory.registerBuilder('Edit.FileUpload', cls.DeprecatedFileUploadEditWidget);
  });
;
'use strict';

modulum('EditWidget', ['FieldWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Edit widget.
     * @class EditWidget
     * @memberOf classes
     * @extends classes.FieldWidgetBase
     * @publicdoc Widgets
     */
    cls.EditWidget = context.oo.Class(cls.FieldWidgetBase, function($super) {
      return /** @lends classes.EditWidget.prototype */ {

        __name: 'EditWidget',

        _completerCurrentChildrenChangeHandler: null,

        __dataContentPlaceholderSelector: cls.WidgetBase.selfDataContent,

        _completerWidget: null,
        _inputType: 'text',
        _maxLength: -1,
        _displayFormat: null,

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          if (!this._ignoreLayout) {
            this._layoutInformation = new cls.LayoutInformation(this);
            this._layoutEngine = new cls.LeafLayoutEngine(this);
            this._layoutInformation._fixedSizePolicyForceMeasure = true;
            this._layoutInformation.setSingleLineContentOnly(true);
          }
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          this._inputElement = this._element.getElementsByTagName('input')[0];

          // needed for completer
          this._inputElement.on('blur.EditWidget', this._onBlur.bind(this));
          this._inputElement.on('input.EditWidget', this._onInput.bind(this));

          // Manage requestFocus during selection of text
          this._inputElement.on('mousedown.EditWidget', cls.WidgetBase._onSelect.bind(this));
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._inputElement) {
            this._inputElement.off('input.EditWidget');
            this._inputElement.off('mousedown.EditWidget');
            this._inputElement.off('blur.EditWidget');
            this._inputElement.remove();
            this._inputElement = null;
          }
          if (this._completerWidget) {
            this._completerWidget.destroy();
            this._completerWidget = null;
            if (this._completerCurrentChildrenChangeHandler) {
              this._completerCurrentChildrenChangeHandler();
              this._completerCurrentChildrenChangeHandler = null;
            }
          }
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          this._onRequestFocus(domEvent);
          return true;
        },

        /**
         * @inheritDoc
         */
        managePriorityKeyDown: function(keyString, domKeyEvent, repeat) {
          var keyProcessed = false;

          if (this.hasCompleter()) {
            keyProcessed = this.getCompleterWidget().managePriorityKeyDown(keyString, domKeyEvent, repeat);
          }

          this._updateCapsLockWarning();

          if (keyProcessed) {
            return true;
          } else {
            return $super.managePriorityKeyDown.call(this, keyString, domKeyEvent, repeat);
          }
        },

        /**
         * @inheritDoc
         */
        manageKeyUp: function(keyString, domKeyEvent) {
          $super.manageKeyUp.call(this, keyString, domKeyEvent);

          this.emit(context.constants.widgetEvents.keyUp, domKeyEvent, true);
        },

        /**
         * @inheritDoc
         */
        _onInput: function() {
          $super._onInput.call(this);

          // sometimes we have to display dropdown again without VM interaction
          // case occurs when we select an item, close dropdown and rollback selected item. In this case
          if (this._completerWidget &&
            this.getValue() &&
            this.getValue() === this._oldValue &&
            !this._completerWidget.isVisible()) {
            this._completerWidget.show();
          }

          // TODO this code should probably be moved in FieldWidgetBase when fix GBC-2088
          // IE11 bug : input event being raised on edit click. Try to catch this specific case by testing if value changed and field doesn't have VM focus yet.
          if (!window.browserInfo.isIE || this.getValue() !== this._oldValue || this.hasVMFocus()) {
            this.emit(context.constants.widgetEvents.change, true);
          }
        },

        /**
         * Blur handler
         * @param {Object} event
         * @private
         */
        _onBlur: function(event) {
          this.emit(context.constants.widgetEvents.blur, event);
        },

        /**
         * @inheritDoc
         */
        setReadOnly: function(readonly) {
          if (this._isReadOnly !== readonly) {
            $super.setReadOnly.call(this, readonly);
            this._setInputReadOnly(readonly);
          }
        },

        /**
         * Set input readonly attribute if it doesn't have focus or is noentry.
         * @param {boolean} readonly - true to set the edit part as read-only, false otherwise
         */
        _setInputReadOnly: function(readonly) {
          this._setElementAttribute('readonly', readonly ? 'readonly' : null, "_inputElement");
        },

        /**
         * Defines the Edit's maximum number of characters allowed
         * @param {number} maxlength maximum number of characters allowed in the field
         * @publicdoc
         */
        setMaxLength: function(maxlength) {
          if (maxlength) {
            this._maxLength = maxlength;
            this._setElementAttribute('maxlength', maxlength, "_inputElement");
          }
        },

        /**
         * Get the maximum number of characters allowed
         * @returns {number} the maximum number of characters allowed in the field
         * @publicdoc
         */
        getMaxLength: function() {
          return this._maxLength;
        },

        /**
         * Defines the alignment of the text in the input
         * @see http://www.w3.org/wiki/CSS/Properties/text-align
         * @param {string} align - a CSS text alignment. null restores the default value.
         * @publicdoc
         */
        setTextAlign: function(align) {
          this._textAlign = align;
          this.setStyle('>input', {
            'text-align': align
          });

          //only when focus
          align = this.isEnabled() ? this.getStart() : align;
          //not when number type
          align = this.isNumber() ? this.getEnd() : align;

          this.setStyle('>input:focus', {
            'text-align': align
          });
        },

        /**
         * Define the 'size' attribute of the input
         * @param {number} cols - size attribute
         * @publicdoc
         */
        setCols: function(cols) {
          this._inputElement.setAttribute('size', cols);
        },

        /**
         * Get the alignment of the text
         * @see http://www.w3.org/wiki/CSS/Properties/text-align
         * @returns {string} a CSS text alignment
         * @publicdoc
         */
        getTextAlign: function() {
          return this.getStyle('>input', 'text-align');
        },

        /**
         * Check if the widget format is number
         * @return {boolean} true if the widget format is number, false otherwise
         */
        isNumber: function() {
          var regex = /SMALLINT|INTEGER|BIGINT|INT|DECIMAL|MONEY|SMALLFLOAT|FLOAT/g;
          var match = regex.exec(this.getDisplayFormat());
          return !!match;
        },

        /**
         * Get the display format if any
         * @return {?string} the display format
         * @publicdoc
         */
        getDisplayFormat: function() {
          return this._displayFormat;
        },

        /**
         * Set current display format to use on each set value
         * @param {string} format - display format
         * @publicdoc
         */
        setDisplayFormat: function(format) {
          this._displayFormat = format;
        },

        /**
         * @inheritDoc
         */
        setValue: function(value, fromVM) {
          $super.setValue.call(this, value, fromVM);
          if (window.browserInfo.isSafari) {
            // This hack is required to fix GBC-1362. Safari doesn't display uppercased text if the value of the field hasn't changed
            // We force a temporary different value. This can be removed once this bug is fixed : https://bugs.webkit.org/show_bug.cgi?id=171050
            this._inputElement.value = value + ' ';
          }
          this._inputElement.value = value;
        },

        /**
         * @inheritDoc
         */
        getValue: function() {
          if (this._inputElement) {
            var result = this._inputElement.value;
            if (this.isEditing()) {
              if (this.getTextTransform() === 'up') {
                result = result.toLocaleUpperCase();
              }
              if (this.getTextTransform() === 'down') {
                result = result.toLocaleLowerCase();
              }
            }
            return result;
          }
          return null;
        },

        /**
         * Set the cursors
         * When cursor2 === cursor, it is a simple cursor set
         * @param {number} cursor - the selection range beginning (-1 for end)
         * @param {number=} [cursor2] - the selection range end, if any
         * @publicdoc
         */
        setCursors: function(cursor, cursor2) {
          if (!cursor2) {
            cursor2 = cursor;
          }
          if (cursor2 && cursor2 < 0) {
            cursor2 = this.getValue() && this.getValue().length || 0;
          }

          if (this.isInTable() && !this.isEnabled()) { // fix for GBC-1170
            cursor = cursor2 = 0;
          }
          this._element.toggleClass('noTextSelection', this.isInTable() && !this.isEnabled());

          this._inputElement.setCursorPosition(cursor, cursor2);
        },

        /**
         * Get cursors
         * @return {{start: number, end: number}} object with cursors
         * @publicdoc
         */
        getCursors: function() {
          var cursors = {
            start: 0,
            end: 0
          };
          if (this._inputElement && this._inputElement.value) {
            try {
              cursors.start = this._inputElement.selectionStart;
              cursors.end = this._inputElement.selectionEnd;
            } catch (ignore) {
              // Some input types don't allow cursor manipulation
            }
          }
          return cursors;
        },

        /**
         * Set field as a password (displays bullets instead of value)
         * @param {boolean} isPassword - true if the widget should be in 'password' mode, false otherwise
         * @publicdoc
         */
        setIsPassword: function(isPassword) {
          if (isPassword) {
            this._inputElement.setAttribute('type', 'password');
          } else {
            this._inputElement.setAttribute('type', 'text');
            this.setType(this._inputType);
          }
          this.toggleClass("gbc_isPassword", !!isPassword);
        },

        /**
         * Check if field is set as password
         * @returns {boolean} true if the widget is in 'password' mode, false otherwise
         * @publicdoc
         */
        isPassword: function() {
          return this._inputElement.getAttribute('type') === 'password';
        },

        /**
         * Display or not the caps lock warning
         * @private
         */
        _updateCapsLockWarning: function() {
          if (this.isPassword()) {
            // Check if caps lock is on, and display accordingly
            if (!window.browserInfo.isSafari) { // Safari add this by itself
              this.removeClass("capsOn");
              if (window._capsLock) {
                this.addClass("capsOn");
              }
            }
          }
        },

        /**
         * Check if max length of the widget has been reached
         * @returns {boolean} return true if max length is reached in input element
         */
        _isMaxLength: function() {
          return this._maxLength !== -1 && this._inputElement.value.length >= this._maxLength &&
            this._inputElement.selectionStart === this._inputElement.selectionEnd;
        },

        /**
         * Used to manage the keyboardHint.
         * @param {string} valType the type attribute value to set
         * @publicdoc
         */
        setType: function(valType) {
          this._inputType = valType;
          if (!this.isPassword()) {
            this._inputElement.setAttribute('type', valType);
            if (window.browserInfo.isFirefox) {
              // sad old browser patch
              this._inputElement.setAttribute('step', valType === 'number' ? 'any' : null);
            }
          }
        },

        /**
         * Get the type of the field
         * @returns {string} this Edit current type
         * @publicdoc
         */
        getType: function() {
          return this._inputType;
        },

        /**
         * Sets the focus to the widget
         * @publicdoc
         */
        setFocus: function(fromMouse) {
          $super.setFocus.call(this, fromMouse);
          this._inputElement.domFocus();
          this._updateCapsLockWarning();
        },

        /**
         * Check if the Edit Widget has a completer
         * @return {boolean} true if has a completer, false otherwise
         */
        hasCompleter: function() {
          return this.getCompleterWidget() !== null;
        },

        /**
         * Get the completer widget if any
         * @return {?classes.CompleterWidget} the completer widget, null if none
         * @publicdoc
         */
        getCompleterWidget: function() {
          return this._completerWidget;
        },

        /**
         * Will add a completer to the edit
         * @publicdoc
         */
        addCompleterWidget: function() {
          if (!this._completerWidget) {
            this._completerWidget = cls.WidgetFactory.createWidget('Completer', this.getBuildParameters());
            this._completerWidget.addCompleterWidget(this);
            this._completerCurrentChildrenChangeHandler = this._completerWidget.onCurrentChildrenChange(function(value) {
              this.setEditing(this._oldValue !== value);
              this.setValue(value);
            }.bind(this));
          }
        },

        /**
         * @inheritDoc
         */
        setEnabled: function(enabled) {
          $super.setEnabled.call(this, enabled);
          if (this._textAlign) {
            this.setTextAlign(this._textAlign);
          }
        },

        /**
         * @inheritDoc
         */
        setTitle: function(title) {
          $super.setTitle.call(this, title);
          if (title === "") {
            this._inputElement.removeAttribute("aria-label");
          } else {
            this._inputElement.setAttribute("aria-label", title);
          }

        }

      };
    });
    cls.WidgetFactory.registerBuilder('Edit', cls.EditWidget);
    cls.WidgetFactory.registerBuilder('EditWidget', cls.EditWidget);
  });
;
"use strict";

modulum('FieldWidgetBase', ['TextWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Base class for genero formfield widgets
     * @class FieldWidgetBase
     * @memberOf classes
     * @publicdoc Widgets
     * @extends classes.TextWidgetBase
     */
    cls.FieldWidgetBase = context.oo.Class(cls.TextWidgetBase, function($super) {
      return /** @lends classes.FieldWidgetBase.prototype */ {
        __name: "FieldWidgetBase",
        /**
         * Flag for augmentedFace
         * @type {boolean}
         */
        __virtual: true,

        /**
         * List of values through time
         * @type {Array}
         */
        _valueStack: null,

        /**
         * true if widget has pending changes
         * @type {boolean}
         */
        _editing: false,

        /**
         * true if widget is readOnly and can't be edited nor focused
         * @type {boolean}
         * */
        _isReadOnly: false,

        /**
         * the input element
         * @protected
         * @type {HTMLElement}
         */
        _inputElement: null,

        /**
         * Indicates if key event handlers are bound
         */
        _keyEventsBound: false,

        /***
         * Time of the last widget modification
         * @type {number}
         */
        _editingTime: 0,

        /**
         * Position of the current value in the stack
         * @type {Number}
         */
        _valueStackCursor: -1,

        /**
         * Old value, used by typeahead
         * @type {?string}
         */
        _oldValue: null,

        /**
         * true if widget should not be editable but navigation is possible
         * @type {boolean}
         */
        _notEditable: false,

        /**
         * true if widget requires a value
         * @type {boolean}
         */
        _required: false,

        /**
         * true if widget is set as not Null
         * @type {boolean}
         */
        _notNull: false,

        /**
         * List of possible values for the widget
         * @type {?Array}
         */
        _include: null,

        /**
         * Flag to check if the mouse button is currently pressed
         * @type {boolean}
         */
        _isMousePressed: false,

        /**
         * @constructs
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          this.setEnabled(false, true);
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          this._valueStack = [];
          if (window.isMobile()) {
            var inputElement = this._element.getElementsByTagName('input')[0];
            if (inputElement) {
              // Track the focus and mouse down/up events on mobile devices to handle the virtual keybord's TAB key
              inputElement.on('focus.FieldWidgetBase', this._onMobileFocus.bind(this));
              inputElement.on('mousedown.FieldWidgetBase', this._onMobileMouseDown.bind(this));
              inputElement.on('mouseup.FieldWidgetBase', this._onMobileMouseUp.bind(this));
            }
          }
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          $super.destroy.call(this);

          this._valueStack = null;
          this._oldValue = null;

          this.unbindKeyEvents();
          this._keyEventsBound = false;

          if (this._inputElement && this.isNotEditable()) {
            this._inputElement.off('drop.FieldWidgetBase_notEditable');
          }
          if (this._inputElement && window.isMobile()) {
            this._inputElement.off('focus.FieldWidgetBase');
            this._inputElement.off('mousedown.FieldWidgetBase');
            this._inputElement.off('mouseup.FieldWidgetBase');
          }
          this._inputElement = null;
        },

        /**
         * @inheritDoc
         */
        _afterInitElement: function() {
          $super._afterInitElement.call(this);

          this.bindKeyEvents();
          this._keyEventsBound = true;
        },

        /**
         * Get the input part of the widget
         * @return {HTMLElement} the input part of the widget
         * @publicdoc
         */
        getInputElement: function() {
          return this._inputElement;
        },

        /**
         * Check if the widget has an input element
         * @return {boolean} true if widget has an input element
         * @publicdoc
         */
        hasInputElement: function() {
          return !!this.getInputElement();
        },

        /**
         * Bind all keys events of the widget (done when the widget becomes active)
         * @protected
         */
        bindKeyEvents: function() {},
        /**
         * Unbind all keys events of the widget (done when the widget becomes inactive or in typeahead)
         * @protected
         */
        unbindKeyEvents: function() {},

        /**
         * Set the value of widget
         * @param {string|number} value - sets the value to display
         * @param {boolean} [fromVM] - true if value comes from the VM
         * @publicdoc
         */
        setValue: function(value, fromVM) {
          if (this.hasCursors() && !fromVM) { // only widgets with cursors manage undo/redo
            this._valueStack.push(value);
            this._valueStackCursor++;
          }

          if (fromVM) {
            if (this.getValue() !== value) {
              this._valueStack = [value];
              this._valueStackCursor = 0;
            } else {
              this._valueStack.push(value);
              this._valueStackCursor++;
            }
            this._oldValue = value;
          }
          if (this._valueStack.length > 30) {
            this._valueStack.shift();
            this._valueStackCursor--;
          }
        },

        /**
         * Internal setValue to change value without any event emited
         * @param {string} value - the value
         * @private
         */
        _setValue: function(value) {
          if (this._inputElement) {
            this._inputElement.value = value;
          }
        },

        /**
         * Handle input event to manage
         *  - set editing
         *  - shift attribute (textTransform !== none)
         * @private
         */
        _onInput: function() {
          if (this.isNotEditable()) {
            // If not editable, rollback to old value (the initial one)
            this._inputElement.value = this._oldValue;
          } else {
            this._editingTime = Date.now();
            this.setEditing(this.isEditing() || this.getValue() !== this._oldValue);
            if (this.isEditing() && this._textTransform !== 'none' && this.hasInputElement()) {
              var start = this._inputElement.selectionStart;
              var end = this._inputElement.selectionEnd;
              this._inputElement.value = this.getValue();
              this._inputElement.setCursorPosition(start, end);
            }

          }
        },

        /**
         * Handle drop event
         * @param evt
         * @private
         */
        _onDrop: function(evt) {
          if (this.isNotEditable()) {
            evt.preventCancelableDefault();
          }
        },

        /**
         * NotEditable allows cursor moving, but not a value change
         * @param {boolean} notEditable - true to set the edit part as read-only
         */
        setNotEditable: function(notEditable) {
          this._notEditable = notEditable;
          if (this._inputElement) {
            if (notEditable) {
              this._inputElement.on('drop.FieldWidgetBase_notEditable', this._onDrop.bind(this));
            } else {
              this._inputElement.off('drop.FieldWidgetBase_notEditable');
            }
          }
        },

        /**
         * NotEditable allows cursor moving, but not a value change
         * @return {boolean} true if the edit part is not editable
         */
        isNotEditable: function() {
          return this._notEditable;
        },

        /**
         * Set the widget validation to 'required'
         * @param {boolean} required - true if a value is required
         */
        setRequired: function(required) {
          this._required = required;
          this.toggleClass("gbc_Required", required);
          this.setAriaAttribute("required", required.toString());
        },

        /**
         * Verify if the widget value is required
         * @return {boolean} true if a value is required
         */
        isRequired: function() {
          return this._required;
        },

        /**
         * Set the widget validation to noNull
         * @param {boolean} notNull - false if the widget value can be null, true otherwise
         */
        setNotNull: function(notNull) {
          this._notNull = notNull;
          this.toggleClass("gbc_NotNull", notNull);
        },

        /**
         * Verify if the widget can be null
         * @return {boolean} false if the widget value can be null, true otherwise
         */
        isNotNull: function() {
          return this._notNull;
        },

        /**
         * Get the list of allowed values defined by INCLUDE list
         * @param {Array|null} include - list of allowed values or null if not defined
         */
        setAllowedValues: function(include) {
          this._include = include;
        },

        /**
         * Get the list of allowed values defined by INCLUDE list
         * @return {Array|null} list of allowed values or null if not defined
         */
        getAllowedValues: function() {
          return this._include;
        },

        /**
         * Prevent value change but allow navigation
         * @param {Event} evt the browser event
         * @param {string} keyString the string representation of the key sequence
         * @private
         */
        _preventEditAllowNavigation: function(evt, keyString) {
          var prevent = ["ctrl+x", "ctrl+v", "meta+x", "meta+v"].contains(keyString); // CTRL+X & CTRL+V forbidden
          prevent = prevent || (["tab", "home", "end", "left", "right", "up", "down", "shift+left", "shift+right", "ctrl+c",
            "ctrl+a",
            "meta+c", "meta+a"
          ].contains(
            keyString) === false);

          if (prevent) {
            evt.preventCancelableDefault();
            this.flash();
          }
        },

        /**
         * Get the value of the widget
         * @returns {?string|number} the value
         * @publicdoc
         */
        getValue: function() {
          return null;
        },

        /**
         * @inheritDoc
         */
        getClipboardValue: function() {
          return this.getValue();
        },

        /**
         * Define the widget as readonly or not
         * @param {boolean} readonly - true to set the widget as readonly without possibility of edition, false otherwise
         * @publicdoc
         */
        setReadOnly: function(readonly) {
          this._isReadOnly = readonly;
        },

        /**
         * Check if the widget is readonly or not
         * @returns {boolean} true if the widget is readonly, false otherwise
         * @publicdoc
         */
        isReadOnly: function() {
          return this._isReadOnly;
        },

        /**
         * @returns {number} time of the last widget modification
         */
        getEditingTime: function() {
          return this._editingTime;
        },

        /**
         * Check if widget is currently editing
         * @return {boolean}
         */
        isEditing: function() {
          return this._editing;
        },

        /**
         * Flag or unflag widget as having value pending changes
         * @param editing {boolean} the new editing state
         * @publicdoc
         */
        setEditing: function(editing) {
          this._editing = editing;
          if (this.getElement()) {
            this.getElement().toggleClass("editing", !!editing);
          }
        },

        /**
         * Returns if the widget is focusable
         * @return {boolean} State of focusable
         * @publicdoc
         */
        isFocusable: function() {
          return this.hasInputElement() || $super.isFocusable.call(this);
        },

        /**
         * Tests if the widget has really the DOM focus (check document.activeElement)
         * @returns {boolean} true if the widget has the DOM focus
         * @publicdoc
         */
        hasDOMFocus: function() {
          return (this.hasInputElement() && this.getInputElement() === document.activeElement) ||
            $super.hasDOMFocus.call(this);
        },

        /**
         * Defines the enabled status of the widget
         * @param {boolean} enabled true if the widget allows user interaction, false otherwise.
         * @publicdoc
         */
        setEnabled: function(enabled, noSelectionUpdate) {
          if (this._enabled !== enabled) {
            this._enabled = !!enabled;
            this.domAttributesMutator(function(noSelectionUpdate) {
              if (this._enabled) {
                this.removeClass("disabled");
                if (this.hasInputElement() && !this.isReadOnly()) {
                  this.getInputElement().removeAttribute("readonly");
                }
              } else {
                this.addClass("disabled");
                if (!noSelectionUpdate) {
                  if (this.hasCursors()) {
                    this.setCursors(0);
                    this.afterDomMutator(function() {
                      var selection = window.getSelection();
                      if (selection) {
                        var hasTextSelection = selection.focusNode === this._element;
                        if (hasTextSelection) {
                          selection.removeAllRanges();
                        }
                      }
                    }.bind(this));
                  }
                }
                if (this.hasInputElement()) {
                  this.getInputElement().setAttribute("readonly", "readonly");
                }
              }
            }.bind(this, noSelectionUpdate));
          }
          // bind/unbind keys events
          if (enabled && (this.isNotEditable && !this.isNotEditable() || this.isReadOnly && !this.isReadOnly())) {
            if (!this._keyEventsBound) {
              this._keyEventsBound = true;
              this.bindKeyEvents();
            }
          } else {
            if (this._keyEventsBound) {
              this._keyEventsBound = false;
              this.unbindKeyEvents();
            }
          }
        },

        /**
         * @inheritDoc
         */
        loseVMFocus: function() {
          $super.loseVMFocus.call(this);
          this.setEditing(false);
        },

        /**
         * @inheritDoc
         */
        loseFocus: function() {
          $super.loseFocus.call(this);
          this.setEditing(false);
        },

        /**
         * @inheritDoc
         */
        managePriorityKeyDown: function(keyString, domKeyEvent, repeat) {
          var keyProcessed = false;

          if (this.isEnabled() && this.hasCursors()) {
            if (keyString === "home") {
              this.setCursors(0);
              keyProcessed = true;
            } else if (keyString === "end") {
              this.setCursors(this.getValue() && this.getValue().toString().length || 0);
              keyProcessed = true;
            }
          }

          if (keyProcessed) {
            return true;
          } else {
            return $super.managePriorityKeyDown.call(this, keyString, domKeyEvent, repeat);
          }
        },

        /**
         * @inheritDoc
         */
        manageKeyDown: function(keyString, domKeyEvent, repeat) {
          var keyProcessed = false;

          if (this.isEnabled() && !this.isReadOnly()) {

            if (keyString === "ctrl+z" || keyString === 'meta+z') {
              this.undo();
              keyProcessed = true;
            } else if (keyString === "ctrl+shift+z" || keyString === 'meta+shift+z') {
              this.redo();
              keyProcessed = true;
            }

            if (this.isNotEditable()) {
              this._preventEditAllowNavigation(domKeyEvent, keyString);
            }
          }

          if (keyProcessed) {
            return true;
          } else {
            return $super.manageKeyDown.call(this, keyString, domKeyEvent, repeat);
          }
        },

        /**
         * Cancel the last value
         */
        undo: function() {
          if (this.hasCursors()) { // only widgets with cursors manage undo/redo
            var cursors = this.getCursors();
            var prevValue = this.getValue();
            //go back but store the current as last known value
            if (this._valueStackCursor === this._valueStack.length - 1 && this._valueStack[this._valueStack.length - 1] !==
              this.getValue()) {
              this.setValue(this.getValue());
            }
            this._valueStackCursor--;
            this._valueStackCursor = this._valueStackCursor < 0 ? 0 : this._valueStackCursor;

            this.afterDomMutator(function() {
              var val = this._valueStack[this._valueStackCursor];
              if (typeof val === "string" && this.hasInputElement()) {
                this._setValue(val);
                var diff = prevValue.length - val.length;
                this.setCursors(cursors.start - diff);
              }
            }.bind(this));
          }
        },

        /**
         * Restore the last value
         */
        redo: function() {
          if (this.hasCursors()) { // only widgets with cursors manage undo/redo
            var cursors = this.getCursors();
            var prevValue = this.getValue();
            if (this._valueStackCursor < this._valueStack.length - 1) {
              this._valueStackCursor++;
            }
            this.afterDomMutator(function() {
              var val = this._valueStack[this._valueStackCursor];
              if (typeof val === "string" && this.hasInputElement()) {
                this._setValue(val);
                var diff = prevValue.length - val.length;
                this.setCursors(cursors.start - diff);
              }
            }.bind(this));
          }
        },

        /**
         * @inheritDoc
         */
        buildExtraContextMenuActions: function(contextMenu) {
          $super.buildExtraContextMenuActions.call(this, contextMenu);

          if (!this.isReadOnly() && !this.isInTable() && this.hasInputElement()) {

            var selectAllAllowed = this.getValue().length > 0;
            contextMenu.addAction("selectAll", i18next.t("gwc.contextMenu.selectAll"), "font:FontAwesome.ttf:f0ea", "Ctrl+A", {
              clickCallback: function() {
                contextMenu.hide();
                this.setFocus();
                this.selectAllInputText();
              }.bind(this),
              disabled: !selectAllAllowed
            }, true);
          }
        },

        /**
         * Select all the text in the input element
         * @publicdoc
         */
        selectAllInputText: function() {
          if (this.hasInputElement()) {
            var cursor2 = this.getValue() && this.getValue().length || 0;
            this._inputElement.setCursorPosition(0, cursor2);
          }
        },

        /**
         * Defines a placeholder text
         * @param {string} placeholder - placeholder text
         * @publicdoc
         */
        setPlaceHolder: function(placeholder) {
          if (this.hasInputElement()) {
            if (placeholder) {
              this._inputElement.setAttribute('placeholder', placeholder);
            } else {
              this._inputElement.removeAttribute('placeholder');
            }
          }
        },

        /**
         * Method used to validate or not the value, this trigger a rollback if not valid when sending
         * the value to the VM
         * @return {boolean} - true if valid, false otherwise
         */
        validateValue: function() {
          // Implement your own method on widgets
          return true;
        },

        /**
         * This function requests the VM focus if this focus event hasn't been triggered
         * by a mouse or touch event.
         * This happens when the user presses the TAB key of a mobile's virtual keyboard.
         * - TAB generates only a focus event
         * - A tap or click generates a mousedown, focus and mouseup events
         * @param {FocusEvent} event HTML focus event
         * @private
         */
        _onMobileFocus: function(event) {
          if (!this._isMousePressed) {
            this._onRequestFocus(event);
          }
        },

        /**
         * @param {MouseEvent} event HTML mouse event
         * @private
         */
        _onMobileMouseDown: function(event) {
          this._isMousePressed = true;
        },

        /**
         * @param {MouseEvent} event HTML mouse event
         * @private
         */
        _onMobileMouseUp: function(event) {
          this._isMousePressed = false;
        }
      };
    });
  });
;
'use strict';

modulum('GbcImageWidget', ['ImageWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * GBC Image widget to create internal images (i.e: with zmdi)
     * @class GbcImageWidget
     * @memberOf classes
     * @extends classes.ImageWidget
     * @publicdoc Widgets
     */
    cls.GbcImageWidget = context.oo.Class(cls.ImageWidget, function($super) {
      return /** @lends classes.GbcImageWidget.prototype */ {
        __name: 'GbcImageWidget',
        __templateName: "ImageWidget",

        /**
         * Update image according to several pre-set parameters
         * @private
         */
        _updateImage: function() {
          if (!this._element) {
            return;
          }
          if (this._hasContent) {
            this._element.empty();
            this._hasContent = false;
          }
          if (this._img) {
            this._img.off('error.ImageWidget');
            this._img.off('load.ImageWidget');
            this._img = null;
          }
          var backgroundImage = null;
          var backgroundSize = null;
          var backgroundRepeat = null;
          var backgroundPosition = null;
          var width = null;

          if (!!this._src) {

            this._img = document.createElement('i');
            this._img.on('error.ImageWidget', this._onError.bind(this));
            this._img.setAttribute('class', "zmdi " + this._src);
            this._img.on('load.ImageWidget', this._onLoad.bind(this));
            this._element.appendChild(this._img);

            this._element.toggleClass('gbc_autoScale', this._autoScale);
          }
          if (this._standalone) {
            if (!this._border) {
              this._border = document.createElement('div');
              this._border.addClass('gbc_ImageWidget_border');
            }
            this._element.appendChild(this._border);
          }
          this.setStyle({
            'background-image': backgroundImage,
            'background-size': backgroundSize,
            'background-repeat': backgroundRepeat,
            'background-position': backgroundPosition,
            'width': width
          });
          if (this.__charMeasurer) {
            this._element.appendChild(this.__charMeasurer);
          }
        },
      };
    });
    cls.WidgetFactory.registerBuilder('GbcImage', cls.GbcImageWidget);
  });
;
'use strict';

modulum('HLineWidget', ['ColoredWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * HLine widget.
     * @class HLineWidget
     * @memberOf classes
     * @extends classes.ColoredWidgetBase
     */
    cls.HLineWidget = context.oo.Class(cls.ColoredWidgetBase, function($super) {
      return /** @lends classes.HLineWidget.prototype */ {
        __name: 'HLineWidget',

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          this._layoutInformation = new cls.LayoutInformation(this);
          this._layoutEngine = new cls.LeafLayoutEngine(this);
        }
      };
    });
    cls.WidgetFactory.registerBuilder('HLine', cls.HLineWidget);
  });
;
'use strict';

modulum('ImageWidget', ['ColoredWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Image widget.
     * @class ImageWidget
     * @memberOf classes
     * @extends classes.ColoredWidgetBase
     * @publicdoc Widgets
     */
    cls.ImageWidget = context.oo.Class(cls.ColoredWidgetBase, function($super) {
      return /** @lends classes.ImageWidget.prototype */ {
        __name: 'ImageWidget',
        /**
         * @type {?string}
         */
        _src: null,
        _defaultColor: null,
        /** @type {boolean} */
        _autoScale: false,
        /** @type {boolean} */
        _gotFirstInitialImage: false,
        /** @type {boolean} */
        _firstInitialSizing: true,
        /** @type {boolean} */
        _initialAutoscaling: false,
        /** @type {HTMLElement} */
        _img: null,
        /** @type {HTMLElement} */
        _border: null,
        /** @type {boolean} */
        _standalone: false,
        /** @type {boolean} */
        _hasContent: false,
        /** @type {Object} */
        _alignment: null,

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          this._layoutInformation = new cls.LayoutInformation(this);
          this._layoutInformation.shouldFillStack = true;
          this._layoutEngine = new cls.ImageLayoutEngine(this);
          this._layoutEngine._shouldFillHeight = true;
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._border = null;
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          this._onRequestFocus(domEvent); // request focus
          this.emit(context.constants.widgetEvents.click, domEvent);
          return true;
        },

        /**
         * Define image as a regular standalone widget
         * @param {boolean} standalone - true if standalone, false otherwise
         */
        setStandaloneImage: function(standalone) {
          this._standalone = standalone;
          this._element.toggleClass('gbc_withBorder', !!standalone);
          this._element.toggleClass('gbc_selfImage', !!standalone);
        },

        /**
         * If image has action, change cursor
         * @param {boolean} clickable - true if clickable, false otherwise
         * @publicdoc
         */
        setClickableImage: function(clickable) {
          if (clickable) {
            this.addClass('clickable');
          } else {
            this.removeClass('clickable');

          }
        },

        /**
         * ShortCut for setSrc
         * This is used in the context of an Image FormField
         * @param {string} val the URL of the image to display or a font-image URL: font:[fontname]:[character]:[color]
         * @see setSrc
         * @publicdoc
         */
        setValue: function(val) {
          this.setSrc(val);
        },

        /**
         * Shortcut for getSrc
         * This is used in the context of an Image FormField
         * @returns {string} the URL of the displayed image or a font-image URL: font:[fontname]:[character]:[color]
         * @see getSrc
         * @publicdoc
         */
        getValue: function() {
          return this.getSrc();
        },

        /**
         * ShortCut for setSrc
         * This is used in the context of a Static Image
         * @param {string} image the URL of the image to display or a font-image URL: font:[fontname]:[character]:[color]
         * @see setSrc
         * @publicdoc
         */
        setImage: function(image) {
          this.setSrc(image);
        },

        /**
         * Shortcut for getSrc
         * This is used in the context of a Static FormField
         * @returns {string} the URL of the displayed image or a font-image URL: font:[fontname]:[character]:[color]
         * @see getSrc
         * @publicdoc
         */
        getImage: function() {
          return this.getSrc();
        },

        /**
         * Check if image is a font image
         * @return {boolean} true if is a font image
         * @publicdoc
         */
        isFontImage: function() {
          if (this._src) {
            return this._src.startsWith('font:');
          } else {
            return false;
          }
        },

        /**
         * Set the source of the image file
         * @param {string} src the URL of the image to display or a font-image URL: font:[fontname]:[character]:[color]
         * @param {boolean} directApply true to apply src directly (internal use)
         * @publicdoc
         */
        setSrc: function(src, directApply) {
          this.getLayoutInformation().invalidateMeasure();
          if (src !== this._src) {
            var old = this._src,
              initial = this.getLayoutInformation().getSizePolicyConfig().isInitial();
            this._src = src;
            if (initial && this._gotFirstInitialImage && old !== null && src !== null) {
              this._firstInitialSizing = false;
            }
            if (initial && old === null && src !== null) {
              this._gotFirstInitialImage = true;
            }
            this._updateImage(directApply);
          }
          this.domAttributesMutator(function() {
            if (!this._destroyed && this._img && this.getTitle()) {
              this._img.setAttribute("alt", this.getTitle());
            }
          }.bind(this));
        },

        /**
         * Get the source of the image file
         * @returns {string} the URL of the displayed image or a font-image URL: font:[fontname]:[character]:[color]
         * @publicdoc
         */
        getSrc: function() {
          return this._src;
        },

        /**
         * @inheritDoc
         */
        setTitle: function(title) {
          $super.setTitle.call(this, title);
          if (this._img) {
            this._img.setAttribute('alt', title);
          }
        },

        /**
         * Define the image as stretchable
         * @param {boolean} stretch - true if stretchable
         * @publicdoc
         */
        setStretch: function(stretch) {
          this._element.toggleClass('stretch', stretch);
        },

        /**
         * Forces the image to be stretched to fit in the area reserved for the image.
         * @param {boolean} setted true : autoScale , false: default
         * @publicdoc
         */
        setAutoScale: function(setted) {
          if (setted !== this._autoScale) {
            this._autoScale = setted;
            this._updateImage();
          }
        },

        /**
         * Se the default color
         * @param {string} color - any CSS compliant color
         */
        setDefaultColor: function(color) {
          this._defaultColor = color;
        },

        /**
         * @inheritDoc
         */
        setFocus: function(fromMouse) {
          this._element.domFocus();
        },

        /**
         * @inheritDoc
         */
        getClipboardValue: function() {
          return this.getValue();
        },

        /**
         * Align the image
         * @param {number|string} y - y position
         * @param {number|string} x - x position
         * @publicdoc
         */
        setAlignment: function(y, x) {
          var rtl = this.getStart() === 'right';
          this._alignment = {
            x: x,
            y: y,
            val: (x === 'horizontalCenter' || x === 'center' ? 'center' :
                ((x === 'right' && !rtl) || (x !== 'right' && rtl) ? 'right' : 'left')
              ) + ' ' +
              (y === 'verticalCenter' || y === 'center' ? 'center' : (y === 'bottom' ? 'bottom' : 'top'))
          };
          var pos = {
            'align-items': y === 'verticalCenter' ? 'center' : (y === 'bottom' ? 'flex-end' : 'flex-start'),
            'justify-content': x === 'horizontalCenter' ? 'center' : (x === 'right' ? 'flex-end' : 'flex-start'),
            'background-position': this._alignment.val
          };
          this.setStyle(pos);
        },

        /**
         * Update image according to several pre-set parameters
         * @param {boolean} directApply true to apply src directly (internal use)
         * @private
         */
        _updateImage: function(directApply) {
          if (!this._element) {
            return;
          }
          if (this._hasContent) {
            this._element.empty();
            this._hasContent = false;
          }
          if (this._img) {
            this._img.off('error.ImageWidget');
            this._img.off('load.ImageWidget');
            this._img = null;
          }
          var backgroundImage = null;
          var backgroundSize = null;
          var backgroundRepeat = null;
          var backgroundPosition = null;
          var width = null;
          var height = null;

          if (!!this._src) {

            if (this._src.startsWith('font:')) {
              var pattern = /font:([^:]+).ttf:([^:]+):?([^:]*)/,
                match = this._src.match(pattern),
                fontName, character, color;
              if (match) {
                fontName = match[1];
                character = match[2];
                color = match[3] || this._defaultColor;
              }
              if (!!fontName && !!character) {
                var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('viewBox', '0 0 640 512');
                // to left align svg, we need to set xMin, otherwise with a 100% width viewBox it will be centered
                svg.setAttribute('preserveAspectRatio', 'xMinYMid meet');
                var text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('text-anchor', 'middle');
                // EDGE & IE doesn't support dominant-baseline central attribute, so we need to center using another way
                if (window.browserInfo.isEdge || window.browserInfo.isIE) {
                  text.setAttribute('dy', '0.7ex');
                } else {
                  text.setAttribute('dominant-baseline', 'central');
                }
                text.setAttribute('x', '320');
                text.setAttribute('y', '256');
                text.setAttribute('font-size', '470');
                text.setAttribute('font-family', 'image2font_' + fontName);
                if (directApply) {
                  text.textContent = String.fromCharCode('0x' + character);
                } else {
                  window.requestAnimationFrame(function(text, character) {
                    text.textContent = String.fromCharCode('0x' + character);
                  }.bind(this, text, character));
                }
                if (!!color) {
                  text.setAttribute('fill', color);
                }
                svg.appendChild(text);
                this._element.appendChild(svg);
                this._hasContent = true;
                this.emit(context.constants.widgetEvents.ready);
              }
              this.getElement().toggleClass('gbc_fixedSvg', !this._autoScale);
            } else {
              var isInitial = this.getLayoutInformation().getSizePolicyConfig().isInitial();
              if (this._inTable || this._autoScale && (!isInitial || !this._firstInitialSizing)) {
                backgroundImage = "url('" + this._src + "')";
                backgroundSize = 'contain';
                backgroundRepeat = 'no-repeat';
                width = '100%';
                height = '100%';
                backgroundPosition = this._alignment && this._alignment.val || this.getStart();
                this.emit(context.constants.widgetEvents.ready);
              } else {
                this._img = document.createElement('img');
                this._img.on('error.ImageWidget', this._onError.bind(this));
                if (directApply) {
                  this._img.setAttribute("src", this._src);
                } else {
                  this._setElementAttribute("src", this._src, "_img");
                }
                this._img.on('load.ImageWidget', this._onLoad.bind(this));
                this._element.appendChild(this._img);
              }
              this._hasContent = true;
            }
            this.toggleClass('gbc_autoScale', this._autoScale);
          }
          if (this._standalone) {
            if (!this._border) {
              this._border = document.createElement('div');
              this._border.addClass('gbc_ImageWidget_border');
            }
            this._element.appendChild(this._border);
          }
          this.setStyle({
            'background-image': backgroundImage,
            'background-size': backgroundSize,
            'background-repeat': backgroundRepeat,
            'background-position': backgroundPosition,
            'width': width
          });
          if (this.__charMeasurer) {
            this._element.appendChild(this.__charMeasurer);
          }
        },

        /**
         * Error handler in case of wrong loading and other
         * @private
         */
        _onError: function() {
          this._img.off('error.ImageWidget');
          this._img.off('load.ImageWidget');
          if (!!this._element) {
            this._element.addClass('hidden');
          }
        },

        /**
         * Load handler to decide what to do after image finished loading
         * @private
         */
        _onLoad: function() {
          this._img.off('error.ImageWidget');
          this._img.off('load.ImageWidget');
          if (!!this._element) {
            var w = this._img.naturalWidth,
              h = this._img.naturalHeight;
            if (!this.getLayoutEngine().hasNaturalSize()) {
              if (!this._autoScale) {
                this._layoutEngine.invalidateMeasure();
              }
              this.getLayoutEngine()._needMeasure = true;
            }
            this.getLayoutEngine().setNaturalSize(w, h);
            this._element.toggleClass('gbc_ImageWidget_wider', w > h).toggleClass('gbc_ImageWidget_higher', w <= h);

            this.getLayoutInformation()._sizeRatio = h / w;

            var isInitial = this.getLayoutInformation().getSizePolicyConfig().isInitial();
            if (isInitial && this._firstInitialSizing) {
              if (this._autoScale) {
                this._initialAutoscaling = true;
                this.getLayoutInformation()._keepRatio = true;
              } else {
                if (!this.getLayoutEngine().hasNaturalSize()) {
                  this.getLayoutEngine()._needMeasure = true;
                }
              }
            }
            this.emit(context.constants.widgetEvents.ready, this.getLayoutEngine().hasNaturalSize());
            gbc.LogService.ui.log("Image loaded", true, this.__name, this);
          }
        },

        /**
         * Callback once image has been layouted
         * @private
         */
        _whenLayouted: function() {
          if (this._initialAutoscaling) {
            this._initialAutoscaling = false;
            this._firstInitialSizing = false;
            this._updateImage();
          }
        },

        /**
         * @inheritDoc
         */
        setHidden: function(hidden) {
          $super.setHidden.call(this, hidden);
          if (!this._hidden && this._element.parentNode) {
            this._element.parentNode.removeClass('gl_gridElementHidden');
          }
        },

        getStyleSheetId: function() {
          var windowWidget = this.getWindowWidget(),
            windowWidgetId = windowWidget && windowWidget.getUniqueIdentifier();
          return this._uuid || windowWidgetId || "_";
        },

        /**
         * Get the natural dimension of the image
         * @return {{width: number, height: number}}
         */
        getNaturalDimension: function() {
          return {
            width: this._img.naturalWidth,
            height: this._img.naturalHeight
          };
        }

      };
    });
    cls.WidgetFactory.registerBuilder('Image', cls.ImageWidget);
    cls.WidgetFactory.registerBuilder('ImageWidget', cls.ImageWidget);
  });
;
'use strict';

modulum('LabelWidget', ['TextWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Label widget.
     * @class LabelWidget
     * @memberOf classes
     * @extends classes.TextWidgetBase
     * @publicdoc Widgets
     */
    cls.LabelWidget = context.oo.Class(cls.TextWidgetBase, function($super) {
      return /** @lends classes.LabelWidget.prototype */ {
        __name: 'LabelWidget',
        __dataContentPlaceholderSelector: cls.WidgetBase.selfDataContent,
        /**
         * @type {HTMLElement}
         */
        _textContainer: null,
        /** @type {boolean} */
        _hasHTMLContent: false,
        _value: null,
        _displayFormat: null,

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          if (!this._ignoreLayout) {
            this._layoutInformation = new cls.LayoutInformation(this);
            this._layoutEngine = new cls.LeafLayoutEngine(this);
            this._layoutInformation.forcedMinimalWidth = 16;
            this._layoutInformation.forcedMinimalHeight = 16;
          }
        },

        /**
         * @inheritDoc
         */
        resetLayout: function() {
          if (this._layoutInformation) {
            this._layoutInformation._initialMeasure = false;
            this._layoutInformation.invalidateInitialMeasure(false, this._value !== null && this._value !== '' && this._value !==
              false && this._value !== 0);
          }
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          this._textContainer = this._element.getElementsByTagName('span')[0];
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._textContainer = null;
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          this._onRequestFocus(domEvent);
          this.emit(context.constants.widgetEvents.click, domEvent);
          return true;
        },

        /**
         * Get the display format
         * @return {?string} could be null, or 'html'
         * @publicdoc
         */
        getDisplayFormat: function() {
          return this._displayFormat;
        },

        /**
         * Set current display format to use on each set value
         * @param {string} format the display format
         * @publicdoc
         */
        setDisplayFormat: function(format) {
          this._displayFormat = format;
        },

        /**
         * @inheritDoc
         */
        setValue: function(value) {
          var formattedValue = value;
          var hadValue = this._value !== null && this._value !== '' && this._value !== false && this._value !== 0;
          var hasValue = formattedValue !== null && formattedValue !== '' && formattedValue !== false && formattedValue !== 0;
          if (this._layoutInformation) {
            this._layoutInformation.invalidateInitialMeasure(hadValue, hasValue);
          }
          this._value = formattedValue || null;
          this.domAttributesMutator(function() {
            if (this._hasHTMLContent === true) {
              this._textContainer.innerHTML = formattedValue;
            } else {
              var newValue = (!!formattedValue || formattedValue === 0 || formattedValue === false) ? formattedValue : '';
              if (this.isInTable()) {
                newValue = newValue.replace(/\n/g, " "); // no newline in label in table
              }
              this._textContainer.textContent = newValue;
              this._textContainer.toggleClass("is-empty-label", newValue === "");
            }
          }.bind(this));
          if (this._layoutEngine) {
            if (!hadValue && hasValue) {
              this._layoutEngine.forceMeasurement();
            }
            this._layoutEngine.invalidateMeasure();
          }
        },

        /**
         * @inheritDoc
         */
        getValue: function() {
          if (this._hasHTMLContent === true) {
            return this._textContainer.innerHTML;
          } else {
            var content = this._textContainer.textContent;
            if (content === '\u00a0') {
              return '';
            }
            return content;
          }
        },

        /**
         * @inheritDoc
         */
        getClipboardValue: function() {
          return this.getValue();
        },

        /**
         * @inheritDoc
         */
        setFocus: function(fromMouse) {
          this._element.domFocus();
        },

        /**
         * Add some html formating
         * @param {HTMLElement} jcontrol - holder for html content
         */
        setHtmlControl: function(jcontrol) {
          jcontrol.innerHTML = this.getValue();
          jcontrol.addClass('gbc-label-text-container');
          this._textContainer.replaceWith(jcontrol);
          this._textContainer = jcontrol;
          this._hasHTMLContent = true;
        }
      };
    });
    cls.WidgetFactory.registerBuilder('Label', cls.LabelWidget);
  });
;
'use strict';

modulum('MenuLabelWidget', ['TextWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * MenuLabelWidget widget.
     * @class MenuLabelWidget
     * @memberOf classes
     * @extends classes.LabelWidget
     */
    cls.MenuLabelWidget = context.oo.Class(cls.LabelWidget, function($super) {
      /** @lends classes.MenuLabelWidget.prototype */
      return {
        __name: 'MenuLabelWidget',

        /** @type {HTMLElement}*/
        _imageContainer: null,
        /** @type {HTMLElement}*/
        _commentContainer: null,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          this._ignoreLayout = true;
          $super._initElement.call(this);
          this._imageContainer = this._element.querySelector('.gbc-label-image-container');
          this._commentContainer = this._element.querySelector('.gbc-label-comment-container');
          this._textContainer = this._element.querySelector('.gbc-label-text-container');
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          // no layout
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._imageContainer = null;
          this._commentContainer = null;
          $super.destroy.call(this);
        },

        /**
         * Defines the image source
         * @param {string} imgSrc - url of the label image
         */
        setImage: function(imgSrc) {
          var img = cls.WidgetFactory.createWidget('ImageWidget', this.getBuildParameters());
          img.setSrc(imgSrc, true);
          this._imageContainer.innerHTML = img._element.innerHTML;
          img.destroy();
        },

        /**
         * Set the text of the label
         * @param {string} text - the text
         * @publicdoc
         */
        setText: function(text) {
          this.setValue(text);
        },

        /**
         * Set the text of the label comment
         * @param {string} comment - text to set as comment
         */
        setComment: function(comment) {
          this._commentContainer.innerText = comment;
        },

      };
    });
    cls.WidgetFactory.registerBuilder('MenuLabel', cls.MenuLabelWidget);
  });
;
'use strict';

modulum('MessageWidget', ['TextWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Message Widget to display information as toated popups
     * @class MessageWidget
     * @memberOf classes
     * @extends classes.TextWidgetBase
     * @publicdoc Widgets
     */
    cls.MessageWidget = context.oo.Class(cls.TextWidgetBase, function($super) {
      return /** @lends classes.MessageWidget.prototype */ {
        __name: 'MessageWidget',
        $static: /** @lends classes.MessageWidget */ {
          defaultDisplayTime: 10
        },

        /**
         * Content of the message
         * @type {string}
         */
        _text: '',

        /**
         * Is the message is displayed with html formatting
         * @type {boolean}
         */
        _htmlFormat: false,

        /** @type {string} */
        _kind: 'message',

        /**
         * Timer to handle display time
         * @type {?number}
         */
        _currentTimeout: null,

        /**
         * Time (in seconds) before hiding message
         * 0  : always show
         * -1 : always hide
         */
        _messageDisplayTime: 0,

        /**
         * Close button element
         * @type {HTMLElement}
         */
        _closeButton: null,

        /**
         * Text Element
         * @type {HTMLElement}
         */
        _textElement: null,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);

          this._closeButton = this._element.querySelector('.close-button');
          this._textElement = this._element.querySelector('.message-text');

          var themeDisplayTime = context.ThemeService.getValue('theme-message-display-time');
          this._messageDisplayTime = Object.isNumber(themeDisplayTime) || Object.isString(themeDisplayTime) ?
            parseInt(themeDisplayTime, 10) : cls.MessageWidget.defaultDisplayTime;

          this.setHidden(true);
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._closeButton = null;
          this._textElement = null;

          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          if (domEvent.target.isElementOrChildOf(this._closeButton)) {
            this.setHidden(true);
          }
          return true;
        },

        /**
         * Set the message text
         * @param {string} text - the text to display
         * @publicdoc
         */
        setText: function(text) {
          if (text !== this._text) {
            this._text = text;
            this._refreshText();
            this.getLayoutEngine().invalidateMeasure();
          }
        },

        /**
         * Handle text reformatting
         * @private
         */
        _refreshText: function() {
          this.domAttributesMutator(function() {
            if (this._htmlFormat) {
              this._textElement.innerHTML = this._text;
            } else {
              this._textElement.textContent = this._text;
            }
          }.bind(this));

          if (this._text.trim().length <= 0) {
            this.setHidden(true);
          } else {
            this.setHidden(false);
          }
          if (this.isReversed()) {
            var ui = this.getUserInterfaceWidget();
            if (ui) {
              var left = ui.getElement().getBoundingClientRect().left;
              this.setStyle({
                'left': (left + 12) + 'px'
              });
            }
          }
        },

        /**
         * Get the current text
         * @returns {string} the displayed text
         * @publicdoc
         */
        getText: function() {
          return this._textElement.textContent;
        },

        /**
         * Hide / show the message
         * @param {boolean} hidden - visibility state
         * @publicdoc
         */
        setHidden: function(hidden) {
          // Message text is empty or display time is 0, hide it
          if (this._text.trim().length <= 0 || this._messageDisplayTime < 0) {
            hidden = true;
          }
          if (!hidden) {
            this.removeClass("out-of-view");
          }
          var disp = this._messageDisplayTime * 1000;
          // Handle hide timeout only if display time is positive
          if (this._messageDisplayTime > 0) {
            if (this._hidden !== hidden) {
              $super.setHidden.call(this, hidden);
              if (this._currentTimeout !== null) {
                this._clearTimeout(this._currentTimeout);
                this._currentTimeout = null;
              }
              if (!hidden) {
                this._currentTimeout = this._registerTimeout(this._hide.bind(this), disp);
              }
              this.emit("hide.MessageWidget", hidden);
            }
          } else {
            $super.setHidden.call(this, hidden);
          }
        },

        /**
         * do hide
         * @private
         */
        _hide: function() {
          this.setHidden(true);
          this._currentTimeout = null;
        },

        /**
         * Set message formatting as html
         * @param {boolean} html - true if html formatted, false otherwise
         * @publicdoc
         */
        setHtmlFormat: function(html) {
          if (this._htmlFormat !== html) {
            this._htmlFormat = html;
            this._refreshText();
          }
        },

        /**
         * Defines the type of message, thus the right customization variables will be used
         * @param {string} kind - could be 'message' or 'error'
         * @publicdoc
         */
        setMessageKind: function(kind) {
          this._kind = kind;
          if (kind) {
            // Handle display time
            var themeDisplayTime = context.ThemeService.getValue('theme-' + kind + '-display-time');
            this._messageDisplayTime = Object.isNumber(themeDisplayTime) || Object.isString(themeDisplayTime) ?
              parseInt(themeDisplayTime, 10) : cls.MessageWidget.defaultDisplayTime;
            // Handle position
            if (context.ThemeService.getValue("theme-" + kind + "-display-position")) {
              this.addClass(context.ThemeService.getValue("theme-" + kind + "-display-position"));
            }
          }
        },

        /**
         * Get the message kind
         * @return {string} could be 'error' or 'message'
         */
        getMessageKind: function() {
          return this._kind;
        },

        /**
         * Get the 4ST position value for the message
         * @return {string} - something like "bottom-left"
         */
        getPosition: function() {
          var pos = "bottom-right"; // default value
          var kind = this.getMessageKind();
          var themePos = context.ThemeService.getValue("theme-" + kind + "-display-position");
          return themePos ? themePos : pos;
        },

        /**
         * Use this to create a widget in the dom without displaying it
         */
        setDummyMessage: function() {
          this.setText("...");
          this.addClass("out-of-view"); // see: GBC-2187
        },

      };
    });
    cls.WidgetFactory.registerBuilder('Message', cls.MessageWidget);
  });
;
'use strict';

modulum('DateEditMobileWidget', ['DateEditWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * DateEdit widget Mobile.
     * Limitations: you cannot use some 4ST : daysOff, firstDayOfWeek, showCurrentMonthOnly, showWeekNumber
     * @class DateEditMobileWidget
     * @memberOf classes
     * @extends classes.DateEditWidgetBase
     * @publicdoc Widgets
     */
    cls.DateEditMobileWidget = context.oo.Class(cls.DateEditWidgetBase, function($super) {
      return /** @lends classes.DateEditMobileWidget.prototype */ {
        __name: 'DateEditMobileWidget',

        /**
         * @type {Node}
         */
        _pickerLabel: null,

        // TODO cleaning it should have no pikaday in mobile version ?

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);

          this._inputElement.setAttribute("data-date", "");

          // Trick to open picker when touching icon
          this._inputElement.setAttribute("id", this.getRootClassName() + "_input");
          this._pickerLabel = this._element.getElementsByTagName("label")[0];
          this._pickerLabel.setAttribute("for", this.getRootClassName() + "_input");

          this._pikerIcon.on('touchstart.IconDateEditWidget', this._onIconClick.bind(this));
          this._element.on('touchstart.DateEditMobileWidget', this._onTouchStart.bind(this));
          this._inputElement.on("change.DateEditMobileWidget", function(event) {
            if (this.isEnabled()) {
              var valueAsDate = event.target.valueAsDate;
              if (valueAsDate) {
                var d = {
                  year: valueAsDate.getUTCFullYear(),
                  month: valueAsDate.getUTCMonth() + 1,
                  day: valueAsDate.getUTCDate()
                };
                var momentDate = gbc.moment(d.year + "-" + d.month + "-" + d.day, "YYYY-MM-DD");
                if (momentDate.isValid()) {
                  this.setValue(momentDate.format(this._displayFormat));
                }
              } else {
                this.setValue("");
              }
              this.emit(context.constants.widgetEvents.change);
            }
          }.bind(this));
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._pikerIcon.off('touchstart.IconDateEditWidget');
          this._element.off('touchstart.DateEditMobileWidget');
          this._inputElement.off("change.DateEditMobileWidget");
          $super.destroy.call(this);
        },

        /**
         * Overrided to prevent pikaday picker to open
         */
        _onIconClick: function(event) {
          event.stopPropagation();
          // if widget already has VM focus, we need to explicitly set focus to input when clicking on dateedit icon, otherwise keyboard binding are not trapped.
          // if widget doesn't have VM focus, VM will set focus to input.
          if (this.hasVMFocus() && this.isEnabled()) {
            this._inputElement.domFocus();
          }
          this._onRequestFocus(event); // request focus
        },

        /**
         * Handler when input is touched
         * @param event
         * @private
         */
        _onTouchStart: function(event) {
          if (this.isEnabled()) {
            this._onRequestFocus(event); // request focus
          } else {
            event.stopPropagation();
            event.stopImmediatePropagation();
            event.preventCancelableDefault();
            return false;
          }
        },

        /**
         * @inheritDoc
         */
        setValue: function(value, fromVM) {
          // if from VM, convert it to good format, so it can open the picker at the right date!
          if (fromVM) {
            var dateObj = context.moment(value, this._displayFormat);
            if (dateObj.isValid()) {
              this._inputElement.value = dateObj.format("YYYY-MM-DD");
            } else {
              this._inputElement.value = value;
            }
          }
          this._inputElement.setAttribute("data-date", value);
        },

        /**
         * @inheritDoc
         */
        getValue: function() {
          return this._inputElement.getAttribute("data-date");
        }

      };
    });
  });
;
'use strict';

modulum('DateTimeEditMobileWidget', ['DateTimeEditWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * DateTimeEdit widget.
     * @class DateTimeEditMobileWidget
     * @memberOf classes
     * @extends classes.DateTimeEditWidgetBase
     * @publicdoc Widgets
     */
    cls.DateTimeEditMobileWidget = context.oo.Class(cls.DateTimeEditWidgetBase, function($super) {
      return /** @lends classes.DateTimeEditMobileWidget.prototype */ {
        __name: 'DateTimeEditMobileWidget',

        /**
         * @inheritDoc
         */
        __dataContentPlaceholderSelector: '.gbc_dataContentPlaceholder',

        /**
         * Active/disable seconds for the widget. By default yes.
         * @type {boolean}
         */
        _showSeconds: false,

        /**
         * @inheritDoc
         */
        _displayFormat: null,

        /**
         * @inheritDoc
         */
        _maxLength: -1,

        /**
         * @type {Node}
         */
        _pickerLabel: null,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this, true);
          // default datetime format
          this._displayFormat = 'MM/DD/YYYY HH:mm:ss';

          this._inputElement.on('touchstart.DateTimeEditWidgetBase', this._onRequestFocus.bind(this));

          // Trick to open picker when touching icon
          this._inputElement.setAttribute("id", this.getRootClassName() + "_input");
          this._pickerLabel = this._element.getElementsByTagName("label")[0];
          this._pickerLabel.setAttribute("for", this.getRootClassName() + "_input");
          this._inputElement.on("change.DateTimeEditWidgetBase", function(event) {
            this.setValue(event.target.value);
            this.emit(context.constants.widgetEvents.change);
          }.bind(this));
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._inputElement.off("change.DateTimeEditWidgetBase");
          $super.destroy.call(this);
        },

        /**
         * Overrided to prevent pikaday picker to open
         * // TODO it seems to be never called, there is pikaday in mobile
         */
        _onIconClick: function(event) {
          event.stopPropagation();
          // if widget already has VM focus, we need to explicitly set focus to input when clicking on dateedit icon, otherwise keyboard binding are not trapped.
          // if widget doesn't have VM focus, VM will set focus to input.
          if (this.hasVMFocus() && this.isEnabled() && !this.isModal()) {
            this._inputElement.domFocus();
          }
          this._onRequestFocus(event); // request focus
        },

        /**
         * @inheritDoc
         */
        setValue: function(value, fromVM) {
          var dateObj;
          // if from VM, convert it to good format, so it can open the picker at the right date
          if (value) {
            if (fromVM) {
              dateObj = context.moment(value, this._displayFormat);
              if (dateObj.isValid()) {
                this._inputElement.value = dateObj.format("YYYY-MM-DDTHH:mm:ss");
              }
            } else {
              dateObj = context.moment(value, "YYYY-MM-DDTHH:mm:ss");
            }
            this._inputElement.setAttribute("data-date", dateObj.format(this._displayFormat));
          } else { // manage null/empty value
            if (fromVM) {
              this._inputElement.value = value;
            }
            this._inputElement.setAttribute("data-date", value);
          }
        },

        /**
         * @inheritDoc
         */
        getValue: function() {
          return this._inputElement.getAttribute("data-date");
        },

        /**
         * @inheritDoc
         */
        setFormat: function(format) {
          $super.setFormat.call(this, format);
          if (this._showSeconds) {
            // Display seconds
            this.getInputElement().setAttribute("step", "1");
          } else {
            this.getInputElement().removeAttribute("step");
          }
        }
      };
    });
  });
;
'use strict';

modulum('SpinEditMobileWidget', ['SpinEditWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * SpinEdit Mobile widget.
     * @class SpinEditMobileWidget
     * @memberOf classes
     * @extends classes.SpinEditWidgetBase
     * @publicdoc Widgets
     *
     * ignore step attr
     */
    cls.SpinEditMobileWidget = context.oo.Class(cls.SpinEditWidgetBase, function($super) {
      return /** @lends classes.SpinEditMobileWidget.prototype */ {
        __name: 'SpinEditMobileWidget',

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          this.getElement().on('touchstart.SpinEditMobileWidget', this._onTouch.bind(this));
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this.getElement().off('touchstart.SpinEditMobileWidget');
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        _onTouch: function(event) {
          if (this.isEnabled()) {
            this._inputElement.setAttribute("placeholder", this._inputElement.value);
            this._inputElement.value = "";
          }
          this._onRequestFocus(event); // request focus
        },

        /**
         * @inheritDoc
         */
        _onInput: function() {
          $super._onInput.call(this);

          // Check value
          var curVal = this.getValue();
          if (this._max && curVal > this._max) {
            this.setValue(this._max);
          }
          if (this._min && curVal < this._min) {
            this.setValue(this._min);
          }
        },

        /**
         * @inheritDoc
         */
        getValue: function() {
          // Use vm value if not defined
          var value = parseInt(this._inputElement.value, 10);
          var isDefined = Object.isNumber(value) && !Object.isNaN(value);
          return isDefined ? value : this._oldValue;
        },

        /**
         * @inheritDoc
         */
        loseFocus: function() {
          if (this._inputElement.value === "") {
            this._inputElement.value = this._oldValue;
          }
        }
      };
    });
  });
;
'use strict';

modulum('TimeEditMobileWidget', ['TimeEditWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * TimeEdit Mobile widget.
     * @class TimeEditMobileWidget
     * @memberOf classes
     * @extends classes.TimeEditWidgetBase
     * @publicdoc Widgets
     */
    cls.TimeEditMobileWidget = context.oo.Class(cls.TimeEditWidgetBase, function($super) {
      return /** @lends classes.TimeEditMobileWidget.prototype */ {
        __name: 'TimeEditMobileWidget',

        /**
         * @type {Node}
         */
        _pickerLabel: null,
        _pickerIcon: null,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);

          this._pickerIcon = this._element.getElementsByClassName('widget-decoration')[0];

          this._inputElement = this._element.getElementsByTagName('input')[0];
          this.setValue('00:00:00');

          this._inputElement.on("change.TimeEditMobileWidget", function(event) {
            var val = this._inputElement.value;
            if (window.isIOS() && this._useSeconds) {
              val += ":00";
            }
            this._inputElement.setAttribute("data-time", val);
            this.emit(context.constants.widgetEvents.change);
          }.bind(this));
          this._element.on('touchstart.TimeEditMobileWidget', this._onRequestFocus.bind(this));

          // Trick to open picker when touching icon
          this._inputElement.setAttribute("id", this.getRootClassName() + "_input");
          this._pickerLabel = this._element.getElementsByTagName("label")[0];
          this._pickerLabel.setAttribute("for", this.getRootClassName() + "_input");
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          var target = domEvent.target;
          if (target.isElementOrChildOf(this._inputElement) || target.isElementOrChildOf(this._pickerIcon)) {
            this._onRequestFocus(domEvent); // request focus
          }
          return true;
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._element.off('touchstart.TimeEditMobileWidget');
          this._inputElement.off('change.TimeEditMobileWidget');
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        setDisplayFormat: function(format) {
          $super.setDisplayFormat.call(this, format);
          this._updateFormat();
        },

        /**
         * @inheritDoc
         */
        setValue: function(value, fromVM) {
          if (this.getValue() !== value) {
            $super.setValue.call(this, value, fromVM);
            this._inputElement.setAttribute("data-time", value);
            if (fromVM) {
              this._updateFormat();
            }
          }
        },

        /**
         * Add/remove seconds accuracy from input time picker
         * @private
         */
        _updateFormat: function() {
          if (this._useSeconds) {
            this._inputElement.setAttribute("step", "1");
          } else {
            this._inputElement.removeAttribute("step");
          }
        },

        /**
         * @inheritDoc
         */
        getValue: function() {
          return this._inputElement.getAttribute("data-time");
        }
      };
    });
  });
;
'use strict';

modulum('ProgressBarWidget', ['FieldWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Progressbar widget.
     * @class ProgressBarWidget
     * @memberOf classes
     * @extends classes.FieldWidgetBase
     * @publicdoc Widgets
     */
    cls.ProgressBarWidget = context.oo.Class(cls.FieldWidgetBase, function($super) {
      return /** @lends classes.ProgressBarWidget.prototype */ {
        __name: 'ProgressBarWidget',
        __dataContentPlaceholderSelector: cls.WidgetBase.selfDataContent,

        /** @type {string} */
        _progressSelector: '>div>.mt-progress-level',

        /** @type {HTMLElement} */
        _progressElement: null,
        /** @type {HTMLElement} */
        _percentageElement: null,

        /** @type {number} */
        _value: 0,
        /** @type {number} */
        _valueMin: 0,
        /** @type {number} */
        _valueMax: 100,

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          this._progressElement = this._element.querySelector('div>div');
          this._percentageElement = this._element.querySelector('.mt-progress-bar-percentage');
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          if (!this._ignoreLayout) {
            this._layoutInformation = new cls.LayoutInformation(this);
            this._layoutEngine = new cls.LeafLayoutEngine(this);
            this._layoutInformation.getSizePolicyConfig().initial = cls.SizePolicy.Fixed();
            this._layoutInformation.getSizePolicyConfig().dynamic = cls.SizePolicy.Fixed();
            // this._layoutInformation.forcedMinimalWidth = 80;
            this._layoutInformation.forcedMinimalHeight = 20;
            this._layoutEngine._shouldFillHeight = true;
          }
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._progressElement = null;
          this._percentageElement = null;
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          // in table we have to request focus on row when clicking on a table column progress bar
          if (this.isInTable()) {
            this._onRequestFocus(domEvent); // request focus
          }
          return true;
        },

        /**
         * Overrided to use mt-progress-color instead of secondary color
         * @inheritDoc
         */
        setColor: function(color) {
          if (color === gbc.ThemeService.getValue("theme-secondary-color")) {
            color = gbc.ThemeService.getValue("mt-progress-color");
          }
          this.setStyle(this._progressSelector, {
            'background-color': !!color ? color + ' !important' : null
          });
        },

        /**
         * Get the color of the progressBar
         * @return {string} the CSS value for the backgrund-color attribute
         * @publicdoc
         */
        getColor: function() {
          return this.getStyle(this._progressSelector, 'background-color');
        },

        /**
         * Set the color of the progressBar
         * @param {string} color - any CSS compliant color
         * @publicdoc
         */
        setBackgroundColor: function(color) {
          this.setStyle({
            'background-color': !!color ? color + ' !important' : null
          });
        },

        /**
         * Get the color of the progressBar
         * @return {string} the CSS value for the backgrund-color attribute
         * @publicdoc
         */
        getBackgroundColor: function() {
          return this.getStyle('background-color');
        },

        /**
         * @inheritDoc
         */
        getValue: function() {
          return this._value;
        },

        /**
         * @inheritDoc
         */
        setValue: function(value, fromVM) {
          value = +value;
          // Check if number
          value = Number.isNaN(value) ? this._valueMin : value;
          // Check if value is higher than Max
          value = value > this._valueMax ? this._valueMax : value;
          // Check if value is lower than min
          value = value < this._valueMin ? this._valueMin : value;
          this._value = value;

          var percentValue = Math.round((this._value - this._valueMin) / (this._valueMax - this._valueMin) * 100);
          this.afterDomMutator(function() {
            this.setStyle(this._progressSelector, {
              'width': '' + percentValue + '% !important'
            });
          }.bind(this));
          if (this._percentageElement) {
            this._percentageElement.querySelector("span").innerText = percentValue;
            this.setAriaAttribute("valuetext", percentValue + " %");
          }
          this.setAriaAttribute("valuenow", value);
        },

        /**
         * Set the progressbar as running (with animation)
         * @param {boolean} running - true starts the animation for an unknown progress progressbar, false stops it.
         * @publicdoc
         */
        setRunning: function(running) {
          this._progressElement.toggleClass('running', running);
          this._element.toggleClass('running', running);
        },

        /**
         * Check if the progressBar is running
         * @returns {boolean} true if the animation is running for an unknown progress progressbar, false otherwise.
         * @publicdoc
         */
        isRunning: function() {
          return this._element.hasClass('running');
        },

        /**
         * Set the state of the progressBar as unknown
         * @param {boolean} unknown true to switch to the unknown progress mode, false otherwise
         * @publicdoc
         */
        setProgressUnknown: function(unknown) {
          this._progressElement.toggleClass('mt-progress-level-unknown', unknown);
          if (unknown) {
            this.setStyle(this._progressSelector, {
              'width': '0% !important'
            });
          }
        },

        /**
         * Check if progress status is unknown
         * @returns {boolean} true if the progressbar is in unknown progress mode, false otherwise
         * @publicdoc
         */
        isProgressUnknown: function() {
          return this._progressElement.hasClass('mt-progress-level-unknown');
        },

        /**
         * Set the minimum value of the progressBar
         * @param {number} valueMin - minimum value the progressBar can handle
         * @publicdoc
         */
        setMin: function(valueMin) {
          this._valueMin = parseInt(valueMin, 10);
          this.setAriaAttribute("valuemin", valueMin);
          this.setValue(this._value, false);
        },

        /**
         * Get the minimum value of the progressBar
         * @return {number} minimum value the progressBar can handle
         * @publicdoc
         */
        getMin: function() {
          return this._valueMin;
        },

        /**
         * Set the maximum value of the progressBar
         * @param {number} valueMax - maximum value the progressBar can handle
         * @publicdoc
         */
        setMax: function(valueMax) {
          this._valueMax = parseInt(valueMax, 10);
          this.setAriaAttribute("valuemax", valueMax);
          this.setValue(this._value, false);
        },

        /**
         * Get the maximum value of the progressBar
         * @return {number} maximum value the progressBar can handle
         * @publicdoc
         */
        getMax: function() {
          return this._valueMax;
        },

        /**
         * @inheritDoc
         */
        setFocus: function(fromMouse) {
          this._element.domFocus();
        },

        /**
         * Show the percentage in the progressbar
         * @param {string} pos - position of the percentage info: 'left', 'right' or center
         */
        showPercentage: function(pos) {
          if (pos && this._percentageElement) {
            this._percentageElement.removeClass('.percentage-left');
            this._percentageElement.removeClass('.percentage-center');
            this._percentageElement.removeClass('.percentage-right');
            this._percentageElement.addClass('percentage-' + pos);
          }
        },

      };
    });
    cls.WidgetFactory.registerBuilder('ProgressBar', cls.ProgressBarWidget);
  });
;
"use strict";

modulum('RadioGroupWidget', ['FieldWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * RadioGroup widget.
     * @class RadioGroupWidget
     * @memberOf classes
     * @extends classes.FieldWidgetBase
     * @publicdoc Widgets
     */
    cls.RadioGroupWidget = context.oo.Class(cls.FieldWidgetBase, function($super) {
      return /** @lends classes.RadioGroupWidget.prototype */ {
        __name: 'RadioGroupWidget',
        /**
         * currently aimed item
         * @type {number}
         */
        _currentAimIndex: 0,

        /**
         * Widget value
         * @type {string|?}
         */
        _value: null,
        /**
         * @type {boolean}
         */
        _notNull: false,
        /**
         * @type {boolean}
         */
        _allowNullValue: false,

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          this.setFocusable(true);
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          if (!this._ignoreLayout) {
            this._layoutInformation = new cls.LayoutInformation(this);
            this._layoutEngine = new cls.LeafLayoutEngine(this);
            this._layoutInformation.getSizePolicyConfig().initial = cls.SizePolicy.Dynamic();
            this._layoutInformation.getSizePolicyConfig().fixed = cls.SizePolicy.Dynamic();
          }
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageKeyDown: function(keyString, domKeyEvent, repeat) {
          var keyProcessed = false;

          if (this.isEnabled() && !this.isReadOnly()) {

            keyProcessed = true;
            switch (keyString) {
              case "down":
              case this.getEnd():
                this._onNext();
                break;
              case "up":
              case this.getStart():
                this._onPrevious();
                break;
              case "space":
                this._onSpace();
                break;
              default:
                keyProcessed = false;
            }
          }

          if (keyProcessed) {
            return true;
          } else {
            return $super.manageKeyDown.call(this, keyString, domKeyEvent, repeat);
          }
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {

          this._onRequestFocus(domEvent);
          if (domEvent.target.elementOrParent("gbc_RadioGroupItem")) {
            this._onItemClick(domEvent);
          }
          this.emit(context.constants.widgetEvents.click, domEvent);

          return false;
        },

        /**
         * On click handler
         * @param {Object} evt - DOM event
         * @private
         */
        _onItemClick: function(evt) {
          if (this.isEnabled()) {
            var item = evt.target.closest('gbc_RadioGroupItem');
            this._currentAimIndex = 0;
            for (; item.previousElementSibling; item = item.previousElementSibling) {
              if (item.previousElementSibling !== this.__charMeasurer) {
                ++this._currentAimIndex;
              }
            }
            this._prepareValue(this._currentAimIndex, true);
            this.emit(context.constants.widgetEvents.change, false);
          }
        },

        /**
         * On previous handler : action to do when we want to go to previous value
         * @private
         */
        _onPrevious: function() {
          this._currentAimIndex = (this._currentAimIndex <= 0) ?
            this._element.children.length - 2 : //(remove charMeasurer child
            (this._currentAimIndex - 1);
          this._prepareValue(this._currentAimIndex, false);
          this.emit(context.constants.widgetEvents.change, false);
        },

        /**
         * On next handler : action to do when we want to go to next value
         * @private
         */
        _onNext: function() {
          this._currentAimIndex = (this._currentAimIndex >= (this._element.children.length - 2)) ? //(remove charMeasurer child
            0 :
            (this._currentAimIndex + 1);
          this._prepareValue(this._currentAimIndex, false);
          this.emit(context.constants.widgetEvents.change, false);
        },

        /**
         * On space Key handler
         * @private
         */
        _onSpace: function() {
          this._prepareValue(this._currentAimIndex, true);
          this.emit(context.constants.widgetEvents.change, false);
        },

        /**
         * Return index of value in _values array
         * @param {string} value - value to look for
         * @return {number} position of the value
         * @private
         */
        _indexOf: function(value) {
          var children = this._element.childrenExcept(this.__charMeasurer);
          for (var i = 0; i < children.length; ++i) {
            if (children[i].getAttribute('data-value') === value.toString()) {
              return i;
            }
          }
          return -1;
        },

        /**
         * Add a choice to the list
         * @param {object} choice - choice to add
         * @private
         */
        _addChoice: function(choice) {
          var button = context.TemplateService.renderDOM('RadioGroupItem');
          button.setAttribute('data-value', choice.value);
          button.getElementsByTagName('span')[0].textContent = choice.text;
          this._element.appendChild(button);
          if (this.getLayoutEngine()) {
            this.getLayoutEngine().forceMeasurement();
            this.getLayoutEngine().invalidateMeasure();
          }
        },

        /**
         * Removes a choice at the given index
         * @param {number} index
         * @private
         */
        _removeChoiceAt: function(index) {
          this._element.allchild('gbc_RadioGroupItem')[index].remove();
        },

        /**
         * Removes the given choice
         * @param {object} choice
         * @private
         */
        _removeChoice: function(choice) {
          var index = this._indexOf(choice.value);
          if (index >= 0) {
            this._removeChoiceAt(index);
          }
          if (this.getLayoutEngine()) {
            this.getLayoutEngine().forceMeasurement();
            this.getLayoutEngine().invalidateMeasure();
          }
        },

        /**
         * Adds a single or a list of choices
         * @param {string|string[]} choices - choices to add to the radio ensemble
         * @publicdoc
         */
        setChoices: function(choices) {
          this.clearChoices();
          if (choices) {
            if (Array.isArray(choices)) {
              for (var i = 0; i < choices.length; i++) {
                this._addChoice(choices[i]);
              }
              this.updateValue();
            } else {
              this._addChoice(choices);
            }
            this._addAriaNavigation();
          }
        },

        /**
         * Removes a single or a list of choices
         * @param {(string|string[])} choices - choices to remove
         * @publicdoc
         */
        removeChoices: function(choices) {
          if (choices) {
            if (Array.isArray(choices)) {
              for (var i = 0; i < choices.length; i++) {
                this._removeChoice(choices[i]);
              }
            } else {
              this._removeChoice(choices);
            }
          }
        },

        /**
         * Clears all choices
         * @publicdoc
         */
        clearChoices: function() {
          while (this._element.childrenExcept(this.__charMeasurer).length !== 0) {
            this._element.childrenExcept(this.__charMeasurer)[0].remove();
          }
          if (this.getLayoutEngine()) {
            this.getLayoutEngine().forceMeasurement();
            this.getLayoutEngine().invalidateMeasure();
          }
        },

        /**
         * Set the layout orientation.
         * @param {string} orientation - 'vertical' or 'horizontal'.
         * @publicdoc
         */
        setOrientation: function(orientation) {
          this._element.toggleClass('gbc_RadioGroupWidget_horizontal', orientation === 'horizontal');
          this._element.toggleClass('gbc_RadioGroupWidget_vertical', orientation === 'vertical');
          if (this.getLayoutEngine()) {
            this.getLayoutEngine().forceMeasurement();
            this.getLayoutEngine().invalidateMeasure();
          }
        },

        /**
         * Get the layout orientation.
         * @returns {string} the layout orientation. 'vertical' or 'horizontal'.
         * @publicdoc
         */
        getOrientation: function() {
          if (this._element.hasClass('gbc_RadioGroupWidget_horizontal')) {
            return 'horizontal';
          } else {
            return 'vertical';
          }
        },

        /**
         * Get the value of the radiogroup
         * @returns {string} value - the current value
         * @publicdoc
         */
        getValue: function() {
          var children = this._element.childrenExcept(this.__charMeasurer);
          for (var i = 0; i < children.length; ++i) {
            var item = children[i];
            if (item.getElementsByClassName('zmdi')[0].hasClass('checked')) {
              return item.getAttribute('data-value');
            }
          }
          return '';
        },

        /**
         * @inheritDoc
         */
        setValue: function(value, fromVM) {
          $super.setValue.call(this, value, fromVM);
          this._setValue(value);
        },

        /**
         * Internal setValue used to be inherited correctly by DummyWidget
         * @param {string} value - the value to set
         * @private
         */
        _setValue: function(value) {
          this._value = value;
          var children = this._element.childrenExcept(this.__charMeasurer);
          for (var i = 0; i < children.length; ++i) {
            var item = children[i];
            var isChecked = value !== null ? item.getAttribute('data-value') === value.toString() : false;
            item.setAttribute("aria-checked", isChecked.toString());
            item.getElementsByClassName('zmdi')[0].toggleClass('checked', isChecked);
            item.getElementsByClassName('zmdi')[0].toggleClass('unchecked', !isChecked || !value);
            if (isChecked) {
              this._currentAimIndex = i;
            }
          }
        },

        /**
         * Set again the value, can be useful if items have changed
         * @publicdoc
         */
        updateValue: function() {
          if (!!this._value) {
            this.setValue(this._value);
          }
        },

        /**
         * Prepare the value
         * @param {number} index - index of the value
         * @param {boolean} doSetValue -
         * @private
         */
        _prepareValue: function(index, doSetValue) {
          if (this.isEnabled()) {
            this._updateVisualAim();
            if (doSetValue || this._element.querySelectorAll('.checked').length !== 0) {
              var children = this._element.childrenExcept(this.__charMeasurer);
              for (var i = 0; i < children.length; ++i) {
                var element = children[i],
                  item = element.getElementsByClassName('zmdi')[0],
                  isCurrent = i === index;
                if (!isCurrent) {
                  item.removeClass('checked');
                  item.addClass('unchecked');
                } else {
                  if (!item.hasClass('checked')) {
                    item.removeClass('unchecked');
                    item.addClass('checked');
                  } else {
                    if (!this._notNull || this._allowNullValue) {
                      item.removeClass('checked');
                      item.addClass('unchecked');
                    }
                  }
                }
              }
              this.setEditing(this.getValue() !== this._oldValue);
            }
          }
        },

        /**
         * Add a visual outline to see the position
         * @protected
         */
        _updateVisualAim: function() {
          var children = this._element.childrenExcept(this.__charMeasurer);
          for (var i = 0; i < children.length; ++i) {
            var item = children[i];
            item.toggleClass('aimed', i === this._currentAimIndex);
            if (i === this._currentAimIndex) {
              item.setAttribute("aria-selected", "true");
            }
          }
        },

        /**
         * @inheritDoc
         */
        setEnabled: function(enabled) {
          $super.setEnabled.call(this, enabled);
          this._element.toggleClass('disabled', !enabled);
          var children = this._element.childrenExcept(this.__charMeasurer);
          for (var i = 0; i < children.length; ++i) {
            var item = children[i].getElementsByClassName('zmdi')[0];
            item.toggleClass('disabled', !enabled);
          }
        },

        /**
         * Sets the focus to the widget
         * @publicdoc
         */
        setFocus: function(fromMouse) {
          this._element.domFocus();
          this._updateVisualAim();
          $super.setFocus.call(this, fromMouse);
        },

        /**
         * Set widget mode. Useful when widget have peculiar behavior in certain mode
         * @param {string} mode the widget mode
         * @param {boolean} active the active state
         */
        setWidgetMode: function(mode, active) {
          this._allowNullValue = mode === "Construct";
        },

        /**
         * Add accessible navigation for radiogroup
         * @private
         */
        _addAriaNavigation: function() {
          var children = this._element.childrenExcept(this.__charMeasurer);
          for (var i = 0; i < children.length; ++i) {
            children[i].setAttribute('aria-posinset', (i + 1).toString());
            children[i].setAttribute('aria-setsize', children.length.toString());
          }
        }

      };
    });
    cls.WidgetFactory.registerBuilder('RadioGroup', cls.RadioGroupWidget);
  });
;
'use strict';

modulum('RichTextWidget', ['WebComponentWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * TextEdit widget.
     * @class RichTextWidget
     * @memberOf classes
     * @extends classes.WebComponentWidget
     */
    cls.RichTextWidget = context.oo.Class(cls.WebComponentWidget, function($super) {
      return /** @lends classes.RichTextWidget.prototype */ {
        __name: 'RichTextWidget',
        /**
         * @type {?string}
         */
        _richtextPath: null,

        _richTextProperties: null,

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          this._richtextPath = context.ThemeService.getResource("webcomponents/fglrichtext/fglrichtext.html");
          $super.constructor.call(this, opts);
          this._richTextProperties = {
            toolbar: true,
          };
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          // Use this line if gbc should use the FGL richtext editor (only for 3.10)
          // this._richtextPath = gbc.WebComponentService.getWebcomponentUrl() + '/fglrichtext/fglrichtext.html';
          this.setWebComponentType('api');
          this.setUrl(this._richtextPath);
        },

        /**
         * Display the toolbar or not
         * @param {boolean|string} show
         */
        showEditToolBox: function(show) {
          this._richTextProperties.toolbar = show !== 'hide';
          this._onReadyExecute(function() {
            this._toICAPI('onProperty', {
              'toolbar': show
            });
          }.bind(this));

          this._toICAPI('onProperty', {
            'toolbar': show
          });
        },

        /**
         * Defines the toolbar items
         * @param {string} items - string representing items
         */
        setToolbarItems: function(items) {
          this._onReadyExecute(function() {
            this._toICAPI('onProperty', {
              'toolbar': items
            });
          }.bind(this));

          this._toICAPI('onProperty', {
            'toolbar': items
          });
        },

        /**
         * @inheritDoc
         */
        _onReady: function() {
          $super._onReady.call(this);
          this._iframeElement.removeClass('hidden');
          //Load Spellchecker and create a default toolbar
          this._onReadyExecute(function() {
            var tb = this._richTextProperties.toolbar ?
              'bold italic underline | alignleft aligncenter alignright alignjustify | bullist numlist | outdent indent | fontsizeselect' :
              'hide';
            this._toICAPI('onProperty', {
              'toolbar': tb,
              'spellcheck': 'browser'
            });
          }.bind(this));
        },

        /**
         * @inheritDoc
         */
        setReadOnly: function(readonly) {
          $super.setReadOnly.call(this, readonly);

          this._onReadyExecute(function() {
            this._toICAPI('onStateChanged', JSON.stringify({
              'active': readonly,
            }));
          }.bind(this));
        },

        /**
         * @inheritDoc
         */
        setEnabled: function(enabled) {
          $super.setEnabled.call(this, enabled);
          // Enable or disable Editor
          this._onReadyExecute(function() {
            this._toICAPI('onStateChanged', JSON.stringify({
              'active': enabled ? 1 : 0,
            }));
          }.bind(this));
        },

        /**
         * NotEditable allows cursor moving, but not a value change
         * @param {boolean} notEditable - true to set the edit part as read-only
         */
        setNotEditable: function(notEditable) {
          this._notEditable = notEditable;
          this._onReadyExecute(function() {
            // Note that noteditable key is in lowercase since properties sent by VM are always in lowercase
            this._toICAPI('onProperty', JSON.stringify({
              'noteditable': notEditable,
            }));
          }.bind(this));
        },

        /**
         * @inheritDoc
         */
        setValue: function(value, fromVM) {
          if (value === '') {
            value = null;
          }
          this._value = value;
          if (this._isReady && this.value !== this._flushValue) {
            this._toICAPI('onData', this._value ? this._value : '');
          } else {
            this.when(cls.WebComponentWidget.ready, this._onReadyData.bind(this));
          }
        },

        /**
         * @inheritDoc
         */
        setFocus: function(fromMouse) {
          this._onReadyExecute(function() {
            if (this._iframeElement !== document.activeElement) {
              this._toICAPI('onFocus', true);
            }
          }.bind(this));
          $super.setFocus.call(this, fromMouse);
        },

        /**
         * Force webcomponent to get data
         */
        flushWebcomponentData: function() {
          this._toICAPI('onFlushData');
        },

      };
    });
    cls.WidgetFactory.registerBuilder('RichText', cls.RichTextWidget);
  });
;
'use strict';

modulum('RipGraphicWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Label widget.
     * @class RipGraphicWidget
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.RipGraphicWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.RipGraphicWidget.prototype */ {
        __name: 'RipGraphicWidget',

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          if (!this._ignoreLayout) {
            this._layoutInformation = new cls.LayoutInformation(this);
            this._layoutEngine = new cls.LeafLayoutEngine(this);
          }
        },
        setType: function(type) {
          this.addClass(type);
        }
      };
    });
    cls.WidgetFactory.registerBuilder('RipGraphic', cls.RipGraphicWidget);
  });
;
'use strict';

modulum('SliderWidget', ['FieldWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Slider widget.
     * @class SliderWidget
     * @memberOf classes
     * @extends classes.FieldWidgetBase
     * @publicdoc Widgets
     */
    cls.SliderWidget = context.oo.Class(cls.FieldWidgetBase, function($super) {
      return /** @lends classes.SliderWidget.prototype */ {
        __name: 'SliderWidget',
        /**
         * Redefine where the data is located
         * @type {string|Object}
         */
        __dataContentPlaceholderSelector: cls.WidgetBase.selfDataContent,
        /**
         * Slider orientation. Default is horizontal
         * @type {?string}
         */
        _orientation: null,
        /**
         * Flag to indicate if we updated orientation before or after first widget layout
         */
        _afterLayoutFlag: null,

        /**
         * @constructs
         * @param {Object} opts - Options passed to the constructor
         * @publicdoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          this.setFocusable(true);
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          if (!this._ignoreLayout) {
            this._layoutInformation = new cls.LayoutInformation(this);
            this._layoutEngine = new cls.SliderLayoutEngine(this);
            this._layoutInformation.getSizePolicyConfig().initial = cls.SizePolicy.Dynamic();
            this._layoutInformation.getSizePolicyConfig().fixed = cls.SizePolicy.Dynamic();
            this._layoutInformation._forceFixedWidthMeasure = true;
          }
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          this._inputElement = this._element.getElementsByTagName('input')[0];
          var onSlideEnd = this._onSlide.bind(this);

          this._inputElement.on('touchend.SliderWidget', onSlideEnd);
          this._inputElement.on('mouseup.SliderWidget', onSlideEnd);

          this._inputElement.on('touchstart.SliderWidget', function() {
            this._preventContainerScrolling(true);
          }.bind(this));
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._inputElement.off('touchend.SliderWidget');
          this._inputElement.off('mouseup.SliderWidget');
          this._inputElement.off('touchstart.SliderWidget');
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          this._onRequestFocus(domEvent); // request focus
          return true;
        },

        /**
         * @inheritDoc
         */
        manageKeyDown: function(keyString, domKeyEvent, repeat) {
          var keyProcessed = false;

          if (this.isEnabled() && !this.isReadOnly()) {

            keyProcessed = true;
            switch (keyString) {
              case "down":
              case "pagedown":
              case this.getStart():
                this.setEditing(true);
                this._decrease();
                this.emit(context.constants.widgetEvents.change, false);
                break;
              case "up":
              case "pageup":
              case this.getEnd():
                this.setEditing(true);
                this._increase();
                this.emit(context.constants.widgetEvents.change, false);
                break;
              default:
                keyProcessed = false;
            }
          }

          if (keyProcessed) {
            return true;
          } else {
            return $super.manageKeyDown.call(this, keyString, domKeyEvent, repeat);
          }
        },

        /**
         * Handler executed on mouse click. We update the value depending of pointer location click on the slider
         * and send it to VM
         * @param {Object} evt - DOM event
         */
        _onSlide: function(evt) {
          if (!this.hasFocus()) {
            this._onRequestFocus(evt); // request focus
          }
          // need to emit change because on some browsers, change event is not raised when slider has not yet the focus
          if (this.isEnabled() && !this.isReadOnly()) {
            var total;
            // Vertical sliders are rotated with CSS. evt.offsetX takes this into account. getBoundingClientRect doesn't
            var clickPos = 0;
            var inputRect = this._inputElement.getBoundingClientRect();
            if (!!evt.offsetX) {
              clickPos = evt.offsetX;
              // on mobile offsetX doesn't exist. We need to calculate the relative click position using global pageX and input position
            } else if (window.isTouchDevice() && evt.changedTouches[0]) {
              if (this.getOrientation() === 'horizontal') {
                clickPos = evt.changedTouches[0].pageX - inputRect.left;
              } else {
                clickPos = inputRect.bottom - evt.changedTouches[0].pageY;
              }
            }
            if (this.getOrientation() === 'horizontal') {
              total = inputRect.width;
            } else {
              total = inputRect.height;
            }
            var expectedTotal = this.getMax() - this.getMin();
            var expectedVal = expectedTotal * (clickPos / total);
            var step = this.getStep();
            var value = this.getMin() + Math.floor(expectedVal / step) * step;
            if ((expectedVal % step) > (step / 2)) {
              value += step;
            }
            this.setEditing(true);
            this._inputElement.value = value;
          }
          this._preventContainerScrolling(false);
          this.emit(context.constants.widgetEvents.change, false);
        },

        /**
         * Increase the displayed value
         */
        _increase: function() {
          this.setValue((this.getValue() || 0) + this.getStep());
        },

        /**
         * Decrease the displayed value
         */
        _decrease: function() {
          this.setValue((this.getValue() || 0) - this.getStep());
        },

        /**
         * @inheritDoc
         */
        getValue: function() {
          return parseInt(this._inputElement.value, 10);
        },

        /**
         * @inheritDoc
         */
        setValue: function(value, fromVM) {
          $super.setValue.call(this, value, fromVM);
          value = +value;
          this._inputElement.value = Object.isNumber(value) && !Number.isNaN(value) ? value : 0;
          this.setAriaAttribute("valuenow", value);
        },

        /**
         * Get minimum possible value of the slider
         * @returns {number} the minimum value
         * @publicdoc
         */
        getMin: function() {
          return this._inputElement.getIntAttribute('min');
        },

        /**
         * Define the minimum possible value of the slider
         * @param {number} value - the minimum value
         * @publicdoc
         */
        setMin: function(value) {
          if (Object.isNumber(value)) {
            this._inputElement.setAttribute('min', value);
          } else {
            this._inputElement.removeAttribute('min');
          }
          this.setAriaAttribute("valuemin", value);
        },

        /**
         * Get maximum possible value of the slider
         * @returns {number} the maximum value
         * @publicdoc
         */
        getMax: function() {
          return this._inputElement.getIntAttribute('max');
        },

        /**
         * Define the maximum possible value of the slider
         * @param {number} value - the maximum value
         * @publicdoc
         */
        setMax: function(value) {
          if (Object.isNumber(value)) {
            this._inputElement.setAttribute('max', value);
          } else {
            this._inputElement.removeAttribute('max');
          }
          this.setAriaAttribute("valuemax", value);
        },

        /**
         * Get slider step when increasing or decreasing value
         * @returns {number} the step value
         * @publicdoc
         */
        getStep: function() {
          return this._inputElement.getIntAttribute('step');
        },

        /**
         * Define the slider step when increasing or decreasing value
         * @param {number} step - the step value
         * @publicdoc
         */
        setStep: function(step) {
          this._inputElement.setAttribute('step', Object.isNumber(step) && step > 0 ? step : 1);
        },

        /**
         * @inheritDoc
         */
        setTitle: function(title) {
          this._inputElement.setAttribute('title', title);
        },

        /**
         * @inheritDoc
         */
        getTitle: function() {
          return this._inputElement.getAttribute('title');
        },

        /**
         * Set the orientation of the slider widget
         * @param {string} orientation can be 'horizontal' or 'vertical'
         * @param {boolean} afterLayout internal
         * @publicdoc
         */
        setOrientation: function(orientation, afterLayout) {
          if (this._orientation !== orientation || this._afterLayoutFlag !== afterLayout) {
            this._orientation = orientation;
            this._afterLayoutFlag = afterLayout;
            var newStyle = {};

            if (orientation === 'vertical' && afterLayout) {
              // Rotate only after layout
              this.setStyle({
                'transform': 'rotate(-90deg)'
              });
            } else {
              newStyle = {
                '-webkit-appearance': null,
                'writing-mode': null
              };
              if (this._inputElement) {
                this._inputElement.removeAttribute('orient');
              }
            }
            this.setStyle('>input[type=range]', newStyle);
            this.setAriaAttribute("orientation", orientation);
          }
        },

        /**
         * Get the current slider orientation. Default is horizontal.
         * @returns {string} current css orientation
         * @publicdoc
         */
        getOrientation: function() {
          return this._orientation ? this._orientation : 'horizontal';
        },

        /**
         * @inheritDoc
         */
        setFocus: function(fromMouse) {
          this._inputElement.domFocus();
          $super.setFocus.call(this, fromMouse);
        },

        /**
         * @inheritDoc
         */
        setReadOnly: function(readonly) {
          $super.setReadOnly.call(this, readonly);
          this._setInputReadOnly(readonly);
        },

        /**
         * Set if input element is readonly
         * @param {boolean} readonly
         * @private
         */
        _setInputReadOnly: function(readonly) {
          if (readonly) {
            this._inputElement.setAttribute('readonly', 'readonly');
          } else {
            this._inputElement.removeAttribute('readonly');
          }
        },

        /**
         * Prevent the container to scroll while doing touch to scroll the tab-titles
         * @param {Boolean} prevent - true to prevent it, false otherwise
         * @private
         */
        _preventContainerScrolling: function(prevent) {
          var form = this.getFormWidget();
          if (form) {
            form.getContainerElement().toggleClass("prevent-touch-scroll", prevent);
          }
        }

      };
    });
    cls.WidgetFactory.registerBuilder('Slider', cls.SliderWidget);
  });
;
'use strict';

modulum('SpinEditWidget', ['SpinEditWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * SpinEdit widget.
     * @class SpinEditWidget
     * @memberOf classes
     * @extends classes.SpinEditWidgetBase
     * @publicdoc Widgets
     */
    cls.SpinEditWidget = context.oo.Class(cls.SpinEditWidgetBase, function($super) {
      return /** @lends classes.SpinEditWidget.prototype */ {
        __name: 'SpinEditWidget',

        /**
         * @inheritDoc
         */
        managePriorityKeyDown: function(keyString, domKeyEvent, repeat) {
          if (this.isEnabled()) {
            if (keyString === "home" && this.getMin() !== null) {
              return false; // don't process this key it will be processed in manageKeyDown function
            } else if (keyString === "end" && this.getMax() !== null) {
              return false; // don't process this key it will be processed in manageKeyDown function
            }
          }

          return $super.managePriorityKeyDown.call(this, keyString, domKeyEvent, repeat);
        },

        /**
         * @inheritDoc
         */
        manageKeyDown: function(keyString, domKeyEvent, repeat) {
          var keyProcessed = false;

          if (this.isEnabled() && !this.isReadOnly()) {

            keyProcessed = true;
            var updateValue = 0;
            switch (keyString) {
              case "down":
                updateValue = -1;
                break;
              case "pagedown":
                updateValue = -10;
                break;
              case "up":
                updateValue = 1;
                break;
              case "pageup":
                updateValue = 10;
                break;
              case "home":
                var min = this.getMin();
                if (min !== null) {
                  this.setEditing(this._oldValue !== min);
                  this.setValue(min);
                  this.emit(context.constants.widgetEvents.change, false);
                }
                break;
              case "end":
                var max = this.getMax();
                if (max !== null) {
                  this.setEditing(this._oldValue !== max);
                  this.setValue(max);
                  this.emit(context.constants.widgetEvents.change, false);
                }
                break;
              default:
                keyProcessed = this._processKey(domKeyEvent, keyString);
            }

            if (updateValue !== 0) {
              this._updateValue(updateValue);
              this.emit(context.constants.widgetEvents.change, false);
            }
          }

          if (keyProcessed) {
            return true;
          } else {
            return $super.manageKeyDown.call(this, keyString, domKeyEvent, repeat);
          }
        },

      };
    });
    cls.WidgetFactory.registerBuilder('SpinEdit', cls.SpinEditWidget);
  });
;
'use strict';

modulum('TextEditWidget', ['FieldWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * TextEdit widget.
     * @class TextEditWidget
     * @memberOf classes
     * @extends classes.FieldWidgetBase
     * @publicdoc Widgets
     */
    cls.TextEditWidget = context.oo.Class(cls.FieldWidgetBase, function($super) {
      return /** @lends classes.TextEditWidget.prototype */ {
        __name: 'TextEditWidget',
        /**
         * true if textedit can contains HTML content
         * @type {boolean}
         */
        _hasHTMLContent: false,
        /** @type classes.HtmlFilterWidget **/
        _htmlFilter: null,
        /** @type {boolean} */
        _wantReturns: true,
        /** @type {boolean} */
        _wantTabs: false,
        /**
         * Redefine where the data is located
         * @type {string|Object}
         */
        __dataContentPlaceholderSelector: cls.WidgetBase.selfDataContent,

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          if (!this._ignoreLayout) {
            this._layoutInformation = new cls.LayoutInformation(this);
            this._layoutInformation.shouldFillStack = true;
            this._layoutEngine = new cls.LeafLayoutEngine(this);
            this._layoutEngine._shouldFillHeight = true;
            this._layoutInformation.getSizePolicyConfig().dynamic = cls.SizePolicy.Initial();
            this._layoutInformation.forcedMinimalWidth = 20;
            this._layoutInformation.forcedMinimalHeight = 20;
          }
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          this._inputElement = this._element.getElementsByTagName('textarea')[0];
          this._initListeners();
        },

        /**
         * Initialize all widget events listener
         */
        _initListeners: function() {
          this._inputElement.on('input.TextEditWidget', this._onInput.bind(this));
          // Manage requestFocus during selection of text
          this._inputElement.on('mousedown.TextEditWidget', cls.WidgetBase._onSelect.bind(this));
        },

        /**
         * Clear event listeners of the widget
         */
        _unloadListeners: function() {
          this._inputElement.off('mousedown.TextEditWidget');
          this._inputElement.off('input.TextEditWidget');
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._unloadListeners();

          if (this._htmlFilter) {
            this._htmlFilter.destroy();
            this._htmlFilter = null;
          }

          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          this._onRequestFocus(domEvent); // request focus
          this.emit(context.constants.widgetEvents.click, domEvent);
          return true;
        },

        /**
         * @inheritDoc
         */
        managePriorityKeyDown: function(keyString, domKeyEvent, repeat) {
          var keyProcessed = false;

          if (this.isEnabled()) {
            switch (keyString) {
              // Standard navigation : let default
              case "up":
              case "down":
              case "end":
              case "home":
                domKeyEvent.gbcDontPreventDefault = true;
                keyProcessed = true;
                break;

              case "enter":
              case "return":
                if (!this.isNotEditable() && this._wantReturns) {
                  domKeyEvent.gbcDontPreventDefault = true;
                  keyProcessed = true;
                }
                break;

              case "tab":
                if (!this.isNotEditable() && this._wantTabs) {
                  keyProcessed = true;
                  this._insertTab();
                }
                break;
            }
          }

          if (keyProcessed) {
            return true;
          } else {
            return $super.managePriorityKeyDown.call(this, keyString, domKeyEvent, repeat);
          }
        },

        /**
         * @inheritDoc
         */
        manageKeyUp: function(keyString, domKeyEvent) {
          $super.manageKeyUp.call(this, keyString, domKeyEvent);

          this.emit(context.constants.widgetEvents.keyUp, domKeyEvent, true);
        },

        /**
         * @inheritDoc
         */
        _onInput: function() {
          $super._onInput.call(this);

          // TODO this code should probably be moved in FieldWidgetBase when fix GBC-2088
          // IE11 bug : input event being raised on edit click. Try to catch this specific case by testing if value changed and field doesn't have VM focus yet.
          if (!window.browserInfo.isIE || this.getValue() !== this._oldValue || this.hasVMFocus()) {
            this.emit(context.constants.widgetEvents.change, true);
          }
        },

        /**
         * Insert a TAB char
         * @private
         */
        _insertTab: function() {
          var s = this._inputElement.selectionStart;
          var value = this._inputElement.value.substring(0, this._inputElement.selectionStart) + "\t" + this._inputElement.value
            .substring(this._inputElement.selectionEnd);

          // If Maxlength is not defined, insert tab character anyway
          if (!this.getMaxLength() || value.length <= this.getMaxLength()) {
            this.setValue(value);
            this._inputElement.selectionEnd = s + 1;
          }
        },

        /**
         * @inheritDoc
         */
        setValue: function(value, fromVM) {
          $super.setValue.call(this, value, fromVM);
          this._setValue(value);
        },

        /**
         * Internal setValue used to be inherited correctly by DummyWidget
         * @param {string} value - the value
         * @private
         */
        _setValue: function(value) {
          if (this._hasHTMLContent) {
            this._inputElement.innerHTML = this._htmlFilter.filterHtml(value);
          } else {
            this._inputElement.value = value;
          }
        },

        /**
         * @inheritDoc
         */
        getValue: function() {
          if (this._hasHTMLContent === true) {
            return this._inputElement.innerHTML;
          } else {
            var result = this._inputElement.value;
            if (this.isEditing()) {
              if (this.getTextTransform() === 'up') {
                result = result.toLocaleUpperCase();
              }
              if (this.getTextTransform() === 'down') {
                result = result.toLocaleLowerCase();
              }
            }
            return result;
          }
        },

        /**
         * @inheritDoc
         */
        setReadOnly: function(readonly) {
          $super.setReadOnly.call(this, readonly);
          this._setInputReadOnly(readonly);
        },

        /**
         * Set input readonly attribute if it doesn't have focus or is noentry.
         * @param {boolean} readonly - true to set the edit part as read-only, false otherwise
         */
        _setInputReadOnly: function(readonly) {
          if (readonly || this._isReadOnly) {
            if (this._hasHTMLContent) {
              this._inputElement.setAttribute('contenteditable', false);
            } else {
              this._inputElement.setAttribute('readonly', 'readonly');
            }
          } else {
            if (this._hasHTMLContent) {
              this._inputElement.setAttribute('contenteditable', true);
            } else {
              this._inputElement.removeAttribute('readonly');
            }
          }
        },

        /**
         * Define the maximum number of characters allowed
         * @param {number} maxlength - maximum number of characters allowed in the field
         * @publicdoc
         */
        setMaxLength: function(maxlength) {
          this._setElementAttribute('maxlength', maxlength, "_inputElement");
        },

        /**
         * Get the maximum number of characters allowed
         * @returns {number} the maximum number of characters allowed in the field
         * @publicdoc
         */
        getMaxLength: function() {
          return this._inputElement.getIntAttribute('maxlength');
        },

        /** Place the cursor at the given position,
         * @param {number} cursor - first cursor position
         * @param {number} [cursor2] - second cursor position
         * @publicdoc
         */
        setCursors: function(cursor, cursor2) {
          if (!cursor2) {
            cursor2 = cursor;
          } else if (cursor2 === -1) { // for textEditWidget if cursor2 === -1 we don't select all the text, !== editWidget
            cursor2 = cursor;
          }
          this._inputElement.setCursorPosition(cursor, cursor2);
        },

        /**
         * Get cursors
         * @return {{start: number, end: number}} object with cursors
         * @publicdoc
         */
        getCursors: function() {
          var cursors = {
            start: 0,
            end: 0
          };
          if (this._inputElement && this._inputElement.value) {
            try {
              cursors.start = this._inputElement.selectionStart;
              cursors.end = this._inputElement.selectionEnd;
            } catch (ignore) {
              // Some input types don't allow cursor manipulation
            }
          }
          return cursors;
        },

        /**
         * @inheritDoc
         */
        setTextAlign: function(align) {
          $super.setTextAlign.call(this, align);
          this.setStyle(">textarea", {
            "text-align": align
          });
        },

        /**
         * Replace default textarea element used to display text with an html element which can displays HTML
         * @param {HTMLElement} jcontrol - div element
         * @publicdoc
         */
        setHtmlControl: function(jcontrol) {
          if (this._htmlFilter === null) {
            this._htmlFilter = cls.WidgetFactory.createWidget('HtmlFilterWidget', this.getBuildParameters());
          }
          if (this.isEnabled()) {
            jcontrol.setAttribute('contenteditable', true);
          }
          jcontrol.innerHTML = this.getValue();
          // Remove events before replacing the widget
          this._unloadListeners();
          this._inputElement.replaceWith(jcontrol);
          this._hasHTMLContent = true;
          this._inputElement = jcontrol;
          // Initialize events for the new widget
          this._initListeners();
          if (this.hasFocus()) {
            // Force focus again if it has focus
            this.setFocus();
          }
        },

        /**
         * @inheritDoc
         */
        setFocus: function(fromMouse) {
          this._inputElement.domFocus();
          $super.setFocus.call(this, fromMouse);
        },

        /**
         * Set number of editable rows inside the textedit widget
         * @param {number} rows - number of rows
         * @publicdoc
         */
        setRows: function(rows) {
          this._inputElement.setAttribute('rows', rows || 1);
        },

        /**
         * Make the textedit content return the new line breaking the word or not
         * @param {string} format - css value
         * @publicdoc
         */
        setWrapPolicy: function(format) {
          this._inputElement.toggleClass('breakword', format === 'anywhere');
        },

        /**
         * @inheritDoc
         */
        setEnabled: function(enabled) {
          $super.setEnabled.call(this, enabled);
          this._setInputReadOnly(!enabled);
        },

        /**
         * Set if textedit accepts TAB key
         * @param {boolean} wantTabs - true if TAB key should be accepted in the textedit
         * @publicdoc
         */
        setWantTabs: function(wantTabs) {
          this._wantTabs = wantTabs;
        },

        /**
         * Set if textedit accepts RETURN/ENTER key
         * @param {boolean} wantReturns - true if returns/enters should be accepted in the textedit
         * @publicdoc
         */
        setWantReturns: function(wantReturns) {
          this._wantReturns = wantReturns;
        },

        /**
         * Defines the scrollBars to display
         * @param {string} scrollBars - value can be 'auto', 'both', 'none', 'horizontal', 'vertical'
         */
        setScrollBars: function(scrollBars) {
          this.addClass("scrollbars-" + scrollBars);
        },
      };
    });
    cls.WidgetFactory.registerBuilder('TextEdit', cls.TextEditWidget);
  });
;
'use strict';

modulum('TimeEditWidget', ['TimeEditWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * TimeEdit widget.
     * @class TimeEditWidget
     * @memberOf classes
     * @extends classes.TimeEditWidgetBase
     * @publicdoc Widgets
     */
    cls.TimeEditWidget = context.oo.Class(cls.TimeEditWidgetBase, function($super) {
      return /** @lends classes.TimeEditWidget.prototype */ {
        __name: 'TimeEditWidget',

        /**
         * Array of time fragment HH, MM and SS
         * @type {DateTimeHelper.timeFragment[]}
         */
        _groups: null,

        /**
         * Current cursor position
         * @type {Object}
         */
        _currentCursors: null,

        /**
         * Flag to indicate if valid number has been entered
         * @type {boolean}
         */
        _numericPressed: false,

        /**
         * Up arrow element
         * @type {Element}
         */
        _upArrow: null,

        /**
         * Down arrow element
         * @type {Element}
         */
        _downArrow: null,

        /**
         * Current group of time being updated
         * @type {number}
         */
        _currentGroup: 0,

        /**
         * Last valid time being set
         * @type {?string}
         */
        _lastValid: null,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          this._groups = [
            cls.DateTimeHelper.timeFragment(24),
            cls.DateTimeHelper.timeFragment(60),
            cls.DateTimeHelper.timeFragment(60)
          ];
          this._lastValid = '00:00:00';
          this._inputElement = this._element.getElementsByTagName('input')[0];
          this._upArrow = this._element.getElementsByClassName('up')[0];
          this._downArrow = this._element.getElementsByClassName('down')[0];

          this._inputElement.on('input.TimeEditWidget', this._onInput.bind(this));
          this._inputElement.on('mousedown.TimeEditWidget', cls.WidgetBase._onSelect.bind(this));

          this.setValue(this._lastValid);

          this._currentCursors = {
            start: 0,
            end: 0
          };

          this._inputElement.on("change.TimeEditWidget", function(event) {
            this._inputElement.setAttribute("data-time", this._inputElement.value);
          }.bind(this));
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._currentCursors = null;
          this._upArrow = null;
          this._downArrow = null;
          this._inputElement.off('change.TimeEditWidget');
          this._inputElement.off('input.TimeEditWidget');
          this._inputElement.off('mousedown.TimeEditWidget');
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {

          var target = domEvent.target;
          if (target.isElementOrChildOf(this._upArrow)) {
            this._onUpIcon(domEvent);
          } else if (target.isElementOrChildOf(this._downArrow)) {
            this._onDownIcon(domEvent);
          } else if (target.isElementOrChildOf(this._inputElement)) {
            this._onInputClick(domEvent);
          }

          return true;
        },

        /**
         * @inheritDoc
         */
        manageKeyDown: function(keyString, domKeyEvent, repeat) {
          var keyProcessed = false;

          if (this.isEnabled() && !this.isReadOnly()) {

            var start = this._inputElement.selectionStart;
            var end = this._inputElement.selectionEnd;

            keyProcessed = true;
            switch (keyString) {
              case "down":
                this._decrease();
                this.emit(context.constants.widgetEvents.change, false, true);
                break;
              case "up":
                this._increase();
                this.emit(context.constants.widgetEvents.change, false, true);
                break;
              case this.getStart():
              case this.getEnd():
                this._updateCurrentGroup();
                keyProcessed = false; // let the default behavior, just update current group
                break;
              case ":":
              case "shift+:":
              case "ctrl+" + this.getEnd():
                //Update current group of time being selected
                this._moveGroup(1);
                this._updateSelection();
                break;
              case "ctrl+" + this.getStart():
                this._moveGroup(-1);
                this._updateSelection();
                break;
              case "backspace":
                // only whole text or single group selection deletion are permitted
                if (!this.isEditing() && !this.hasFocus()) { // first keydown in typeahead mode (cursors not ready yet)
                  return true;
                }

                if ((start === 0 && this.getValue().length === end) || this.getValue().charAt(end - 1) !== ':') {
                  keyProcessed = false; // let the default behavior
                }
                break;
              case "del":
                // only whole text or single group selection deletion are permitted
                if (!this.isEditing() && !this.hasFocus()) { // first keydown in typeahead mode (cursors not ready yet)
                  return true;
                }
                if ((start === 0 && this.getValue().length === end) || this.getValue().charAt(end) !== ':' || start === end - 2) { // if 2 digits group selected
                  keyProcessed = false; // let the default behavior
                }
                break;
              default:
                keyProcessed = this._processKey(domKeyEvent, keyString);
            }
          }

          if (keyProcessed) {
            return true;
          } else {
            return $super.manageKeyDown.call(this, keyString, domKeyEvent, repeat);
          }
        },

        /**
         * Validate current group of time and eventually update set next group as current
         * @inheritDoc
         */
        manageKeyUp: function(keyString, domKeyEvent) {
          $super.manageKeyUp.call(this, keyString, domKeyEvent);

          // if key pressed was delete or backspace, we do not update current group
          var key = cls.KeyboardApplicationService.keymap[domKeyEvent.which];
          var groupChanged = (key === "del" || key === "backspace") ? false : this._updateCurrentGroup();
          var groupComplete = true;
          if (this._numericPressed) {
            this._numericPressed = false; // important to set it back to false since keypress event isn't raised for special command
            groupComplete = this._updateGroups(this.getValue());
            if (groupComplete) {
              this._moveGroup(1);
              this._updateSelection();
            }
          }
          if (groupChanged || groupComplete) {
            this.emit(context.constants.widgetEvents.change, true);
          }
        },

        /**
         * Process one key event
         * @param {Object} event
         * @param {string} keyString
         * @returns {boolean} true if key has been processed, false otherwise
         */
        _processKey: function(event, keyString) {
          var isModifier = cls.KeyboardHelper.isSpecialCommand(keyString);
          var isValid = !isModifier && cls.KeyboardHelper.isNumeric(event.gbcKey) && !this._isMaxLength();

          this._numericPressed = isValid;

          // timeedit is empty : we need to initialise its format on first numeric pressed
          if (isValid && this.getValue().length === 0) {
            this._updateFromGroups();
            this._updateSelection();
          }

          if (!isValid && !isModifier) {
            event.preventCancelableDefault();
            return true;
          }

          return false;
        },

        /**
         * Increase the current group value and update current group selection if needed
         */
        _increase: function() {
          this.setEditing(true);
          if (this._groups[this._currentGroup].increaseValue()) {
            if (this._currentGroup > 0 && this._groups[this._currentGroup - 1].increaseValue()) {
              if (this._currentGroup > 1) {
                this._groups[0].increaseValue();
              }
            }
          }
          this._updateFromGroups();
          this._updateSelection();
        },

        /**
         * Decrease the current group value
         */
        _decrease: function() {
          this.setEditing(true);
          if (this._groups[this._currentGroup].decreaseValue()) {
            if (this._currentGroup > 0 && this._groups[this._currentGroup - 1].decreaseValue()) {
              if (this._currentGroup > 1) {
                this._groups[0].decreaseValue();
              }
            }
          }
          this._updateFromGroups();
          this._updateSelection();
        },

        /**
         * Changes the current group
         * @param {number} where - group index
         */
        _moveGroup: function(where) {
          if (where < 0) {
            if (this._currentGroup !== 0) {
              this._currentGroup = this._currentGroup + where;
            }
          } else {
            if (this._currentGroup < this._groups.length - 1) {
              this._currentGroup = this._currentGroup + where;
            }
          }
        },

        /**
         * Updates the current group depending on the cursor position
         * @returns {boolean} true if the current group has changed, false otherwise
         */
        _updateCurrentGroup: function() {
          var value = this.getValue(),
            firstColon = value.indexOf(':'),
            secondColon = value.lastIndexOf(':');
          var position = this._inputElement.selectionEnd;
          var newPosition = 0;
          var oldPosition = this._currentGroup;
          if (secondColon !== -1) {
            newPosition = position <= firstColon ? 0 : (firstColon === secondColon || position <= secondColon ? 1 : 2);
          } else {
            oldPosition = 0;
          }
          oldPosition = Math.min(this._currentGroup, oldPosition);

          this._currentGroup = newPosition;
          var hasChanged = newPosition !== oldPosition;
          if (hasChanged && !this._isGroupComplete(oldPosition)) {
            this._updateFromGroups();
          }
          return hasChanged;
        },

        /**
         * Indicates if group is complete
         * @param {number} groupIndex - cursor position of group to test
         * @returns {boolean} true if group is complete
         */
        _isGroupComplete: function(groupIndex) {
          var value = this.getValue().split(':');
          return this._groups[groupIndex].fromText(value[groupIndex]);
        },

        /**
         * Update current group time value
         * @param {string} value - time value
         * @param {boolean} [force] - if true we consider this value is valid
         * @returns {boolean} true if group is complete
         */
        _updateGroups: function(value, force) {
          var complete = true;
          if (!this._useSeconds && this._groups.length === 3) {
            this._groups.pop();
          }
          for (var i = 0; i < this._groups.length; i++) {
            complete = complete && this._isGroupComplete(i);
          }
          if (complete || force) {
            this._updateFromGroups();
            this._lastValid = this.getValue();
          }
          return complete;
        },

        /**
         * Rebuilds the value from groups
         */
        _updateFromGroups: function() {
          var value = '';
          for (var i = 0; i < this._groups.length; i++) {
            value += (i > 0 ? ':' : '') + this._groups[i].getText();
          }
          this.setValue(value);
        },

        /**
         * Updates the selection range based on current group
         */
        _updateSelection: function() {
          var start = this._currentGroup * 3;
          if (start < 0) {
            start = 0;
          }
          if (start + 2 <= this.getValue().length) {
            this.setCursors(start, start + 2, true);
          }
        },

        /**
         * Handler which updates current group of time being updated
         * @param {UIEvent} event - DOM event
         */
        _onInputClick: function(event) {
          if (this.isEnabled() && !this.isReadOnly() && this.getValue() !== '') {
            // on click we update current time group and update selection/cursors in consequence
            this._updateCurrentGroup();
            this._updateSelection();
          }
          this._onRequestFocus(event); // request focus
        },

        /**
         * @inheritDoc
         */
        _onUpIcon: function(evt) {
          if (this.isEnabled() && !this.isReadOnly()) {
            this._onRequestFocus(evt); // request focus
            if (this.hasVMFocus()) { // focus input element before updating its cursors
              this._inputElement.domFocus();
            }
            this._increase();
            this.emit(context.constants.widgetEvents.change, false, true); // ask for cursors sending
          }
        },

        /**
         * @inheritDoc
         */
        _onDownIcon: function(evt) {
          if (this.isEnabled() && !this.isReadOnly()) {
            this._onRequestFocus(evt); // request focus
            if (this.hasVMFocus()) { // focus input element before updating its cursors
              this._inputElement.domFocus();
            }
            this._decrease();
            this.emit(context.constants.widgetEvents.change, false, true); // ask for cursors sending
          }
        },

        /**
         * Get cursors
         * @return {{start: number, end: number}} object with cursors
         * @publicdoc
         */
        getCursors: function() {
          return this._currentCursors;
        },

        /**
         * Place the cursor at the given position,
         * @param {number} cursor - first cursor position
         * @param {number} cursor2 - second cursor position
         * @param {Boolean} doNotUpdateGroup
         */
        setCursors: function(cursor, cursor2, doNotUpdateGroup) {
          var start = cursor;
          var end = cursor2;
          if (cursor2 === -1) {
            start = 0;
            end = 2;
          } else if (!cursor2) { // if cursor2 isn't defined, start cursor is used as end as well
            end = start;
          }
          this._currentCursors.start = start;
          this._currentCursors.end = end;
          this._inputElement.setCursorPosition(start, end);
          if (!doNotUpdateGroup) {
            this._updateCurrentGroup();
          }
          if (!cursor2) { // if cursor2 isn't defined or set to 0, we need to fallback selection to current group
            this._updateSelection();
          }
        },

        /**
         * @inheritDoc
         */
        setDisplayFormat: function(format) {
          $super.setDisplayFormat.call(this, format);
          this._updateGroups(this.getValue());
        },

        /**
         * @inheritDoc
         */
        setValue: function(value, fromVM) {
          if (this.getValue() !== value) {
            $super.setValue.call(this, value, fromVM);
            this._updateGroups(value);
          }
        },

        /**
         * @inheritDoc
         */
        setFocus: function(fromMouse) {
          $super.setFocus.call(this, fromMouse);
          var currentCursors = this.getCursors();
          this.setCursors(currentCursors.start, currentCursors.end);
        }
      };
    });
    cls.WidgetFactory.registerBuilder('TimeEdit', cls.TimeEditWidget);
  });
;
'use strict';

modulum('ToggleCheckBoxWidget', ['CheckBoxWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Toggle Checkbox widget. Like a switch
     * @class ToggleCheckBoxWidget
     * @memberOf classes
     * @extends classes.CheckBoxWidget
     * @publicdoc Widgets
     */
    cls.ToggleCheckBoxWidget = context.oo.Class(cls.CheckBoxWidget, function($super) {
      return /** @lends classes.ToggleCheckBoxWidget.prototype */ {
        __name: 'ToggleCheckBoxWidget',
        __dataContentPlaceholderSelector: cls.WidgetBase.selfDataContent,

        /** @type {Boolean} **/
        _threeState: false,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          this._checkboxElement = this._element.getElementsByClassName('switch')[0];
        },

        /**
         * Set the value and change the widget visual as well
         * @param {string|number} value - the value to set
         * @param {boolean=} fromVM - true if value comes from the VM
         * @publicdoc
         */
        setValue: function(value, fromVM) {
          $super.setValue.call(this, value);
          this._checkboxElement.querySelector('input').checked = (value === this._checkedValue);
          this.setAriaAttribute("checked", value); // ensure it's a stringified boolean
        },

        /**
         * Will get the next value : forced to check / uncheck since toggle is only 2 states
         * @return {string|number} the checked or unchecked value
         * @publicdoc
         */
        getNextValue: function() {
          var current = this._value;
          if (current === this._uncheckedValue) {
            return this._checkedValue;
          } else if (current === this._checkedValue) {
            return this._uncheckedValue;
          }
        },

        /**
         * Get the current value of the widget according to its state
         * @return {string|number} the current value of the widget
         * @publicdoc
         */
        getValue: function() {
          var checkBox = this._checkboxElement.querySelector('input');
          if (checkBox.checked) {
            return this._checkedValue;
          } else {
            return this._uncheckedValue;
          }
        },

        /**
         * Allow/disallow widget user interaction.
         * @param {boolean} enabled - the wanted state
         * @publicdoc
         */
        setEnabled: function(enabled) {
          var checkBox = this._checkboxElement.querySelector('input');
          checkBox.disabled = !enabled;
          $super.setEnabled.call(this, enabled);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          domEvent.preventCancelableDefault(); // click should not change automatically checkbox it is done by manageMouseClick
          return $super.manageMouseClick.call(this, domEvent);
        },

      };
    });

    cls.WidgetFactory.registerBuilder('CheckBox[customWidget=toggleButton]', cls.ToggleCheckBoxWidget);
    cls.WidgetFactory.registerBuilder('ToggleCheckBox', cls.ToggleCheckBoxWidget);
  });
;
"use strict";

modulum('FileInputWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Upload widget.
     * @class FileInputWidget
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.FileInputWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.FileInputWidget.prototype */ {
        __name: "FileInputWidget",
        $static: /** @lends classes.FileInputWidget */ {
          statusChangedEvent: "statusChanged",
          fileSelectionChangedEvent: "fileSelectionChanged",
          progressChangedEvent: "progressChanged"
        },
        _allowMultipleFiles: false,
        /**
         * @type {?string}
         */
        _rawCaption: null,
        _files: null,
        /**
         * @type {HTMLElement}
         */
        _hiddenInput: null,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          this._hiddenInput = this._element.querySelector("input");
          this._element.on("click.FileInputWidget", this._onClick.bind(this));
          this._element.on("drop.FileInputWidget", this._onDrop.bind(this));
          this._element.on("dragenter.FileInputWidget", this._onDragEnter.bind(this));
          this._element.on("dragleave.FileInputWidget", this._onDragLeave.bind(this));
          this._element.on("dragover.FileInputWidget", this._onDragOver.bind(this));
          this._element.on("mouseover.FileInputWidget", this._onMouseOver.bind(this));
          this._element.on("mouseout.FileInputWidget", this._onMouseOut.bind(this));
          this._hiddenInput.on("change.FileInputWidget", this._onFileChanged.bind(this));
          this.setCaption();
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._hiddenInput = null;
          this._element.off("click.FileInputWidget");
          this._element.off("drop.FileInputWidget");
          this._element.off("dragenter.FileInputWidget");
          this._element.off("dragleave.FileInputWidget");
          this._element.off("dragover.FileInputWidget");
          this._element.off("mouseover.FileInputWidget");
          this._element.off("mouseout.FileInputWidget");
          $super.destroy.call(this);
        },

        /**
         *
         * @private
         */
        _onClick: function() {
          this._hiddenInput.click();
        },

        /**
         *
         * @param {MouseEvent} event
         * @private
         */
        _onDrop: function(event) {
          this._element.removeClass("dropping");
          event.stopPropagation();
          event.stopImmediatePropagation();
          event.preventCancelableDefault();
          this._files = event.dataTransfer.files;
          this._onFileChanged();
        },

        /**
         *
         * @param {Object} event - DOM event
         * @private
         */
        _onDragEnter: function(event) {
          this._element.addClass("dropping");
        },

        /**
         *
         * @param {Object} event - DOM event
         * @private
         */
        _onDragLeave: function(event) {
          this._element.removeClass("dropping");
        },

        /**
         *
         * @param {MouseEvent} event
         * @private
         */
        _onDragOver: function(event) {
          this._element.addClass("dropping");
          event.stopPropagation();
          event.stopImmediatePropagation();
          event.preventCancelableDefault();
          try {
            var effects = event && event.dataTransfer && !window.browserInfo.isIE && event.dataTransfer.effectAllowed;
            event.dataTransfer.dropEffect = 'move' === effects || 'linkMove' === effects ? 'move' : 'copy';
          } catch (e) {}
        },

        /**
         *
         * @param {Object} event - DOM event
         * @private
         */
        _onMouseOver: function(event) {
          this._element.addClass("dropping");
        },

        /**
         *
         * @param {Object} event - DOM event
         * @private
         */
        _onMouseOut: function(event) {
          this._element.removeClass("dropping");
        },

        /**
         * @private
         */
        _onFileChanged: function() {
          var result, i;
          if (this._allowMultipleFiles) {
            result = [];
            if (this._files) {
              for (i = 0; i < this._files.length; i++) {
                if (this._files[i]) {
                  result.push(this._files[i].name);
                }
              }
            }
            if (this._hiddenInput.files) {
              for (i = 0; i < this._hiddenInput.files.length; i++) {
                if (this._hiddenInput.files[i]) {
                  result.push(this._hiddenInput.files[i].name);
                }
              }
            }
          } else {
            if (this._files && this._files[0] && this._files[0].name) {
              result = this._files[0].name;
            }
            if (this._hiddenInput.files && this._hiddenInput.files[0] && this._hiddenInput.files[0].name) {
              result = this._hiddenInput.files[0].name;
            }
          }
          if (!!result) {
            this.emit(cls.FileInputWidget.fileSelectionChangedEvent, result);
          }
        },
        /**
         *
         * @param extension
         */
        setExtension: function(extension) {
          if (extension !== ".*") {
            this._hiddenInput.setAttribute("accept", extension);
          }
        },
        /**
         *
         * @param caption
         */
        setCaption: function(caption) {
          this._rawCaption = caption;
          this._updateCaption();
        },

        _updateCaption: function() {
          if (this._rawCaption) {
            this._element.querySelector("span").textContent = this._rawCaption;
          } else {
            this._element.querySelector("span").textContent = (this._allowMultipleFiles ? i18next.t(
              "gwc.file.upload.droporclick-multiple") : i18next.t("gwc.file.upload.droporclick"));
          }
        },

        /**
         *
         * @param allow
         */
        allowMultipleFiles: function(allow) {
          this._allowMultipleFiles = !!allow;
          if (allow) {
            this._hiddenInput.setAttribute("multiple", "multiple");
          } else {
            this._hiddenInput.removeAttribute("multiple");
          }
          this._updateCaption();
        },

        /**
         * @returns {boolean}
         */
        isAllowMultipleFiles: function() {
          return this._allowMultipleFiles;
        },

        /**
         *
         * @param hook
         * @return {*|HandleRegistration}
         */
        whenFileSelectionChanged: function(hook) {
          return this.when(cls.FileInputWidget.fileSelectionChangedEvent, hook);
        },

        /**
         *
         * @param filename
         * @param url
         * @param callback
         * @param errorCallback
         */
        send: function(filename, url, callback, errorCallback) {
          var formData = null,
            i, file;
          if (this._files) {
            formData = new FormData();
            for (i = 0; i < this._files.length; ++i) {
              file = this._files[i];
              if (file.name === filename) {
                formData.append(file.name, file);
                break;
              }
              //TODO : manage multifile support
            }
          } else {
            formData = new FormData();
            var files = this._element.querySelector("form").file.files;
            for (i = 0; i < files.length; ++i) {
              file = files[i];
              if (file.name === filename) {
                formData.append(file.name, file);
                break;
              }
              //TODO : manage multifile support
            }
          }
          var request = new XMLHttpRequest();
          if (context.ThemeService.getValue("theme-network-use-credentials-headers")) {
            request.withCredentials = true;
          }
          request.onload = function() {
            callback();
          }.bind(this);
          request.onerror = function() {
            errorCallback();
          };
          request.open("POST", url);
          request.send(formData);
        }
      };
    });
    cls.WidgetFactory.registerBuilder('FileInput', cls.FileInputWidget);
  });
;
"use strict";

modulum('FilePickerWidget', ['ModalWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class FilePickerWidget
     * @memberOf classes
     * @extends classes.ModalWidget
     */
    cls.FilePickerWidget = context.oo.Class(cls.ModalWidget, function($super) {
      return /** @lends classes.FilePickerWidget.prototype */ {
        __name: "FilePickerWidget",
        __templateName: "ModalWidget",
        $static: {
          fileSelectionChangedEvent: "fileSelectionChanged"
        },
        /**
         * @type {HTMLElement}
         */
        _headerTitleDom: null,
        /**
         * @type {classes.FileInputWidget}
         */
        _fileInput: null,
        /**
         * @type {?string}
         */
        _rawCaption: null,

        /**
         * @type {Number}
         */
        _selfDestroyTimer: null,
        /**
         * @type {Array<string>}
         */
        _selectedFiles: null,
        /**
         * @type {Array<string>}
         */
        _availableFiles: null,

        /**
         * @inheritDoc
         */
        _initContainerElement: function() {
          $super._initContainerElement.call(this);
          this._element.addClass("gbc_ModalWidget").addClass("mt-dialog-filetransfer");
          var dialogContents = document.createElement("div");

          this._headerTitleDom = document.createElement('span');
          this._headerTitleDom.innerHTML = '<i class="zmdi zmdi-upload"></i> <span>' + i18next.t("gwc.file.upload.select") +
            '<span>';
          this.setHeader(this._headerTitleDom);

          this.setClosable(false);
          this.setContent(dialogContents);

          this._fileInput = cls.WidgetFactory.createWidget("FileInput", this.getBuildParameters());
          dialogContents.appendChild(this._fileInput.getElement());
          this._fileInput.setParentWidget(this);
          this._fileInput.whenFileSelectionChanged(this._whenFileSelectionChanged.bind(this));
          this.when(context.constants.widgetEvents.modalOut, function() {
            this.hide(false);
          }.bind(this));
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._fileInput.destroy();
          this._fileInput = null;
          this._headerTitleDom = null;
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        show: function() {
          $super.show.call(this);
          this.resizeHandler();
        },
        /**
         * hides the dialog
         * @inheritDoc
         * @param {boolean} gotFile
         */
        hide: function(gotFile) {
          var wasDisplayed = this.isVisible();
          $super.hide.call(this);
          if (wasDisplayed && !gotFile) {
            var emptySelection = this._fileInput && this._fileInput.isAllowMultipleFiles() ? [] : null;
            this.emit(cls.FilePickerWidget.fileSelectionChangedEvent, emptySelection);
          }
        },
        /**
         * sets the file input extension filter
         * @param {string} extension
         */
        setExtension: function(extension) {
          this._fileInput.setExtension(extension);
        },

        /**
         * sets the dialog caption
         * @param {string} caption
         */
        setCaption: function(caption) {
          this._rawCaption = caption;
          this._updateCaption();
        },

        /**
         * updates dialog caption
         * @private
         */
        _updateCaption: function() {
          var caption = this._rawCaption;
          if (!this._rawCaption) {
            if (this._fileInput.isAllowMultipleFiles()) {
              caption = i18next.t("gwc.file.upload.select-multiple");
            } else {
              caption = i18next.t("gwc.file.upload.select");
            }
          }
          this._headerTitleDom.querySelector("span").textContent = caption;
        },

        /**
         * whether or not to allow multipli file selection
         * @param {boolean} allow
         */
        allowMultipleFiles: function(allow) {
          this._fileInput.allowMultipleFiles(allow);
          this._updateCaption();
        },

        /**
         * callback when file input selection changed
         * @param event
         * @param src
         * @param data
         * @private
         */
        _whenFileSelectionChanged: function(event, src, data) {
          // normalize() converts 2 combined diacritical marks into 1 (ex:  encoded as e')
          // For exemple under Safari a file with name 'Qualit.pdf' has a length of 12 while under
          // chrome length will be 11 because of the special accent char : 
          // for this reason we need to normalize our file name
          // ! IE11 doesn't support normalize.
          if (Array.isArray(data)) {
            this._selectedFiles = data;
          } else {
            var fileName = data.normalize ? data.normalize() : data;
            this._selectedFiles = [fileName];
          }
          this._availableFiles = this._selectedFiles.slice();
          this.emit(cls.FilePickerWidget.fileSelectionChangedEvent, data);
          this._resetSelfDestroy();
          this.hide(true);
        },

        /**
         * register callback when file input selection changed
         * @param {Hook} hook
         * @return {HandleRegistration}
         */
        whenFileSelectionChanged: function(hook) {
          return this.when(cls.FileInputWidget.fileSelectionChangedEvent, hook);
        },

        /**
         * gets the files availables for sending
         * @return {Array<string>}
         */
        getAvailableFiles: function() {
          return this._availableFiles || [];
        },

        /**
         * sends the given filename's resource to the given url
         * @param {string} filename
         * @param {string} url
         * @param {function} callback
         * @param {function} errorCallback
         */
        send: function(filename, url, callback, errorCallback) {
          this._stopSelfDestroyTimer();
          var cb = function(fn) {
            this._startSelfDestroyTimer();
            fn();
          };
          this._fileInput.send(filename, url, cb.bind(this, callback), cb.bind(this, errorCallback));
        },

        /**
         * free the given filename's resource
         * @param {string} filename
         * @param {boolean} [selfDestroyOnEmpty] if no more files waiting, self destructs if true
         */
        freeFile: function(filename, selfDestroyOnEmpty) {
          if (this._availableFiles) {
            this._availableFiles.remove(filename);
            if (selfDestroyOnEmpty && !this._availableFiles.length) {
              this.destroy();
            }
          }
        },

        /**
         * stop the self destruction timer
         * @private
         */
        _stopSelfDestroyTimer: function() {
          if (this._selfDestroyTimer) {
            this._clearTimeout(this._selfDestroyTimer);
            this._selfDestroyTimer = null;
          }
        },
        /**
         * start the self destruction timer
         * @private
         */
        _startSelfDestroyTimer: function() {
          var timeout = parseInt(context.ThemeService.getValue("$gbc-FilePicker-selfdestroy-timeout"), 10) || 900;
          this._selfDestroyTimer = this._registerTimeout(this._onSelfDestroy.bind(this), timeout * 1000);
        },
        /**
         * reset the self destruction timer
         * @private
         */
        _resetSelfDestroy: function() {
          this._stopSelfDestroyTimer();
          this._startSelfDestroyTimer();
        },
        /**
         * triggered when self destruction activates
         * @private
         */
        _onSelfDestroy: function() {
          this._selfDestroyTimer = null;
          this.destroy();
        }
      };
    });
    cls.WidgetFactory.registerBuilder('FilePicker', cls.FilePickerWidget);
  });
;
'use strict';

modulum('WebComponentWidget', ['FieldWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * WebComponent widget.
     * @class WebComponentWidget
     * @memberOf classes
     * @extends classes.FieldWidgetBase
     * @publicdoc Widgets
     */
    cls.WebComponentWidget = context.oo.Class(cls.FieldWidgetBase, function($super) {
      return /** @lends classes.WebComponentWidget.prototype */ {
        $static: {
          gICAPIVersion: '1.0',
          focusEvent: context.constants.widgetEvents.focus,
          dataEvent: 'wc_data',
          actionEvent: 'wc_action',
          ready: 'wc_ready'
        },

        __name: 'WebComponentWidget',
        __dataContentPlaceholderSelector: cls.WidgetBase.selfDataContent,
        _webComponentType: null,
        /**
         * @type {Window}
         */
        _webComponentWindow: null,
        _webComponentProxy: null,
        _webComponentWindowKeyDown: null,
        _flushValue: '',
        _flushingData: false,
        _url: null,
        _isReady: false,
        _value: null,
        _stopOnError: true,

        /**
         * @type HTMLElement
         */
        _iframeElement: null,

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          if (!this._ignoreLayout) {
            this._layoutInformation = new cls.LayoutInformation(this);
            this._layoutInformation.shouldFillStack = true;
            this._layoutEngine = new cls.LeafLayoutEngine(this);
            this._layoutInformation.forcedMinimalWidth = 20;
            this._layoutInformation.forcedMinimalHeight = 20;
          }
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          this._iframeElement = this._element.getElementsByTagName('iframe')[0];
          this._iframeElement.on('load.WebComponentWidget', this._onLoad.bind(this));
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._delegatesKeyboard(false);
          try {
            this._webComponentWindow.gICAPI = null;
          } catch (e) {}
          this._webComponentWindow = null;
          this._iframeElement.off('load.WebComponentWidget');
          this._iframeElement = null;
          $super.destroy.call(this);
        },

        /**
         * Handler for onData when iframe is loaded
         * @private
         */
        _onReadyData: function() {
          if (this.value !== this._flushValue) {
            this._toICAPI('onData', this._value ? this._value : '');
          }
        },

        /**
         * Handler called once iframe has loaded its content
         * @private
         */
        _onLoad: function() {
          if (this.getUrl()) {
            if (this._webComponentType === 'api') {
              this._injectApi();
              this._delegatesKeyboard(true);
            } else if (this._webComponentType === 'url') {
              this.emit(context.constants.widgetEvents.change);
            }
            this._onReady();
          }
        },

        /**
         * Handler for onFocus when iframe is loaded
         * @private
         */
        _onReadyFocus: function() {
          if (this._uiWidget && this._uiWidget.getVMFocusedWidget() !== this) {
            this.emit(context.constants.widgetEvents.change);
            this._toICAPI('onFocus', false);
          } else {
            if (this._iframeElement !== document.activeElement) {
              this._toICAPI('onFocus', true);
            } else {
              this._toICAPI('onFocus', false);
            }
          }
        },

        /**
         * Handler for onBlur when iframe is loaded
         * @private
         */
        _onReadyBlur: function() {
          this.getValue();
          this.emit(context.constants.widgetEvents.blur);
          this._toICAPI('onFocus', false);
        },

        /**
         * OnStateChanged handler once iframe is ready
         * @param {boolean} active - form state
         * @param {string} dialogType - form display type (display, input ...)
         * @private
         */
        _onReadyStateChanged: function(active, dialogType) {
          this._toICAPI('onStateChanged', JSON.stringify({
            'active': parseInt(active),
            'dialogType': dialogType.toString()
          }));
        },

        /**
         * Set the property of the webcomponent
         * @param {string} property - stringified json object of properties
         * @private
         */
        _setProperty: function(property) {
          var pty = property;
          if (this._isReady) {
            this._toICAPI('onProperty', pty);
          } else {
            this.when(cls.WebComponentWidget.ready, this._onReadyProperty.bind(this, pty));
          }
        },

        /**
         * When the iframe is loaded handler
         * @private
         */
        _onReady: function() {
          this._isReady = true;
          this.emit(context.constants.widgetEvents.ready);
        },

        /**
         * onProperty handler once iframe is ready
         * @param {string} property - stringified json object of properties
         * @private
         */
        _onReadyProperty: function(property) {
          this._toICAPI('onProperty', property);
        },

        /**
         * Inject the API on the webcomponent
         * @returns {boolean} false if not applicable
         * @private
         */
        _injectApi: function() {
          //Add a new proxy for this webcomponent
          context.WebComponentService.setProxy(this.getUniqueIdentifier());
          this._webComponentProxy = context.WebComponentService.getProxy(this.getUniqueIdentifier());
          //Get the content of the iframe window to put api on
          this._webComponentWindow = this._iframeElement.contentWindow;

          // This try/catch statement is used to prevent IE to crash too early
          try {
            Function.noop(this._webComponentWindow.DocURL);
          } catch (e) {
            context.LogService.gICAPI.error('Webcomponent not found:', this._url);
            context.LogService.gICAPI.error('onICHostReady no present in webcomponent, cannot continue!');
            this.webComponentNotFound();
            return false;
          } // end IE fix

          try {
            this._webComponentWindow.gICAPIVersion = cls.WebComponentWidget.gICAPIVersion;
            // Bind WebComponent API to the iframe
            this._webComponentWindow.gICAPI = this._gICAPI();
            // Tell the WebComponent that host is ready
            if (this._webComponentWindow.onICHostReady) {
              this._webComponentWindow.onICHostReady('1.0');
            } else {
              context.LogService.gICAPI.error('onICHostReady no present in webcomponent, cannot continue!');
              this.webComponentNotFound();
              return false;
            }
          } catch (e) {
            this.error(e, true);
            return false;
          }
          this.emit(cls.WebComponentWidget.ready);
        },

        /**
         * Api object to bind to the webcomponent window.
         * It will be used inside the webcomponent to interact with the VM
         * @private
         */
        _gICAPI: function() {
          return {
            SetFocus: function() {
              // Generates a focus change request. The focus is entirely managed by the runtime system
              this._webComponentProxy.setFocus(this);
            }.bind(this),
            SetData: function(dataStr) {
              this._webComponentProxy.setData(this, dataStr);
            }.bind(this),
            Action: function(actionName) {
              this._webComponentProxy.action(this, actionName);
            }.bind(this),
            version: '1.0' // Legacy, but mostly not used
          };
        },

        /**
         * Delegate the keyboard management to GBC keyboard service (for accelerators and so)
         * @warning This works only if webcomponent is on the same domain as GBC application
         * @param {boolean} delegate - true to delegate it, false to let the webcomponent live by itself
         * @private
         */
        _delegatesKeyboard: function(delegate) {
          try {
            if (!this._webComponentWindow) {
              this._webComponentWindow = this._iframeElement.contentWindow;
            }
            if (delegate) {
              // If handler already exists, remove it before creating it again
              if (this._webComponentWindowKeyDown) {
                this._webComponentWindow.document.body.removeEventListener('keydown', this._webComponentWindowKeyDown);
              }
              // Define the keyDown handler
              this._webComponentWindowKeyDown = function(evt) {
                this.emit(gbc.constants.widgetEvents.webcomponentKeyDown, evt);
              }.bind(this);
              // Bind the iframe keyDown event to the keyDown handler
              this._webComponentWindow.document.body.addEventListener('keydown', this._webComponentWindowKeyDown);
            } else {
              if (this._webComponentWindowKeyDown) {
                this._webComponentWindow.document.body.removeEventListener('keydown', this._webComponentWindowKeyDown);
                this._webComponentWindowKeyDown = null;
              }
            }
          } catch (error) {
            context.LogService.gICAPI.warn("Can not use GBC accelerators in a cross-domain Webcomponents (" + this._url + ")");
          }
        },

        /**
         * Function to transmit gICAPI orders to webcomponent
         * @param {string} verb - onData, onProperty, onChangeState, onFlushData
         * @param {string=} args - arguments passed to the gICAPI if any
         * @private
         */
        _toICAPI: function(verb, args) {
          try {
            var arg = args;
            if (verb === 'onData' && arg === null) {
              arg = [null];
            } else {
              if (!arg && arg !== false && arg !== '' && arg !== 0) {
                arg = [];
              }
              if (arg.prototype !== Array) {
                arg = [arg];
              }
            }
            if (this._webComponentWindow && this._webComponentWindow.gICAPI && this._webComponentWindow.gICAPI[verb]) {
              this._webComponentWindow.gICAPI[verb].apply(this._webComponentWindow.gICAPI, arg);
              if (verb === "onFlushData") {
                this._flushingData = false;
              }
            }
          } catch (e) {
            this.error(e);
          }
        },

        /**
         * Handler to execute a function only once the component is ready
         * @param callback
         * @protected
         */
        _onReadyExecute: function(callback) {
          if (this._isReady) {
            callback();
          } else {
            this.when(cls.WebComponentWidget.ready, function() {
              callback();
            }.bind(this));
          }
        },

        /**
         * @inheritDoc
         */
        managePriorityKeyDown: function(keyString, domKeyEvent, repeat) {
          if (keyString === "home" || keyString === "end") {
            return false; // consider home/end key as not processed to keep default from webcomponent
          } else {
            return $super.managePriorityKeyDown.call(this, keyString, domKeyEvent, repeat);
          }
        },

        /**
         * Report an error in webcomponent
         * @param e - error object
         * @param {boolean} stop - will stop the application if true
         */
        error: function(e, stop) {
          context.LogService.gICAPI.error(i18next.t('gwc.app.webcompError.message'));
          context.LogService.gICAPI.error(">>> " + ': ' + e.toString(), e);
          if (this._stopOnError || stop) {
            this.webComponentNotFound(i18next.t('gwc.app.webcompError.message') + ' : "' + e.toString() +
              '"--> see console for more details');
          } else {
            var errorLayer = document.createElement("div");
            var errorStyle =
              'position: fixed;top: 0; color: #721c24; background-color: #f8d7da;border-color: #f5c6cb;border: 1px solid; padding: 10px; border-radius: .25rem;';
            errorLayer.innerHTML = '<b>' + i18next.t('gwc.app.webcompError.message') + ' :</b> <i>' + e.toString() +
              '</i><br> See console for more info';
            errorLayer.setAttribute("style", errorStyle);
            errorLayer.addEventListener("click", function() {
              this.setAttribute("style", "display:none;");
            });
            this._webComponentWindow.document.querySelector("body").appendChild(errorLayer);
          }
        },

        /**
         *@inheritDoc
         */
        setFocus: function(fromMouse) {
          if (this._isReady) {
            this._iframeElement.domFocus(); //force focus to blur other elements
            this._toICAPI('onFocus', true);
          } else {
            this.when(cls.WebComponentWidget.ready, this._onReadyFocus.bind(this));
          }
          $super.setFocus.call(this, fromMouse);
        },

        hasDOMFocus: function() {
          return document.activeElement === this._iframeElement;
        },

        /**
         * Tell the WebComponent that typeahead lost the Focus on it
         * @publicdoc
         */
        loseFocus: function() {
          $super.loseFocus.call(this);
          this._onReadyExecute(function() {
            this._onReadyBlur();
          }.bind(this));
        },

        /**
         * Called when the WC formfield's state has changed
         * @param {boolean} active - form state
         * @param {string} dialogType - form display type (display, input ...)
         * @publicdoc
         */
        onStateChanged: function(active, dialogType) {
          this._onReadyExecute(function() {
            this._onReadyStateChanged(active, dialogType);
          }.bind(this));
        },

        /**
         * Defines the address of the WebComponent
         * @param {string} url - address
         * @publicdoc
         */
        setUrl: function(url) {
          this._url = url;
          url = url ? url : 'about:blank';
          this._iframeElement.setAttribute('src', url);
        },

        /**
         * Get the address of the WebComponent
         * If the webcomponent is url based, it will work only if url is on same domain as application
         * @returns {string} address of the webcomponent
         */
        getUrl: function() {
          var url = this._iframeElement.getAttribute('src') || this._url;
          var contentUrl = false;
          if (this._webComponentType === 'url') {
            try {
              contentUrl = this._iframeElement.contentWindow && this._iframeElement.contentWindow.location.href;
            } catch (e) {
              contentUrl = false;
            }
          }
          return contentUrl ? contentUrl : url;

        },

        /**
         * Set the WebComponent value
         * @param {string} value -value of the webcomponent, will be the url of it if WebComp is urlType
         * @param {boolean} fromVM - flag to define if value comes from the VM
         * @publicdoc
         */
        setValue: function(value, fromVM) {
          var empty = value === '';
          // Value should be a string to fit GDC/VM specs
          if (typeof value !== 'string') {
            value = JSON.stringify(value);
          }
          this._value = value;
          if (this._webComponentType === 'url') {
            this.setUrl(empty ? '' : value);
          } else {
            this._onReadyExecute(function() {
              this._toICAPI('onData', this._value ? this._value : '');
            }.bind(this));
          }
        },

        /**
         * Get The value of the webComponent
         * @returns {string} value or url of the webcomponent
         */
        getValue: function() {
          this.flushWebcomponentData();
          var result = this._webComponentType === 'api' ? this._flushValue ? this._flushValue : this._value : this.getUrl();
          this._flushValue = null; // reset value
          return result;
        },

        /**
         * Define the type of component
         * @param {string} type - should be 'api' or 'url'
         */
        setWebComponentType: function(type) {
          this._webComponentType = type;
        },

        /**
         * Get the type of component
         * @return {?string} type - should be 'api' or 'url'
         */
        getWebComponentType: function() {
          return this._webComponentType;
        },

        /**
         * Force webcomponent to get data
         * @public
         */
        flushWebcomponentData: function() {
          if (!this._flushingData) {
            this._flushingData = true;
            this._toICAPI('onFlushData');
          }
        },

        /**
         * Stop VMApplication with a message
         * @param {string=} message - message to give to the app close (default is defined in locales)
         * @public
         */
        webComponentNotFound: function(message) {
          if (!context.bootstrapInfo.ignoreWebComponentFails) {
            //VMApplication stop with a message
            var currentApp = gbc.SessionService.getCurrent() && gbc.SessionService.getCurrent().getCurrentApplication();
            if (currentApp) {
              currentApp.fail(message ? message : i18next.t('gwc.app.webcompNotFound.message'));
            }
          }
        }
      };
    });
    cls.WidgetFactory.registerBuilder('WebComponent', cls.WebComponentWidget);
  });
;
"use strict";

modulum('HtmlFilterWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     *  Widget used to filter html document values
     * @class HtmlFilterWidget
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.HtmlFilterWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.HtmlFilterWidget.prototype */ {
        __name: "HtmlFilterWidget",

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          this._options = {
            filterScript: true,
            filterStyle: true,
            filterHead: true
          };

        },

        /**
         * Sanitize HTML
         * @param {string} html to sanitize
         * @return {string} - the html string corresponding to the body content only
         */
        filterHtml: function(html) {
          var filtered = html;
          try {
            // load html into iframe
            var iframe = document.createElement('iframe');
            document.body.appendChild(iframe);
            iframe.contentWindow.document.open();
            iframe.contentWindow.document.write(html);
            iframe.contentWindow.document.close();
            filtered = iframe.contentDocument.body.innerHTML;
            document.body.removeChild(iframe);
          } catch (ex) {
            filtered = "HTML cannot be sanitized";
          }
          return filtered;
        }

      };
    });
    cls.WidgetFactory.registerBuilder('HtmlFilterWidget', cls.HtmlFilterWidget);

  });
;
"use strict";

modulum('FlowDecoratorWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {
    /**
     * Widget to handle overflowing items in a dropdown
     * @memberOf classes
     * @extends classes.WidgetBase
     * @publicdoc Widgets
     */
    cls.FlowDecoratorWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.FlowDecoratorWidget.prototype */ {
        __name: "FlowDecoratorWidget",

        /** @type {classes.WidgetBase[]} */
        _overflowWidgets: null,

        /** @type {classes.DropDownWidget} */
        _dropDown: null,

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          this._layoutInformation = new cls.LayoutInformation(this);
          this._layoutEngine = new cls.FlowItemLayoutEngine(this);
        },

        /**
         * @inheritDoc
         */
        constructor: function(opt) {
          $super.constructor.call(this, opt);
          this._overflowWidgets = [];
          this._dropDown = cls.WidgetFactory.createWidget('DropDown', this.getBuildParameters());
          this._dropDown.addClass("gbc_FlowingDropDown");
          this._dropDown.reverseX = true;
        },

        /**
         * @inheritDoc
         */
        setParentWidget: function(widget, options) {
          $super.setParentWidget.call(this, widget, options);
          this._dropDown.setParentWidget(widget);
          this._dropDown.shouldClose = function(targetElement) {
            var isParentChild = targetElement.isElementOrChildOf(widget.getElement());
            return !isParentChild;
          };
        },

        /**
         * Defines the orientation of the dropdown
         * @param {String} orientation - can be "horizontal" or "vertical"
         */
        setOrientation: function(orientation) {
          this._dropDown.addClass("gbc_orientation_" + orientation);
        },

        /**
         * Defines the rendering of the dropdown
         * @param {String} rendering - can be "list" or "buttons"
         */
        setRendering: function(rendering) {
          this._dropDown.addClass("gbc_rendering_" + rendering);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          if (this._dropDown && this._dropDown.isVisible()) {
            this.closeDropDown();
          } else {
            this.openDropDown();
          }
          return true;
        },

        /**
         * Show the dropdown with flowing items
         */
        openDropDown: function() {
          this._dropDown.show();
        },

        /**
         * Hide the dropdown with flowing items
         */
        closeDropDown: function() {
          this._dropDown.hide();
        },

        /**
         * Flow a given child widget
         * @param {classes.WidgetBase} widget - widget to add to the dropdown
         * @param {boolean} flowing true to add to the dropdown, false to put it back to the toolbar
         */
        flowChild: function(widget, flowing) {
          var opt = {};

          if (flowing) {
            opt.ordered = true;
            this._dropDown.adoptChildWidget(widget, opt);
            widget.when(context.constants.widgetEvents.click, function() {
              this._dropDown.hide();
            }.bind(this));
          } else {

            this.getParentWidget().adoptChildWidget(widget, opt);
          }
          if (this._dropDown.getChildren().length <= 0) {
            this.enable(false);
          }
        },

        /**
         * Get a copy of flowing children
         * @return {classes.WidgetBase[]}
         */
        getFlowingChildren: function() {
          return this._dropDown.getChildren().slice(0);
        },

        /**
         * Enable the flowing mechanism by displaying it
         * @param {Boolean} enabled - true to activate it, false to de-activate
         */
        enable: function(enabled) {
          this.setHidden(!enabled);
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          $super.destroy.call(this);
          if (this._dropDown) {
            this._dropDown.destroy();
            this._dropDown = null;
          }
        },

      };
    });
    cls.WidgetFactory.registerBuilder('FlowDecorator', cls.FlowDecoratorWidget);

  });
;
"use strict";

modulum('ScrollAreaWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * ScrollArea Widget.
     * Use to catch scrolling event and forward them to a Matrix
     * @class ScrollAreaWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     */
    cls.ScrollAreaWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.ScrollAreaWidget.prototype */ {
        __name: "ScrollAreaWidget",

        _size: 0,
        _pageSize: 0,
        _lineHeight: 15,

        _totalHeight: 0,

        //ThinScroll vars
        _displayTime: null,
        _mouseIsOver: false,
        _thinTimer: null,
        _scrollbar: null,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);

          this._element.on("wheel.ScrollAreaWidget", this._onWheel.bind(this));

          var body = document.getElementsByTagName("body")[0];
          // Using getRootClassName() to qualify event for easier removal on destroy, since we bind it on 'body'
          body.on("touchstart.ScrollAreaWidget." + this.getRootClassName(), this._onTouchStart.bind(this));
          body.on("touchend.ScrollAreaWidget." + this.getRootClassName(), this._onTouchEnd.bind(this));
          body.on("touchmove.ScrollAreaWidget." + this.getRootClassName(), this._onTouchMove.bind(this));

          this._scrollbar = cls.WidgetFactory.createWidget("ScrollBar", this.getBuildParameters());
          this._scrollbar.display(true);
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._element.off("wheel.ScrollAreaWidget");

          var body = document.getElementsByTagName("body")[0];
          body.off("touchstart.ScrollAreaWidget." + this.getRootClassName());
          body.off("touchend.ScrollAreaWidget." + this.getRootClassName());
          body.off("touchmove.ScrollAreaWidget." + this.getRootClassName());

          this._scrollbar.destroy();
          $super.destroy.call(this);
        },

        /**
         * On wheel handler
         * @param {UIEvent} event
         * @private
         */
        _onWheel: function(event) {
          this.emit(context.constants.widgetEvents.mousewheel, event);
          //event.preventCancelableDefault(); // Not allowed since passive:true
          event.stopPropagation();
          event.stopImmediatePropagation();
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {

          var gridElement = this._element.parent("g_GridElement");
          // Hide the scrollArea layer
          gridElement.addClass("hidden");
          // Create a click event that will be triggered to the div beyond
          var target = document.elementFromPoint(domEvent.clientX, domEvent.clientY);
          // Focus event is needed to trigger a VM focus request (InputArray)
          var event = document.createEvent('HTMLEvents');
          event.initEvent('focus', true, false);
          target.dispatchEvent(event);
          // Click event is needed to trigger a VM row selection event (DisplayArray)
          event = document.createEvent('HTMLEvents');
          event.initEvent('click', true, false);
          target.dispatchEvent(event);
          // Show back the scrollArea layer
          gridElement.removeClass("hidden");

          return false;
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          this._layoutInformation = new cls.LayoutInformation(this);
          this._layoutEngine = new cls.LeafLayoutEngine(this);
          this._layoutEngine._shouldFillHeight = true;
          this.getLayoutInformation()._extraGap = {
            afterX: window.scrollBarSize
          };

          if (this._scrollbar) {
            // position scrollbar according to scrollarea widget
            this._layoutInformation.onGridInfoChanged(function() {
              var scrollAreaLayoutInfo = this.getLayoutInformation();
              var scrollBarLayoutInfo = this._scrollbar.getLayoutInformation();
              scrollBarLayoutInfo.setGridX(scrollAreaLayoutInfo.getGridX() + scrollAreaLayoutInfo.getGridWidth() - 1);
              scrollBarLayoutInfo.setGridY(scrollAreaLayoutInfo.getGridY());
              scrollBarLayoutInfo.setGridWidth(1);
              scrollBarLayoutInfo.setGridHeight(scrollAreaLayoutInfo.getGridHeight());
            }.bind(this));

          }
        },

        /**
         * Handler called when start to touch the screen
         * @param {UIEvent} event - dom touch event
         * @private
         */
        _onTouchStart: function(event) {
          if (this.isTouchEventInScrollArea(event)) {
            this.emit(context.constants.widgetEvents.touchStart, event);
          }
        },

        /**
         * Handler called when stop touching the screen
         * @param {UIEvent} event - dom touch event
         * @private
         */
        _onTouchEnd: function(event) {
          this.emit(context.constants.widgetEvents.touchEnd, event);
        },

        /**
         * Handler called on moving finger on screen
         * @param {UIEvent} event - dom touch event
         * @private
         */
        _onTouchMove: function(event) {
          if (this.isTouchEventInScrollArea(event)) {
            this.emit(context.constants.widgetEvents.touchMove, event);
          }
        },

        /**
         * Check if the given event is located in the scroll area
         * Note that scrollbar is removed from the scrolling area
         * @param {UIEvent} event - dom touch event
         * @return {boolean}
         */
        isTouchEventInScrollArea: function(event) {
          var rect = this._element.getBoundingClientRect();
          var sbRect = this._scrollbar.getElement().getBoundingClientRect();
          return event.touches[0].clientY > rect.top &&
            event.touches[0].clientY < rect.top + rect.height &&
            event.touches[0].clientX > rect.left &&
            event.touches[0].clientX < rect.left + rect.width - sbRect.width;
        },

        /**
         * Get the scroll Widget
         * @return {classes.ScrollAreaWidget}
         */
        getScrollWidget: function() {
          return this;
        },

        /**
         * @inheritDoc
         */
        setParentWidget: function(widget, options) {
          $super.setParentWidget.call(this, widget, options);
          if (this._scrollbar && widget) {
            widget.addChildWidget(this._scrollbar);
            this._scrollbar.setScrollArea(this);
          }
        },

        /**
         * Define the total size of the scrollArea
         * @param size
         */
        setSize: function(size) {
          if (size !== this._size) {
            this._size = size;
            this.setTotalHeight(this._lineHeight * this._size);
            if (this._scrollbar) {
              this._scrollbar.setSize(size);
            }
          }
        },

        /**
         * Define the page size of the scrollArea
         * @param pageSize
         */
        setPageSize: function(pageSize) {
          if (this._pageSize !== pageSize) {
            this._pageSize = pageSize;
            var lineHeight = this._element.clientHeight / pageSize;
            this.setLineHeight(lineHeight);
            if (this._scrollbar) {
              this._scrollbar.setPageSize(pageSize);
            }
          }
        },

        /**
         * Set the offset of the scrollArea
         * @param offset
         */
        setOffset: function(offset) {
          this._offset = offset;
          if (this._scrollbar) {
            this._scrollbar.setOffset(offset);
          }
        },

        /**
         * Set the line height
         * @param lineHeight
         */
        setLineHeight: function(lineHeight) {
          this._lineHeight = lineHeight;
          if (this._scrollbar) {
            this._scrollbar.setLineHeight(lineHeight);
          }
        },

        /**
         * Will set the total height of the scrollArea
         * @param {number} height total
         */
        setTotalHeight: function(height) {
          if (!this.isEnabled()) {
            height = 0;
          }
          this.setStyle(".spacer", {
            "height": Math.max(0, height) + "px"
          });
          this._totalHeight = Math.max(0, height);
          if (this._scrollbar) {
            this._scrollbar.setTotalHeight(this._totalHeight);
          }
        },

        /**
         * Defines the scroll area to use thinscrollbar
         * @param {number} displayTime - in second, how long the scrollbar is displayed 0 is always visible, -1 is never
         */
        setThinScrollbar: function(displayTime) {
          this.getLayoutInformation()._extraGap = {
            afterX: 0
          };

          this.addClass("thinScrollBar");
          // get grid parent
          this._displayTime = displayTime;
          this._scrollbar.setDisplayTime(displayTime);
        },

        /**
         * Defines the enabled status of the widget
         * @param {boolean} enabled true if the widget allows user interaction, false otherwise.
         * @publicdoc
         */
        setEnabled: function(enabled) {
          $super.setEnabled.call(this, enabled);
          this._scrollbar.setEnabled(enabled);
        }

      };
    });
    cls.WidgetFactory.registerBuilder('ScrollArea', cls.ScrollAreaWidget);
  });
;
"use strict";

modulum('ScrollBarWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Thin ScrollBar Widget.
     * @class ScrollBarWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     */
    cls.ScrollBarWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.ScrollBarWidget.prototype */ {
        __name: "ScrollBarWidget",
        _scrollArea: null,
        _totalHeight: 0,
        _thumbHeight: 0,
        _displayTime: 1, // default as defined in genero doc
        _displayTimer: null,
        _mouseDown: false,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          this._thumbElement = this._element.querySelector(".thumb");

          var dragDropManager = this._dragDropManager.bind(this);
          this._element.on('mousedown.scrollBarWidget', dragDropManager);
          this._element.on('touchstart.scrollBarWidget', dragDropManager);

          this._element.on("mouseover.scrollBarWidget", this._mouseMove.bind(this));
          this._thumbElement.on("mouseover.scrollBarWidget", this._mouseMove.bind(this));
          this._element.on("mouseleave.scrollBarWidget", this._mouseLeave.bind(this));
          this._thumbElement.on("mouseleave.scrollBarWidget", this._mouseLeave.bind(this));
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          this._layoutInformation = new cls.LayoutInformation(this);
          this._layoutEngine = new cls.LeafLayoutEngine(this);
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._onDrop();
          this._element.off("mousedown.scrollBarWidget");
          this._element.off("touchstart.scrollBarWidget");

          this._element.off("mouseover.scrollBarWidget");
          this._thumbElement.off("mouseover.scrollBarWidget");
          this._element.off("mouseleave.scrollBarWidget");
          this._thumbElement.off("mouseleave.scrollBarWidget");
          $super.destroy.call(this);
        },

        /**
         * Define the thumb height
         * @param {Number} height - total height in px
         * @private
         */
        _setThumbHeight: function(height) {
          this._thumbHeight = height;
          this._thumbElement.style.height = height + "px";
        },

        /**
         * Define the thumb position
         * @param {Number} top - distance from top in px
         * @private
         */
        _setThumbPosition: function(top) {
          // Keep thumb into view
          var max = this._element.clientHeight - this._thumbHeight;
          top = top >= 0 && top < max ? top : top >= max ? max : 0;
          this._thumbElement.style.top = top + "px";
        },

        /**
         * Handler called when the mouse is mooving over the scrollbar
         * @private
         */
        _mouseMove: function() {
          this.display(true);
        },

        /**
         * Handler called when the mouse is leaving the scrollbar
         * @private
         */
        _mouseLeave: function() {
          if (this._displayTime > 0) {
            this.display(false);
          }
        },

        /**
         * Once you start dragging the scrollbar
         * @param ctx
         * @returns {boolean}
         * @private
         */
        _dragDropManager: function(ctx) {
          this._element.classList.add('ss-grabbed');
          document.body.classList.add('ss-grabbed');

          var drag = this._onDrag.bind(this);
          var drop = this._onDrop.bind(this);

          document.body.on('mousemove.scrollBarWidget', drag);
          document.body.on('mouseup.scrollBarWidget', drop);
          document.body.on('touchmove.scrollBarWidget', drag);
          document.body.on('touchend.scrollBarWidget', drop);

          return false;
        },

        /**
         * Scrollbar moving
         * @param e
         * @private
         */
        _onDrag: function(e) {
          this.afterDomMutator(function() {
            e = e.touches ? e.touches[0] : e;
            this._mouseDown = true;
            var newPos = e.pageY - this._element.getClientRects()[0].top - (this._thumbHeight / 2);
            this._setThumbPosition(newPos);

            var size = this._size;
            var pageSize = this._pageSize;
            var thumbTop = parseInt(this._thumbElement.style.top, 10);
            // Take thumb height into account
            var total = parseInt(this._element.clientHeight - this._thumbHeight, 10);
            var thumbRatio = ((thumbTop) / (total));

            // offset should be >= 0
            var maxOffset = (size - pageSize) < 0 ? 0 : size - pageSize;

            //need to update the VM position as well
            var requestedOffset = parseInt(maxOffset * thumbRatio, 10);
            if (requestedOffset >= 0) {
              e.forceOffset = requestedOffset;
              this._scrollArea.emit(context.constants.widgetEvents.scroll, e);
            }
          }.bind(this));
        },

        /**
         * Stop dragging the scrollbar
         * @private
         */
        _onDrop: function() {
          this._mouseDown = false;
          this._element.classList.remove('ss-grabbed');
          document.body.classList.remove('ss-grabbed');
          document.body.off('mousemove.scrollBarWidget');
          document.body.off('mouseup.scrollBarWidget');
          document.body.off('touchmove.scrollBarWidget');
          document.body.off('touchend.scrollBarWidget');
        },

        /**
         * Set delay before hiding the scrollBar
         * @param {number} delay in second
         */
        setDisplayTime: function(delay) {
          this._displayTime = delay;
        },

        /**
         * Show or hide the scrollBar
         * @param {boolean} displayed true:visible, false: hidden
         * @param {boolean=} instant force the delay to 0 if true
         */
        display: function(displayed, instant) {
          if (this._displayTime < 0) {
            this.addClass("thinScrollbar-vanished");
            displayed = false;
          }

          var delay = instant ? 0 : this._displayTime ? this._displayTime : 0;
          if (!displayed) {
            this._displayTimer = this._registerTimeout(function() {
              this._displayTimer = null;
              if (this.isEnabled()) { // Do not vanish if not enabled
                this.addClass("thinScrollbar-vanished");
              }
            }.bind(this), delay * 1000);
          } else {
            if (this._displayTimer) {
              this._clearTimeout(this._displayTimer);
              this._displayTimer = null;
            }
            this.removeClass("thinScrollbar-vanished");
          }
        },

        /**
         * Define the linked scrollArea
         * @param {widget} widget
         */
        setScrollArea: function(widget) {
          this._scrollArea = widget;
        },

        /**
         * Total height of the scrollArea
         * @param {number} height in pixels
         */
        setTotalHeight: function(height) {
          this._totalHeight = height;
        },

        /**
         * Set the line height used for calculations
         * @param {Number} lineHeight
         */
        setLineHeight: function(lineHeight) {
          this._lineHeight = lineHeight;
          this._setThumbHeight(lineHeight);
        },

        /**
         * Set the total of element in scroll (linked to scrollArea)
         * @param {number} size
         */
        setSize: function(size) {
          this._size = size;
        },

        /**
         * Set the number of element in scroll Page (linked to scrollArea)
         * @param {number} pageSize
         */
        setPageSize: function(pageSize) {
          this._pageSize = pageSize;
        },

        /**
         * Set the current offset (linked to scrollArea)
         * @param {number} offset
         */
        setOffset: function(offset) {
          this.display(true);
          this._offset = offset;
          if (this._lineHeight) {
            var maxPos = this._element.clientHeight - this._thumbHeight;
            var maxOffset = this._size - this._pageSize;
            var pos = (offset * maxPos) / maxOffset;
            this._setThumbPosition(pos);
          }
          if (this._displayTime > 0) {
            this.display(false);
          }
        }
      };
    });
    cls.WidgetFactory.registerBuilder('ScrollBar', cls.ScrollBarWidget);
  });
;
"use strict";

modulum('ScrollTabDecorator',
  function(context, cls) {
    /**
     * Add scroll tab mechanism to widget elements
     * @class ScrollTabDecorator
     * @memberOf classes
     */
    cls.ScrollTabDecorator = context.oo.Class(function($super) {
      return /** @lends classes.ScrollTabDecorator.prototype */ {
        __name: "ScrollTabDecorator",

        _tabsHost: null,
        _tabsTitlesBar: null,
        _tabsTitlesHost: null,
        _tabsTitlesElement: null,
        _previousScroller: null,
        _nextScroller: null,
        _leftScrollInterval: null,
        _rightScrollInterval: null,
        _offsetPos: "offsetLeft",
        _offsetSize: "offsetWidth",
        _scrollPos: "scrollLeft",
        _scrollStep: 6,
        _scrollToId: 0,
        _refreshScrollersId: 0,

        _position: "top",
        _scrollerPosition: 0,

        _scrollSpeed: 10,
        _scrollClickOnly: false,
        _mouseDownStatus: false,

        /**
         * Initializes the scrollTab object. You need to provide a widget instance which will be instrumented
         * @param widget the widget to handle
         */
        constructor: function(widget) {
          $super.constructor.call(this);
          this._widget = widget;

          if (window.isMobile()) {
            this._widget.addClass("compact");
          }

          this._tabsHost = this._widget.getElement().getElementsByClassName("mt-tabs")[0];
          this._tabsTitlesBar = this._widget.getElement().getElementsByClassName("mt-tab-titles-bar")[0];
          this._tabsTitlesHost = this._widget.getElement().getElementsByClassName("mt-tab-titles")[0];
          this._tabsTitlesElement = this._widget.getElement().getElementsByClassName("mt-tab-titles-container")[0];
          this._previousScroller = this._widget.getElement().getElementsByClassName("mt-tab-previous")[0];
          this._nextScroller = this._widget.getElement().getElementsByClassName("mt-tab-next")[0];

          this._widget.getElement().on("mouseover.FolderWidget", function() {
            this.refreshScrollers();
            this._widget.getElement().off("mouseover.FolderWidget");
          }.bind(this));

          this._previousScroller
            .on("mouseover.FolderWidget", this._beginScrollTabsLeft.bind(this))
            .on("mousedown.FolderWidget", this._beginScrollTabsLeft.bind(this))
            .on("mouseout.FolderWidget", this._endScrollTabsLeft.bind(this))
            .on("mouseup.FolderWidget", this._endScrollTabsLeft.bind(this));

          this._nextScroller
            .on("mouseover.FolderWidget", this._beginScrollTabsRight.bind(this))
            .on("mousedown.FolderWidget", this._beginScrollTabsRight.bind(this))
            .on("mouseup.FolderWidget", this._endScrollTabsRight.bind(this))
            .on("mouseout.FolderWidget", this._endScrollTabsRight.bind(this));

          if (window.isTouchDevice()) {
            if (this._tabsTitlesBar) {
              this._tabsTitlesBar.on("touchstart.scrolltab", this._startTouchScroll.bind(this));
              this._tabsTitlesBar.on("touchend.scrolltab", this._endTouchScroll.bind(this));
              this._tabsTitlesBar.on("touchmove.scrolltab", this._touchMove.bind(this));
            } else if (this._tabsTitlesElement) {
              this._tabsTitlesElement.on("touchstart.scrolltab", this._startTouchScroll.bind(this));
              this._tabsTitlesElement.on("touchend.scrolltab", this._endTouchScroll.bind(this));
              this._tabsTitlesElement.on("touchmove.scrolltab", this._touchMove.bind(this));
            }
          }
          this._scrollSpeed = parseInt(context.ThemeService.getValue("theme-scrollers-speed"), 10);
          this._scrollClickOnly = context.ThemeService.getValue("theme-scrollers-clickonly");
          this._scrollClickOnly = this._scrollClickOnly === true || this._scrollClickOnly === "true";

        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._widget.getElement().off("mouseover.FolderWidget");

          this._previousScroller.off("mouseover.FolderWidget");
          this._previousScroller.off("mousedown.FolderWidget");
          this._previousScroller.off("mouseout.FolderWidget");
          this._previousScroller.off("mouseup.FolderWidget");
          this._nextScroller.off("mouseover.FolderWidget");
          this._nextScroller.off("mousedown.FolderWidget");
          this._nextScroller.off("mouseup.FolderWidget");
          this._nextScroller.off("mouseout.FolderWidget");

          if (this._scrollToId) {
            window.cancelAnimationFrame(this._scrollToId);
            this._scrollToId = 0;
          }
          if (this._refreshScrollersId) {
            window.cancelAnimationFrame(this._refreshScrollersId);
            this._refreshScrollersId = 0;
          }

          this._endScrollTabsLeft();
          this._endScrollTabsRight();

          if (window.isTouchDevice()) {
            if (this._tabsTitlesBar) {
              this._tabsTitlesBar.off("touchstart.scrolltab");
              this._tabsTitlesBar.off("touchend.scrolltab");
              this._tabsTitlesBar.off("touchmove.scrolltab");
            }
            if (this._tabsTitlesElement) {
              this._tabsTitlesElement.off("touchstart.scrolltab");
              this._tabsTitlesElement.off("touchend.scrolltab");
              this._tabsTitlesElement.off("touchmove.scrolltab");
            }
          }
          this._tabsHost = null;
          this._tabsTitlesBar = null;
          this._tabsTitlesHost = null;
          this._tabsTitlesElement = null;
          this._previousScroller = null;
          this._nextScroller = null;
          this._widget = null;
        },

        /**
         * Method to scroll titles to the Left
         * @param event
         * @private
         */
        _beginScrollTabsLeft: function(event) {

          // If click only, quit if event is not a click
          if (this._scrollClickOnly && event.type !== "mousedown") {
            event.preventCancelableDefault();
            event.stopImmediatePropagation();
            event.stopPropagation();
            return;
          }

          // Do the actual scrolling to the left
          var scrollLeft = function(st) {
            var scroll = st._tabsTitlesHost[st._scrollPos];
            if (scroll > 0) {
              st._tabsTitlesHost[st._scrollPos] = scroll = scroll - st._scrollStep;
            }
            if (scroll <= 0) {
              st._previousScroller.removeClass("overflown-previous");
              st._endScrollTabsLeft();
            } else {
              st._previousScroller.addClass("overflown-previous");
            }
            st._nextScroller.toggleClass("overflown-next",
              scroll + st._tabsTitlesHost[st._offsetSize] < st._tabsTitlesElement[st._offsetSize]
            );
          };

          scrollLeft(this);

          // If we keep mouse over the scroller (or clicked), continue scrolling according to the speed
          if (!this._leftScrollInterval) {
            this._leftScrollInterval = window.setInterval(function() {
              scrollLeft(this);
            }.bind(this), this._scrollSpeed);
          }
        },

        /**
         * Clear the scrolling to the left
         * @private
         */
        _endScrollTabsLeft: function() {
          if (!!this._leftScrollInterval) {
            window.clearInterval(this._leftScrollInterval);
            this._leftScrollInterval = null;
          }
        },

        /**
         * Method to scroll titles to the Right
         * @param event
         * @private
         */
        _beginScrollTabsRight: function(event) {

          if (this._scrollClickOnly && event.type !== "mousedown") {
            event.preventCancelableDefault();
            event.stopImmediatePropagation();
            event.stopPropagation();
            return;
          }

          // Do the actual scrolling to the right
          var scrollRight = function(st) {
            var scroll = st._tabsTitlesHost[st._scrollPos],
              now;
            st._tabsTitlesHost[st._scrollPos] = scroll + st._scrollStep;
            if ((now = st._tabsTitlesHost[st._scrollPos]) <= scroll) {
              st._nextScroller.removeClass("overflown-next");
              st._endScrollTabsRight();
            } else {
              st._nextScroller.addClass("overflown-next");
            }
            st._previousScroller.toggleClass("overflown-previous", now > 0);
          };

          scrollRight(this);

          // If we keep mouse over the scroller (or clicked), continue scrolling according to the speed
          if (!this._rightScrollInterval) {
            this._rightScrollInterval = window.setInterval(function() {
              scrollRight(this);
            }.bind(this), this._scrollSpeed);
          }
        },

        /**
         * Clear the scrolling to the right
         * @private
         */
        _endScrollTabsRight: function() {
          if (!!this._rightScrollInterval) {
            window.clearInterval(this._rightScrollInterval);
            this._rightScrollInterval = null;
          }
        },

        /**
         * Ensure the display state of the scrolling arrows
         */
        refreshScrollers: function() {
          if (this._refreshScrollersId) {
            window.cancelAnimationFrame(this._refreshScrollersId);
          }
          this._refreshScrollersId = window.requestAnimationFrame(function() {
            this._refreshScrollersId = 0;
            if (this._tabsTitlesHost) {
              var scroll = this._tabsTitlesHost[this._scrollPos];
              this._nextScroller.toggleClass("overflown-next",
                scroll + this._tabsTitlesHost[this._offsetSize] < this._tabsTitlesElement[this._offsetSize]
              );
              this._previousScroller.toggleClass("overflown-previous", scroll > 0);
            }
          }.bind(this));
        },

        /**
         * Display or not the scrollers
         * @param display
         */
        showScroller: function(display) {
          if (display) {
            this._previousScroller.removeClass("vanished");
            this._nextScroller.removeClass("vanished");
          } else {
            this._previousScroller.addClass("vanished");
            this._nextScroller.addClass("vanished");
          }
        },

        /**
         * Scroll the title bar to see the given element
         * @param {classes.PageWidget} element
         */
        scrollTo: function(element) {
          if (this._scrollToId) {
            window.cancelAnimationFrame(this._scrollToId);
          }
          this._scrollToId = window.requestAnimationFrame(function() {
            this._scrollToId = 0;
            if (element) {
              var scroll = this._tabsTitlesHost[this._scrollPos];
              var titleLeft = element[this._offsetPos],
                titleWidth = element[this._offsetSize],
                hostWidth = this._tabsTitlesHost[this._offsetSize],
                deltaLeft = titleLeft - scroll;
              if ((deltaLeft) < 0 || (deltaLeft + titleWidth) > hostWidth) {
                this._tabsTitlesHost[this._scrollPos] = titleLeft;
              }
            }
            this.refreshScrollers();
          }.bind(this));
        },

        /**
         *
         * @param position
         * @private
         */
        _updateOffset: function(position) {
          switch (position) {
            case "top":
            case "bottom":
              this._offsetPos = "offsetLeft";
              this._offsetSize = "offsetWidth";
              this._scrollPos = "scrollLeft";
              this._scrollStep = 6;
              break;
            case "left":
            case "right":
              this._offsetPos = "offsetTop";
              this._offsetSize = "offsetHeight";
              this._scrollPos = "scrollTop";
              this._scrollStep = 2;
              break;
          }
        },

        /**
         * Set the tabs position
         * @param {string} tag - tag of the item
         * @param {string} position - could be top, right, bottom or left
         * @publicdoc
         */
        updatePosition: function(tag, position) {
          this._position = position;
          if (this._tabsHost) {
            this._tabsHost.setAttribute(tag, position);
          }
          if (this._tabsTitlesBar) {
            this._tabsTitlesBar.setAttribute(tag, position);
          }
          if (this._tabsTitlesHost) {
            this._tabsTitlesHost.setAttribute(tag, position);
          }
          if (this._tabsTitlesElement) {
            this._tabsTitlesElement.setAttribute(tag, position);
          }
          if (this._previousScroller) {
            this._previousScroller.setAttribute(tag, position);
          }
          if (this._nextScroller) {
            this._nextScroller.setAttribute(tag, position);
          }

          this._updateOffset(position);
        },

        /**
         Touch / Mobile specific methods
         **/

        /**
         * Handler when a finger touches the screen
         * @param evt
         * @private
         */
        _startTouchScroll: function(evt) {
          var styleAttr = ["top", "bottom"].indexOf(this._position) >= 0 ? "scrollLeft" : "scrollTop";
          this._scrollTouching = true;
          this._scrollTouchingPos = evt.changedTouches[0];
          this._scrollerPosition = this._tabsTitlesHost[styleAttr];
          this._nextScroller.addClass("overflown-next");
          this._previousScroller.addClass("overflown-previous");
          this._preventContainerScrolling(true);
        },

        /**
         * Handler when a finger stop touching the screen
         * @private
         */
        _endTouchScroll: function() {
          this._scrollTouching = false;
          this._scrollTouchingPos = null;
          this._preventContainerScrolling(false);
          this.refreshScrollers();
        },

        /**
         * Moves the scroller as the finger moves on touchscreen
         * @param evt
         * @private
         */
        _touchMove: function(evt) {
          var styleAttr = ["top", "bottom"].indexOf(this._position) >= 0 ? "scrollLeft" : "scrollTop";
          var rectAttr = ["top", "bottom"].indexOf(this._position) >= 0 ? "clientX" : "clientY";
          if (this._scrollTouching) {
            // move to current tabs position minus the drift from touch start to touch current pos
            this._tabsTitlesHost[styleAttr] = this._scrollerPosition - (evt.changedTouches[0][rectAttr] - this._scrollTouchingPos[
              rectAttr]);
          }
        },

        /**
         * Prevent the container to scroll while doing touch to scroll the tab-titles
         * @param {Boolean} prevent - true to prevent it, false otherwise
         * @private
         */
        _preventContainerScrolling: function(prevent) {
          var form = this._widget.getFormWidget();
          if (form) {
            form.getContainerElement().toggleClass("prevent-touch-scroll", prevent);
          }
        }

      };
    });
  });
;
"use strict";

modulum('ScrollWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * HBox or VBox widget.
     * @class ScrollWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     */
    cls.ScrollWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.ScrollWidget.prototype */ {
        __name: "ScrollWidget",
        _lineHeight: 0,
        _pageSize: 0,
        _size: 0,
        _offset: 0,
        _spacer: null,
        _lastPosition: 0,

        //override default
        _initElement: function() {
          $super._initElement.call(this);

          this._element.on('scroll.ScrollWidget', this._onScroll.bind(this));

          this._spacer = this.getElement().getElementsByTagName("div")[0];
        },
        destroy: function() {
          this._element.off('scroll.ScrollWidget');
          $super.destroy.call(this);

        },
        _onScroll: function(event) {
          this.getParentWidget().emit(context.constants.widgetEvents.scroll, event, this._lineHeight);
        },
        _initLayout: function() {
          this._layoutInformation = new cls.LayoutInformation(this);
          this._layoutEngine = new cls.ScrollLayoutEngine(this);
        },

        /**
         * @inheritDoc
         */
        setParentWidget: function(widget, options) {
          this._detachScrollBar();
          $super.setParentWidget.call(this, widget, options);
          if (widget) {
            this._attachScrollBar();
          }
        },

        setEnabled: function(enabled) {
          $super.setEnabled.call(this, enabled);
          if (!enabled) {
            this.setTotalHeight(0);
          }
          //this.setThinScrollBar(1);
        },

        setPageSize: function(pageSize) {
          this._pageSize = pageSize;
        },

        getPageSize: function() {
          return this._pageSize;
        },

        setSize: function(size) {
          this._size = size;
        },

        setLineHeight: function(lineHeight) {
          this._lineHeight = lineHeight;
        },

        getLineHeight: function() {
          return this._lineHeight;
        },

        setOffset: function(offset) {
          this._offset = offset;
        },

        // Refresh the scrollBar
        refreshScroll: function(force) {
          if (this._lastPosition !== this._offset || force) {
            this._lastPosition = this._offset;
            var pixelOffset = this._lineHeight * this._offset;
            this.afterDomMutator(function() {
              this.getElement().scrollTop = pixelOffset;
            }.bind(this));
          }
        },

        /**
         * Will set the visible height of the scroll Area
         * @param {number} height visible
         */
        setVisibleHeight: function(height) {
          this.setStyle({
            "height": height + "px"
          });
        },

        /**
         * Will set the total height of the scrollArea
         * @param {number} height total
         */
        setTotalHeight: function(height) {
          if (!this.isEnabled()) {
            height = 0;
          }
          this.setStyle(".spacer", {
            "height": Math.max(0, height) + "px"
          });
        },

        /**
         * Will add a scrollbar to parent container
         * */
        _attachScrollBar: function() {
          var parentElement = this.getParentWidget().getElement();
          parentElement.appendChild(this.getElement());

          // Add a listener on parent scroll
          // usage of requestAnimationFrame for firefox optimization (ENGGCS-3347)
          this.afterDomMutator(function() {
            var mouseWheelFunc = function(event) {
              if (this.isEnabled()) {
                this.getParentWidget().emit(context.constants.widgetEvents.mousewheel, event, this._lineHeight);
              }
            }.bind(this);
            var touchMoveFunc = function(event) {
              if (this.isEnabled()) {
                this.getParentWidget().emit(context.constants.widgetEvents.touchMove, event, this._lineHeight);
              }
            }.bind(this);
            var touchStartFunc = function(event) {
              if (this.isEnabled()) {
                this.getParentWidget().emit(context.constants.widgetEvents.touchStart, event, this._lineHeight);
              }
            }.bind(this);
            var touchEndFunc = function(event) {
              if (this.isEnabled()) {
                this.getParentWidget().emit(context.constants.widgetEvents.touchEnd, event, this._lineHeight);
              }
            }.bind(this);

            parentElement.on('wheel.ScrollWidget', mouseWheelFunc);
            if (window.isTouchDevice()) {
              parentElement.on('touchstart.ScrollWidget', touchStartFunc);
              parentElement.on('touchend.ScrollWidget', touchEndFunc);
              parentElement.on('touchmove.ScrollWidget', touchMoveFunc);
            }
          }.bind(this));
        },

        /**
         * Will remove scrollbar to parent container
         * */
        _detachScrollBar: function() {
          if (this.getParentWidget()) {
            var parentElement = this.getParentWidget().getElement();
            parentElement.off('wheel.ScrollWidget');
            if (window.isTouchDevice()) {
              parentElement.off('touchstart.ScrollWidget');
              parentElement.off('touchend.ScrollWidget');
              parentElement.off('touchmove.ScrollWidget');
            }
          }
        }

      };
    });
    cls.WidgetFactory.registerBuilder('Scroll', cls.ScrollWidget);
  });
;
"use strict";

modulum('Border4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class Border4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.Border4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.Border4STBehavior.prototype */ {
        __name: "Border4STBehavior",

        usedStyleAttributes: ["border"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.setNoBorder) {
            var border = controller.getAnchorNode().getStyleAttribute('border');
            widget.setNoBorder(this.isSANoLike(border));
          }
        }
      };
    });
  });
;
"use strict";

modulum('BrowserMultiPage4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class BrowserMultiPage4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.BrowserMultiPage4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.BrowserMultiPage4STBehavior.prototype */ {
        __name: "BrowserMultiPage4STBehavior",

        usedStyleAttributes: ["BrowserMultiPage"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var node = controller && controller.getAnchorNode(),
            app = node && node.getApplication(),
            session = app && app.getSession(),
            isAvailable = session &&
            (
              session.hasServerFeature("browser-multi-page") ||
              (cls.ServerHelper.compare(session.info().serverVersion, "GAS/3.00.22") >= 0)
            );

          if (app && isAvailable) {
            app.setBrowserMultiPageMode(this.isSAYesLike(node.getStyleAttribute('browserMultiPage')));
          }
        }
      };
    });
  });
;
"use strict";

modulum('ButtonType4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class ButtonType4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.ButtonType4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.ButtonType4STBehavior.prototype */ {
        __name: "ButtonType4STBehavior",

        usedStyleAttributes: ["buttonType"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.setButtonType) {
            var buttonType = controller.getAnchorNode().getStyleAttribute('buttonType');
            if (buttonType) {
              widget.setButtonType(buttonType);
            }
          }
        }
      };
    });
  });
;
"use strict";

modulum('CollapserPosition4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * 4ST style used to change collapser position
     * @class CollapserPosition4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.CollapserPosition4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.CollapserPosition4STBehavior.prototype */ {
        __name: "CollapserPosition4STBehavior",

        usedStyleAttributes: ["collapserPosition"],

        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var node = controller && controller.getAnchorNode(),
            widget = controller.getWidget();

          if (node && widget && widget.setCollapserPosition) {
            var position = node.getStyleAttribute("collapserPosition");
            // Only left and right positions are allowed, others are ignored
            if (["left", "right"].indexOf(position) >= 0) {
              widget.setCollapserPosition(position);
            }
          }
        },

      };
    });
  });
;
"use strict";

modulum('Collapsible4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class Collapsible4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.Collapsible4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.Collapsible4STBehavior.prototype */ {
        __name: "Collapsible4STBehavior",

        usedStyleAttributes: ["collapsible", "initiallyCollapsed"],

        /**
         * @inheritDoc
         */
        _attachWidget: function(controller, data) {
          if (controller.getWidget()) {
            data.toggleClickHandler = controller.getWidget().when(
              context.constants.widgetEvents.toggleClick,
              this._onToggleClick.bind(this, controller, data)
            );
          }
        },
        /**
         * @inheritDoc
         */
        _detachWidget: function(controller, data) {
          if (data.toggleClickHandler) {
            data.toggleClickHandler();
            data.toggleClickHandler = null;
          }
        },

        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var node = controller && controller.getAnchorNode(),
            widget = controller.getWidget();
          var storedSettingsGroupId = this._getIdentifier(controller);
          widget.setGroupIdentifier(storedSettingsGroupId);
          if (node && widget && widget.setCollapsible) {
            var isCollapsible = this.isSAYesLike(node.getStyleAttribute("collapsible")),
              initiallyCollapsedAttr = node.getStyleAttribute("initiallyCollapsed"),
              initiallyCollapsed = this.isSAYesLike(initiallyCollapsedAttr);
            widget.setCollapsible(isCollapsible);

            if (initiallyCollapsedAttr === "always") {
              widget.setCollapsed(true);
            } else if (initiallyCollapsedAttr === "never") {
              widget.setCollapsed(false);
            } else {
              var storedCollapsedState = context.StoredSettingsService
                .getGroupCollapsedState(storedSettingsGroupId.formName, storedSettingsGroupId.id);
              if (typeof storedCollapsedState === "boolean") {
                widget.setCollapsed(storedCollapsedState);
              } else if (initiallyCollapsed && !data.initiallyCollapsed) {
                data.initiallyCollapsed = true;
                widget.setCollapsed(true);
              }
            }
          }
        },
        /**
         *
         * @param {classes.ControllerBase} controller
         * @param {*} data
         * @private
         */
        _onToggleClick: function(controller, data) {
          var node = controller && controller.getAnchorNode(),
            app = node && node.getApplication();
          if (app) {
            app.layout.refreshLayout();
          }
        },

        /**
         * Get an unique id for a Group
         * @param controller
         * @returns {{formName:string, id:string}} identifier of the Group
         * @private
         */
        _getIdentifier: function(controller) {
          var identifier = [];
          var bindings = controller.getNodeBindings();
          var anchor = bindings.anchor;
          var parentNode = anchor.getParentNode();
          var siblings = null;
          var formName = "";

          // Goes up in AUI tree to get position of each splitter in VBox, HBox and Grid
          while (parentNode !== null) {
            if (["Group"].indexOf(anchor.getTag()) >= 0) {
              siblings = parentNode.getDescendants(anchor.getTag());
              identifier.push(anchor.getTag() + siblings.indexOf(anchor));
            } else if (anchor.getTag() === "Form") {
              formName = anchor.attribute("name");
            }

            anchor = parentNode;
            parentNode = anchor.getParentNode();
          }
          return {
            formName: formName,
            id: identifier.reverse().join("_")
          };
        }

      };
    });
  });
;
"use strict";

modulum('ButtonIcon4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class ButtonIcon4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.ButtonIcon4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.ButtonIcon4STBehavior.prototype */ {
        __name: "ButtonIcon4STBehavior",

        usedStyleAttributes: ["buttonIcon"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.setButtonIcon) {
            var buttonIcon = controller.getAnchorNode().getStyleAttribute('buttonIcon');
            widget.setButtonIcon(buttonIcon);
          }
        }
      };
    });
  });
;
"use strict";

modulum('CalendarType4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class CalendarType4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.CalendarType4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.CalendarType4STBehavior.prototype */ {
        __name: "CalendarType4STBehavior",

        /**
         * calendarType = { "modal" (default) | "dropdown" }
         */
        usedStyleAttributes: ["calendarType"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.setCalendarType) {
            var calendarType = controller.getAnchorNode().getStyleAttribute('calendarType');
            widget.setCalendarType(calendarType);
          }
        }
      };
    });
  });
;
"use strict";

modulum('DaysOff4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class DaysOff4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.DaysOff4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.DaysOff4STBehavior.prototype */ {
        __name: "DaysOff4STBehavior",

        usedStyleAttributes: ["daysOff"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.setDisabledDays) {
            var daysOff = controller.getAnchorNode().getStyleAttribute('daysOff');
            widget.setDisabledDays(daysOff);
          }
        }
      };
    });
  });
;
"use strict";

modulum('FirstDayOfWeek4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class FirstDayOfWeek4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.FirstDayOfWeek4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.FirstDayOfWeek4STBehavior.prototype */ {
        __name: "FirstDayOfWeek4STBehavior",

        usedStyleAttributes: ["firstDayOfWeek"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.setFirstDayOfWeek) {
            var firstDayOfWeek = controller.getAnchorNode().getStyleAttribute('firstDayOfWeek');
            widget.setFirstDayOfWeek(firstDayOfWeek);
          }
        }
      };
    });
  });
;
"use strict";

modulum('ShowWeekNumber4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class ShowWeekNumber4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.ShowWeekNumber4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.ShowWeekNumber4STBehavior.prototype */ {
        __name: "ShowWeekNumber4STBehavior",

        usedStyleAttributes: ["showWeekNumber"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.showWeekNumber) {
            var showWeekNumber = controller.getAnchorNode().getStyleAttribute('showWeekNumber');
            widget.showWeekNumber(showWeekNumber);
          }
        }
      };
    });
  });
;
"use strict";

modulum('TabPosition4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class TabPosition4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.TabPosition4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.TabPosition4STBehavior.prototype */ {
        __name: "TabPosition4STBehavior",

        usedStyleAttributes: ["position"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.setTabPosition) {
            var pos = controller.getAnchorNode().getStyleAttribute('position');
            if (pos) {
              widget.setTabPosition(pos);
            } else {
              widget.setTabPosition('top');
            }
          }
        }
      };
    });
  });
;
"use strict";

modulum('FontSize4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class FontSize4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.FontSize4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.FontSize4STBehavior.prototype */ {
        __name: "FontSize4STBehavior",

        usedStyleAttributes: ["fontSize"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.setFontSize) {
            var font = controller.getAnchorNode().getStyleAttribute('fontSize');
            widget.setFontSize(font);
          }
        }
      };
    });
  });
;
"use strict";

modulum('FontStyle4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class FontStyle4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.FontStyle4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.FontStyle4STBehavior.prototype */ {
        __name: "FontStyle4STBehavior",

        usedStyleAttributes: ["fontStyle"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.setFontStyle) {
            var font = controller.getAnchorNode().getStyleAttribute('fontStyle');
            widget.setFontStyle(font);
          }
        }
      };
    });
  });
;
"use strict";

modulum('ForceDefaultSettings4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class ForceDefaultSettings4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.ForceDefaultSettings4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.ForceDefaultSettings4STBehavior.prototype */ {
        __name: "ForceDefaultSettings4STBehavior",

        usedStyleAttributes: ["forceDefaultSettings"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          controller.forceDefaultSettings = this.isSAYesLike(controller.getAnchorNode().getStyleAttribute('forceDefaultSettings'));
        }
      };
    });
  });
;
"use strict";

modulum('GridAutomaticStack4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * Defines the render behavior of the grid.
     * Values can be:
     *    "grid": works as a standard Genero grid.
     *    "stack": will stack all elements of the grid on one cojulnm depending on their position in the AUI.
     * @class GridAutomaticStack4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.GridAutomaticStack4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.GridAutomaticStack4STBehavior.prototype */ {
        __name: "GridAutomaticStack4STBehavior",

        usedStyleAttributes: ["customWidget"],

        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.getLayoutInformation) {
            var GridAutomaticStackValue = controller.getAnchorNode().getStyleAttribute('customWidget') === "automaticStack";
            widget.getLayoutInformation().setGridAutomaticStack(GridAutomaticStackValue);
            return true;
          }
        }
      };
    });
  });
;
"use strict";

modulum('SplitViewArrows4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class SplitViewArrows4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.SplitViewArrows4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.SplitViewArrows4STBehavior.prototype */ {
        __name: "SplitViewArrows4STBehavior",

        usedStyleAttributes: ["splitViewNavigationWithArrows"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.setArrowsStyle) {
            var splitViewArrowsStyle = controller.getAnchorNode().getStyleAttribute('splitViewNavigationWithArrows');
            if (splitViewArrowsStyle) {
              widget.setArrowsStyle(splitViewArrowsStyle);
            }
          }
        }
      };
    });
  });
;
"use strict";

modulum('SplitViewDots4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class SplitViewDots4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.SplitViewDots4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.SplitViewDots4STBehavior.prototype */ {
        __name: "SplitViewDots4STBehavior",

        usedStyleAttributes: ["splitViewNavigationWithDots"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.setWithDots) {
            var splitViewDotsStyle = controller.getAnchorNode().getStyleAttribute('splitViewNavigationWithDots');
            if (splitViewDotsStyle) {
              widget.setWithDots(splitViewDotsStyle);
            }
          }
        }
      };
    });
  });
;
"use strict";

modulum('Highlight4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class Highlight4STBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.Highlight4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.Highlight4STBehavior.prototype */ {
        __name: "Highlight4STBehavior",

        usedStyleAttributes: ["highlightColor", "highlightCurrentCell", "highlightCurrentRow", "highlightTextColor"],
        watchedAttributes: {
          anchor: ['dialogType', 'focusOnField', 'currentRow'],
          parent: ['active']
        },
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          var anchorNode = controller.getAnchorNode();

          if (widget && widget.updateHighlight) {

            // -- TABLE & SCROLLGRID WIDGET -------------------------------------------------
            // In DISPLAY ARRAY without FOCUSONFIELD
            //   highlightCurrentRow is enable by default (yes) but can be explicitly set to yes or no.
            //   highlightCurrentCell is ignored.
            // In DISPLAY ARRAY with FOCUSONFIELD
            //   highlightCurrentRow is disable by default (no) but can be explicitly set to yes or no.
            //   highlightCurrentCell is enable by default (yes) but can be explicitly set to yes or no.
            // In INPUT ARRAY
            //   highlightCurrentRow is disable by default (no) but can be explicitly set to yes or no.
            //   highlightCurrentCell is disable by default (no) but can be explicitly set to yes or no.
            // ---------------------------------------------------
            // -- LISTVIEW WIDGET -------------------------------------------------
            // In DISPLAY ARRAY
            //   highlightCurrentRow is disable by default (no) but can be explicitly set to yes or no.
            //   highlightCurrentCell is ignored
            // FOCUSONFIELD, INPUT ARRAY --> not managed
            // ---------------------------------------------------

            var highlightColorAttr = anchorNode.getStyleAttribute("highlightColor");
            var highlightCurrentCellAttr = anchorNode.getStyleAttribute("highlightCurrentCell");
            var highlightCurrentRowAttr = anchorNode.getStyleAttribute("highlightCurrentRow");
            var highlightTextColorAttr = anchorNode.getStyleAttribute("highlightTextColor");
            var dialogType = anchorNode.attribute("dialogType");

            if (!dialogType) { // in case of scrollgrid use the dialogType of first Matrix
              var node = anchorNode.findNodeWithAttribute(null, "dialogType");
              dialogType = node ? node.attribute("dialogType") : "DisplayArray";
            }

            var isDisplayArray = (dialogType === "DisplayArray");
            var isInputArray = (dialogType === "InputArray");
            var hasFocusOnField = false;
            if (anchorNode.getTag() === 'Table') {
              hasFocusOnField = anchorNode.attribute('focusOnField') === 1;
            } else {
              var matrix = anchorNode.findNodeWithAttribute('Matrix', 'currentRow', -1);
              hasFocusOnField = matrix && anchorNode.attribute('active') === 1;
            }
            var isListView = controller.isListView ? controller.isListView() : false;

            // Defines the highlight color of row
            widget.setHighlightColor(highlightColorAttr);

            // Defines the highlighted text color of row
            widget.setHighlightTextColor(highlightTextColorAttr);

            // set default values
            var highlightCurrentRow = false;
            var highlightCurrentCell = false;
            if (isDisplayArray) {
              if (hasFocusOnField) {
                highlightCurrentRow = false;
                highlightCurrentCell = true;
              } else {
                if (isListView) {
                  highlightCurrentRow = false;
                } else {
                  highlightCurrentRow = true;
                  highlightCurrentCell = highlightCurrentRow;

                }
              }
            } else if (isInputArray) {
              highlightCurrentRow = false;
              highlightCurrentCell = false;
            }

            // set 4ST values
            if (highlightCurrentRowAttr !== null) {
              highlightCurrentRow = this.isSAYesLike(highlightCurrentRowAttr);
            }
            if (highlightCurrentCellAttr !== null) {
              highlightCurrentCell = this.isSAYesLike(highlightCurrentCellAttr);
            }

            if (isDisplayArray && !hasFocusOnField) {
              highlightCurrentCell = highlightCurrentRow; // highlight cell should be equal at highlight row in this case
            }

            widget.setHighlightCurrentRow(highlightCurrentRow);

            if (widget.setHighlightCurrentCell) { // not implement for listview
              widget.setHighlightCurrentCell(highlightCurrentCell);
            }

            widget.updateHighlight();
          }
        }
      };
    });
  });
;
"use strict";

modulum('Alignment4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class Alignment4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.Alignment4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.Alignment4STBehavior.prototype */ {
        __name: "Alignment4STBehavior",
        _values: {
          y: ["top", "verticalCenter", "bottom"],
          x: ["left", "horizontalCenter", "right"]
        },

        usedStyleAttributes: ["alignment"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.setAlignment) {
            var isButton = controller.getAnchorNode().getTag() === "Button";
            var pos = controller.getAnchorNode().getStyleAttribute('alignment');
            if (pos) {
              if (pos === "center") {
                pos = "verticalCenter horizontalCenter";
              }
              var y = "top";
              var x = "left";
              var positions = pos.split(" ");
              if (this._values.y.indexOf(positions[0]) !== -1) {
                y = positions[0];
                x = positions.length === 2 ? positions[1] : null;
              } else if (this._values.x.indexOf(positions[0]) !== -1) {
                x = positions[0];
                y = positions.length === 2 ? positions[1] : null;
              }
              widget.setAlignment(y, x);
            } else if (!isButton) {
              if (controller.isInTable()) {
                widget.setAlignment('verticalCenter', 'horizontalCenter');
              } else {
                widget.setAlignment('top', 'left');
              }
            }
          }
        }
      };
    });
  });
;
"use strict";

modulum('ItemsAlignment4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class ItemsAlignment4STBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.ItemsAlignment4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.ItemsAlignment4STBehavior.prototype */ {
        __name: "ItemsAlignment4STBehavior",

        usedStyleAttributes: ["scrollgridItemsAlign"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          var anchorNode = controller.getAnchorNode();

          if (widget && widget.setItemsAlignment) {
            var itemsAlignmentAttr = anchorNode.getStyleAttribute("itemsAlignment");
            widget.setItemsAlignment(itemsAlignmentAttr);
          }
        }
      };
    });
  });
;
"use strict";

modulum('Percentage4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class Percentage4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.Percentage4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.Percentage4STBehavior.prototype */ {
        __name: "Percentage4STBehavior",

        usedStyleAttributes: ["percentageVisible"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.showPercentage) {
            var pos = controller.getAnchorNode().getStyleAttribute('percentageVisible');
            widget.showPercentage(pos);
          }
        }
      };
    });
  });
;
"use strict";

modulum('ReduceFilter4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class ReduceFilter4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.ReduceFilter4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.ReduceFilter4STBehavior.prototype */ {
        __name: "ReduceFilter4STBehavior",

        usedStyleAttributes: ["reduceFilter"],
        watchedAttributes: {
          anchor: ['noFilter']
        },
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.setReduceFilter) {

            var noFilter = controller.getAnchorNode().attribute("noFilter") === 1;
            var reduceFilter = controller.getAnchorNode().getStyleAttribute('reduceFilter');

            if (reduceFilter === null) { // reduceFilter is not defined in 4ST use theme default value
              reduceFilter = context.ThemeService.getValue("theme-default-reduceFilter");
            } else {
              reduceFilter = this.isSAYesLike(reduceFilter);
            }

            widget.setReduceFilter(reduceFilter && !noFilter);
          }
        }
      };
    });
  });
;
"use strict";

modulum('RowActionTrigger4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class RowActionTrigger4STBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.RowActionTrigger4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.RowActionTrigger4STBehavior.prototype */ {
        __name: "RowActionTrigger4STBehavior",

        usedStyleAttributes: ["rowActionTrigger"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.setRowActionTriggerByDoubleClick) {
            var node = controller.getAnchorNode();
            var rowActionTriggerStyle = node.getStyleAttribute("rowActionTrigger");

            var rowActionTriggerByDoubleClick;
            if (rowActionTriggerStyle === null) { // if there is no style, default depends of widget type
              if (controller.isListView && controller.isListView()) {
                rowActionTriggerByDoubleClick = false; // for listview default is single click
              } else {
                rowActionTriggerByDoubleClick = true; // for other widgets default is double click
              }
            } else { // if there is a style, use it
              rowActionTriggerByDoubleClick = (rowActionTriggerStyle !== "singleClick");
            }

            widget.setRowActionTriggerByDoubleClick(rowActionTriggerByDoubleClick);
          }
        }
      };
    });
  });
;
"use strict";

modulum('ScaleIcon4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * Defines the scaling behaviors of the associated icon.
     * Values can be:
     *    "no": No scaling occurs and the image is taken as-is.
     *          It is up to the developer to resize the source image to avoid misalignment.
     *          This is the default on GDC/GBC.
     *    "yes": Image are scaled down according to the height of the widget (button or edit field).
     *           Setting a big font can result in a big icon. This is the default on GMA/GMI.
     *    "nnnpx": Image are scaled down according to the specified size.
     *             For example, scaleIcon="128px" will make every icon a maximum of 128*128 pixels.
     *             At least one side equal to 128 pixels, depending if the source image is square or not.
     * @class ScaleIcon4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.ScaleIcon4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.ScaleIcon4STBehavior.prototype */ {
        __name: "ScaleIcon4STBehavior",

        usedStyleAttributes: ["scaleIcon"],

        /**
         * @param {classes.ControllerBase} controller
         * @param data
         * @param scaleByDefault
         */
        setup: function(controller, data, scaleByDefault) {
          data._scaleByDefault = !!scaleByDefault;
        },
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.setAutoScale) {
            var scaleIconValue = controller.getAnchorNode().getStyleAttribute('scaleIcon');
            if (scaleIconValue !== null) {
              widget.setAutoScale(this.isSAYesLike(scaleIconValue));
            } else {
              widget.setAutoScale(data._scaleByDefault);
            }
          }
        }
      };
    });
  });
;
"use strict";

modulum('ShowEditToolBox4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class ShowEditToolBox4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.ShowEditToolBox4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.ShowEditToolBox4STBehavior.prototype */ {
        __name: "ShowEditToolBox4STBehavior",

        usedStyleAttributes: ["showEditToolBox"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.showEditToolBox) {
            var show = controller.getAnchorNode().getStyleAttribute('showEditToolBox');
            if (show !== "auto") {
              show = this.isSAYesLike(show) ? "show" : "hide";
            }
            widget.showEditToolBox(show);
          }
        }
      };
    });
  });
;
"use strict";

modulum('StyleBehaviorBase', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class StyleBehaviorBase
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.StyleBehaviorBase = context.oo.Class(cls.BehaviorBase, function($super) {
      return /** @lends classes.StyleBehaviorBase.prototype */ {
        __name: "StyleBehaviorBase",

        /**
         * Test if style attribute is "yes" like
         * @param {number|string} sa Style attribute
         */
        isSAYesLike: function(sa) {
          return sa === 1 || sa === "yes" || sa === "true";
        },

        /**
         * Test if style attribute is "no" like
         * @param {number|string} sa Style attribute
         */
        isSANoLike: function(sa) {
          return sa === 0 || sa === "no" || sa === "false" || sa === "none";
        }
      };
    });
  });
;
"use strict";

modulum('AllowWebSelection4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class AllowWebSelection4STBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.AllowWebSelection4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.AllowWebSelection4STBehavior.prototype */ {
        __name: "AllowWebSelection4STBehavior",

        usedStyleAttributes: ["allowWebSelection"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          var tableNode = controller.getAnchorNode();
          if (widget && widget.setDefaultItemSelection) {
            var allowWebSelection = this.isSAYesLike(tableNode.getStyleAttribute("allowWebSelection"));

            widget.setDefaultItemSelection(allowWebSelection);
          }
        }
      };
    });
  });
;
"use strict";

modulum('FrozenColumns4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class FrozenColumns4STBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.FrozenColumns4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.FrozenColumns4STBehavior.prototype */ {
        __name: "FrozenColumns4STBehavior",

        usedStyleAttributes: ["leftFrozenColumns", "rightFrozenColumns"],

        /**
         * @param {classes.ControllerBase} controller
         * @param {Object} data
         */
        setup: function(controller, data) {
          data.firstApply = true;
        },
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          var tableNode = controller.getAnchorNode();
          if (widget) {

            var storedFrozenLeft = data.firstApply ? controller.getStoredSetting("leftFrozen") : null;
            var storedFrozenRight = data.firstApply ? controller.getStoredSetting("rightFrozen") : null;

            var leftFrozenColumns = null;
            var rightFrozenColumns = null;

            if (storedFrozenLeft !== null) {
              leftFrozenColumns = storedFrozenLeft;
            } else {
              leftFrozenColumns = tableNode.getStyleAttribute("leftFrozenColumns");
            }

            if (storedFrozenRight !== null) {
              rightFrozenColumns = storedFrozenRight;
            } else {
              rightFrozenColumns = tableNode.getStyleAttribute("rightFrozenColumns");
            }

            // NOTE don't reset value from style if it doesn't change because it can reset the value set by the table contextmenu
            if (leftFrozenColumns && (data._leftFrozenDefaultValue !== leftFrozenColumns)) {
              widget.setLeftFrozenColumns(leftFrozenColumns);
              data._leftFrozenDefaultValue = leftFrozenColumns;
            }
            if (rightFrozenColumns && (data._rightFrozenDefaultValue !== rightFrozenColumns)) {
              widget.setRightFrozenColumns(rightFrozenColumns);
              data._rightFrozenDefaultValue = rightFrozenColumns;
            }
          }

          data.firstApply = true;
        }
      };
    });
  });
;
"use strict";

modulum('ResizeFillsEmptySpace4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class ResizeFillsEmptySpace4STBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.ResizeFillsEmptySpace4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.ResizeFillsEmptySpace4STBehavior.prototype */ {
        __name: "ResizeFillsEmptySpace4STBehavior",

        usedStyleAttributes: ["resizeFillsEmptySpace"],

        /**
         *
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          var tableNode = controller.getAnchorNode();

          if (widget && widget.setResizeFillsEmptySpace) {
            var resizeFillsEmptySpace = tableNode.getStyleAttribute("resizeFillsEmptySpace");
            widget.setResizeFillsEmptySpace(this.isSAYesLike(resizeFillsEmptySpace));
          }
        }
      };
    });
  });
;
"use strict";

modulum('ShowGrid4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class ShowGrid4STBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.ShowGrid4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.ShowGrid4STBehavior.prototype */ {
        __name: "ShowGrid4STBehavior",

        usedStyleAttributes: ["showGrid"],
        watchedAttributes: {
          anchor: ['dialogType']
        },

        /**
         * Indicates if the grid lines must be visible in a table.
         * Values can be "yes" (default when INPUT ARRAY),"no" (default when DISPLAY ARRAY). (1 or 0 on older front-ends).
         *
         * By default, when a Table is in editable mode (INPUT ARRAY), the front-end displays grid lines in the table.
         * You can change this behavior by setting this attribute to "no".
         *
         * By default, when a Table is in editable mode (DISPLAY ARRAY), the front-end does not display grid lines in the table.
         * You can change this behavior by setting this attribute to "yes".
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          var tableNode = controller.getAnchorNode();
          var showGrid = tableNode.getStyleAttribute("showGrid");
          var dialogType = tableNode.attribute("dialogType");
          if (widget && widget.setShowGrid) {
            var apply = (showGrid === null &&
                (dialogType === "Input" || dialogType === "InputArray" ||
                  dialogType === "Construct")) ||
              this.isSAYesLike(showGrid);
            widget.setShowGrid(apply);
          }
        }
      };
    });
  });
;
"use strict";

modulum('TableHeader4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class TableHeader4STBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.TableHeader4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.TableHeader4STBehavior.prototype */ {
        __name: "TableHeader4STBehavior",

        usedStyleAttributes: ["headerHidden", "headerAlignment"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          var tableNode = controller.getAnchorNode();
          if (widget) {
            var headerHidden = tableNode.getStyleAttribute("headerHidden");
            var headerAlignment = tableNode.getStyleAttribute("headerAlignment");
            if (widget.setHeaderHidden && widget.setHeaderAlignment) {
              if (headerHidden) {
                widget.setHeaderHidden(this.isSAYesLike(headerHidden));
              }
              if (headerAlignment) {
                if (headerAlignment === "default") {
                  headerAlignment = "left"; // default is left
                }
                widget.setHeaderAlignment(headerAlignment);
              }
            }
          }
        }
      };
    });
  });
;
"use strict";

modulum('TableType4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class TableType4STBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.TableType4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.TableType4STBehavior.prototype */ {
        __name: "TableType4STBehavior",

        usedStyleAttributes: ["tableType"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          var tableNode = controller.getAnchorNode();
          var tableType = tableNode.getStyleAttribute("tableType");
          if (widget && widget.setFrozenTable) {
            widget.setFrozenTable(tableType === "frozenTable");
          }
        }
      };
    });
  });
;
"use strict";

modulum('TextFormat4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class TextFormat4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.TextFormat4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.TextFormat4STBehavior.prototype */ {
        __name: "TextFormat4STBehavior",

        usedStyleAttributes: ["textFormat"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.setHtmlControl) {
            var format = controller.getAnchorNode().getStyleAttribute('textFormat');
            if (format === "html") {
              if (controller._widgetType === "TextEdit" &&
                controller.setAsRichText &&
                controller.getAnchorNode().attribute("dialogType") === "Input") {
                controller.setAsRichText(true); //return true to invalidate following behaviors
              } else {
                var control = document.createElement("div");
                control.addClass('textEditHtml');
                widget.setHtmlControl(control);
              }
            }
          } else if (widget && widget.setHtmlFormat) {
            var htmlFormat = controller.getAnchorNode().getStyleAttribute('textFormat');
            widget.setHtmlFormat(htmlFormat === "html");
          }
        }
      };
    });
  });
;
"use strict";

modulum('TextPosition4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class TextPosition4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.TextPosition4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.TextPosition4STBehavior.prototype */ {
        __name: "TextPosition4STBehavior",

        usedStyleAttributes: ["toolBarTextPosition"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.getElement) {
            var format = controller.getAnchorNode().getStyleAttribute('toolBarTextPosition');
            var element = widget.getElement();
            if (element) {
              if (format === "textBesideIcon") {
                element.addClass("flex-row");
              } else {
                element.removeClass("flex-row");
              }
            }
          }
        }
      };
    });
  });
;
"use strict";

modulum('ThinScrollBarDisplayTime4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**

     * @class ThinScrollBarDisplayTime4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.ThinScrollBarDisplayTime4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.ThinScrollBarDisplayTime4STBehavior.prototype */ {
        __name: "ThinScrollBarDisplayTime4STBehavior",

        usedStyleAttributes: ["thinScrollbarDisplayTime"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.setThinScrollbar) {
            var thinScrollbarDisplayTime = controller.getAnchorNode().getStyleAttribute('thinScrollbarDisplayTime');
            if (thinScrollbarDisplayTime !== null) {
              widget.setThinScrollbar(parseInt(thinScrollbarDisplayTime, 10));
            }
          }
        }
      };
    });
  });
;
"use strict";

modulum('ActionPanelButtonTextAlign4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class ActionPanelButtonTextAlign4STBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.ActionPanelButtonTextAlign4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.ActionPanelButtonTextAlign4STBehavior.prototype */ {
        __name: "ActionPanelButtonTextAlign4STBehavior",

        usedStyleAttributes: ["actionPanelButtonTextAlign", "ringMenuButtonTextAlign"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          var panelNode = controller.getAnchorNode();
          var buttonTextAlign = null;
          if (panelNode.getTag() === 'Menu') {
            buttonTextAlign = panelNode.getStyleAttribute("ringMenuButtonTextAlign");
          } else {
            buttonTextAlign = panelNode.getStyleAttribute("actionPanelButtonTextAlign");
          }
          if (widget && buttonTextAlign && ["left", "right"].indexOf(buttonTextAlign) >= 0) {
            var i = 0,
              children = widget.getChildren(),
              len = children.length;
            for (; i < len; i++) {
              var child = children[i];
              if (child && child.setContentAlign) {
                child.setContentAlign(buttonTextAlign);
              }
            }
          }
        }
      };
    });
  });
;
"use strict";

modulum('ActionPanelButtonTextHidden4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class ActionPanelButtonTextHidden4STBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.ActionPanelButtonTextHidden4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.ActionPanelButtonTextHidden4STBehavior.prototype */ {
        __name: "ActionPanelButtonTextHidden4STBehavior",

        usedStyleAttributes: ["actionPanelButtonTextHidden", "ringMenuButtonTextHidden"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          var panelNode = controller.getAnchorNode();

          var buttonTextHidden = null;
          if (panelNode.getTag() === 'Menu') {
            buttonTextHidden = panelNode.getStyleAttribute("ringMenuButtonTextHidden");
          } else {
            buttonTextHidden = panelNode.getStyleAttribute("actionPanelButtonTextHidden");
          }
          if (widget) {
            var i = 0,
              children = widget.getChildren(),
              len = children.length;
            for (; i < len; i++) {
              var child = children[i];
              if (child && child.setTextHidden) {
                child.setTextHidden(buttonTextHidden);
              }
            }
          }
        }
      };
    });
  });
;
"use strict";

modulum('ActionPanelPosition4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class ActionPanelPosition4STBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.ActionPanelPosition4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.ActionPanelPosition4STBehavior.prototype */ {
        __name: "ActionPanelPosition4STBehavior",

        usedStyleAttributes: ["actionPanelPosition"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          var panelNode = controller.getAnchorNode();
          var isInChromeBar = controller.isInChromeBar();

          var actionPanelPosition = panelNode.getStyleAttribute("actionPanelPosition");
          if (widget && widget.setActionPanelPosition) {
            if (!isInChromeBar) {
              if (actionPanelPosition) {
                widget.setActionPanelPosition(actionPanelPosition);
              } else {
                widget.setActionPanelPosition('right');
              }
            }
          }
        }
      };
    });
  });
;
"use strict";

modulum('BackgroundImage4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class BackgroundImage4STBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.BackgroundImage4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.BackgroundImage4STBehavior.prototype */ {
        __name: "BackgroundImage4STBehavior",

        usedStyleAttributes: ["backgroundImage"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          var windowNode = controller.getAnchorNode();

          var backgroundImage = windowNode.getStyleAttribute("backgroundImage");
          if (widget && widget.setBackgroundImage) {
            widget.setBackgroundImage(backgroundImage);
          }
        }
      };
    });
  });
;
"use strict";

modulum('DefaultTTFColor4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class DefaultTTFColor4STBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.DefaultTTFColor4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.DefaultTTFColor4STBehavior.prototype */ {
        __name: "DefaultTTFColor4STBehavior",

        usedStyleAttributes: ["defaultTTFColor"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.setDefaultColor) {
            var winNode = controller.getAnchorNode().getAncestor("Window");
            var color = winNode.getStyleAttribute('defaultTTFColor');
            widget.setDefaultColor(color);
          }
        }
      };
    });
  });
;
"use strict";

modulum('Position4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class Position4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.Position4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.Position4STBehavior.prototype */ {
        __name: "Position4STBehavior",

        usedStyleAttributes: ["position"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.setPosition) {
            var pos = controller.getAnchorNode().getStyleAttribute('position');
            if (pos !== widget._position) {
              widget._position = pos;
              if (pos === "field") { // get ref field widget
                // Get the previous focused node or value node if table or matrix
                var previousId = controller.getUINode().previousAttribute("focus");
                var previousNode = controller.getUINode().getApplication().getNode(previousId);
                if (previousNode) {
                  if (previousNode.getCurrentValueNode) {
                    var currentValueNode = previousNode.getCurrentValueNode(true);
                    if (currentValueNode) {
                      previousNode = currentValueNode;
                    }
                  }
                  pos = previousNode.getController().getWidget();
                }
              }
              widget.setPosition(pos);
            }
          }
        }
      };
    });
  });
;
"use strict";

modulum('Reverse4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class Reverse4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.Reverse4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.Reverse4STBehavior.prototype */ {
        __name: "Reverse4STBehavior",

        usedStyleAttributes: ["reverse"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.setReverse) {
            var reverse = controller.getUINode().getStyleAttribute('reverse');
            widget.setReverse(this.isSAYesLike(reverse));
          }
        }
      };
    });
  });
;
"use strict";

modulum('RingMenuPosition4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class RingMenuPosition4STBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.RingMenuPosition4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.RingMenuPosition4STBehavior.prototype */ {
        __name: "RingMenuPosition4STBehavior",

        usedStyleAttributes: ["ringMenuPosition"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          var menuNode = controller.getAnchorNode();
          var isInChromeBar = controller.isInChromeBar();

          var ringMenuPosition = menuNode.getStyleAttribute("ringMenuPosition");
          if (widget && widget.setActionPanelPosition) {
            if (!isInChromeBar) {
              if (!!ringMenuPosition) {
                widget.setActionPanelPosition(ringMenuPosition);
              } else {
                widget.setActionPanelPosition('right');
              }
            }
          }
        }
      };
    });
  });
;
"use strict";

modulum('Sizable4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class Sizable4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.Sizable4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.Sizable4STBehavior.prototype */ {
        __name: "Sizable4STBehavior",

        usedStyleAttributes: ["sizable", "border"],

        /**
         *
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var node = controller && controller.getAnchorNode(),
            widget = controller && controller.getWidget();
          if (widget) {
            var isSizable = node.getStyleAttribute('sizable') ? !this.isSANoLike(node.getStyleAttribute('sizable')) : true,
              modal = widget.getModal && widget.getModal();
            if (!modal) {
              widget.getLayoutInformation().setSizable(isSizable);
            } else {
              var noBorder = node.getStyleAttribute('border') === "none";
              if (!noBorder && modal.setSizable) {
                widget.getLayoutInformation().setSizable(isSizable);
                modal.setSizable(isSizable);
              }
            }
          }
        }
      };
    });
  });
;
"use strict";

modulum('StartMenuPosition4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class StartMenuPosition4STBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.StartMenuPosition4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.StartMenuPosition4STBehavior.prototype */ {
        __name: "StartMenuPosition4STBehavior",

        usedStyleAttributes: ["startMenuPosition"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          var node = controller.getAnchorNode();

          var type = node.getStyleAttribute("startMenuPosition");
          if (widget && widget.setStartMenuType) {
            if (type) {
              widget.setStartMenuType(type);
            }
          }
        }
      };
    });
  });
;
"use strict";

modulum('TabbedContainer4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class TabbedContainer4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.TabbedContainer4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.TabbedContainer4STBehavior.prototype */ {
        __name: "TabbedContainer4STBehavior",

        usedStyleAttributes: ["tabbedContainer"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var node = controller && controller.getAnchorNode(),
            app = node && node.getApplication();

          if (app) {
            var isTabbedContainer = this.isSAYesLike(node.getStyleAttribute('tabbedContainer'));
            if (isTabbedContainer) {
              var widget = node.getController() && node.getController().getWidget();
              if (widget && !(widget.getModal && widget.getModal()) && node.getApplication().getNode(0).getChildren("StartMenu").length) {
                app.setTabbedContainerMode(isTabbedContainer, node);
              }
            }
          }
        }
      };
    });
  });
;
"use strict";

modulum('ToolBarPosition4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class ToolBarPosition4STBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.ToolBarPosition4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.ToolBarPosition4STBehavior.prototype */ {
        __name: "ToolBarPosition4STBehavior",

        usedStyleAttributes: ["toolBarPosition"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          var tbNode = controller.getAnchorNode();

          var tbPosition = tbNode.getStyleAttribute("toolBarPosition");
          if (widget && widget.setToolBarPosition) {
            if (tbPosition) {
              widget.setToolBarPosition(tbPosition);
            } else {
              widget.setToolBarPosition('top');
            }
          }
        }
      };
    });
  });
;
"use strict";

modulum('WindowOptionClose4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class WindowOptionClose4STBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.WindowOptionClose4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.WindowOptionClose4STBehavior.prototype */ {
        __name: "WindowOptionClose4STBehavior",

        watchedAttributes: {
          ui: ['currentWindow']
        },
        usedStyleAttributes: ["windowOptionClose"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          var windowNode = controller.getAnchorNode();

          var windowOptionClose = windowNode.getStyleAttribute("windowOptionClose");
          if (widget) {
            if (this.isSAYesLike(windowOptionClose)) {
              var currentWindow = controller.getAnchorNode() &&
                controller.getAnchorNode().getParentNode() &&
                controller.getAnchorNode().getParentNode().attribute("currentWindow");
              context.HostService.setClosableWindowActionActive(widget, currentWindow === controller.getAnchorNode().getId());
            } else if (windowOptionClose !== null) {
              context.HostService.setClosableWindowActionActive(widget, false);
            }
          }
        }
      };
    });
  });
;
"use strict";

modulum('WrapPolicy4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class WrapPolicy4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.WrapPolicy4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.WrapPolicy4STBehavior.prototype */ {
        __name: "WrapPolicy4STBehavior",

        usedStyleAttributes: ["wrapPolicy"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.setWrapPolicy) {
            var format = controller.getAnchorNode().getStyleAttribute('wrapPolicy');
            widget.setWrapPolicy(format);
          }
        }
      };
    });
  });
;
"use strict";

modulum('NavigationAriaBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * // TODO comment
     * @class NavigationAriaBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.NavigationAriaBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.NavigationAriaBehavior.prototype */ {
        __name: "NavigationAriaBehavior",

        watchedAttributes: {
          anchor: ['tabIndexRt']
        },

        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var bindings = controller.getNodeBindings();
          var parent = bindings.parent;
          var anchor = bindings.anchor;
          var widget = anchor.getWidget();
          var visibleChildren = parent.getChildrenWithAttribute("MenuAction", "hidden", 0);
          var posInSet = anchor.attribute('tabIndexRt');
          widget.setAriaAttribute("posinset", posInSet);
          widget.setAriaAttribute("setsize", visibleChildren.length);
          widget.setAriaRole("menuitem");
        },

        /**
         * @inheritDoc
         */
        destroy: function(controller, data) {
          $super.destroy.call(this, controller, data);
        }
      };
    });
  });
;
"use strict";

modulum('BehaviorBase', ['EventListener'],
  /**
   * @namespace Behaviors
   * @param {gbc} context
   * @param {classes} cls
   */
  function(context, cls) {
    /**
     * Base class for all behaviors
     * @class BehaviorBase
     * @memberOf classes
     */
    cls.BehaviorBase = context.oo.Class(function($super) {
      return /** @lends classes.BehaviorBase.prototype */ {
        __name: "BehaviorBase",
        /**
         * List of watched attributes
         * @type {Object}
         * @protected
         */
        _watchedAttributes: null,
        /**
         * List of watched style attributes
         * @type {string[]}
         * @protected
         */
        usedStyleAttributes: null,
        /**
         * @inheritDoc
         * @constructs
         */
        constructor: function() {
          this.watchedBindings = this.watchedAttributes && Object.keys(this.watchedAttributes);
          this.watchedBindingsCount = this.watchedBindings && this.watchedBindings.length;
        },
        //TODO see if this return value is used somewhere
        /**
         * Applies the behavior on the widget
         * @param {classes.ControllerBase} controller The controller to apply the behavior
         * @param {*} data data to pass to the behavior
         * @return {boolean} bool
         */
        apply: function(controller, data) {
          data.dirty = false;
          return this._apply(controller, data);
        },
        /**
         * internal method to be overriden in behaviors
         * @protected
         * @param {classes.ControllerBase} controller The controller to apply the behavior
         * @param {*} data data to pass to the behavior
         * @return {boolean} bool
         */
        _apply: function(controller, data) {
          context.LogService.error("Behavior " + this.__name + " must override apply()");
          return false;
        },
        /**
         * Attaches the needed observers to the AUI tree.
         * This is the top level implementation. Checks that the behavior isn't already attached
         * @param {classes.ControllerBase} controller the controller
         * @param {*} data the data
         */
        attach: function(controller, data) {
          this.detach(controller, data);
          this._attach(controller, data);
        },

        /**
         * Attaches the needed observers to the AUI tree
         * @protected
         * @param {classes.ControllerBase} controller the controller
         * @param {*} data the data
         */
        _attach: function(controller, data) {},
        /**
         * Detached all AUI tree observers*
         * This is the top level implementation. Checks that the behavior is attached
         * @param {classes.ControllerBase} controller the controller
         * @param {*} data the data
         */
        detach: function(controller, data) {
          this._detach(controller, data);
        },
        /**
         * Detached all AUI tree observers
         * @param {classes.ControllerBase} controller the controller
         * @param {*} data the data
         */
        _detach: function(controller, data) {},
        /**
         * Attaches the needed observers Widget.
         * This is the top level implementation. Checks that the behavior isn't already attached
         * @param {classes.ControllerBase} controller the controller
         * @param {*} data the data
         */
        attachWidget: function(controller, data) {
          this.detachWidget(controller, data);
          this._attachWidget(controller, data);
        },
        /**
         * Attaches the needed observers to Widget
         * @protected
         * @param {classes.ControllerBase} controller the controller
         * @param {*} data the data
         */
        _attachWidget: function(controller, data) {},
        /**
         * Detached all Widget observers*
         * This is the top level implementation. Checks that the behavior is attached
         * @param {classes.ControllerBase} controller the controller
         * @param {*} data the data
         */
        detachWidget: function(controller, data) {
          this._detachWidget(controller, data);
        },
        /**
         * Detached all Widget observers
         * @protected
         * @param {classes.ControllerBase} controller the controller
         * @param {*} data the data
         */
        _detachWidget: function(controller, data) {},
        /**
         * Attach the behavior to the controller
         * @param {classes.ControllerBase} controller the controller
         * @param {*} data the data
         */
        firstAttach: function(controller, data) {
          this.attach(controller, data);
          this.attachWidget(controller, data);
        },
        /**
         * get a list of pair node/attribute names
         * @return {Object} the watched attributes
         * @protected
         */
        _getWatchedAttributes: function() {
          return this._watchedAttributes;
        },
        /**
         * test if the behavior can apply to the controller
         * @param {classes.ControllerBase} controller the controller
         * @param {*} data the data
         * @param {classes.TreeModificationTracker} treeModificationTrack tree modifications log
         * @return {boolean} true if behavior can apply to the controller
         */
        canApply: function(controller, data, treeModificationTrack) {
          if (data.dirty) {
            return true;
          }

          if (this.watchedAttributes) {
            var len = this.watchedBindingsCount;
            for (var i = 0; i < len; ++i) {
              var nodeBinding = this.watchedBindings[i];
              var node = controller._nodeBindings[nodeBinding];
              if (!!node) {
                if (treeModificationTrack.isNodeCreated(node)) {
                  return true;
                }
                var modifiedAttributes = treeModificationTrack.getChangedAttributes(node._id);
                var nodeWatchedAttributes = this.watchedAttributes[nodeBinding],
                  attrLen = nodeWatchedAttributes.length;
                for (var j = 0; j < attrLen; ++j) {
                  if (modifiedAttributes[nodeWatchedAttributes[j]]) {
                    return true;
                  }
                }
              }
            }
          }

          var watched = this._getWatchedAttributes();
          if (watched) {
            var xi = 0,
              xlen = watched.length;

            for (; xi < xlen; xi++) {
              var current = watched[xi];
              if (!current.node) {
                continue;
              }
              if (treeModificationTrack.isNodeCreated(current.node._id)) {
                return true;
              }
              if (treeModificationTrack.isNodeAttributeChanged(current.node._id, current.attribute)) {
                return true;
              }
            }
          }
          return false;
        },
        /**
         * Cleans up the behavior
         * @param {classes.ControllerBase} controller the controller
         * @param {*} data the data
         */
        cleanup: function(controller, data) {
          this.detachWidget(controller, data);
          this.detach(controller, data);
        }
      };
    });
  });
;
"use strict";

modulum('ActivePseudoSelectorBehavior', ['PseudoSelectorBehaviorBase'],
  function(context, cls) {
    /**
     * @class ActivePseudoSelectorBehavior
     * @memberOf classes
     * @extends classes.PseudoSelectorBehaviorBase
     */
    cls.ActivePseudoSelectorBehavior = context.oo.Singleton(cls.PseudoSelectorBehaviorBase, function($super) {
      return /** @lends classes.ActivePseudoSelectorBehavior.prototype */ {
        __name: "ActivePseudoSelectorBehavior",

        activeChanged: function(controller, data, event, eventData) {
          var node = controller.getAnchorNode();
          if (node._pseudoSelectorsUsedInSubTree.active ||
            node._pseudoSelectorsUsedInSubTree.inactive) {
            this.setStyleBasedBehaviorsDirty(node);
          }
        },

        _attach: function(controller, data) {
          var node = controller.getNodeBindings().container || controller.getAnchorNode();
          data.onActiveAttributeChanged = node.onAttributeChanged('active', this.activeChanged.bind(this, controller, data));
        },

        _detach: function(controller, data) {
          if (data.onActiveAttributeChanged) {
            data.onActiveAttributeChanged();
            data.onActiveAttributeChanged = null;
          }
        }
      };
    });
  }
);
;
"use strict";

modulum('DialogTypePseudoSelectorBehavior', ['PseudoSelectorBehaviorBase'],
  function(context, cls) {
    /**
     * @class DialogTypePseudoSelectorBehavior
     * @memberOf classes
     * @extends classes.PseudoSelectorBehaviorBase
     */
    cls.DialogTypePseudoSelectorBehavior = context.oo.Singleton(cls.PseudoSelectorBehaviorBase, function($super) {
      return /** @lends classes.DialogTypePseudoSelectorBehavior.prototype */ {
        __name: "DialogTypePseudoSelectorBehavior",

        dialogTypeChanged: function(controller, data, event, eventData) {
          var node = controller.getNodeBindings().container;
          if (node._pseudoSelectorsUsedInSubTree.display ||
            node._pseudoSelectorsUsedInSubTree.input ||
            node._pseudoSelectorsUsedInSubTree.display) {
            this.setStyleBasedBehaviorsDirty(node);
          }
        },

        _attach: function(controller, data) {
          var node = controller.getNodeBindings().container;
          data.onDialogTypeAttributeChanged = node.onAttributeChanged('dialogType', this.dialogTypeChanged.bind(this, controller,
            data));
        },

        _detach: function(controller, data) {
          if (data.onDialogTypeAttributeChanged) {
            data.onDialogTypeAttributeChanged();
            data.onDialogTypeAttributeChanged = null;
          }
        }
      };
    });
  }
);
;
"use strict";

modulum('FocusCurrentCellPseudoSelectorBehavior', ['PseudoSelectorBehaviorBase'],
  function(context, cls) {
    /**
     * @class FocusCurrentCellPseudoSelectorBehavior
     * @memberOf classes
     * @extends classes.PseudoSelectorBehaviorBase
     */
    cls.FocusCurrentCellPseudoSelectorBehavior = context.oo.Singleton(cls.PseudoSelectorBehaviorBase, function($super) {
      return /** @lends classes.FocusCurrentCellPseudoSelectorBehavior.prototype */ {
        __name: "FocusCurrentCellPseudoSelectorBehavior",

        currentCellChanged: function(controller, data) {
          var node = controller.getAnchorNode();
          if (node._pseudoSelectorsUsedInSubTree.focus) {
            var offset = node.attribute('offset');
            var currentRowIndex = node.attribute('currentRow') - offset;
            if (node.getTag() === 'Table') {
              var currentColumn = node.attribute('currentColumn');
              if (data.previousCurrentRowIndex !== undefined && data.previousCurrentColumn !== undefined) {
                this._setTableCellStyleBasedBehaviorsDirty(node, data.previousCurrentRowIndex, data.previousCurrentColumn);
              }
              this._setTableCellStyleBasedBehaviorsDirty(node, currentRowIndex, currentColumn);
              data.previousCurrentRowIndex = currentRowIndex;
              data.previousCurrentColumn = currentColumn;
            } else {
              if (data.previousCurrentRowIndex !== undefined) {
                this._setColumnCellStyleBasedBehaviorsDirty(node, data.previousCurrentRowIndex);
              }
              this._setColumnCellStyleBasedBehaviorsDirty(node, currentRowIndex);
              data.previousCurrentRowIndex = currentRowIndex;
            }
          }
        },

        _setTableCellStyleBasedBehaviorsDirty: function(table, rowIndex, columnIndex) {
          var column = table.getChildren('TableColumn')[columnIndex];
          if (!!column) {
            this._setColumnCellStyleBasedBehaviorsDirty(column, rowIndex);
          }
        },

        _setColumnCellStyleBasedBehaviorsDirty: function(container, rowIndex) {
          var valueList = container.getFirstChild('ValueList');
          if (!!valueList) {
            var value = valueList.getChildren()[rowIndex];
            if (!!value) {
              var ctrl = value.getController();
              if (!!ctrl) {
                ctrl.setStyleBasedBehaviorsDirty();
              }
            }
          }
        },

        _attach: function(controller, data) {
          var node = controller.getAnchorNode();
          var updateFunction = this.currentCellChanged.bind(this, controller, data);
          data.onCurrentRowAttributeChanged = node.onAttributeChanged('currentRow', updateFunction);
          data.onOffsetAttributeChanged = node.onAttributeChanged('offset', updateFunction);
          if (node.getTag() === 'Table') {
            data.onCurrentColumnAttributeChanged = node.onAttributeChanged('currentColumn', updateFunction);
          }
        },

        _detach: function(controller, data) {
          if (data.onCurrentColumnAttributeChanged) {
            data.onCurrentColumnAttributeChanged();
            data.onCurrentColumnAttributeChanged = null;
          }
          if (data.onOffsetAttributeChanged) {
            data.onOffsetAttributeChanged();
            data.onOffsetAttributeChanged = null;
          }
          if (data.onCurrentRowAttributeChanged) {
            data.onCurrentRowAttributeChanged();
            data.onCurrentRowAttributeChanged = null;
          }
        }
      };
    });
  }
);
;
"use strict";

modulum('FocusPseudoSelectorBehavior', ['PseudoSelectorBehaviorBase'],
  function(context, cls) {
    /**
     * @class FocusPseudoSelectorBehavior
     * @memberOf classes
     * @extends classes.PseudoSelectorBehaviorBase
     */
    cls.FocusPseudoSelectorBehavior = context.oo.Singleton(cls.PseudoSelectorBehaviorBase, function($super) {
      return /** @lends classes.FocusPseudoSelectorBehavior.prototype */ {
        __name: "FocusPseudoSelectorBehavior",

        focusChanged: function(controller, data, event, node, eventData) {
          var uiNode = controller.getAnchorNode();
          if (uiNode._pseudoSelectorsUsedInSubTree.focus) {
            if (!!eventData.old) {
              var oldFocusedNode = uiNode.getApplication().getNode(eventData.old);
              // Previously focused node may have been removed from the AUI tree.
              if (!!oldFocusedNode) {
                if (oldFocusedNode._pseudoSelectorsUsedInSubTree.focus) {
                  this.setStyleBasedBehaviorsDirty(oldFocusedNode);
                }
              }
            }
            var newFocusedWidget = uiNode.getApplication().getNode(eventData.new);
            if (newFocusedWidget && newFocusedWidget._pseudoSelectorsUsedInSubTree.focus) {
              this.setStyleBasedBehaviorsDirty(newFocusedWidget);
            }
          }
        },

        _attach: function(controller, data) {
          var uiNode = controller.getAnchorNode();
          data.onFocusAttributeChanged = uiNode.onAttributeChanged('focus', this.focusChanged.bind(this, controller, data));
        },

        _detach: function(controller, data) {
          if (data.onFocusAttributeChanged) {
            data.onFocusAttributeChanged();
            data.onFocusAttributeChanged = null;
          }
        }
      };
    });
  }
);
;
"use strict";

modulum('OffsetPseudoSelectorBehavior', ['PseudoSelectorBehaviorBase'],
  function(context, cls) {
    /**
     * @class OffsetPseudoSelectorBehavior
     * @memberOf classes
     * @extends classes.PseudoSelectorBehaviorBase
     */
    cls.OffsetPseudoSelectorBehavior = context.oo.Singleton(cls.PseudoSelectorBehaviorBase, function($super) {
      return /** @lends classes.OffsetPseudoSelectorBehavior.prototype */ {
        __name: "OffsetPseudoSelectorBehavior",

        offsetChanged: function(controller, data, event, eventData) {
          var node = controller.getAnchorNode();
          if (node._pseudoSelectorsUsedInSubTree.even ||
            node._pseudoSelectorsUsedInSubTree.odd) {
            this.setStyleBasedBehaviorsDirty(node);
          }
        },

        _attach: function(controller, data) {
          var node = controller.getAnchorNode();
          data.onOffsetAttributeChanged = node.onAttributeChanged('offset', this.offsetChanged.bind(this, controller, data));
        },

        _detach: function(controller, data) {
          if (data.onOffsetAttributeChanged) {
            data.onOffsetAttributeChanged();
            data.onOffsetAttributeChanged = null;
          }
        }
      };
    });
  });
;
"use strict";

modulum('PseudoSelectorBehaviorBase', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class PseudoSelectorBehaviorBase
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.PseudoSelectorBehaviorBase = context.oo.Class(cls.BehaviorBase, function($super) {
      return /** @lends classes.PseudoSelectorBehaviorBase.prototype */ {
        __name: "PseudoSelectorBehaviorBase",
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {},

        /**
         * set node and all its descendants controllers dirty
         * @param {classes.NodeBase} rootNode main node
         */
        setStyleBasedBehaviorsDirty: function(rootNode) {
          rootNode.forThisAndEachDescendant(function(node) {
            var controller = node.getController();
            if (!!controller) {
              controller.setStyleBasedBehaviorsDirty();
            }
          });
        }
      };
    });
  });
;
"use strict";

modulum('ButtonRequestFocusUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * @class ButtonRequestFocusUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.ButtonRequestFocusUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.ButtonRequestFocusUIBehavior.prototype */ {
        __name: "ButtonRequestFocusUIBehavior",

        /**
         *
         * @protected
         */
        _attachWidget: function(controller, data) {
          var widget = controller.getWidget();
          if (!!widget) {
            data.focusListener = widget.when(context.constants.widgetEvents.click, this._onRequestFocus.bind(this, controller));
          }
        },
        /**
         * @inheritDoc
         */
        _detachWidget: function(controller, data) {
          if (data.focusListener) {
            data.focusListener();
            data.focusListener = null;
          }
        },
        /**
         *
         * @param controller
         * @param {Object} event - DOM event
         * @param src
         * @param domEvent
         * @private
         */
        _onRequestFocus: function(controller, event, src, domEvent) {
          if (controller && controller.scrollGridLineController) {
            controller.scrollGridLineController._onClick();
            if (domEvent && domEvent.stopPropagation) {
              domEvent.stopPropagation();
            }
          }
        }
      };
    });
  });
;
"use strict";

modulum('CanvasItemOnClickUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * @class CanvasItemOnClickUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.CanvasItemOnClickUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.CanvasItemOnClickUIBehavior.prototype */ {
        /** @type {string} */
        __name: "CanvasItemOnClickUIBehavior",

        anchor: ['acceleratorKey1', 'acceleratorKey3'],
        /**
         * @inheritDoc
         */
        _attachWidget: function(controller, data) {
          if (!!controller.getWidget()) {
            data.clickHandle = controller.getWidget().when(gbc.constants.widgetEvents.click, this._onClick.bind(this, controller,
              false));
            data.rightClickHandle = controller.getWidget().when(gbc.constants.widgetEvents.rightClick, this._onClick.bind(this,
              controller, true));
          }
        },
        /**
         * @inheritDoc
         */
        _detachWidget: function(controller, data) {
          if (data.clickHandle) {
            data.clickHandle();
            data.clickHandle = null;
          }
          if (data.rightClickHandle) {
            data.rightClickHandle();
            data.rightClickHandle = null;
          }
        },
        /**
         * @inheritDoc
         */
        _apply: function(controller) {
          var anchorNode = controller.getAnchorNode();
          if (!anchorNode.attribute('acceleratorKey1') && !anchorNode.attribute('acceleratorKey3')) {
            controller.getWidget().addClass("gbc_noPointerEvents");
          }
        },
        /**
         *
         * @param controller
         * @param isRightClick
         * @private
         */
        _onClick: function(controller, isRightClick) {
          var anchorNode = controller.getAnchorNode();

          var acceleratorKey = null;
          if (!isRightClick) {
            acceleratorKey = anchorNode.attribute('acceleratorKey1');
            // Left mouse button
          } else {
            // Right mouse button
            acceleratorKey = anchorNode.attribute('acceleratorKey3');
          }
          if (acceleratorKey) {
            var app = anchorNode.getApplication();
            var vmEvent = new cls.VMKeyEvent(acceleratorKey, anchorNode.getId());
            app.typeahead.event(vmEvent, anchorNode);
          }
        }
      };
    });
  }
);
;
"use strict";

modulum('ChangePageUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * @class ChangePageUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.ChangePageUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.ChangePageUIBehavior.prototype */ {
        /** @type {string} */
        __name: "ChangePageUIBehavior",
        /**
         * @inheritDoc
         */
        _attachWidget: function(controller, data) {
          var widget = controller.getWidget();
          if (!!widget) {
            data.changeHandle = widget.when(context.constants.widgetEvents.change, this._pageChanged.bind(this, controller, data));
            data.requestFocusHandle = widget.when(context.constants.widgetEvents.requestFocus, this._requestFocus.bind(this,
              controller, data));
          }
        },
        /**
         * @inheritDoc
         */
        _detachWidget: function(controller, data) {
          if (data.changeHandle) {
            data.changeHandle();
            data.changeHandle = null;
          }
          if (data.requestFocusHandle) {
            data.requestFocusHandle();
            data.requestFocusHandle = null;
          }
        },

        /**
         * Page changed
         * @param controller
         * @param data
         * @param evt
         * @param folder
         * @param page
         * @param {boolean=} executeAction - true if we need to execute action on page change, false otherwise
         * @private
         */

        _pageChanged: function(controller, data, evt, folder, page, executeAction) {
          var node = controller.getAnchorNode();
          var app = node.getApplication();

          app.getUI().getWidget().getLayoutInformation().invalidateMeasure();
          app.layout.refreshLayout();
          // If not specified, execute action
          executeAction = typeof executeAction !== "undefined" ? executeAction : true;
          if (app && app.action && executeAction) {
            var currentPageWidget = node.getWidget().getCurrentPage();
            var options = {};
            if (currentPageWidget) {
              app.action.execute(currentPageWidget._auiTag, null, options);
            }
          }
        },

        /**
         * If current focused node is child of previous page, request focus on first focusable widget of the current page
         * @private
         */
        _requestFocus: function(controller, data) {
          var node = controller.getAnchorNode();
          var folderWidget = controller.getWidget();
          var focusedWidget = null;
          var focusedNode = node.getApplication().getFocusedVMNodeAndValue(true);
          if (focusedNode) {
            focusedWidget = focusedNode.getController().getWidget();
          }
          if (!focusedWidget || focusedWidget.isChildOf(folderWidget)) {
            var pageIndex = folderWidget.getCurrentPage() ? folderWidget.getCurrentPage().getPageIndex() : -1;
            if (pageIndex >= 0 && pageIndex < node.getChildren().length) {
              var pageNode = node.getChildren()[pageIndex];

              var pageHasActiveAction = pageNode.attribute("actionActive") !== 0 && pageNode.isAttributeSetByVM("actionIdRef");

              //1. When no action is associated to a folder page,
              //   the front-end can choose to set the focus to the next focusable element (here inside a sub-page).
              //2. When an action is associated to a folder page,
              //   it's typically in the hands of the program to decide what to do,
              //   and the front-end should not overwrite this.
              if (!pageHasActiveAction) {
                // request focus on the first active widget
                var firstActiveNode = this._getFirstFocusableField(pageNode);
                if (firstActiveNode) {
                  if (firstActiveNode.getCurrentValueNode && firstActiveNode.getCurrentValueNode(false)) {
                    firstActiveNode = firstActiveNode.getCurrentValueNode(false);
                  }
                  var firstActiveController = firstActiveNode.getController();
                  if (firstActiveController) {
                    var firstActiveWidget = firstActiveController.getWidget();
                    if (firstActiveWidget) {
                      if (firstActiveNode.isInTable()) {
                        // if we land in a table, this one should ask the VM rather than the field
                        firstActiveWidget.getTableWidgetBase().emit(context.constants.widgetEvents.requestFocus);
                      } else {
                        firstActiveWidget.emit(context.constants.widgetEvents.requestFocus);
                      }
                    }
                  }
                }
              }
            }
          }
        },

        /**
         *
         * @param node
         * @return {*}
         * @private
         */
        _getFirstFocusableField: function(node) {
          if (['FormField', 'Table', 'Matrix', 'Button'].indexOf(node.getTag()) !== -1 &&
            node.attribute("active") !== 0 &&
            (!node.isAttributeSetByVM("tabIndex") || node.attribute("tabIndex") !== 0)) {
            return node;
          }
          var nodeChildren = node.getChildren();
          for (var i = 0; i < nodeChildren.length; ++i) {
            var focusableNode = this._getFirstFocusableField(nodeChildren[i]);
            if (focusableNode) {
              return focusableNode;
            }
          }
          return null;
        }
      };
    });
  });
;
"use strict";

modulum('ContextMenuUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * Handling context menu
     * @class ContextMenuUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.ContextMenuUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.ContextMenuUIBehavior.prototype */ {
        /** @type {string} */
        __name: "ContextMenuUIBehavior",

        /**
         * @inheritDoc
         */
        _attachWidget: function(controller, data) {
          if (!!controller.getWidget()) {
            data.contextMenuHandle = controller.getWidget().when(gbc.constants.widgetEvents.contextMenu, this._onContextMenu.bind(
              this, controller, data));
          }
        },

        /**
         * @inheritDoc
         */
        _detachWidget: function(controller, data) {
          if (data.contextMenuHandle) {
            data.contextMenuHandle();
            data.contextMenuHandle = null;
          }
        },

        /**
         * Create a typeahead command to open contextmenu
         * @param controller
         * @param data
         * @private
         */
        _onContextMenu: function(controller, data) {

          var widget = controller.getWidget();
          if (widget && widget.show) {
            var anchorNode = controller.getAnchorNode();
            var app = anchorNode.getApplication();
            app.typeahead.callback(widget.show.bind(widget));
          }
        }
      };
    });
  });
;
"use strict";

modulum('HasWebComponentUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * @class HasWebComponentUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.HasWebComponentUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.HasWebComponentUIBehavior.prototype */ {
        /** @type {string} */
        __name: "HasWebComponentUIBehavior",
        /**
         * @inheritDoc
         */
        _attachWidget: function(controller, data) {
          if (!!controller.getWidget() && controller.getWidget()._iframeElement) {
            var parentNode = controller.getAnchorNode().getParentNode();
            while (parentNode) {
              if (parentNode.getWidget() && parentNode.getWidget().setHasChildWebComponent) {
                parentNode.getWidget().setHasChildWebComponent(true);
              }
              parentNode = parentNode.getParentNode();
            }
          }
        },
        /**
         * @inheritDoc
         */
        _detachWidget: function(controller, data) {
          //TODO many Webcomp

        }

      };
    });
  });
;
"use strict";

modulum('InterruptUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * @class InterruptUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.InterruptUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.InterruptUIBehavior.prototype */ {
        /** @type {string} */
        __name: "InterruptUIBehavior",
        /**
         * @inheritDoc
         */
        _attachWidget: function(controller, data) {
          var node = controller.getAnchorNode();
          if (node.attribute('name') === 'interrupt') {
            var widget = controller.getWidget();
            if (!!widget) {
              var application = node && node.getApplication();
              if (application && application.action) {
                application.action.registerInterruptWidget(widget);
              }
              if (!application.action.hasAction("interrupt")) {
                widget.setInterruptable(true);
                data.actionHandle = widget.when(gbc.constants.widgetEvents.click, this._onAction.bind(this, controller, data));
              }
            }
          }
        },
        /**
         * @inheritDoc
         */
        _detachWidget: function(controller, data) {
          var widget = controller.getWidget();
          if (!!widget) {
            var node = controller.getAnchorNode();
            var application = node && node.getApplication();
            if (application && application.action) {
              application.action.unregisterInterruptWidget(widget);
            }
            widget.setInterruptable(false);
          }
          if (this.actionHandle) {
            this.actionHandle();
            this.actionHandle = null;
          }
        },
        /**
         * Creates an action event and sends it to the VM
         */
        _onAction: function(controller) {
          var node = controller.getAnchorNode(),
            application = node && node.getApplication();
          if (application) {
            if (application.isIdle()) {
              application.action.executeByName("interrupt");
            } else if (!application.action.hasAction("interrupt")) {
              application.interrupt();
            }
          }
        }
      };
    });
  });
;
"use strict";

modulum('OnActionUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * @class OnActionUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.OnActionUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.OnActionUIBehavior.prototype */ {
        /** @type {string} */
        __name: "OnActionUIBehavior",
        /**
         * @inheritDoc
         */
        _attachWidget: function(controller, data) {
          if (!!controller.getWidget()) {
            data.actionHandle = controller.getWidget().when(cls.WebComponentWidget.actionEvent, this._onAction.bind(this,
              controller,
              data));
          }
        },
        /**
         * @inheritDoc
         */
        _detachWidget: function(controller, data) {
          if (data.actionHandle) {
            data.actionHandle();
            data.actionHandle = null;
          }
        },
        /**
         * Creates an action event and sends it to the VM
         * @private
         */
        _onAction: function(controller, data, event, src, actionName) {
          var node = controller.getAnchorNode();
          // Pass the Webcomponent node to ensure its value is flushed
          node.getApplication().action.executeByName(actionName, node, {
            sendValue: true
          });
        }
      };
    });
  });
;
"use strict";

modulum('OnClickStartMenuCommandUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * @class OnClickStartMenuCommandUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.OnClickStartMenuCommandUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.OnClickStartMenuCommandUIBehavior.prototype */ {
        /** @type {string} */
        __name: "OnClickStartMenuCommandUIBehavior",
        /**
         * @inheritDoc
         */
        _attachWidget: function(controller, data) {
          var widget = controller.getWidget();
          if (widget) {
            data.clickHandle = widget.when(gbc.constants.widgetEvents.click, this._onClick.bind(this, controller, data));
          }
        },

        /**
         * @inheritDoc
         */
        _detachWidget: function(controller, data) {
          if (data.clickHandle) {
            data.clickHandle();
            data.clickHandle = null;
          }
        },

        /**
         * Creates an action event and sends it to the VM
         */
        _onClick: function(controller, data) {
          var node = controller.getAnchorNode();
          node.getApplication().action.execute(node.getId());
          var appHost = gbc.HostService.getApplicationHostWidget();
          if (appHost.getSideBar().isDisplayed()) {
            appHost.hideSidebar();
          }
        }
      };
    });
  });
;
"use strict";

modulum('OnClickUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * @class OnClickUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.OnClickUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.OnClickUIBehavior.prototype */ {
        /** @type {string} */
        __name: "OnClickUIBehavior",
        /**
         * @inheritDoc
         */
        _attachWidget: function(controller, data) {
          if (!!controller.getWidget()) {
            data.clickHandle = controller.getWidget().when(gbc.constants.widgetEvents.click, this._onClick.bind(this, controller,
              data));
          }
        },
        /**
         * @inheritDoc
         */
        _detachWidget: function(controller, data) {
          if (data.clickHandle) {
            data.clickHandle();
            data.clickHandle = null;
          }
        },

        /**
         * Creates an action command
         */
        _onClick: function(controller, data, gbcEvent, element, domEvent, actionOnly) {
          var bindings = controller.getNodeBindings();
          var app = bindings.anchor.getApplication();
          var actionNode = bindings.decorator ? bindings.decorator : bindings.anchor;

          var options = {};
          if (!actionOnly) {
            options.sendValue = true;
          }

          app.action.execute(actionNode.getId(), null, options);
        }
      };
    });
  });
;
"use strict";

modulum('OnDataUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * @class OnDataUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.OnDataUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.OnDataUIBehavior.prototype */ {
        /** @type {string} */
        __name: "OnDataUIBehavior",
        /**
         * @inheritDoc
         */
        _attachWidget: function(controller, data) {
          if (!!controller.getWidget()) {
            data.dataHandle = controller.getWidget().when(cls.WebComponentWidget.dataEvent, this._onData.bind(this, controller,
              data));
          }
        },
        /**
         * @inheritDoc
         */
        _detachWidget: function(controller, data) {
          if (data.dataHandle) {
            data.dataHandle();
            data.dataHandle = null;

          }
        },

        /**
         * On data widget event
         * @private
         */
        _onData: function(controller, data, event, widget, eventData) {
          if (widget._flushValue !== eventData) {
            widget._flushValue = eventData;
          }
        }
      };
    });
  });
;
"use strict";

modulum('OnLayoutPagedUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * @class OnLayoutPagedUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.OnLayoutPagedUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.OnLayoutPagedUIBehavior.prototype */ {
        /** @type {string} */
        __name: "OnLayoutPagedUIBehavior",
        /**
         * @inheritDoc
         */
        _attachWidget: function(controller, data) {
          var node = controller.getAnchorNode();
          data.afterLayoutHandler = node.getApplication().layout.afterLayout(this._onLayout.bind(this, controller, data));
        },
        /**
         * @inheritDoc
         */
        _detachWidget: function(controller, data) {
          if (data.afterLayoutHandler) {
            data.afterLayoutHandler();
            data.afterLayoutHandler = null;
          }
        },

        /**
         * On layout widget event: send new page size to vm
         * @private
         */
        _onLayout: function(controller, data) {
          var node = controller.getAnchorNode();
          var pageSize = node.attribute('pageSize');

          var widget = controller.getWidget();
          var app = node.getApplication();

          if (app) {
            var dataAreaWidth = widget.getDataAreaWidth();
            var dataAreaHeight = widget.getDataAreaHeight();
            if (!isNaN(dataAreaHeight) && !isNaN(dataAreaWidth)) {
              var rowWidth = widget.getRowWidth();
              var rowHeight = widget.getRowHeight();

              var newPageSize = 1;
              if (rowHeight !== 0 && rowWidth !== 0) {
                var gutter = context.ThemeService.getValue("theme-grid-inner-gutter");
                var margin = context.ThemeService.getValue("theme-margin-ratio") * 8; // Account for margin around each item
                var lines = Math.floor(dataAreaHeight / (rowHeight + (margin * 2 + gutter * 2))) || 1; // for small screens minimum should be 1
                var cols = Math.floor(dataAreaWidth / (rowWidth + 2 * margin)) || 1; // for small screens minimum should be 1
                newPageSize = lines * cols;
              }

              if (app.isIdle() && app.typeahead.hasFinished() && newPageSize !== data.requestedPageSize && (pageSize !==
                  newPageSize)) {
                var event = new cls.VMConfigureEvent(node.getId(), {
                  pageSize: newPageSize,
                  bufferSize: newPageSize
                });
                app.typeahead.event(event, node);
                data.requestedPageSize = newPageSize;
                event = new cls.VMConfigureEvent(node.getId(), {
                  offset: Math.floor(node.attribute('offset') / newPageSize) * newPageSize
                });
                app.typeahead.event(event, node);
              }
            }
          }
        }
      };
    });
  });
;
"use strict";

modulum('OnLayoutUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * @class OnLayoutUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.OnLayoutUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.OnLayoutUIBehavior.prototype */ {
        /** @type {string} */
        __name: "OnLayoutUIBehavior",
        /**
         * @inheritDoc
         */
        _attachWidget: function(controller, data) {
          var node = controller.getAnchorNode();
          data.afterLayoutHandler = node.getApplication().layout.afterLayout(this._onLayout.bind(this, controller, data));
        },
        /**
         * @inheritDoc
         */
        _detachWidget: function(controller, data) {
          if (data.afterLayoutHandler) {
            data.afterLayoutHandler();
            data.afterLayoutHandler = null;
          }
        },

        /**
         * On layout widget event: send new page size to vm
         * @private
         */
        _onLayout: function(controller, data) {
          var node = controller.getAnchorNode();
          var pageSize = node.attribute('pageSize');
          var bufferSize = node.attribute('bufferSize');

          var widget = controller.getWidget();

          var isVisible = widget.isPageVisible ? widget.isPageVisible() : true;
          isVisible = isVisible && widget.isElementInDOM() && widget.isVisibleRecursively();
          // if widget is in a page which is not visible it is not necessary to send a pageSize
          if (isVisible && widget.getDataAreaHeight && widget.getRowHeight) {
            var dataAreaHeight = widget.getDataAreaHeight();
            if (!isNaN(dataAreaHeight)) {
              var rowHeight = widget.getRowHeight();

              var newPageSize = Math.floor(dataAreaHeight / rowHeight);
              newPageSize = Number.isNaN(newPageSize) ? 1 : Math.max(newPageSize, 1);

              var newBufferSize = newPageSize + 1;

              var app = node.getApplication();
              if (app) {
                if (app.isIdle() && !app.typeahead.hasPendingFunctionCallResultCommands(true) && newPageSize !== data
                  .requestedPageSize && (pageSize !==
                    newPageSize ||
                    bufferSize !== newBufferSize)) {

                  var event = new cls.VMConfigureEvent(node.getId(), {
                    pageSize: newPageSize,
                    bufferSize: newBufferSize
                  });

                  // fix illegal offset because of FGL-4900 (code can be removed when dvm bug fixed)
                  var size = node.attribute('size');
                  var offset = node.attribute('offset');
                  if (newPageSize + offset > size) { // newPageSize + offset > size (illegal offset)
                    event.attributes.offset = Math.max(size - newPageSize, 0); // correct offset
                  }

                  app.typeahead.event(event, node);
                  data.requestedPageSize = newPageSize;
                }
              }
            }
          }
        }
      };
    });
  });
;
"use strict";

modulum('OnSplitterUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * @class OnSplitterUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.OnSplitterUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.OnSplitterUIBehavior.prototype */ {
        /** @type {string} */
        __name: "OnSplitterUIBehavior",
        /**
         * @inheritDoc
         */
        _attachWidget: function(controller, data) {
          var widget = controller.getWidget();
          if (!!widget) {
            data.splitterHandle = widget.when(context.constants.widgetEvents.splitter, this._onSplitter.bind(this,
              controller,
              data));
          }

        },
        /**
         * @inheritDoc
         */
        _detachWidget: function(controller, data) {
          if (data.splitterHandle) {
            data.splitterHandle();
            data.splitterHandle = null;
          }
        },

        /**
         *
         * @param controller
         * @param data
         * @private
         */
        _onSplitter: function(controller, data) {
          controller.getWidget().getLayoutEngine().invalidateAllocatedSpace();
          controller.getAnchorNode().getApplication().layout.refreshLayout();
        }
      };
    });
  });
;
"use strict";

modulum('RequestFocusUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * @class RequestFocusUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.RequestFocusUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.RequestFocusUIBehavior.prototype */ {
        __name: "RequestFocusUIBehavior",

        /**
         * @inheritDoc
         */
        _attachWidget: function(controller, data) {
          var widget = controller.getWidget();
          if (!!widget) {
            data.focusListener = widget.when(context.constants.widgetEvents.requestFocus, this._onRequestFocus.bind(this,
              controller,
              data));
          }
        },

        /**
         * @inheritDoc
         */
        _detachWidget: function(controller, data) {
          if (data.focusListener) {
            data.focusListener();
            data.focusListener = null;
          }
          if (data.focusReadyListener) {
            data.focusReadyListener();
            data.focusReadyListener = null;
          }
        },
        /**
         *
         * @param controller
         * @param data
         * @private
         */
        _onRequestFocus: function(controller, data) {
          var anchorNode = controller.getAnchorNode();
          var app = anchorNode.getApplication();
          // Keep capture allowed value when the event is received.
          var restoringFocus = app.focus.isRestoringVMFocus();
          if (!restoringFocus) {

            if (controller.isInMatrix()) {
              var matrixNode = controller.getNodeBindings().container;
              if (matrixNode.attribute("dialogType") === "DisplayArray") {
                var valueNodeIndex = anchorNode.getIndex();
                var offset = matrixNode.attribute('offset');
                var size = matrixNode.attribute('size');
                var currentRow = valueNodeIndex + offset;

                if (currentRow >= size) {
                  // don't request focus if currentRow >= size, this is invalid in Display array
                  return;
                }
              }
            }

            var originWidgetNode = app.focus.getFocusedNode();
            var widget = controller.getWidget();
            if (originWidgetNode !== anchorNode) {

              if (originWidgetNode) {
                var originWidgetController = originWidgetNode.getController();
                if (
                  originWidgetController
                ) { // check if controller exists. In come case we could have a MenuAction node which doesn't have a controller
                  originWidgetController.sendWidgetValue(true);
                }
              }

              var cursors = { // for widgets which don't support cursors send 0,0 to VM to set focus
                start: 0,
                end: 0
              };
              if (widget.hasCursors()) {
                cursors = widget.getCursors();
              }
              app.typeahead.focus(anchorNode, cursors.start, cursors.end);

              this._setFocusToWidget(widget, anchorNode);
            } else if (!widget.hasDOMFocus()) {
              this._setFocusToWidget(widget);
            }
          }
        },
        /**
         *
         * @param {classes.WidgetBase} widget
         * @param {classes.NodeBase} [node]
         * @private
         */
        _setFocusToWidget: function(widget, node) {
          // set the focused node for typeahead (when mouse click)
          if (!!node) {
            node.getApplication().focus.setFocusedNode(node);
          }

          var table = widget.getTableWidgetBase();
          if (table && table.isDisplayMode() && widget.isInTable()) { // In a table (DISPLAY ARRAY)
            var tableNode = !!node ? node.getAncestor("Table") : null;
            if (!!tableNode) { // set focus on the table node
              node.getApplication().focus.setFocusedNode(tableNode);
            }
            table.setFocus(true);
            if (node) {
              table.setCurrentRow(node.getIndex());
            }
          } else if (node && widget.isInMatrix()) { // In a matrix
            var matrixNode = node.getParentNode().getParentNode();
            matrixNode.getController().updateCurrentRow(matrixNode, node.getIndex());
          } else {
            widget.setFocus(true);
          }
        }
      };
    });
  });
;
"use strict";

modulum('RowActionUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * Handling row action (double click on table/scrollgrid)
     * @class RowActionUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.RowActionUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.RowActionUIBehavior.prototype */ {
        /** @type {string} */
        __name: "RowActionUIBehavior",

        /**
         * @inheritDoc
         */
        _attachWidget: function(controller, data) {
          if (!!controller.getWidget()) {
            data.rowActionHandle = controller.getWidget().when(gbc.constants.widgetEvents.rowAction, this._onRowAction.bind(
              this, controller, data));
          }
        },

        /**
         * @inheritDoc
         */
        _detachWidget: function(controller, data) {
          if (data.rowActionHandle) {
            data.rowActionHandle();
            data.rowActionHandle = null;
          }
        },

        /**
         * Creates an action event and sends it to the VM
         * @param controller
         * @param data
         * @private
         */
        _onRowAction: function(controller, data) {
          var anchorNode = controller.getAnchorNode();

          // Table case
          if (anchorNode.getTag().startsWith('Table')) {
            var tableNode = anchorNode.getTag() === 'Table' ? anchorNode : anchorNode.getParentNode();
            var active = tableNode.attribute('actionActive');
            var tableWidget = tableNode.getController().getWidget();
            var noEntry = anchorNode.attribute('noEntry');
            var doubleClickEnable = tableNode.attribute('doubleClick').length > 0 || tableWidget.isDisplayMode();

            if (tableWidget && active && doubleClickEnable && (tableWidget.isDisplayMode() || noEntry === 1)) {
              anchorNode.getApplication().action.execute(tableNode.getId());
            }
          }
          // Scrollgrid case
          else if (anchorNode.getTag() === 'ScrollGrid') {
            if (anchorNode.isAttributeSetByVM("doubleClick")) {
              anchorNode.getApplication().action.execute(anchorNode.getId());
            } else {
              var matrix = anchorNode.getFirstChild('Matrix');
              if (matrix && matrix.attribute('dialogType').indexOf('Display') !== -1) {
                // TODO GBC-1760 we should use ActionApplicationService to search an action
                var dialog = anchorNode.getAncestor('Window').getActiveDialog();
                var acceptAction = dialog.getFirstChildWithAttribute(null, 'name', 'accept');
                if (acceptAction) {
                  anchorNode.getApplication().action.execute(acceptAction.getId());
                }
              }
            }
          }
        }
      };
    });
  });
;
"use strict";

modulum('RowAndSelectionUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * @class RowAndSelectionUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.RowAndSelectionUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.RowAndSelectionUIBehavior.prototype */ {
        /** @type {string} */
        __name: "RowAndSelectionUIBehavior",
        /**
         * @inheritDoc
         */
        _attachWidget: function(controller, data) {
          data.lastEvent = null;
          var widget = controller.getWidget();
          if (!!widget) {
            data.downHandle = widget.when(gbc.constants.widgetEvents.keyArrowDown, this._onNavigationKey.bind(this, controller,
              "nextrow"));
            data.upHandle = widget.when(gbc.constants.widgetEvents.keyArrowUp, this._onNavigationKey.bind(this, controller,
              "prevrow"));
            data.pageDownHandle = widget.when(gbc.constants.widgetEvents.keyPageDown, this._onNavigationKey.bind(this, controller,
              "nextpage"));
            data.pageUpHandle = widget.when(gbc.constants.widgetEvents.keyPageUp, this._onNavigationKey.bind(this, controller,
              "prevpage"));
            data.homeHandle = widget.when(gbc.constants.widgetEvents.keyHome, this._onNavigationKey.bind(this, controller,
              "firstrow"));
            data.endHandle = widget.when(gbc.constants.widgetEvents.keyEnd, this._onNavigationKey.bind(this, controller, "lastrow"));

            data.leftHandle = widget.when(gbc.constants.widgetEvents.keyArrowLeft, this._onKeyLeft.bind(this, controller, data));
            data.rightHandle = widget.when(gbc.constants.widgetEvents.keyArrowRight, this._onKeyRight.bind(this, controller, data));

            data.spaceHandle = widget.when(gbc.constants.widgetEvents.keySpace, this._onKeySpace.bind(this, controller, data));
            data.selectAllHandle = widget.when(gbc.constants.widgetEvents.selectAll, this._onSelectAll.bind(this, controller, data));
          }
        },
        /**
         * @inheritDoc
         */
        _detachWidget: function(controller, data) {
          if (data.downHandle) {
            data.downHandle();
            data.downHandle = null;
          }
          if (data.upHandle) {
            data.upHandle();
            data.upHandle = null;
          }
          if (data.leftHandle) {
            data.leftHandle();
            data.leftHandle = null;
          }
          if (data.rightHandle) {
            data.rightHandle();
            data.rightHandle = null;
          }
          if (data.pageDownHandle) {
            data.pageDownHandle();
            data.pageDownHandle = null;
          }
          if (data.pageUpHandle) {
            data.pageUpHandle();
            data.pageUpHandle = null;
          }
          if (data.homeHandle) {
            data.homeHandle();
            data.homeHandle = null;
          }
          if (data.endHandle) {
            data.endHandle();
            data.endHandle = null;
          }
          if (data.spaceHandle) {
            data.spaceHandle();
            data.spaceHandle = null;
          }
          if (data.selectAllHandle) {
            data.selectAllHandle();
            data.selectAllHandle = null;
          }
        },

        /**
         * On navigation key widget event
         * @private
         */
        _onNavigationKey: function(controller, actionName, event, sender, domEvent) {
          var node = controller.getAnchorNode();
          if (node.attribute('multiRowSelection') !== 0) {
            this._sendCommands(controller, actionName, domEvent.ctrlKey || domEvent.metaKey, domEvent.shiftKey);
          } // else is managed by TypeAheadApplicationService
        },

        /**
         * Creates, configures and sends commands
         * @param {classes.TableController} controller
         * @param {string} actionName - action name (nextrow, prevrow, ...)
         * @param {boolean} ctrlKey - true if ctrl or meta key is pressed
         * @param {boolean} shiftKey - true if shift key is pressed
         */
        _sendCommands: function(controller, actionName, ctrlKey, shiftKey) {
          var node = controller.getAnchorNode();
          var app = node.getApplication();

          var sendSelect = !(ctrlKey && !shiftKey);
          if (sendSelect) {
            app.typeahead.rowSelection(node, ctrlKey, shiftKey, cls.TypeAheadRowSelection.currentRow, actionName);
          }

          app.typeahead.currentRow(node, actionName, ctrlKey, shiftKey);
        },

        /**
         * On keyLeft widget event
         * @private
         */
        _onKeyLeft: function(controller, data, event, sender, domEvent) {
          var widget = controller.getWidget();
          if (widget.hasFocusOnField()) {
            var keyEvent = new cls.VMKeyEvent("Left");
            var node = controller.getAnchorNode();
            node.getApplication().typeahead.event(keyEvent, node);
          } else if (widget.isDisplayMode() && !widget.isTreeView()) {
            widget.doHorizontalScroll("left");
          }
        },

        /**
         * On keyRight widget event
         * @private
         */
        _onKeyRight: function(controller, data, event, sender, domEvent) {
          var widget = controller.getWidget();
          if (widget.hasFocusOnField()) {
            var keyEvent = new cls.VMKeyEvent("Right");
            var node = controller.getAnchorNode();
            node.getApplication().typeahead.event(keyEvent, node);
          } else if (widget.isDisplayMode() && !widget.isTreeView()) {
            widget.doHorizontalScroll("right");
          }
        },

        /**
         * On keySpace widget event
         * @private
         */
        _onKeySpace: function(controller, data, event, sender, domEvent) {
          var node = controller.getAnchorNode();
          if (node.attribute('multiRowSelection') !== 0) {
            var app = node.getApplication();
            app.typeahead.rowSelection(node, domEvent.ctrlKey, domEvent.shiftKey, cls.TypeAheadRowSelection.toggle);
          }
        },

        /**
         * On selectAll widget event
         * @private
         */
        _onSelectAll: function(controller, data, event, sender) {
          var node = controller.getAnchorNode();
          if (node.attribute('multiRowSelection') !== 0) {
            var app = node.getApplication();
            app.typeahead.rowSelection(node, false, false, cls.TypeAheadRowSelection.selectAll);
          }
        }
      };
    });
  });
;
"use strict";

modulum('RowSelectionUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * @class RowSelectionUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.RowSelectionUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.RowSelectionUIBehavior.prototype */ {
        __name: "RowSelectionUIBehavior",

        /**
         * @inheritDoc
         * @protected
         */
        _attachWidget: function(controller, data) {
          var widget = controller.getWidget();
          if (!!widget) {
            data.onClickHandle = widget.when(context.constants.widgetEvents.tableClick, this._onClick.bind(this, controller, data));
          }
        },
        /**
         * @inheritDoc
         * @protected
         */
        _detachWidget: function(controller, data) {
          if (data.onClickHandle) {
            data.onClickHandle();
            data.onClickHandle = null;
          }
        },

        _onClick: function(controller, data, event, sender, domEvent) {
          var bindings = controller.getNodeBindings();
          var anchorNode = bindings.anchor;
          var tableNode = bindings.container.getParentNode();
          if (tableNode.attribute('multiRowSelection') !== 0) {
            var offset = tableNode.attribute('offset');
            var index = anchorNode.getIndex();
            var clickedRow = offset + index;

            var vmEvent = tableNode.getController().buildRowSelectionEvent(clickedRow, domEvent.ctrlKey || domEvent.metaKey,
              domEvent.shiftKey);
            tableNode.getApplication().typeahead.event(vmEvent, anchorNode);
          }
        }
      };
    });
  });
;
"use strict";

modulum('ScrollOffsetUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * Dataset scroll behavior. Moves the dataset directly to the requested offset
     * @class ScrollOffsetUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.ScrollOffsetUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.ScrollOffsetUIBehavior.prototype */ {
        __name: "ScrollOffsetUIBehavior",

        /**
         * @inheritDoc
         */
        _attachWidget: function(controller, data) {
          var widget = controller.getWidget();
          data.scrollHandle = widget.when(context.constants.widgetEvents.offset, this._onScrollOffset.bind(this, controller, data));
        },

        /**
         * @inheritDoc
         */
        _detachWidget: function(controller, data) {
          if (data.scrollHandle) {
            data.scrollHandle();
            data.scrollHandle = null;
          }
        },

        /**
         * Send the requested scroll offset to the VM
         * @param controller Widget controller
         * @param data Behavior data
         * @param event source event
         * @private
         */
        _onScrollOffset: function(controller, data, event) {
          var offset = event.data[0];
          var node = controller.getAnchorNode();
          node.getApplication().typeahead.scroll(node, offset);
        }
      };
    });
  });
;
"use strict";

modulum('ScrollUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * @class ScrollUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.ScrollUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.ScrollUIBehavior.prototype */ {
        __name: "ScrollUIBehavior",

        _throttleTimeout: 180,
        /**
         * @inheritDoc
         */
        _attachWidget: function(controller, data) {
          controller.requestOffsetPending = false;
          var widget = controller.getWidget();
          if (widget) {
            data.scrollHandle = widget.when(context.constants.widgetEvents.scroll, this._onScroll.bind(this, controller, data));

            if (controller.nativeVerticalScroll) {
              widget.getScrollableArea().on('wheel.ScrollUIBehavior', this._preventWhenRequestOffsetPending.bind(this, controller));
              widget.getScrollableArea().on('scroll.ScrollUIBehavior', this._preventWhenRequestOffsetPending.bind(this,
                controller));
            } else { // no need to handle these events if widget use native scrolling
              data.mousewheelHandle = widget.when(context.constants.widgetEvents.mousewheel, this._onMousewheel.bind(this,
                controller,
                data));
              data.touchMoveHandle = widget.when(context.constants.widgetEvents.touchMove, this._onTouchMove.bind(this, controller,
                data));
              data.touchStartHandle = widget.when(context.constants.widgetEvents.touchStart, this._onTouchStart.bind(this,
                controller,
                data));
              data.touchEndHandle = widget.when(context.constants.widgetEvents.touchEnd, this._onTouchEnd.bind(this, controller,
                data));
            }
          }
          data.requestedOffset = null;
        },

        /**
         *
         * @param controller
         * @param {Object} event - DOM event
         * @private
         */
        _preventWhenRequestOffsetPending: function(controller, event) {
          // for perf, prevent default when a requestoffset is pending
          if (controller.requestOffsetPending) {
            event.stopPropagation();
            event.stopImmediatePropagation();
          }
        },
        /**
         * @inheritDoc
         */
        _detachWidget: function(controller, data) {
          if (data.throttleScroll) {
            window.clearTimeout(data.throttleScroll);
            data.throttleScroll = null;
          }

          if (data.scrollHandle) {
            data.scrollHandle();
            data.scrollHandle = null;
          }
          if (data.mousewheelHandle) {
            data.mousewheelHandle();
            data.mousewheelHandle = null;
          }
          if (data.touchMoveHandle) {
            data.touchMoveHandle();
            data.touchMoveHandle = null;
          }
          if (data.touchStartHandle) {
            data.touchStartHandle();
            data.touchStartHandle = null;
          }
          if (data.touchEndHandle) {
            data.touchEndHandle();
            data.touchEndHandle = null;
          }

          var widget = controller.getWidget();
          if (widget && controller.nativeVerticalScroll) {
            widget.getScrollableArea().off('wheel.ScrollUIBehavior');
            widget.getScrollableArea().off('scroll.ScrollUIBehavior');
          }
        },

        /**
         *
         * @param controller
         * @param data
         * @param e
         * @return {boolean}
         * @private
         */
        _onScroll: function(controller, data, e) {
          var widget = controller.getWidget();
          if (!widget.isEnabled()) {
            var event = e.data[0];
            return true;
          } else {
            data.lateEvent = e;
            this._updateScrollData(controller, data);
            var size = controller.getAnchorNode().attribute("size");
            var pageSize = Math.max(controller.getAnchorNode().attribute("pageSize"), 1);

            // if requestedOffset === + or === size send directly offset request, no need to post
            if (data.requestedOffset === 0 || data.requestedOffset === (size - pageSize)) {
              this.requestOffset(controller, data);
            } else {
              this._postRequest(controller, data);
            }

          }
        },

        _updateScrollData: function(controller, data) {
          var scrollData = data.lateEvent;
          var forceOffset = scrollData.data[0].forceOffset; // case of scrollbar widget
          if (forceOffset) {
            data.requestedOffset = forceOffset;
          } else {
            var scrollTop = scrollData.data[0].target.scrollTop;
            var lineHeight = scrollData.data[1] ? scrollData.data[1] : 1; //prevent division by 0
            if (controller.nativeVerticalScroll) {
              data.requestedOffset = Math.floor(scrollTop / lineHeight);
            } else { // case in not the same because if we don't use native scroll, first line is always entirely visible
              data.requestedOffset = Math.round(scrollTop / lineHeight);
            }

            var size = controller.getAnchorNode().attribute("size");
            var pageSize = Math.max(controller.getAnchorNode().attribute("pageSize"), 1);
            // request offset must not be greater than (size - pageSize)
            data.requestedOffset = Math.min(data.requestedOffset, (size - pageSize));
          }
        },

        /**
         *
         * @param controller
         * @param data
         * @param e
         * @return {boolean}
         * @private
         */
        _onMousewheel: function(controller, data, e) {
          var widget = controller.getWidget();
          var event = e.data[0];
          if (!widget.isEnabled()) {
            event.stopImmediatePropagation();
            return false;
          } else {
            //event.preventCancelableDefault(); // Not allowed since passive:true
            //throttle events...
            if (data.requestedOffset === null) {
              data.requestedOffset = controller.getAnchorNode().attribute("offset");
            }
            var original = data.requestedOffset;
            var delta = (window.browserInfo.isFirefox ? (53 / 3) : 1) * event.deltaY;

            var size = controller.getAnchorNode().attribute("size");
            var pageSize = Math.max(controller.getAnchorNode().attribute("pageSize"), 1);

            data.requestedOffset += Math.round(delta / 16);
            data.requestedOffset = Math.max(0, Math.min(data.requestedOffset, size - pageSize));

            if (original !== data.requestedOffset) {
              this._postRequest(controller, data);
            }
          }
        },

        /**
         *
         * @param controller
         * @param data
         * @param e
         * @return {boolean}
         * @private
         */
        _onTouchMove: function(controller, data, e) {
          // Don't do anything if the VM offset order is pending
          if (!controller.requestOffsetPending) {
            var widget = controller.getWidget();
            var event = e.data[0];
            if (!widget.isEnabled()) {
              event.stopImmediatePropagation();
              return false;
            } else {
              //throttle events...
              if (data.requestedOffset === null) {
                data.requestedOffset = controller.getAnchorNode().attribute("offset");
              }
              var original = data.requestedOffset;

              if (this._initialTouchPos && event.touches[0]) {
                var deltaY = event.touches[0].clientY;
                var deltaX = event.touches[0].clientX;

                // If scrolling verticaly : continue, horizontaly: do nothing
                if (Math.abs(this._initialTouchPos.x - deltaX) < Math.abs(this._initialTouchPos.y - deltaY)) {
                  var delta = (window.browserInfo.isFirefox ? (53 / 3) : 1) * deltaY;

                  var size = controller.getAnchorNode().attribute("size");
                  var pageSize = Math.max(controller.getAnchorNode().attribute("pageSize"), 1);

                  var move = this._initialTouchPos.y - delta;
                  delta = Math.sign(move) * delta / 8;

                  data.requestedOffset += Math.round(delta / 16);
                  data.requestedOffset = Math.max(0, Math.min(data.requestedOffset, size - pageSize));

                  if (original !== data.requestedOffset) {
                    this._postRequest(controller, data);
                  }
                }
              }
            }
          }

        },

        /**
         *
         * @param controller
         * @param data
         * @param e
         * @private
         */
        _onTouchStart: function(controller, data, e) {
          var event = e.data[0];
          this._initialTouchPos = {
            x: event.touches[0] ? event.touches[0].clientX : 0,
            y: event.touches[0] ? event.touches[0].clientY : 0
          };
        },
        /**
         *
         * @param controller
         * @param data
         * @param e
         * @private
         */
        _onTouchEnd: function(controller, data, e) {
          //this._initialTouchPos = {x:0,y:0};
        },

        /**
         *
         * @param controller
         * @param data
         * @private
         */
        _postRequest: function(controller, data) {
          if (!data.throttleScroll) {
            data.throttleScroll = window.setTimeout(function(controller, data) {
              this.requestOffset(controller, data);
            }.bind(this, controller, data), this._throttleTimeout);
          }
          return this;
        },

        /**
         * Ask the VM for offset
         * @param controller
         * @param data
         */
        requestOffset: function(controller, data) {
          var anchorNode = controller && controller.getAnchorNode();
          if (!anchorNode) {
            return;
          }
          var widget = controller.getWidget();
          if (!widget) {
            return;
          }

          // before requestOffset (clear current throttle timeout)
          window.clearTimeout(data.throttleScroll);
          data.throttleScroll = null;

          // if a request is already pending, post it
          if (controller.requestOffsetPending) {
            this._postRequest(controller, data);
            return;
          }

          if (data.lateEvent) {
            this._updateScrollData(controller, data);
            data.lateEvent = null;
          }

          var typeahead = anchorNode.getApplication() && anchorNode.getApplication().typeahead;
          if (!typeahead.hasFinished()) {
            this._postRequest(controller, data);
            return;
          }

          var node = controller.getAnchorNode();
          var app = node.getApplication();
          if (node.attribute("offset") !== data.requestedOffset) {

            controller.sendWidgetValue();
            if (app.getFocusedVMNode() === node) {
              widget.setFocus();
            }

            controller.requestOffsetPending = true;
            app.typeahead.scroll(node, data.requestedOffset);
            widget.setOffset(data.requestedOffset);
            widget.lastSentOffset = data.requestedOffset;
          }

          data.lateEvent = null;
          data.requestedOffset = null;
        },
      };
    });
  });
;
"use strict";

modulum('SendValueUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * Behavior controlling the widget's visibility
     * @class SendValueUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.SendValueUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.SendValueUIBehavior.prototype */ {
        __name: "SendValueUIBehavior",
        /**
         * @inheritDoc
         */
        _attachWidget: function(controller, data) {
          if (!!controller.getWidget()) {
            data.changeHandle = controller.getWidget().when(context.constants.widgetEvents.change, this._onChange.bind(this,
              controller, data));
          }
        },
        /**
         * @inheritDoc
         */
        _detachWidget: function(controller, data) {
          if (data.changeHandle) {
            data.changeHandle();
            data.changeHandle = null;
          }
        },

        /**
         * Method called when the widget emits a 'changed' event. Its mission is to send value and eventually cursors to VM
         * @param {classes.ValueContainerControllerBase} controller - widget controller
         * @param {object} data - dom event data
         * @param {object} event - dom event
         * @param {HTMLElement} sender - source element
         * @param {boolean} doNotSendValue - by default we send value to VM. If set to true, we don't send value to VM
         * @param {boolean} sendCursors - by default we don't send cursors with value to VM (this is managed by typeahead)
         * @private
         */
        _onChange: function(controller, data, event, sender, doNotSendValue, sendCursors) {
          var widget = controller.getWidget();
          var anchorNode = controller.getAnchorNode();
          var window = anchorNode.getAncestor("Window");
          var dialog = window.getActiveDialog();
          if (dialog) {
            var dialogTouchedNode = dialog.getFirstChildWithAttribute('Action', 'name', 'dialogtouched');
            if (dialogTouchedNode && dialogTouchedNode.attribute('active') === 1) {
              // Force the widget value to be sent in dialogtouched
              anchorNode.getApplication().action.execute(dialogTouchedNode.getId(), anchorNode, {
                sendValue: true
              });
            } else {
              var containerNode = controller.getNodeBindings().container;
              if (!containerNode.isAttributePresent("active") || containerNode.attribute("active") === 1) {
                var decorationNode = controller.getNodeBindings().decorator;
                if (decorationNode) {
                  var completerNode = decorationNode.getFirstChild();
                  if ((completerNode && completerNode.getTag() === "Completer") || sendCursors) {
                    // The item has a completer, send all keys
                    controller.sendWidgetCursors();
                    controller.sendWidgetValue();
                    return; // return to not send value twice
                  }
                }
                if (!doNotSendValue) {
                  controller.sendWidgetValue();
                }
              }
            }
          }
        }
      };
    });
  });
;
"use strict";

modulum('StartMenuPositionUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * Behavior controlling the switch of widget by controller
     * @class StartMenuPositionUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.StartMenuPositionUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.StartMenuPositionUIBehavior.prototype */ {
        __name: "StartMenuPositionUIBehavior",

        usedStyleAttributes: ["startMenuPosition"],
        /**
         * @inheritDoc
         */
        _attachWidget: function(controller, data) {
          var widget = controller.getWidget();
          if (!!widget) {
            data.startMenuPositionHandle = widget.when(cls.UserInterfaceWidget.startMenuPosition, this._onStartMenuPositionChanged.bind(
              this, controller, data));
          }
        },
        /**
         * @inheritDoc
         */
        _detachWidget: function(controller, data) {
          if (data.startMenuPositionHandle) {
            data.startMenuPositionHandle();
            data.startMenuPositionHandle = null;
          }
        },
        /**
         *
         * @param controller
         * @param data
         * @param {Object} event - DOM event
         * @param sender
         * @param windowIdRef
         * @private
         */
        _onStartMenuPositionChanged: function(controller, data, event, sender, windowIdRef) {
          var app = controller.getAnchorNode().getApplication();
          var uiNode = app.uiNode();
          var startMenu = uiNode.getFirstChild('StartMenu');
          if (startMenu) {
            var windowNode = app.getNode(windowIdRef);
            if (windowNode) {
              var kind = windowNode.getStyleAttribute('startMenuPosition');
              if (kind) {
                startMenu.getController().changeWidgetKind(kind);
              }
            }
          }
        }
      };
    });
  });
;
"use strict";

modulum('TableColumnAfterLastItemClickUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * @class TableColumnAfterLastItemClickUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.TableColumnAfterLastItemClickUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.TableColumnAfterLastItemClickUIBehavior.prototype */ {
        /** @type {string} */
        __name: "TableColumnAfterLastItemClickUIBehavior",
        /**
         * @inheritDoc
         */
        _attachWidget: function(controller, data) {
          var widget = controller.getWidget();
          if (!!widget) {
            data.clickHandle = widget.when(gbc.constants.widgetEvents.tableColumnAfterLastItemClick, this._onClick.bind(this,
              controller,
              data));
          }
        },
        /**
         * @inheritDoc
         */
        _detachWidget: function(controller, data) {
          if (data.clickHandle) {
            data.clickHandle();
            data.clickHandle = null;
          }
        },

        /**
         *
         * @param {classes.ControllerBase} controller
         * @param {Object} data

         * @private
         */
        _onClick: function(controller, data) {

          var tableColumnNode = controller.getAnchorNode();

          if (tableColumnNode.attribute('active') === 0) {
            return; // Nothing to do
          }

          var tableNode = tableColumnNode.getParentNode();
          var app = tableNode.getApplication();

          if (tableColumnNode.attribute("dialogType") === "DisplayArray") {
            app.typeahead.focus(tableNode); // only set the focus on the table
            return;
          } else { // not a display array
            if (tableColumnNode.attribute('noEntry') === 1) {
              return; // Nothing to do
            }

            var tableController = tableNode.getController();

            // send current value node value of the table if not already done before requesting focus change
            tableController.sendWidgetValue();

            // when click after the last row, we must send currentRow = size to VM
            var columnIndex = tableColumnNode.getIndex('TableColumn');
            var rowIndex = tableNode.attribute("size");

            var event = new cls.VMConfigureEvent(tableNode.getId(), {
              currentColumn: columnIndex,
              currentRow: rowIndex
            });

            app.typeahead.event(event, tableColumnNode);
          }
        }
      };
    });
  });
;
"use strict";

modulum('TableColumnDnDUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * @class TableColumnDndUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.TableColumnDndUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.TableColumnDndUIBehavior.prototype */ {
        /** @type {string} */
        __name: "TableColumnDnDUIBehavior",
        /**
         * @inheritDoc
         */
        _attachWidget: function(controller, data) {
          var widget = controller.getWidget();
          if (!!widget) {
            data.dndStartHandle = widget.when(gbc.constants.widgetEvents.tableDragStart, this._onTableDragStart.bind(this,
              controller,
              data));
            data.dndEndHandle = widget.when(gbc.constants.widgetEvents.tableDragEnd, this._onTableDragEnd.bind(this, controller,
              data));
            data.dndDropHandle = widget.when(gbc.constants.widgetEvents.tableDrop, this._onTableDrop.bind(this, controller, data));
            data.dndOverHandle = widget.when(gbc.constants.widgetEvents.tableDragOver, this._onTableDragOver.bind(this, controller,
              data));
            data.dndLeaveHandle = widget.when(gbc.constants.widgetEvents.tableDragLeave, this._onTableDragLeave.bind(this,
              controller,
              data));
            data.dndEnterHandle = widget.when(gbc.constants.widgetEvents.tableDragEnter, this._onTableDragEnter.bind(this,
              controller,
              data));
          }
        },
        /**
         * @inheritDoc
         */
        _detachWidget: function(controller, data) {
          if (data.dndStartHandle) {
            data.dndStartHandle();
            data.dndStartHandle = null;
          }
          if (data.dndEndHandle) {
            data.dndEndHandle();
            data.dndEndHandle = null;
          }
          if (data.dndDropHandle) {
            data.dndDropHandle();
            data.dndDropHandle = null;
          }
          if (data.dndOverHandle) {
            data.dndOverHandle();
            data.dndOverHandle = null;
          }
          if (data.dndLeaveHandle) {
            data.dndLeaveHandle();
            data.dndLeaveHandle = null;
          }
          if (data.dndEnterHandle) {
            data.dndEnterHandle();
            data.dndEnterHandle = null;
          }
        },

        /**
         * Get value node corresponding to index in the column
         * @param columnNode
         * @param index
         * @returns {*|classes.NodeBase}
         * @private
         */
        _getValueNode: function(columnNode, index) {
          var valueListNode = columnNode.getFirstChild("ValueList");
          return valueListNode && valueListNode.getChildren()[index];
        },

        /**
         * Handle tableDragStart event
         * @private
         */
        _onTableDragStart: function(controller, data, event, sender, index, evt) {
          var node = controller.getAnchorNode();
          context.DndService.onDragStart(node.getParentNode(), this._getValueNode(node, index), evt);
        },

        /**
         * Handle tableDragEnd event
         * @private
         */
        _onTableDragEnd: function(controller, data) {
          context.DndService.onDragEnd();
        },

        /**
         * Handle tableDrop event
         * @private
         */
        _onTableDrop: function(controller, data, event, sender, index) {
          var node = controller.getAnchorNode();
          context.DndService.onDrop(this._getValueNode(node, index));
        },

        /**
         * Handle tableDragOver event
         * @private
         */
        _onTableDragOver: function(controller, data, event, sender, index, evt) {
          var node = controller.getAnchorNode();
          context.DndService.onDragOver(node.getParentNode(), this._getValueNode(node, index), evt);
        },

        /**
         * Handle tableDragLeave event
         * @private
         */
        _onTableDragLeave: function(controller, data, event, sender, index, evt) {
          var node = controller.getAnchorNode();
          context.DndService.onDragLeave(node.getParentNode(), this._getValueNode(node, index), evt);
        },

        /**
         * Handle tableDragEnter event
         * @private
         */
        _onTableDragEnter: function(controller, data, event, sender, index, evt) {
          var node = controller.getAnchorNode();
          context.DndService.onDragEnter(node.getParentNode(), this._getValueNode(node, index), evt);
        }
      };
    });
  });
;
"use strict";

modulum('TableColumnHideUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * @class TableColumnHideUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.TableColumnHideUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.TableColumnHideUIBehavior.prototype */ {
        /** @type {string} */
        __name: "TableColumnHideUIBehavior",
        /**
         * @inheritDoc
         */
        _attachWidget: function(controller, data) {
          var widget = controller.getWidget();
          if (!!widget) {
            data.clickHandle = widget.when(gbc.constants.widgetEvents.tableShowHideCol, this._showHideColumn.bind(this, controller,
              data));
          }
        },
        /**
         * @inheritDoc
         */
        _detachWidget: function(controller, data) {
          if (data.clickHandle) {
            data.clickHandle();
            data.clickHandle = null;
          }
        },

        /**
         * Show or hide table column (send event to VM)
         * @param {classes.ControllerBase} controller
         * @param {Object} data
         * @param opt true to show the column, false to hide it, empty to toggle it
         * @private
         */
        _showHideColumn: function(controller, data, opt) {
          var node = controller.getAnchorNode();
          var widget = controller.getWidget();
          var columnIndex = widget.getColumnIndex();
          var hidden = context.constants.visibility.hiddenByUser;
          if (opt.data.length > 0 && opt.data[0] !== "toggle") {
            hidden = opt.data[0] === "show" ? context.constants.visibility.visible : context.constants.visibility.hiddenByUser;
          } else if (columnIndex > -1) {
            hidden = node.attribute('hidden') === context.constants.visibility.hiddenByUser ? context.constants.visibility.visible :
              hidden;
          }

          var event = new cls.VMConfigureEvent(node.getId(), {
            hidden: hidden
          });

          if (hidden === context.constants.visibility.visible || this._getNbColumnsVisible(node.getParentNode()) > 1) {
            node.getApplication().typeahead.event(event, node);

            controller.setStoredSetting("hidden", hidden === context.constants.visibility.hiddenByUser);
          }
        },

        /**
         * Returns the number of columns which are not hidden
         * @returns {number} number of visible columns
         */
        _getNbColumnsVisible: function(tableNode) {
          var nb = 0;
          var children = tableNode.getChildren();
          for (var c = 0; c < children.length; c++) {
            var n = children[c];
            if (n._tag === "TableColumn" && n.attribute('hidden') === 0) {
              nb++;
            }
          }
          return nb;
        }
      };
    });
  });
;
"use strict";

modulum('TableColumnOrderUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * @class TableColumnOrderUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.TableColumnOrderUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.TableColumnOrderUIBehavior.prototype */ {
        /** @type {string} */
        __name: "TableColumnOrderUIBehavior",
        /**
         * @inheritDoc
         */
        _attachWidget: function(controller, data) {
          var widget = controller.getWidget();
          if (!!widget) {
            data.orderHandle = widget.when(gbc.constants.widgetEvents.tableOrderColumn, this._orderColumn.bind(this, controller,
              data));
          }
        },
        /**
         * @inheritDoc
         */
        _detachWidget: function(controller, data) {
          if (data.orderHandle) {
            data.orderHandle();
            data.orderHandle = null;
          }
        },

        /**
         * Order table column (send event to VM)
         * @private
         */
        _orderColumn: function(controller, data, opt) {
          var node = controller.getAnchorNode();
          var tabIndex = opt.data[0];

          var event = new cls.VMConfigureEvent(node.getId(), {
            tabIndex: tabIndex
          });
          node.getApplication().typeahead.event(event, node);

          controller.setStoredSetting("tabIndex", tabIndex);
        }
      };
    });
  });
;
"use strict";

modulum('TableColumnResizeUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * @class TableColumnResizeUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.TableColumnResizeUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.TableColumnResizeUIBehavior.prototype */ {
        /** @type {string} */
        __name: "TableColumnResizeUIBehavior",
        /**
         * @inheritDoc
         */
        _attachWidget: function(controller, data) {
          var widget = controller.getWidget();
          if (!!widget) {
            data.resizeHandle = widget.when(gbc.constants.widgetEvents.tableResizeCol, this._resizeColumn.bind(this, controller,
              data));
          }
        },
        /**
         * @inheritDoc
         */
        _detachWidget: function(controller, data) {
          if (data.resizeHandle) {
            data.resizeHandle();
            data.resizeHandle = null;
          }
        },

        /**
         *
         * @param {classes.ControllerBase} controller
         * @param {Object} data
         * @param opt new width of the column
         * @private
         */
        _resizeColumn: function(controller, data, opt) {

          // Save new width in stored settings
          var width = opt.data[0];
          controller.setStoredSetting("width", width);
        }
      };
    });
  });
;
"use strict";

modulum('TableColumnSortUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * @class TableColumnSortUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.TableColumnSortUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.TableColumnSortUIBehavior.prototype */ {
        /** @type {string} */
        __name: "TableColumnSortUIBehavior",
        /**
         * @inheritDoc
         */
        _attachWidget: function(controller, data) {
          var widget = controller.getWidget();
          if (!!widget) {
            data.clickHandle = widget.when(gbc.constants.widgetEvents.tableHeaderClick, this._sortColumn.bind(this, controller,
              data));
          }
        },
        /**
         * @inheritDoc
         */
        _detachWidget: function(controller, data) {
          if (data.clickHandle) {
            data.clickHandle();
            data.clickHandle = null;
          }
        },

        /**
         * Sort table column (send event to VM)
         * @private
         */
        _sortColumn: function(controller, data, opt) {
          var node = controller.getAnchorNode();

          var reset = opt.data.length > 0 && opt.data[0] === "reset";

          var tableNode = node.getParentNode();
          var widget = controller.getWidget();
          var columnIndex = widget.getColumnIndex();
          var sortType = "";
          if (columnIndex > -1) {
            sortType = tableNode.attribute('sortType') === "asc" ? "desc" : "asc";
          }

          //reset sort order
          columnIndex = reset ? -1 : columnIndex;

          var event = new cls.VMConfigureEvent(tableNode.getId(), {
            sortColumn: columnIndex,
            sortType: sortType
          });
          node.getApplication().typeahead.event(event, tableNode);

          tableNode.getController().setStoredSetting("sortColumn", columnIndex);
          tableNode.getController().setStoredSetting("sortType", sortType);
        }
      };
    });
  });
;
"use strict";

modulum('TableCopyCurrentUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * @class TableCopyCurrentUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.TableCopyCurrentUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.TableCopyCurrentUIBehavior.prototype */ {
        /** @type {string} */
        __name: "TableCopyCurrentUIBehavior",
        /**
         * @inheritDoc
         */
        _attachWidget: function(controller, data) {
          var widget = controller.getWidget();
          if (!!widget) {
            data.copyHandle = widget.when(gbc.constants.widgetEvents.copy, this._copyCurrent.bind(this, controller,
              data));
          }
        },
        /**
         * @inheritDoc
         */
        _detachWidget: function(controller, data) {
          if (data.copyHandle) {
            data.copyHandle();
            data.copyHandle = null;
          }
        },

        /**
         *
         * @param {classes.ControllerBase} controller
         * @param {Object} data
         * @private
         */
        _copyCurrent: function(controller, data) {
          var tableWidget = controller.getWidget();
          var tableNode = controller.getAnchorNode();
          var multiRowSelection = (tableNode.attribute('multiRowSelection') !== 0);

          var app = tableNode.getApplication();
          var vmEvent = null;
          var copyKey = "control-c";

          // search action in active dialog
          // TODO GBC-1760 we should use ActionApplicationService to search an action
          var actionNode = app.getActiveDialogAction(copyKey);
          if (actionNode) {
            vmEvent = new cls.VMActionEvent(actionNode.getId());
          } else {
            // search action in default action list
            actionNode = app.getDefaultAction(copyKey);
            if (actionNode) {
              vmEvent = new cls.VMKeyEvent(copyKey);
            }
          }
          // an action is found for CTRL-C and it's not "editcopy"
          // send the action event and quit
          if (vmEvent && actionNode.attribute('name') !== "editcopy") {
            app.typeahead.event(vmEvent, tableNode);
            return;
          }

          // if current row is visible and multirowselection off use native GBC copy
          if (!multiRowSelection && tableWidget && tableWidget.isCurrentRowVisible()) {
            if (tableWidget.hasFocusOnField()) {
              tableWidget._copyCurrentCellInClipboard();
            } else {
              tableWidget._copyCurrentRowInClipboard();
            }
          } else if (vmEvent) { // an action is found and it's "editcopy" sent it to VM
            app.typeahead.event(vmEvent, tableNode);
          }
        }
      };
    });
  });
;
"use strict";

modulum('TableFrozenUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * @class TableFrozenUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.TableFrozenUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.TableFrozenUIBehavior.prototype */ {
        /** @type {string} */
        __name: "TableFrozenUIBehavior",
        /**
         * @inheritDoc
         */
        _attachWidget: function(controller, data) {
          var widget = controller.getWidget();
          if (!!widget) {
            data.leftFrozenHandle = widget.when(gbc.constants.widgetEvents.tableLeftFrozen, this._leftFrozen.bind(this, controller,
              data));
            data.rightFrozenHandle = widget.when(gbc.constants.widgetEvents.tableRightFrozen, this._rightFrozen.bind(this,
              controller,
              data));
          }
        },
        /**
         * @inheritDoc
         */
        _detachWidget: function(controller, data) {
          if (data.leftFrozenHandle) {
            data.leftFrozenHandle();
            data.leftFrozenHandle = null;
          }
          if (data.rightFrozenHandle) {
            data.rightFrozenHandle();
            data.rightFrozenHandle = null;
          }
        },

        /**
         *
         * @param {classes.ControllerBase} controller
         * @param {Object} data
         * @param opt left frozen column count
         * @private
         */
        _leftFrozen: function(controller, data, opt) {

          // Save left frozen columns count in stored settings
          var count = opt.data[0];
          controller.setStoredSetting("leftFrozen", count);
        },

        /**
         *
         * @param {classes.ControllerBase} controller
         * @param {Object} data
         * @param opt right frozen column count
         * @private
         */
        _rightFrozen: function(controller, data, opt) {

          // Save right frozen columns count in stored settings
          var count = opt.data[0];
          controller.setStoredSetting("rightFrozen", count);
        }
      };
    });
  });
;
"use strict";

modulum('TableResetToDefaultUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * @class TableResetToDefaultUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.TableResetToDefaultUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.TableResetToDefaultUIBehavior.prototype */ {
        /** @type {string} */
        __name: "TableResetToDefaultUIBehavior",
        /**
         * @inheritDoc
         */
        _attachWidget: function(controller, data) {
          var widget = controller.getWidget();
          if (!!widget) {
            data.clickHandle = widget.when(gbc.constants.widgetEvents.tableResetToDefault, this._resetToDefault.bind(this,
              controller,
              data));
          }
        },
        /**
         * @inheritDoc
         */
        _detachWidget: function(controller, data) {
          if (data.clickHandle) {
            data.clickHandle();
            data.clickHandle = null;
          }
        },

        /**
         * Reset table settings
         * @private
         */
        _resetToDefault: function(controller, data, opt) {
          controller.resetStoredSetting();
          var tableColumns = controller.getAnchorNode().getChildren("TableColumn");
          var widget = null;
          for (var i = 0; i < tableColumns.length; i++) {
            widget = tableColumns[i].getController().getWidget();
            // will reset order: ordering by AUI tree position
            widget.setOrder(i);

            //will reset any sorting on each column
            widget.emit(context.constants.widgetEvents.tableHeaderClick, "reset");

            //will reset size on each column
            widget.resetWidth();

            //will reset visible/hidden columns
            widget.emit(gbc.constants.widgetEvents.tableShowHideCol, "show");
          }
        }
      };
    });
  });
;
"use strict";

modulum('TreeItemKeyExpandUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * @class TreeItemKeyExpandUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.TreeItemKeyExpandUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.TreeItemKeyExpandUIBehavior.prototype */ {
        __name: "TreeItemKeyExpandUIBehavior",

        /**
         * @protected
         */
        _attachWidget: function(controller, data) {
          if (!!controller.getWidget()) {
            var tableWidget = controller.getAnchorNode().getParentNode().getController().getWidget();
            data.rightHandle = tableWidget.when(context.constants.widgetEvents.keyArrowRight, this._expandOrCollapse.bind(this,
              controller,
              data, 1));
            data.leftHandle = tableWidget.when(context.constants.widgetEvents.keyArrowLeft, this._expandOrCollapse.bind(this,
              controller,
              data,
              0));
          }
        },

        /**
         * @protected
         */
        _detachWidget: function(controller, data) {
          if (data.rightHandle) {
            data.rightHandle();
            data.rightHandle = null;
          }
          if (data.leftHandle) {
            data.leftHandle();
            data.leftHandle = null;
          }
        },

        /**
         * @param {classes.ControllerBase} controller
         * @param {Object} data
         * @param {number} expand
         * @param eventType
         * @param source
         * @param event
         * @private
         */
        _expandOrCollapse: function(controller, data, expand, eventType, source, event) {
          var node = controller.getAnchorNode();
          var tableNode = node.getParentNode();
          var offset = tableNode.attribute('offset');
          var currentRow = tableNode.attribute('currentRow');
          var treeItemNode = tableNode.findNodeWithAttribute("TreeItem", "row", currentRow - offset);
          if (treeItemNode &&
            (expand === 1 || (source.getScrollableArea() && source.getScrollableArea().scrollLeft === 0))) { // if we have previously horizontally scrolled, we need to scroll back before collapsing nodes
            var vmEvent = null;
            if (expand && (treeItemNode.attribute("expanded") === 1)) {
              event.preventCancelableDefault(); // preventDefault avoid horizontal scroll

              vmEvent = new cls.VMConfigureEvent(tableNode.getId(), {
                currentRow: treeItemNode.attribute("row") + offset + 1
              });
            } else if (!expand && (treeItemNode.attribute("expanded") === 0)) {
              event.preventCancelableDefault(); // preventDefault avoid horizontal scroll

              var parent = treeItemNode.getParentNode();
              if (parent._tag === "TreeItem") {
                vmEvent = new cls.VMConfigureEvent(tableNode.getId(), {
                  currentRow: treeItemNode.attribute("row") - (parent.getChildren().indexOf(treeItemNode) + 1) + offset
                });
              }
            } else if (treeItemNode.attribute("hasChildren")) {
              event.preventCancelableDefault(); // preventDefault avoid horizontal scroll

              vmEvent = new cls.VMConfigureEvent(treeItemNode.getId(), {
                expanded: expand
              });
            }
            if (vmEvent) {
              treeItemNode.getApplication().typeahead.event(vmEvent, tableNode);
            }
          }
        }
      };
    });
  });
;
"use strict";

modulum('TreeItemToggleUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * @class TreeItemToggleUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.TreeItemToggleUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.TreeItemToggleUIBehavior.prototype */ {
        __name: "TreeItemToggleUIBehavior",

        /**
         * @protected
         */
        _attachWidget: function(controller, data) {
          var treeViewColumnWidget = controller.getWidget();
          if (treeViewColumnWidget) {
            data.onClickHandle = treeViewColumnWidget.when(context.constants.widgetEvents.toggleClick, this._toggleState.bind(this,
              controller, data));
          }

        },

        /**
         * @protected
         */
        _detachWidget: function(controller, data) {
          if (data.onClickHandle) {
            data.onClickHandle();
            data.onClickHandle = null;
          }
        },

        /**
         *
         * @param controller
         * @param data
         * @param event
         * @param sender
         * @param {number} index
         * @private
         */
        _toggleState: function(controller, data, event, sender, index) {
          var node = controller.getAnchorNode();
          var tableNode = node.getParentNode();
          var treeItemNode = tableNode.findNodeWithAttribute("TreeItem", "row", index);

          if (treeItemNode.attribute('hasChildren') !== 0) {
            var expanded = treeItemNode.attribute('expanded');
            if (expanded === 0) {
              expanded = 1;
            } else {
              expanded = 0;
            }
            var vmEvent = new cls.VMConfigureEvent(treeItemNode.getId(), {
              expanded: expanded
            });
            treeItemNode.getApplication().typeahead.event(vmEvent, treeItemNode);
          }
        }
      };
    });
  });
;
"use strict";

modulum('WebComponentKeyboardUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * Behavior used to delegates keyboard keydowns from webcomponents to the GBC
     * @class WebComponentKeyboardUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.WebComponentKeyboardUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.WebComponentKeyboardUIBehavior.prototype */ {
        __name: "WebComponentKeyboardUIBehavior",

        /**
         * @inheritDoc
         */
        _attachWidget: function(controller, data) {
          var widget = controller.getWidget();
          if (!!widget) {
            data.keyboardListener = widget.when(context.constants.widgetEvents.webcomponentKeyDown, this._onWebcomponentKeyDown.bind(
              this, controller));
          }
        },

        /**
         * @inheritDoc
         */
        _detachWidget: function(controller, data) {
          if (data.keyboardListener) {
            data.keyboardListener();
            data.keyboardListener = null;
          }
        },

        /**
         * Handler for webcomponent key down
         * @param {classes.ControllerBase} controller
         * @param {Object} event - event
         * @param {classes.EventListener} src
         * @param {KeyboardEvent} domEvent
         * @private
         */
        _onWebcomponentKeyDown: function(controller, event, src, domEvent) {
          var anchor = controller.getAnchorNode();
          var app = anchor.getApplication();
          Event.prototype.normalizeEventForGBC(domEvent);
          app.keyboard._onKeyDown(domEvent);
        }
      };
    });
  });
;
"use strict";

modulum('WindowCloseUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * @class WindowCloseUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.WindowCloseUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.WindowCloseUIBehavior.prototype */ {
        /** @type {string} */
        __name: "WindowCloseUIBehavior",

        /**
         * @inheritDoc
         */
        _attachWidget: function(controller, data) {
          if (!!controller.getWidget()) {
            data.clickHandle = controller.getWidget().when(gbc.constants.widgetEvents.close, this._windowClose.bind(this,
              controller,
              data));
          }
        },

        /**
         * @inheritDoc
         */
        _detachWidget: function(controller, data) {
          if (data.clickHandle) {
            data.clickHandle();
            data.clickHandle = null;
          }
        },

        /**
         *
         * @param controller
         * @param data
         * @private
         */
        _windowClose: function(controller, data) {
          var node = controller.getAnchorNode();
          if (node.getTag() !== "Window") {
            node = node.getAncestor("Window");
          }
          var dialog = node.getActiveDialog();
          if (dialog) {
            var closeActionNodes = dialog.getChildrenWithAttribute(null, "name", "close");
            if (closeActionNodes && closeActionNodes.length > 0) {
              var closeActionNode = closeActionNodes[0];
              controller.getAnchorNode().getApplication().action.execute(closeActionNode.getId());
            }
          }
        }
      };
    });
  });
;
"use strict";

modulum('UIBehaviorBase', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class UIBehaviorBase
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.UIBehaviorBase = context.oo.Class(cls.BehaviorBase, function($super) {
      return /** @lends classes.UIBehaviorBase.prototype */ {
        __name: "UIBehaviorBase",
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {}
      };
    });
  });
;
"use strict";

modulum('ActionDefaultAcceleratorVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Behavior controlling the widget's Menu
     * @class ActionDefaultAcceleratorVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.ActionDefaultAcceleratorVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.ActionDefaultAcceleratorVMBehavior.prototype */ {
        __name: "ActionDefaultAcceleratorVMBehavior",

        watchedAttributes: {
          anchor: ['acceleratorName', 'acceleratorName2', 'acceleratorName3', 'acceleratorName4']
        },

        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var bindings = controller.getNodeBindings();

          // register action default
          var app = bindings.anchor.getApplication();
          if (app) {
            var actionService = app.getActionApplicationService();
            if (actionService) {
              actionService.destroyActionDefault(bindings.anchor);
              actionService.registerActionDefault(bindings.anchor);
            }
          }
        },

        /**
         * @inheritDoc
         */
        _detach: function(controller, data) {
          var anchorNode = controller.getAnchorNode();
          var actionService = anchorNode.getApplication().getActionApplicationService();
          actionService.destroyActionDefault(anchorNode);
        }
      };
    });
  });
;
"use strict";

modulum('ActionEnabledVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Behavior controlling the widget's Menu
     * @class ActionEnabledVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.ActionEnabledVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.ActionEnabledVMBehavior.prototype */ {
        __name: "ActionEnabledVMBehavior",

        watchedAttributes: {
          anchor: ['active'],
          parent: ['active']
        },

        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var bindings = controller.getNodeBindings();
          var activeValue = bindings.anchor.attribute('active');
          var parentActiveValue = bindings.parent.attribute('active');

          // enable/disable accelerators
          var appService = bindings.anchor.getApplication().getActionApplicationService();
          if (activeValue && parentActiveValue) {
            appService.registerAction(bindings.anchor);
          } else {
            appService.destroyAction(bindings.anchor);
          }
        },

        /**
         * @inheritDoc
         */
        _detach: function(controller, data) {
          var anchorNode = controller.getAnchorNode();
          var actionService = anchorNode.getApplication().getActionApplicationService();
          actionService.destroyAction(anchorNode);
        }
      };
    });
  });
;
"use strict";

modulum('AggregateVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class AggregateVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.AggregateVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.AggregateVMBehavior.prototype */ {
        __name: "AggregateVMBehavior",

        watchedAttributes: {
          anchor: ['aggregateText', 'aggregateValue'],
          parent: ['aggregateText']
        },

        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var bindings = controller.getNodeBindings();
          var widget = controller.getWidget();
          if (widget && widget.setAggregate) {

            if (widget.getColumnIndex() === 0) {
              var globalText = bindings.parent.attribute('aggregateText');
              widget.getParentWidget().setAggregateGlobalText(globalText);
            }

            var text = bindings.anchor.attribute('aggregateText');
            var value = bindings.anchor.attribute('aggregateValue');

            if (text !== "") {
              text = text + " ";
            }

            widget.setAggregate(text + value);
          }
        }
      };
    });
  });
;
"use strict";

modulum('ApplicationTitleVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class ApplicationTitleVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.ApplicationTitleVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.ApplicationTitleVMBehavior.prototype */ {
        __name: "ApplicationTitleVMBehavior",

        watchedAttributes: {
          anchor: ['name', 'text']
        },

        /**
         * Switches the current window
         */
        _apply: function(controller, data) {
          var anchor = controller.getAnchorNode();
          var text = anchor.attribute('text');
          var name = anchor.attribute('name');
          anchor.getApplication().getUI().getWidget().getSidebarWidget().setApplicationName(text || name);
        }
      };
    });
  });
;
"use strict";

modulum('AuiNameVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class AuiNameVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.AuiNameVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.AuiNameVMBehavior.prototype */ {
        __name: "AuiNameVMBehavior",

        watchedAttributes: {
          anchor: ['name'],
          container: ['name']
        },
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var bindings = controller.getNodeBindings();
          var node = bindings.container || bindings.anchor;
          var widget = controller.getWidget();
          if (widget && widget.setAuiName) {
            var name = node.attribute('name') || node.attribute('tabName');
            widget.setAuiName(name);
          }
        }
      };
    });
  });
;
"use strict";

modulum('AutoScaleVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class AutoScaleVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.AutoScaleVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.AutoScaleVMBehavior.prototype */ {
        __name: "AutoScaleVMBehavior",

        watchedAttributes: {
          decorator: ['autoScale', 'sizePolicy', 'stretch']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.setAutoScale) {
            var bindings = controller.getNodeBindings();
            var node = bindings.decorator ? bindings.decorator : bindings.anchor;
            var autoScale = node.attribute('autoScale');
            var sizePolicy = node.attribute('sizePolicy');
            var hasStretch = node.isAttributeSetByVM('stretch');
            if (widget.setStretch) {
              widget.setStretch(hasStretch);
            }
            widget.setAutoScale(((sizePolicy === 'fixed' || hasStretch) && !!autoScale) || (sizePolicy === 'initial' && !!autoScale));
          }
        }
      };
    });
  });
;
"use strict";

modulum('BackgroundColorMessageVMBehavior', ['BackgroundColorVMBehavior'],
  function(context, cls) {
    /**
     * @class BackgroundColorMessageVMBehavior
     * @memberOf classes
     * @extends classes.BackgroundColorVMBehavior
     */
    cls.BackgroundColorMessageVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.BackgroundColorMessageVMBehavior.prototype */ {
        __name: "BackgroundColorMessageVMBehavior",

        watchedAttributes: {
          anchor: ['color', 'reverse', 'type']
        },

        /**
         * Applies the background color only if it has been defined by the VM, use default value otherwise.
         */
        _apply: function(controller, data) {
          var messageNode = controller.getAnchorNode();
          var widget = controller.getWidget();
          if (widget) {
            widget.getElement().setAttribute("__" + widget.__name + "_type", messageNode.attribute('type'));
          }
          var isError = messageNode.attribute('type') === 'error';
          var kind = isError ? 'error' : 'message';
          var color = messageNode.getStyleAttribute("backgroundColor", [kind]);
          if (color) {
            controller.getWidget().setBackgroundColor(color);
          } else {
            if (messageNode.isAttributeSetByVM('color')) {
              cls.BackgroundColorVMBehavior._apply(controller, data);
            } else {
              if (isError) {
                widget.setBackgroundColor(context.ThemeService.getValue("theme-error-background-color"));
              } else {
                widget.setBackgroundColor("");
              }
            }
          }
        }
      };
    });
  });
;
"use strict";

modulum('BackgroundColorVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class BackgroundColorVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.BackgroundColorVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.BackgroundColorVMBehavior.prototype */ {
        __name: "BackgroundColorVMBehavior",

        usedStyleAttributes: ["backgroundColor"],

        watchedAttributes: {
          anchor: ['color', 'reverse'],
          decorator: ['color', 'reverse'],
          container: ['dialogType', 'currentRow', 'offset']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.setBackgroundColor) {
            var bindings = controller.getNodeBindings();
            var colorNode = bindings.anchor;
            if (bindings.container && bindings.container.getTag() === "TableColumn") { // TABLE case
              widget.setBackgroundColor(null);
              widget.getParentWidget().setBackgroundColor(null);
              var dialogType = bindings.container.attribute("dialogType");
              if (dialogType === "Display" || dialogType === "DisplayArray") {
                widget = widget.getParentWidget();
              }
            } else if (bindings.container && bindings.container.getTag() === "Matrix") { // MATRIX case
              var currentRow = bindings.container.attribute("currentRow");
              var offset = bindings.container.attribute("offset");
              var size = bindings.container.attribute("size");
              if (currentRow < size && currentRow - offset === bindings.anchor.getIndex()) {
                widget.setBackgroundColor(null); // current highlight color is the background color
                return;
              }
            }
            if (bindings.decorator && !bindings.anchor.isAttributeSetByVM('color')) {
              colorNode = bindings.decorator;
            }

            var isReverse = colorNode.attribute('reverse') === 1;
            var color = null;
            if (isReverse && colorNode.isAttributeSetByVM('color')) {
              color = colorNode.attribute('color');
              if (color === "white") {
                color = context.ThemeService.getValue("theme-field-disabled-background-color");
              }
              widget.setBackgroundColor(this._resolveThemedColor(color));
            } else {
              color = controller.getAnchorNode().getStyleAttribute('backgroundColor');
              if (color) {
                color = color.trim();
                widget.setBackgroundColor(this._resolveThemedColor(color));
              } else {
                widget.setBackgroundColor(isReverse ? "lightgrey" : null);
              }
            }
          }
        },

        /**
         * Get defined themed color corresponding to color name passed as argument
         * @param {string} color - color name
         * @returns {string} returns the color hexadecimal code
         * @private
         */
        _resolveThemedColor: function(color) {
          var themedColor = context.ThemeService.getValue("gbc-genero-" + color);
          if (!!themedColor) {
            return themedColor;
          } else {
            return color;
          }
        }
      };
    });
  });
;
"use strict";

modulum('ButtonTextHiddenVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class ButtonTextHiddenVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.ButtonTextHiddenVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.ButtonTextHiddenVMBehavior.prototype */ {
        __name: "ButtonTextHiddenVMBehavior",

        watchedAttributes: {
          anchor: ['buttonTextHidden']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.setButtonTextHidden) {
            var buttonTextHidden = controller.getAnchorNode().attribute('buttonTextHidden');
            widget.setButtonTextHidden(buttonTextHidden);
          }
        }
      };
    });
  });
;
"use strict";

modulum('CanvasArcParametersVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Behavior controlling the widget's Menu
     * @class CanvasArcParametersVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.CanvasArcParametersVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.CanvasArcParametersVMBehavior.prototype */ {
        __name: "CanvasArcParametersVMBehavior",

        watchedAttributes: {
          anchor: ['startX', 'startY', 'diameter', 'startDegrees', 'extentDegrees']
        },
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var node = controller.getAnchorNode();
          var startX = node.attribute('startX');
          var startY = node.attribute('startY');
          var diameter = node.attribute('diameter');
          var startDegrees = node.attribute('startDegrees');
          var extentDegrees = node.attribute('extentDegrees');

          var startAngle = (extentDegrees >= 0 ? startDegrees : startDegrees + extentDegrees) * Math.PI / 180;
          var endAngle = (extentDegrees >= 0 ? startDegrees + extentDegrees : startDegrees) * Math.PI / 180;

          var d2 = diameter / 2;
          var r = Math.abs(d2);
          var cx = startX + d2;
          var xy = startY - d2;

          var x1 = cx + r * Math.cos(startAngle);
          var y1 = cx + r * Math.sin(startAngle);
          var x2 = cx + r * Math.cos(endAngle);
          var y2 = cx + r * Math.sin(endAngle);

          var largeArcFlag = Math.abs(extentDegrees) < 180 ? 0 : 1;
          var sweepFlag = largeArcFlag === 0 ? 1 : 0;

          controller.getWidget().setParameters(startX, startY, diameter, startDegrees, extentDegrees);
        }
      };
    });
  });
;
"use strict";

modulum('CanvasCircleParametersVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Behavior controlling the widget's Menu
     * @class CanvasCircleParametersVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.CanvasCircleParametersVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.CanvasCircleParametersVMBehavior.prototype */ {
        __name: "CanvasCircleParametersVMBehavior",

        watchedAttributes: {
          anchor: ['startX', 'startY', 'diameter']
        },
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var node = controller.getAnchorNode();
          var startX = node.attribute('startX');
          var startY = node.attribute('startY');
          var diameter = node.attribute('diameter');
          var radius = diameter / 2;
          controller.getWidget().setParameters(startX + radius, startY - radius, Math.abs(radius));
        }
      };
    });
  });
;
"use strict";

modulum('CanvasFillColorVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Behavior controlling the widget's Menu
     * @class CanvasFillColorVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.CanvasFillColorVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.CanvasFillColorVMBehavior.prototype */ {
        __name: "CanvasFillColorVMBehavior",

        watchedAttributes: {
          anchor: ['fillColor']
        },
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var color = controller.getAnchorNode().attribute('fillColor');
          var themedColor = context.ThemeService.getValue("gbc-genero-" + color);
          if (!!themedColor) {
            color = themedColor;
          }
          controller.getWidget().setColor(color);
        }
      };
    });
  });
;
"use strict";

modulum('CanvasLineParametersVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Behavior controlling the widget's Menu
     * @class CanvasLineParametersVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.CanvasLineParametersVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.CanvasLineParametersVMBehavior.prototype */ {
        __name: "CanvasLineParametersVMBehavior",

        watchedAttributes: {
          anchor: ['startX', 'startY', 'endX', 'endY']
        },
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var node = controller.getAnchorNode();
          var startX = node.attribute('startX');
          var startY = node.attribute('startY');
          var endX = node.attribute('endX');
          var endY = node.attribute('endY');

          controller.getWidget().setParameters(startX, startY, endX, endY);
        }
      };
    });
  });
;
"use strict";

modulum('CanvasOvalParametersVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Behavior controlling the widget's Menu
     * @class CanvasOvalParametersVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.CanvasOvalParametersVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.CanvasOvalParametersVMBehavior.prototype */ {
        __name: "CanvasOvalParametersVMBehavior",

        watchedAttributes: {
          anchor: ['startX', 'startY', 'endX', 'endY']
        },
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var node = controller.getAnchorNode();
          var startX = node.attribute('startX');
          var startY = node.attribute('startY');
          var endX = node.attribute('endX');
          var endY = node.attribute('endY');

          var cx = (startX + endX) / 2;
          var cy = (startY + endY) / 2;
          var rx = Math.abs(endX - startX) / 2;
          var ry = Math.abs(endY - startY) / 2;
          controller.getWidget().setParameters(cx, cy, rx, ry);
        }
      };
    });
  });
;
"use strict";

modulum('CanvasPolygonParametersVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Behavior controlling the widget's Menu
     * @class CanvasPolygonParametersVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.CanvasPolygonParametersVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.CanvasPolygonParametersVMBehavior.prototype */ {
        __name: "CanvasPolygonParametersVMBehavior",

        SPACES_RE: /\s+/,

        watchedAttributes: {
          anchor: ['xyList']
        },
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var node = controller.getAnchorNode();
          var xyList = node.attribute('xyList').split(this.SPACES_RE);
          controller.getWidget().setParameters(xyList);
        }
      };
    });
  });
;
"use strict";

modulum('CanvasRectangleParametersVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Behavior controlling the widget's Menu
     * @class CanvasRectangleParametersVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.CanvasRectangleParametersVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.CanvasRectangleParametersVMBehavior.prototype */ {
        __name: "CanvasRectangleParametersVMBehavior",

        watchedAttributes: {
          anchor: ['startX', 'startY', 'endX', 'endY']
        },
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var node = controller.getAnchorNode();
          var startX = node.attribute('startX');
          var startY = node.attribute('startY');
          var endX = node.attribute('endX');
          var endY = node.attribute('endY');
          // Normalize
          var x = Math.min(startX, endX);
          var y = Math.min(startY, endY);
          var width = Math.abs(endX - startX);
          var height = Math.abs(endY - startY);
          controller.getWidget().setParameters(x, y, width, height);
        }
      };
    });
  });
;
"use strict";

modulum('CanvasTextParametersVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Behavior controlling the widget's Menu
     * @class CanvasTextParametersVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.CanvasTextParametersVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.CanvasTextParametersVMBehavior.prototype */ {
        __name: "CanvasTextParametersVMBehavior",

        watchedAttributes: {
          anchor: ['startX', 'startY', 'anchor', 'text']
        },
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var node = controller.getAnchorNode();
          var startX = node.attribute('startX');
          var startY = node.attribute('startY');
          var anchor = node.attribute('anchor');
          var text = node.attribute('text');

          var xTextAnchor = anchor.indexOf('e') !== -1 ? 'end' : anchor.indexOf('w') !== -1 ? 'start' : 'middle';
          var yTextAnchor = anchor.indexOf('s') !== -1 ? 'end' : anchor.indexOf('n') !== -1 ? 'start' : 'middle';

          var canvasWidget = controller.getWidget().getParentWidget();
          var box = canvasWidget.getLayoutInformation().getAvailable();
          var canvasWidth = box.getWidth();
          var canvasHeight = box.getHeight();
          if (typeof canvasWidth !== 'number') {
            canvasWidth = 0;
          }
          if (typeof canvasHeight !== 'number') {
            canvasHeight = 0;
          }

          controller.getWidget().setParameters(canvasWidth, canvasHeight, startX, startY, xTextAnchor, yTextAnchor, text);
        }
      };
    });
  });
;
"use strict";

modulum('CheckBoxValuesVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class CheckBoxValuesVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.CheckBoxValuesVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.CheckBoxValuesVMBehavior.prototype */ {
        __name: "CheckBoxValuesVMBehavior",

        watchedAttributes: {
          decorator: ['valueChecked', 'valueUnchecked']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          var decorator = controller.getNodeBindings().decorator;
          if (widget && widget.setCheckedValue) {
            var checkedValue = decorator.attribute('valueChecked');
            widget.setCheckedValue(checkedValue);
          }
          if (widget && widget.setUncheckedValue) {
            var uncheckedValue = decorator.attribute('valueUnchecked');
            widget.setUncheckedValue(uncheckedValue);
          }
        }
      };
    });
  });
;
"use strict";

modulum('ClickableImageVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class ClickableImageVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.ClickableImageVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.ClickableImageVMBehavior.prototype */ {
        __name: "ClickableImageVMBehavior",

        watchedAttributes: {
          decorator: ['action', "actionActive"],
          anchor: ['action', "actionActive"]
        },

        /**
         *
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.setClickableImage) {
            var imgNode = controller.getNodeBindings().decorator || controller.getNodeBindings().anchor;
            if (imgNode.isAttributeSetByVM('action') && imgNode.isAttributeSetByVM('actionActive')) {
              widget.setClickableImage(imgNode.attribute("action") && imgNode.attribute("actionActive"));
            }
          }
        }
      };
    });
  });
;
"use strict";

modulum('ColorMessageVMBehavior', ['ColorVMBehavior'],
  function(context, cls) {
    /**
     * @class ColorMessageVMBehavior
     * @memberOf classes
     * @extends classes.ColorVMBehavior
     */
    cls.ColorMessageVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.ColorMessageVMBehavior.prototype */ {
        __name: "ColorMessageVMBehavior",

        watchedAttributes: {
          anchor: ['color', 'reverse', 'type']
        },

        /**
         * Applies the color only if it has been defined by the VM, use default value otherwise.
         */
        _apply: function(controller, data) {
          var messageNode = controller.getAnchorNode();
          var kind = messageNode.attribute('type') === 'error' ? 'error' : 'message';
          var color = messageNode.getStyleAttribute("textColor", [kind]);
          var widget = controller.getWidget();
          if (widget.setMessageKind) {
            widget.setMessageKind(kind);
          }

          if (color) {
            widget.setColor(color);
          } else {
            if (messageNode.isAttributeSetByVM('color')) {
              var isReverse = messageNode.attribute('reverse') === 1;

              if (messageNode.attribute('color') === "white") {
                color = context.ThemeService.getValue("theme-message-color");
              } else {
                color = isReverse ? messageNode.getStyleAttribute('textColor') : messageNode.attribute('color');
              }
              widget.setColor(this._resolveThemedColor(color));
            } else {
              widget.setColor(context.ThemeService.getValue("theme-message-color"));
            }
          }
        },

        /**
         * Get defined themed color corresponding to color name passed as argument
         * @param {string} color - color name
         * @returns {string} returns the color hexadecimal code
         * @private
         */
        _resolveThemedColor: function(color) {
          var themedColor = context.ThemeService.getValue("gbc-genero-" + color);
          if (!!themedColor) {
            return themedColor;
          } else {
            return color;
          }
        }
      };
    });
  });
;
"use strict";

modulum('ColorVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class ColorVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.ColorVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.ColorVMBehavior.prototype */ {
        __name: "ColorVMBehavior",

        usedStyleAttributes: ["textColor"],

        watchedAttributes: {
          anchor: ['color', 'reverse'],
          decorator: ['color', 'reverse']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.setColor) {
            var bindings = controller.getNodeBindings();
            var colorNode = bindings.anchor;

            if (bindings.decorator && !bindings.anchor.isAttributeSetByVM('color')) {
              colorNode = bindings.decorator;
            }

            var isReverse = colorNode.attribute('reverse') === 1;
            var color = null;
            if (!isReverse && colorNode.isAttributeSetByVM('color')) {
              color = colorNode.attribute('color');
              // Weird choice but what is white should be black if not reverse on modern UI
              if (color === 'white') {
                color = context.ThemeService.getValue("theme-secondary-color");
                if (bindings.container && bindings.container.getTag() === "TableColumn") {
                  return;
                }
              }
              widget.setColor(this._resolveThemedColor(color));
            } else {
              color = controller.getAnchorNode().getStyleAttribute('textColor');
              if (color) {
                color = this._resolveThemedColor(color);
              }
              widget.setColor(color);
            }
          }
        },

        /**
         * Get defined themed color corresponding to color name passed as argument
         * @param {string} color - color name
         * @returns {string} returns the color hexadecimal code
         * @private
         */
        _resolveThemedColor: function(color) {
          var themedColor = context.ThemeService.getValue("gbc-genero-" + color);
          if (!!themedColor) {
            return themedColor;
          } else {
            return color;
          }
        }
      };
    });
  });
;
"use strict";

modulum('CompleterVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Behavior controlling the completer items
     * @class CompleterVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.CompleterVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.CompleterVMBehavior.prototype */ {
        __name: "CompleterVMBehavior",

        watchedAttributes: {
          anchor: ['value']
        },

        /**
         * Updates the widget's visibility depending on the AUI tree information
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          var completerNode = controller.getNodeBindings().completer;
          var anchorNode = controller.getAnchorNode();
          var focusedNode = anchorNode.getApplication().getFocusedVMNodeAndValue(true);
          var hasFocus = focusedNode === anchorNode;
          if (hasFocus && completerNode && !!widget) { // only display completer if widget has focus and has completer
            if (widget.addCompleterWidget) {
              widget.addCompleterWidget();
            }

            var completerWidget = null;
            if (widget.getCompleterWidget) {
              completerWidget = widget.getCompleterWidget();
            }

            if (completerWidget) {

              var children = completerNode.getChildren();
              var size = completerNode.attribute("size");
              completerWidget.clearChoices();
              completerWidget.setSize(size);

              for (var i = 0; i < size; i++) {
                completerWidget.addChoice(children[i].attribute("text"));
              }

              if (size > 0) {
                completerWidget.show();
              } else {
                completerWidget.hide();
              }
            }
          }
        },

        /**
         * @inheritDoc
         * @protected
         */
        _attach: function(controller, data) {
          var decoratorNode = controller.getNodeBindings().decorator;

          //on new Item node
          data._onNodeCreateHandle = decoratorNode.onNodeCreated(this._onItemsCountChanged.bind(this, controller, data),
            "Item");
          data._onNodeRemoveHandle = decoratorNode.onNodeRemoved(this._onItemsCountChanged.bind(this, controller, data),
            "Item");
        },

        /**
         * Handler executed each time a node is created or removed
         * @param controller
         * @param data
         * @param event
         * @param src
         * @param node
         * @private
         */
        _onItemsCountChanged: function(controller, data, event, src, node) {
          var nodeBindings = controller.getNodeBindings();

          if (nodeBindings) {
            var completerNode = nodeBindings.completer;

            data._watchedAttributes = [{
              node: completerNode,
              attribute: 'size'
            }];
            for (var i = 0; i < completerNode._children.length; ++i) {
              var itemNode = completerNode._children[i];
              data._watchedAttributes.push({
                node: itemNode,
                attribute: 'text'
              });
            }
            data.dirty = true;
          }

        },

        /**
         * @inheritDoc
         * @protected
         */
        _detach: function(controller, data) {
          if (data._onNodeCreateHandle) {
            data._onNodeCreateHandle();
            data._onNodeCreateHandle = null;
          }
          if (data._onNodeRemoveHandle) {
            data._onNodeRemoveHandle();
            data._onNodeRemoveHandle = null;
          }
        }
      };
    });
  });
;
"use strict";

modulum('ComponentTypeVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class ComponentTypeVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.ComponentTypeVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.ComponentTypeVMBehavior.prototype */ {
        __name: "ComponentTypeVMBehavior",

        watchedAttributes: {
          decorator: ['componentType']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          var decoratorNode = controller.getNodeBindings().decorator;
          var widget = controller.getWidget();
          if (widget && widget.setWebComponentType) {
            var componentType = decoratorNode.attribute('componentType');
            var isApi = !!componentType;
            widget.setWebComponentType(componentType ? "api" : "url");
            if (isApi) {
              // if application info has webComponent prefix, use it
              var componentUrlPart = decoratorNode.getApplication().info().webComponent ?
                (decoratorNode.getApplication().info().webComponent + "/" + componentType + "/" + componentType + ".html") :
                (componentType + "/" + componentType + ".html"),
                webcompUrl = context.__wrapper.wrapResourcePath(
                  componentUrlPart,
                  "webcomponents",
                  decoratorNode.getApplication().info().webComponent);
              widget.setUrl(webcompUrl);
            }
          }
        }
      };
    });
  });
;
"use strict";

modulum('CurrentTitleVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class CurrentTitleVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.CurrentTitleVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.CurrentTitleVMBehavior.prototype */ {
        __name: "CurrentTitleVMBehavior",

        watchedAttributes: {
          ui: ['currentWindow'],
          anchor: ['name', 'text', 'image']
        },

        /**
         * Switches the current window
         */
        _apply: function(controller, data) {
          var anchorNode = controller.getAnchorNode();
          if (anchorNode.getApplication() === anchorNode.getApplication().getSession().getCurrentApplication() ||
            anchorNode.getApplication() === anchorNode.getApplication().getSession().getTabbedContainerModeHostApplication() ||
            anchorNode.getApplication().getSession().isInTabbedContainerMode()) {
            var userInterfaceNode = anchorNode.getApplication().getNode(0);
            var uititle = userInterfaceNode.isAttributeSetByVM("text") ? userInterfaceNode.attribute("text") : userInterfaceNode.attribute(
              "name");
            var uiimage = userInterfaceNode.isAttributeSetByVM("image") ? userInterfaceNode.attribute('image') : null;
            var windowNode = anchorNode.getTag() === "Window" ? anchorNode : anchorNode.getAncestor("Window");
            windowNode = windowNode || userInterfaceNode.getFirstChildWithId(userInterfaceNode.attribute("currentWindow"));
            if (windowNode) {
              var title = null;
              var image = null;

              var formNode = windowNode.getFirstChild("Form");
              var menuNode = windowNode.getLastChild("Menu");
              // look for image
              if (windowNode.isAttributeSetByVM("image")) {
                image = windowNode.attribute("image");
              }
              if (formNode && formNode.isAttributeSetByVM("image")) {
                image = formNode.attribute("image");
              } else {
                if (menuNode && menuNode.isAttributeSetByVM("image")) {
                  image = menuNode.attribute("image");
                }
              }

              // look for text / name
              if (formNode ||
                (menuNode && (menuNode.attribute("style") === "winmsg" || menuNode.attribute("style") === "dialog"))
              ) {
                if (windowNode.isAttributeSetByVM("text")) {
                  title = windowNode.attribute("text");
                } else if (windowNode.isAttributeSetByVM("name")) {
                  title = windowNode.attribute("name");
                }
              } else {
                if (menuNode) {
                  if (menuNode.isAttributeSetByVM("text") && menuNode.attribute("text")) {
                    title = menuNode.attribute("text");
                  } else if (windowNode.isAttributeSetByVM("text") && windowNode.attribute("text")) {
                    title = windowNode.attribute("text");
                  } else if (userInterfaceNode.isAttributeSetByVM("text") && userInterfaceNode.attribute("text")) {
                    title = userInterfaceNode.attribute("text");
                  } else if (menuNode.isAttributeSetByVM("name") && menuNode.attribute("name")) {
                    title = menuNode.attribute("name");
                  } else if (windowNode.isAttributeSetByVM("name") && windowNode.attribute("name")) {
                    title = windowNode.attribute("name");
                  } else if (userInterfaceNode.isAttributeSetByVM("name") && userInterfaceNode.attribute("name")) {
                    title = userInterfaceNode.attribute("name");
                  }
                }
              }

              var windowWidget = windowNode.getController().getWidget();
              if (title) {
                if (windowWidget.setText) {
                  windowWidget.setText(title);
                }
              }

              if (image) {
                if (windowWidget.setImage) {
                  windowWidget.setImage(context.__wrapper.wrapResourcePath(image));
                }
              }

              var windowType = windowNode.getStyleAttribute('windowType');
              if (context.HostService.getCurrentWindow() === windowWidget && windowType !== 'modal') {
                var tabbedPage = windowNode.getApplication().getUI().getWidget()._tabbedPage;
                if (tabbedPage) {
                  if (!windowWidget.isModal) {
                    tabbedPage.setText(title);
                    tabbedPage.setImage(context.__wrapper.wrapResourcePath(image ? image : uiimage)); // this is typical rule which enforces to manage title icon directly here and not in widgets
                  }
                } else {
                  context.HostService.setCurrentTitle(title);
                  context.HostService.setCurrentIcon(context.__wrapper.wrapResourcePath(image ? image : uiimage)); // this is typical rule which enforces to manage title icon directly here and not in widgets
                }
              }
            } else {
              var userInterfaceWidget = userInterfaceNode.getController().getWidget();
              if (userInterfaceWidget.setText) {
                userInterfaceWidget.setText(uititle);
              }
              if (userInterfaceWidget.setImage) {
                userInterfaceWidget.setImage(uiimage);
              }
              if (uiimage) {
                context.HostService.setCurrentIcon(context.__wrapper.wrapResourcePath(uiimage), true);
              } else {
                context.HostService.setCurrentIcon("", true);
              }
            }
          }
        }
      };
    });
  });
;
"use strict";

modulum('CurrentWindowVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class CurrentWindowVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.CurrentWindowVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.CurrentWindowVMBehavior.prototype */ {
        __name: "CurrentWindowVMBehavior",

        watchedAttributes: {
          anchor: ['currentWindow']
        },
        /**
         * Switches the current window
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.setCurrentWindowId) {
            var currentWindowId = controller.getAnchorNode().attribute('currentWindow');
            widget.setCurrentWindowId(currentWindowId);
          }
        }
      };
    });
  });
;
"use strict";

modulum('CursorsVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class CursorsVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.CursorsVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.CursorsVMBehavior.prototype */ {
        __name: "CursorsVMBehavior",
        _focusRestoredHandler: null,

        watchedAttributes: {
          container: ['cursor', 'cursor2', 'currentRow', 'offset', 'currentColumn', 'dialogType'],
          ui: ['focus'],
          table: ['currentRow', 'currentColumn', 'offset', 'dialogType']
        },

        /**
         * Get container node
         * @param {classes.NodeBase} containerNode - basic container node
         * @returns {classes.NodeBase} returns container node
         * @private
         */
        _getMainArrayContainer: function(containerNode) {
          switch (containerNode.getTag()) {
            case 'TableColumn':
              return containerNode.getParentNode();
            case 'Matrix':
              return containerNode;
            default:
              return null;
          }
        },

        /**
         * Set cursors position to the widget input field
         * @param controller
         * @param data
         * @private
         */
        _apply: function(controller, data) {
          var widget = null;
          var anchorNode = controller.getAnchorNode();
          var containerNode = controller.getNodeBindings().container;
          var app = anchorNode.getApplication();
          var uiNode = app.uiNode();
          var focusedNodeId = uiNode.attribute('focus');

          var arrayContainer = this._getMainArrayContainer(containerNode);
          if (arrayContainer) {
            // Table or Matrix
            if (focusedNodeId === arrayContainer._id) {
              var currentRow = arrayContainer.attribute("currentRow");
              var offset = arrayContainer.attribute("offset");
              var anchorRowIndex = anchorNode.getIndex();
              if (anchorRowIndex === currentRow - offset) {
                if (arrayContainer.getTag() === "Table") { // consider also currentColumn for table
                  var currentColumn = arrayContainer.attribute("currentColumn");
                  var anchorColumnIndex = containerNode.getIndex();
                  if (anchorColumnIndex === currentColumn) {
                    widget = controller.getWidget();
                  }
                } else {
                  widget = controller.getWidget();
                }
              }
            }
          } else {
            // FormField
            if (focusedNodeId === anchorNode.getId()) {
              widget = controller.getWidget();
            }
          }

          if (widget && widget.hasCursors()) {

            if (this._focusRestoredHandler) {
              this._focusRestoredHandler();
            }
            // set cursor should be done after restoreVMFocus so we have to done it after all orders management
            this._focusRestoredHandler = containerNode.getApplication().focus.when(context.constants.widgetEvents.focusRestored,
              function() {

                // event executed once : we release reference because event listener will destroy it
                this._focusRestoredHandler = null;

                var cursor = containerNode.attribute('cursor');
                var cursor2 = containerNode.attribute('cursor2');
                var completerNode = controller.getNodeBindings() ? controller.getNodeBindings().completer : null;
                widget = controller.getWidget();

                //TODO may access the widget in an other way
                if (widget && widget.hasCursors()) {
                  var widgetValue = "";
                  var auiValue = "";
                  // convert both widget and aui value as string to compare without any type conflict
                  if (controller._getAuiValue && controller._getWidgetValue) { // focus on a ValueContainerBaseController
                    auiValue = controller._getAuiValue();
                    widgetValue = controller._getWidgetValue();
                  }
                  if (widget.isEnabled() &&
                    (widgetValue === auiValue || // TODO explain that ?
                      (!!completerNode && completerNode.attribute("size") <= 1)
                    ) && !app.typeahead.hasPendingValueCommands(anchorNode)) {
                    if (widget.getInputElement && document.activeElement !== widget.getInputElement()) {
                      widget.setFocus();
                    }
                    widget.setCursors(cursor, cursor2);
                  }
                }
              }.bind(this), true);
          }
        },

        /**
         * @inheritDoc
         */
        _detach: function(controller, data) {
          if (this._focusRestoredHandler) {
            this._focusRestoredHandler();
            this._focusRestoredHandler = null;
          }
        }
      };
    });
  });
;
"use strict";

modulum('DateTimeValueVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Manage both value and DBDATE format.
     * @class DateTimeValueVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.DateTimeValueVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.DateTimeValueVMBehavior.prototype */ {
        __name: "DateTimeValueVMBehavior",

        watchedAttributes: {
          anchor: ['value'],
          container: ['varType']
        },
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget) { // for label the function to change text is setValue
            var bindings = controller.getNodeBindings();
            var type = bindings.container.attribute('varType');
            var value = bindings.anchor.attribute('value');
            if (type || value) {
              // true if minute not found, false otherwise
              var sec = !type || !~type.toLowerCase().indexOf("minute");

              var isConstruct = bindings.container.attribute('dialogType') === "Construct";
              var displayFormat = "";
              if (isConstruct) { // in construct, we display ISO format. No conversion is done.
                displayFormat = cls.DateTimeHelper.getISOFormat(sec);
              } else { // Use DBDATE format
                var dbDate = widget.getUserInterfaceWidget().getDbDateFormat();
                displayFormat = cls.DateTimeHelper.parseDbDateFormat(dbDate);
                displayFormat += (sec ? " HH:mm:ss" : " HH:mm");
              }

              if (widget.setFormat) {
                widget.setFormat(displayFormat);
              }

              if (value && !isConstruct) {
                value = cls.DateTimeHelper.toDbDateFormat(value, displayFormat);
              }

              if (widget.setValue) {
                widget.setValue(value, true);
              }
            }
          }
        }
      };
    });
  });
;
"use strict";

modulum('DBDateVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class DBDateVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.DBDateVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.DBDateVMBehavior.prototype */ {
        __name: "DBDateVMBehavior",

        watchedAttributes: {
          anchor: ['dbDate']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.setDbDateFormat) {
            var anchorNode = controller.getAnchorNode();
            if (anchorNode.isAttributeSetByVM('dbDate')) {
              var dbDate = anchorNode.attribute('dbDate');
              widget.setDbDateFormat(dbDate);
            }
          }
        }
      };
    });
  });
;
"use strict";

modulum('DialogTypeVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Behavior controlling the switch of widget by controller
     * @class DialogTypeVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.DialogTypeVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.DialogTypeVMBehavior.prototype */ {
        __name: "DialogTypeVMBehavior",

        watchedAttributes: {
          container: ['dialogType', 'active']
        },
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          if (!!controller && controller.changeWidgetKind) {
            var containerNode = controller.getNodeBindings().container;
            var dialogType = containerNode.attribute('dialogType');
            var active = containerNode.attribute('active') === 1;
            var hasWidgetKindChanged = controller.changeWidgetKind(dialogType, active); // return true to force apply of next behaviors
            var widget = controller.getWidget();
            if (widget && widget.setDialogType) {
              widget.setDialogType(dialogType);
            }
            return hasWidgetKindChanged;
          }
          return false;
        }
      };
    });
  });
;
"use strict";

modulum('DisabledVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Behavior controlling the StartMenuCommand's 'Disable' state
     * @class DisabledVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.DisabledVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.DisabledVMBehavior.prototype */ {
        __name: "DisabledVMBehavior",

        watchedAttributes: {
          anchor: ['disabled']
        },

        /**
         * Sets the widget 'enabled' or  'disabled' depending on the AUI tree state.
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (!!widget && widget.setEnabled) {
            var disabled = controller.getAnchorNode().attribute('disabled');
            widget.setEnabled(!disabled);
          }
        }
      };
    });
  });
;
"use strict";

modulum('DisplayFormatVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class DisplayFormatVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.DisplayFormatVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.DisplayFormatVMBehavior.prototype */ {
        __name: "DisplayFormatVMBehavior",

        watchedAttributes: {
          container: ['keyboardHint', 'varType']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.setDisplayFormat) {
            var containerNode = controller.getNodeBindings().container;
            if (containerNode) {
              var varType = containerNode.attribute('varType');
              if (varType) {
                widget.setDisplayFormat(varType);
              }
            }
          }
        }
      };
    });
  });
;
"use strict";

modulum('DisplayMessageVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class DisplayMessageVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.DisplayMessageVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.DisplayMessageVMBehavior.prototype */ {
        __name: "DisplayMessageVMBehavior",

        watchedAttributes: {
          anchor: ['count', 'hidden']
        },

        _hideHandler: null,

        /**
         * Re-applies all controller's behaviors as all messages share the same widget
         */
        _apply: function(controller, data) {
          if (!data.isApplying) {
            data.isApplying = true;
            var widget = controller.getWidget();
            controller.applyBehaviors(null, true);
            widget.setHidden(false);
            data.isApplying = false;

            var bindings = controller.getNodeBindings();
            var messageService = bindings.anchor.getApplication().message;

            // No need to keep track of this, it is executed once (last param of "when" method set to 'true')
            controller.getAnchorNode().getApplication().layout.when(context.constants.widgetEvents.afterLayoutFocusRestored,
              function() {
                messageService.handlePositions();
              }.bind(this), true);

            if (this._hideHandler) {
              this._hideHandler();
            }
            this._hideHandler = widget.when("hide.MessageWidget", function() {
              messageService.handlePositions();
            }.bind(this));
          }
        },

        /**
         * @inheritDoc
         */
        _detach: function(controller, data) {
          if (this._hideHandler) {
            this._hideHandler();
            this._hideHandler = null;
          }
        }
      };
    });
  });
;
"use strict";

modulum('DndAcceptedVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class DndAcceptedVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.DndAcceptedVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.DndAcceptedVMBehavior.prototype */ {
        __name: "DndAcceptedVMBehavior",

        watchedAttributes: {
          anchor: ['dndAccepted', 'dndIdRef']
        },

        /**
         * @param {classes.ControllerBase} controller
         * @param {*} data
         */
        setup: function(controller, data) {
          data.count = 0;
        },
        /**
         *
         */
        _apply: function(controller, data) {
          var dndAccepted = controller.getAnchorNode().attribute('dndAccepted');
          // to avoid flickering, ignore first dndAccepted return by the VM just after the DragStart event
          if (data.count > 0) {
            context.DndService.dndAccepted = dndAccepted;
          } else {
            context.DndService.dndAccepted = false;
          }
          data.count++;
        }
      };
    });
  });
;
"use strict";

modulum('EnabledButtonVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Behavior controlling the widget's 'enabled' state
     * @class EnabledButtonVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.EnabledButtonVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.EnabledButtonVMBehavior.prototype */ {
        __name: "EnabledButtonVMBehavior",

        watchedAttributes: {
          parent: ['active'],
          anchor: ['active', 'actionActive', 'defaultView'],
          ui: ['runtimeStatus']
        },

        /**
         * Sets the widget 'enabled' or  'disabled' depending on the AUI tree state.
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          var anchorNode = controller.getAnchorNode();
          var uiNode = anchorNode.getApplication().uiNode();
          var parentNode = controller.getNodeBindings().parent;

          var isInterrupt = anchorNode.attribute("name") === "interrupt";
          var isProcessing = uiNode.attribute("runtimeStatus") === "processing";

          if (!!widget && widget.setEnabled) {
            var hidden = false;
            var activeValue = anchorNode.attribute('active');
            if (anchorNode.getParentNode().attribute("style") === "popup") {
              hidden = !activeValue;
            }

            if (anchorNode.isAttributePresent('actionActive')) {
              activeValue = activeValue || anchorNode.attribute('actionActive');
            }

            // When chromeBar theme is on, it changes some visibility behavior
            if (controller.isInChromeBar()) {
              if (parentNode.isAttributePresent('active')) {
                hidden = hidden ? hidden : parentNode.attribute("active") === 0;
              }
              if (anchorNode.isAttributePresent('defaultView')) {
                hidden = hidden ? hidden : anchorNode.attribute("defaultView") === "no";
                hidden = hidden ? hidden : anchorNode.attribute("hidden") === 1;
              }
            }

            var enabled = activeValue === 1;
            if (isInterrupt && !anchorNode.getApplication().action.hasAction("interrupt")) {
              enabled = isProcessing || enabled;
            }

            widget.setEnabled(enabled);

            //hide it if menu popup
            if (hidden && widget.setHidden) {
              widget.setHidden(hidden);
            } else if (widget.setHidden && controller.isInChromeBar()) {
              widget.setHidden(hidden);
            }
          }
        }
      };
    });
  });
;
"use strict";

modulum('EnabledVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Behavior controlling the widget's 'enabled' state
     * @class EnabledVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.EnabledVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.EnabledVMBehavior.prototype */ {
        __name: "EnabledVMBehavior",

        watchedAttributes: {
          anchor: ['active', 'actionActive', 'notEditable'],
          container: ['active', 'dialogType', 'noEntry']
        },

        /**
         * Sets the widget 'enabled' or  'disabled' depending on the AUI tree state.
         */
        _apply: function(controller, data) {
          var activeNode = null;
          var dialogTypeNode = null;
          var actionActiveNode = null;
          var isConstruct = false;

          var bindings = controller.getNodeBindings();
          if (bindings.container) {
            activeNode = bindings.container;
            dialogTypeNode = bindings.container;
            isConstruct = (dialogTypeNode.attribute('dialogType') === context.constants.dialogType.construct);
          } else if (bindings.anchor.isAttributePresent('active')) {
            activeNode = bindings.anchor;
          }
          if (bindings.anchor.isAttributePresent('actionActive')) {
            actionActiveNode = bindings.anchor;
          }

          var widget = controller.getWidget();
          if (!!widget && widget.setEnabled) {
            var activeValue = false;
            if (activeNode) {
              activeValue = activeNode.attribute('active');
            }
            if (actionActiveNode) {
              activeValue = activeValue || actionActiveNode.attribute('actionActive');
            }
            var enabled = activeValue === 1;
            if (dialogTypeNode) {
              var dialogTypeValue = dialogTypeNode.attribute('dialogType');
              enabled = enabled &&
                dialogTypeValue !== context.constants.dialogType.display &&
                dialogTypeValue !== context.constants.dialogType.displayArray;
            }

            var noEntry = (!!activeNode && !isConstruct) ? activeNode.attribute('noEntry') : 0; // In construct ignore noEntry attribute
            var notEditable = !!bindings.decorator ? bindings.decorator.attribute("notEditable") : 0;
            widget.getElement().toggleClass("readonly", noEntry === 1);
            if (noEntry === 1 && widget.setReadOnly) {
              widget.setReadOnly(true);
            } else if (notEditable === 1 && (widget.setReadOnly || widget.setNotEditable)) {
              if (widget.setNotEditable) {
                widget.setNotEditable(true);
              } else {
                widget.setReadOnly(true);
              }
            } else {
              if (widget.setReadOnly) {
                widget.setReadOnly(false);
              }
            }
            widget.setEnabled(enabled); // note that a noentry field is inactive
          }
        }
      };
    });
  });
;
"use strict";

modulum('FieldButtonEnabledVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Handles the enabled / disabled state of a button included in a field (ex. ButtonEdit)
     * @class FieldButtonEnabledVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.FieldButtonEnabledVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.FieldButtonEnabledVMBehavior.prototype */ {
        __name: "FieldButtonEnabledVMBehavior",

        watchedAttributes: {
          container: ['active'],
          decorator: ['actionActive']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.setButtonEnabled) {
            var bindings = controller.getNodeBindings();
            var isEnabled = bindings.container.attribute('active') === 1 &&
              bindings.decorator.attribute('actionActive') === 1;
            widget.setButtonEnabled(isEnabled);
          }
        }
      };
    });
  });
;
"use strict";

modulum('FocusOnFieldVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class FocusOnFieldVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.FocusOnFieldVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.FocusOnFieldVMBehavior.prototype */ {
        __name: "FocusOnFieldVMBehavior",

        watchedAttributes: {
          anchor: ['focusOnField']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.setFocusOnField) {
            var focusOnField = (controller.getAnchorNode().attribute('focusOnField') === 1);
            widget.setFocusOnField(focusOnField);
          }

        }
      };
    });
  });
;
"use strict";

modulum('FontFamilyVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class FontFamilyVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.FontFamilyVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.FontFamilyVMBehavior.prototype */ {
        __name: "FontFamilyVMBehavior",

        usedStyleAttributes: ['fontFamily'],

        watchedAttributes: {
          anchor: ['fontPitch'],
          decorator: ['fontPitch']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.setFontFamily) {
            var bindings = controller.getNodeBindings();
            var fontPitchNode = null;
            if (bindings.decorator) {
              fontPitchNode = bindings.decorator;
            } else if (bindings.anchor.isAttributePresent('fontPitch')) {
              fontPitchNode = bindings.anchor;
            }
            if (fontPitchNode && fontPitchNode.isAttributeSetByVM('fontPitch')) {
              var fontPitch = fontPitchNode.attribute('fontPitch');
              widget.setFontFamily(fontPitch === "fixed" ? 'Droid Sans Mono, monospace' : null);
            } else {
              var font = controller.getAnchorNode().getStyleAttribute('fontFamily');
              if (font) {
                widget.setFontFamily(font);
              }
            }
          }
        }
      };
    });
  });
;
"use strict";

modulum('FontWeightVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class FontWeightVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.FontWeightVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.FontWeightVMBehavior.prototype */ {
        __name: "FontWeightVMBehavior",

        watchedAttributes: {
          anchor: ['bold'],
          decorator: ['bold']
        },

        usedStyleAttributes: ["fontWeight"],

        /**
         *
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.setFontWeight) {
            var bindings = controller.getNodeBindings();
            var boldNode = null;
            if (bindings.anchor.isAttributeSetByVM('bold')) {
              boldNode = bindings.anchor;
            } else if (bindings.decorator && bindings.decorator.isAttributeSetByVM('bold')) {
              boldNode = bindings.decorator;
            }
            if (boldNode) {
              var bold = boldNode.attribute('bold') === 1;
              widget.setFontWeight(bold ? "bold" : null);
            } else {
              var fontWeight = controller.getAnchorNode().getStyleAttribute('fontWeight');
              widget.setFontWeight(fontWeight);
            }
          }
        }
      };
    });
  }
);
;
"use strict";

modulum('FormatVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Manage both DBDATE and Format attribute. If a Format attribute is specified it replaces DBDATE format
     * @class FormatVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.FormatVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.FormatVMBehavior.prototype */ {
        __name: "FormatVMBehavior",

        watchedAttributes: {
          decorator: ['format']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.setFormat) {
            var decoratorNode = controller.getNodeBindings().decorator;
            if (decoratorNode.isAttributeSetByVM('format') && decoratorNode.attribute('format')) {
              // BDL format convention has uppercase equivalent in web conventions
              // except for day abbreviation which has to stay lowercase
              var format = decoratorNode.attribute('format').toUpperCase();
              // day abbreviation exception
              format = format.replace(/(DDD)/g, "ddd");
              widget.setFormat(format);
            } else {
              var dbDate = widget.getUserInterfaceWidget().getDbDateFormat();
              var tradionalFormat = cls.DateTimeHelper.parseDbDateFormat(dbDate);
              widget.setFormat(tradionalFormat);
            }
          }
        }
      };
    });
  });
;
"use strict";

modulum('FormRelatedHiddenVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Behavior controlling the ToolBar's visibility
     * @class FormRelatedHiddenVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.FormRelatedHiddenVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.FormRelatedHiddenVMBehavior.prototype */ {
        __name: "FormRelatedHiddenVMBehavior",

        watchedAttributes: {
          parent: ['hidden'],
        },

        /**
         * Updates the widget's visibility depending on the AUI tree information
         */
        _apply: function(controller, data) {
          var anchorNode = controller.getAnchorNode();
          var formNode = anchorNode.getParentNode();
          var windowNode = formNode.getParentNode();
          var hidden = formNode.attribute('hidden');
          var visible = hidden === context.constants.visibility.visible;
          var inDisplayedWindow = windowNode.getController().getWidget() === context.HostService.getCurrentWindow();
          var toolBarInVisiblePosition = anchorNode.getTag() === 'ToolBar' ? anchorNode.getStyleAttribute('toolBarPosition') !==
            'none' : true;
          var widget = controller.getWidget();
          widget.setHidden(!inDisplayedWindow || !(visible && toolBarInVisiblePosition));
        }
      };
    });
  });
;
"use strict";

modulum('HiddenVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Behavior controlling the widget's visibility
     * @class HiddenVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.HiddenVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.HiddenVMBehavior.prototype */ {
        __name: "HiddenVMBehavior",

        watchedAttributes: {
          anchor: ['hidden', 'defaultView'],
          container: ['hidden', 'pageSize', 'bufferSize']
        },

        /**
         * @param {classes.ControllerBase} controller
         * @param {Object} data
         */
        setup: function(controller, data) {
          data.firstApply = true;
        },

        /**
         * Updates the widget's visibility depending on the AUI tree information
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();

          var bindings = controller.getNodeBindings();
          var hiddenNode = null;
          var defaultViewNode = null;
          if (bindings.container) {
            hiddenNode = bindings.container;
          } else {
            hiddenNode = bindings.anchor;
          }
          if (bindings.anchor.isAttributePresent('defaultView')) {
            defaultViewNode = bindings.anchor;
          }

          // Handle visibility in case of Matrix
          var isMatrix = hiddenNode.getTag() === "Matrix";
          if (isMatrix) {
            var valueList = hiddenNode._children[1];
            var pageSize = hiddenNode.attribute('pageSize');
            var bufferSize = hiddenNode.attribute('bufferSize');
            // Hide if Valuelist is bigger than pageSize
            if (valueList._children.indexOf(controller.getAnchorNode()) >= Math.max(pageSize, bufferSize)) {
              if (widget && widget.setHidden) {
                widget.setHidden(true);
                return;
              }
            }
          }

          if (widget && widget.setHidden) {
            var hidden = hiddenNode.attribute('hidden');
            var visible = hidden === context.constants.visibility.visible;
            var parentStyle = hiddenNode.getParentNode().attribute('style');
            if (visible && !!defaultViewNode && parentStyle !== "popup" && parentStyle !== "dialog") { // defaultView is not taken into account when in menu style is not popup and not dialog (GBC-600)
              var defaultView = defaultViewNode.attribute('defaultView');
              visible = defaultView === context.constants.viewType.showAlways;
            }

            // Table column specific code
            var isTableColumn = hiddenNode.getTag() === "TableColumn";
            if (isTableColumn && widget.setAlwaysHidden) {
              widget.setAlwaysHidden(hidden === context.constants.visibility.hiddenByProgram);

              // Stored settings columns
              var storedHidden = data.firstApply ? controller.getStoredSetting("hidden") : null;
              if (storedHidden !== null && (hidden === context.constants.visibility.hiddenByUser) !== storedHidden) {
                visible = !storedHidden;
                // Send order to hide/show column
                var event = new cls.VMConfigureEvent(hiddenNode.getId(), {
                  hidden: visible ? context.constants.visibility.visible : context.constants.visibility.hiddenByUser
                });
                hiddenNode.getApplication().dvm.onOrdersManaged(function() {
                  hiddenNode.getApplication().typeahead.event(event, hiddenNode);
                }.bind(this), true);
              }
            }

            widget.setHidden(!visible);

            data.firstApply = false;
          }
        }
      };
    });
  });
;
"use strict";

modulum('ImageVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class ImageVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.ImageVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.ImageVMBehavior.prototype */ {
        __name: "ImageVMBehavior",

        watchedAttributes: {
          anchor: ['image'],
          decorator: ['image']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.setImage) {
            var bindings = controller.getNodeBindings();
            var imageNode = null;
            if (bindings.decorator && bindings.decorator.isAttributePresent('image')) {
              imageNode = bindings.decorator;
            } else {
              imageNode = bindings.anchor;
            }
            var image = imageNode.attribute('image');
            widget.setImage(context.__wrapper.wrapResourcePath(image));
          }
        }
      };
    });
  }
);
;
"use strict";

modulum('IncludeVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Handle field validation: Include (list of allowed values)
     * @class IncludeVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.IncludeVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.IncludeVMBehavior.prototype */ {
        __name: "IncludeVMBehavior",

        watchedAttributes: {
          container: ['include']
        },

        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.setAllowedValues) {
            var containerNode = controller.getNodeBindings().container;
            var include = containerNode.attribute('include');
            include = include.split("|");
            widget.setAllowedValues(include.length ? include : null);
          }
        }
      };
    });
  });
;
"use strict";

modulum('IsPasswordVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class IsPasswordVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.IsPasswordVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.IsPasswordVMBehavior.prototype */ {
        __name: "IsPasswordVMBehavior",

        watchedAttributes: {
          anchor: ['isPassword'],
          decorator: ['isPassword']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.setIsPassword) {
            var bindings = controller.getNodeBindings();
            var isPasswordNode = null;
            if (bindings.anchor.isAttributeSetByVM('isPassword')) {
              isPasswordNode = bindings.anchor;
            } else {
              isPasswordNode = bindings.decorator;
            }
            var isPassword = isPasswordNode.attribute('isPassword');
            widget.setIsPassword(isPassword);
          }
        }
      };
    });
  });
;
"use strict";

modulum('ItemVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Behavior controlling the completer items
     * @class ItemVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.ItemVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.ItemVMBehavior.prototype */ {
        __name: "ItemVMBehavior",

        /**
         * Updates the widget's visibility depending on the AUI tree information
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();

          if (widget && widget.setChoices) {
            var children = controller.getNodeBindings().decorator.getChildren(),
              needUpdate = data.widget !== widget || (!data.lastItems || data.lastItems.length !== children.length ||
                !!data.lastItems.find(function(item, i) {
                  return children[i].attribute("name") !== item.value ||
                    children[i].attribute("text") !== item.text;
                }));

            if (needUpdate) {
              data.widget = widget;
              data.lastItems = children.map(function(child) {
                return {
                  text: child.attribute("text"),
                  value: child.attribute("name")
                };
              });
              widget.setChoices(data.lastItems);
            }
          }
        },

        _onItemsCountChanged: function(controller, data, event, src, node) {
          data.dirty = true;
        },

        /**
         * @inheritDoc
         * @protected
         */
        _attach: function(controller, data) {
          var decoratorNode = controller.getNodeBindings().decorator;
          //on new Item node
          data._onNodeCreateHandle = decoratorNode.onNodeCreated(this._onItemsCountChanged.bind(this, controller, data), "Item");
          data._onNodeRemoveHandle = decoratorNode.onNodeRemoved(this._onItemsCountChanged.bind(this, controller, data), "Item");
        },

        /**
         * @inheritDoc
         * @protected
         */
        _detach: function(controller, data) {
          if (data._onNodeCreateHandle) {
            data._onNodeCreateHandle();
            data._onNodeCreateHandle = null;
          }
          if (data._onNodeRemoveHandle) {
            data._onNodeRemoveHandle();
            data._onNodeRemoveHandle = null;
          }
        }
      };
    });
  });
;
"use strict";

modulum('KeyboardHintVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class KeyboardHintVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.KeyboardHintVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.KeyboardHintVMBehavior.prototype */ {
        __name: "KeyboardHintVMBehavior",

        watchedAttributes: {
          container: ['varType'],
          decorator: ['keyboardHint']
        },

        usedStyleAttributes: ["dataTypeHint"],

        /**
         *
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.setType) {
            var bindings = controller.getNodeBindings();
            var keyboardHint = null;
            var keyboardVal = bindings.decorator.attribute('keyboardHint');
            if (!!keyboardVal) {
              keyboardHint = keyboardVal.toLowerCase();
            }
            var varType = null;
            var attrVal = bindings.container.attribute('varType');
            if (!!attrVal) {
              attrVal = attrVal.toLowerCase();
              var pattern = /(\w+)/;
              var match = attrVal.match(pattern);
              varType = match[1];
            }

            switch (keyboardHint) {
              case "email":
                widget.setType("email");
                break;
              case "number":
                widget.setType("text");
                break;
              case "phone":
                widget.setType("tel");
                break;
              case "url":
                widget.setType("url");
                break;
              case "default":
                /* falls through */
              default:
                switch (varType) {
                  case "bigint":
                  case "byte":
                  case "decimal":
                  case "float":
                  case "integer":
                  case "interval":
                  case "smallFloat":
                  case "smallInt":
                  case "tinyInt":
                    widget.setType("text");
                    break;

                  case "date":
                  case "datetime":
                  case "char":
                  case "string":
                  case "text":
                  case "varchar":
                  case "money":
                    /* falls through */
                  default:
                    var dataTypeHint = controller.getAnchorNode().getStyleAttribute('dataTypeHint');
                    if (dataTypeHint) {
                      widget.setType(dataTypeHint);
                    } else {
                      widget.setType("text");
                    }
                }
            }
          }
        }
      };
    });
  });
;
"use strict";

modulum('LayoutInfoVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class LayoutInfoVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.LayoutInfoVMBehavior = context.oo.Singleton(cls.BehaviorBase, function() {
      return /** @lends classes.LayoutInfoVMBehavior.prototype */ {
        __name: "LayoutInfoVMBehavior",

        widgetsIgnoringSizePolicy: ["ButtonEdit", "DateEdit", "DateTimeEdit", "Edit", "ProgressBar", "Slider", "SpinEdit",
          "TextEdit", "TimeEdit"
        ],

        watchedAttributes: {
          anchor: ['width', 'gridWidth', 'height', 'gridHeight', 'posX', 'posY', 'stretch', 'sizePolicy', 'gridChildrenInParent',
            'minWidth', 'minHeight', 'autoScale'
          ],
          container: ['gridChildrenInParent', 'stepX', 'stepY', 'columnCount'],
          decorator: ['width', 'gridWidth', 'height', 'gridHeight', 'posX', 'posY', 'stretch', 'sizePolicy', 'gridChildrenInParent',
            'minWidth', 'minHeight', 'autoScale'
          ]
        },

        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var nodeBindings = controller.getNodeBindings(),
            anchorNode = nodeBindings.anchor,
            layoutInfoNode = nodeBindings.decorator || anchorNode,
            containerNode = nodeBindings.container,
            widget = controller.getWidget(),
            layoutInformation = widget && widget.getLayoutInformation(),
            rawLayoutInformation = layoutInformation && layoutInformation.getRawInformation(),
            layoutEngine = widget && widget.getLayoutEngine();

          var doUpdate = false;

          if (rawLayoutInformation) {
            // we look if some raw info is updated
            var onChange = rawLayoutInformation.onRawLayoutInformationChanged(function() {
              doUpdate = true;
            }, true);
            if (layoutInfoNode) {
              rawLayoutInformation.setSizePolicy(layoutInfoNode.attribute('sizePolicy'));
              rawLayoutInformation.setWidth(layoutInfoNode.attribute('width'));
              rawLayoutInformation.setHeight(layoutInfoNode.attribute('height'));
              rawLayoutInformation.setGridWidth(layoutInfoNode.attribute('gridWidth'));
              rawLayoutInformation.setGridHeight(layoutInfoNode.attribute('gridHeight'));
              rawLayoutInformation.setPosX(layoutInfoNode.attribute('posX'));
              rawLayoutInformation.setPosY(layoutInfoNode.attribute('posY'));
              rawLayoutInformation.setMinWidth(layoutInfoNode.attribute('minWidth'));
              rawLayoutInformation.setMinHeight(layoutInfoNode.attribute('minHeight'));

              rawLayoutInformation.setStretch(layoutInfoNode.attribute('stretch'));
              rawLayoutInformation.setAutoScale(layoutInfoNode.attribute('autoScale'));

              rawLayoutInformation.setWantFixedPageSize(layoutInfoNode.attribute("wantFixedPageSize"));
              rawLayoutInformation.setGridChildrenInParent(layoutInfoNode.attribute('gridChildrenInParent'));
            }
            if (containerNode) {
              rawLayoutInformation.setChildOfGridChildrenInParent(containerNode.attribute('gridChildrenInParent'));
              rawLayoutInformation.setStepX(containerNode.attribute('stepX'));
              rawLayoutInformation.setStepY(containerNode.attribute('stepY'));
              rawLayoutInformation.setColumnCount(containerNode.attribute('columnCount'));
            }
            // if nothing changed, don't forget to free the event hook
            if (!doUpdate) {
              onChange();
            }
          }

          if (layoutInformation && doUpdate) {
            doUpdate = false;
            var sizePolicy = rawLayoutInformation.getSizePolicy();
            if (this.widgetsIgnoringSizePolicy.indexOf(layoutInfoNode.getTag()) !== -1) {
              sizePolicy = "initial";
            }
            if (layoutEngine && layoutEngine.setHint) {
              var widthHint = rawLayoutInformation.getWidth();
              var heightHint = rawLayoutInformation.getHeight();
              if (sizePolicy === 'fixed') {
                if (!widthHint) {
                  widthHint = rawLayoutInformation.getGridWidth();
                }
                if (!heightHint) {
                  heightHint = rawLayoutInformation.getGridHeight();
                }
              }
              layoutEngine.setHint(widthHint, heightHint);
            }

            if (layoutInformation.setMinSizeHint) {
              var minWidthHint = rawLayoutInformation.getMinWidth();
              var minHeightHint = rawLayoutInformation.getMinHeight();
              layoutInformation.setMinSizeHint(minWidthHint, minHeightHint);
            }

            var autoscale = rawLayoutInformation.getAutoScale();
            layoutInformation.setSizePolicyMode(controller.isInMatrix() || (sizePolicy === "dynamic" && autoscale) ? "fixed" :
              sizePolicy);

            doUpdate = layoutInformation.setGridWidth(rawLayoutInformation.getGridWidth(), true) || doUpdate;
            if (widget.setCols) {
              var rawWidth = rawLayoutInformation.getWidth();
              if (!rawLayoutInformation.getGridWidth() && cls.Size.isCols(rawWidth)) {
                widget.setCols(parseInt(rawWidth, 10));
              } else {
                widget.setCols(rawLayoutInformation.getGridWidth() || 1);
              }
            }
            doUpdate = layoutInformation.setGridHeight(rawLayoutInformation.getGridHeight(), true) || doUpdate;

            var position = {
              x: rawLayoutInformation.getPosX() || 0,
              y: rawLayoutInformation.getPosY() || 0
            };
            var isInNormalScrollGrid = false;
            if (containerNode && containerNode.getTag() === "Matrix") {
              var scrollGrid = containerNode.getAncestor("ScrollGrid");
              isInNormalScrollGrid = scrollGrid === null || scrollGrid.attribute("wantFixedPageSize") !== 0;
            }
            if (containerNode && (containerNode !== anchorNode) && isInNormalScrollGrid) {
              var index = anchorNode.getParentNode()._children.indexOf(anchorNode),
                columnCount = rawLayoutInformation.getColumnCount() || 1,
                stepX = (rawLayoutInformation.getStepX() || 0),
                stepY = (rawLayoutInformation.getStepY() || 0);
              var shiftX = index % columnCount;
              var shiftY = Math.floor(index / columnCount);

              position.x += (shiftX * stepX);
              position.y += (shiftY * stepY);
            }

            doUpdate = layoutInformation.setGridX(position.x, true) || doUpdate;
            doUpdate = layoutInformation.setGridY(position.y, true) || doUpdate;
            var stretch = rawLayoutInformation.getStretch();
            if (stretch) {
              var xStretching = layoutInfoNode.getTag() === "Image" ? layoutInformation.getSizePolicyConfig().mode !== "fixed" :
                true;
              layoutInformation.getStretched().setX((stretch === 'x' || stretch === 'both'));
              layoutInformation.getStretched().setY(stretch === 'y' || stretch === 'both');
            }
            if (layoutInfoNode.getTag() === "ScrollGrid" && rawLayoutInformation.getWantFixedPageSize() === 0) {
              layoutInformation.getStretched().setY(true);
            }
            var gridChildrenInParent = +(rawLayoutInformation.getGridChildrenInParent() || 0);
            if (widget.setGridChildrenInParent) {
              widget.setGridChildrenInParent(!!gridChildrenInParent);
            }
            if (doUpdate) {
              layoutInformation.invalidateInfos();
            }
          }
        }
      };
    });
  });
;
"use strict";

modulum('ListViewPageSizeVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class ListViewPageSizeVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.ListViewPageSizeVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.ListViewPageSizeVMBehavior.prototype */ {
        __name: "ListViewPageSizeVMBehavior",

        watchedAttributes: {
          anchor: ['bufferSize', 'pageSize', 'size', 'dialogType']
        },
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var tableNode = controller.getAnchorNode();

          if (this._checkListViewSupport(controller, data)) {
            var bufferSize = tableNode.attribute('bufferSize');
            var tableColumns = tableNode.getChildren("TableColumn");
            var listViewWidget = controller.getWidget();
            var lineIndex;
            for (lineIndex = 0; lineIndex < bufferSize; ++lineIndex) {

              var rowWidget = cls.WidgetFactory.createWidget("ListViewRow", listViewWidget.getBuildParameters());
              listViewWidget.addChildWidget(rowWidget);

              // Add widgets for first column
              if (tableColumns.length > 0) {
                this._createControllersAndWidgets(tableColumns[0], lineIndex, listViewWidget, 0);
              }
              // Add widgets for second column
              if (tableColumns.length > 1) {
                this._createControllersAndWidgets(tableColumns[1], lineIndex, listViewWidget, 1);
              }
            }
            listViewWidget.updateHighlight();
          }
        },

        /**
         * Check if list view is supported and close app if it is not the case
         * @param controller
         * @private
         */
        _checkListViewSupport: function(controller, data) {
          var tableNode = controller.getAnchorNode();
          var dialogType = tableNode.attribute('dialogType');
          var isTree = tableNode.isTreeView();

          if (data.animationFrameOffset) {
            window.cancelAnimationFrame(data.animationFrameOffset);
            data.animationFrameOffset = 0;
          }

          var support = (dialogType.startsWith("Display") && !isTree);
          if (!support) {
            data.animationFrameOffset = window.requestAnimationFrame(function() { // let finish the behavior works and close app after
              data.animationFrameOffset = 0;
              var currentApp = gbc.SessionService.getCurrent() && gbc.SessionService.getCurrent().getCurrentApplication();
              if (currentApp) {
                currentApp.close();
                currentApp.stop("ListView widget not supported in INPUT, INPUT ARRAY, CONSTRUCT, TREE");
              }
            }.bind(this));
          }
          return support;
        },

        _createControllersAndWidgets: function(node, lineIndex, listViewWidget, columnIndex) {
          var valueList = node.getFirstChild("ValueList");
          if (valueList) {
            var valueNode = valueList.getChildren()[lineIndex];
            var ctrl = valueNode.getController();

            if (ctrl && ctrl.getWidget()) {
              return; // if the controller and the widget are already created --> nothing to do
            }

            if (!ctrl) {
              ctrl = valueNode._createController();
              valueNode._controller = ctrl;
              ctrl.setAutoCreateWidget(false);
            }

            var widget = ctrl.createWidgetFromType("Label");
            if (widget) {
              var row = listViewWidget.getRows()[lineIndex];
              row.addChildWidget(widget);
              ctrl._attachWidget(); // attach widget to controller for UI behavior
              if (columnIndex === 1) {
                var decorator = ctrl.getNodeBindings().decorator;
                row.setHorizontalLayout(decorator.attribute("justify") === "right");
              }
            }
          }
        },

        /**
         * @inheritDoc
         */
        _detach: function(controller, data) {
          if (data.animationFrameOffset) {
            window.cancelAnimationFrame(data.animationFrameOffset);
            data.animationFrameOffset = 0;
          }
        },
      };
    });
  }
);
;
"use strict";

modulum('MatrixCurrentRowVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class MatrixCurrentRowVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.MatrixCurrentRowVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.MatrixCurrentRowVMBehavior.prototype */ {
        __name: "MatrixCurrentRowVMBehavior",

        watchedAttributes: {
          container: ['currentRow', 'offset', 'size'],
          ui: ['focus']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          var bindings = controller.getNodeBindings();
          var matrixNode = bindings.container;
          var app = matrixNode.getApplication();
          if (widget && !app.typeahead.hasPendingNavigationCommands()) {
            var uiNode = app.uiNode();
            var currentRow = matrixNode.attribute("currentRow");
            var offset = matrixNode.attribute("offset");
            var size = matrixNode.attribute("size");
            var hasFocus = matrixNode.getId() === uiNode.attribute("focus");

            var addCurrentRowOnField = currentRow !== -1 && (currentRow < size && currentRow - offset === bindings.anchor.getIndex());

            var newCurrentRow = -1;
            // case of scrollgrid
            var matrixParent = matrixNode.getParentNode();
            var matrixParentWidget = matrixParent && matrixParent.getController() && matrixParent.getController().getWidget();
            while (matrixParent && matrixParentWidget && !matrixParentWidget.setCurrentRow) {
              matrixParent = matrixParent.getParentNode();
              matrixParentWidget = matrixParent && matrixParent.getController() && matrixParent.getController().getWidget();
            }

            if (matrixParentWidget && matrixParentWidget.setCurrentRow) {

              if (currentRow === -1 && matrixParent.attribute("active") === 1) { // if one matrix in scrollgrid has a currentRow equal to -1 --> focusOnField activated
                matrixParentWidget.setFocusOnField(true);
              }

              // scrollgrid
              var scrollGridCurrentRow = matrixParent.attribute('currentRow');
              var scrollGridOffset = matrixParent.attribute('offset');

              newCurrentRow = scrollGridCurrentRow - scrollGridOffset;
              matrixParentWidget.setCurrentRow(newCurrentRow);

              var isDisplayArray = (matrixNode.attribute("dialogType") === "DisplayArray");

              // add currentRow class on all filed in display array
              // add currentRow only on current matrix in input array
              // --> to simulate highlightCurrentCell style
              addCurrentRowOnField = addCurrentRowOnField && matrixParentWidget.isHighlightCurrentCell() && (isDisplayArray ||
                hasFocus);
            } else {
              // synchronize processed currentRow with VM currentRow
              if (matrixNode.getController().updateAllSiblingMatrixCurrentRow) {
                newCurrentRow = currentRow - offset;
                matrixNode.getController().updateAllSiblingMatrixCurrentRow(newCurrentRow);

              }
            }

            widget.toggleClass("currentRow", addCurrentRowOnField);

            var parentForm = matrixNode.getAncestor("Form");
            var visibleId = null;
            if (parentForm) {
              visibleId = parentForm.attribute("visibleId");
            }
            // if matrix has vm focus and no visibleId is set on its parent form, then we display it
            if (hasFocus && (!visibleId || visibleId === -1)) {
              controller.ensureVisible();
            }
          }
        }
      };
    });
  }
);
;
"use strict";

modulum('MaxLengthVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class MaxLengthVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.MaxLengthVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.MaxLengthVMBehavior.prototype */ {
        __name: "MaxLengthVMBehavior",

        watchedAttributes: {
          decorator: ['maxLength', 'autoNext', 'picture']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.setMaxLength) {
            var decoratorNode = controller.getNodeBindings().decorator;
            var maxLength = null;
            if (decoratorNode.isAttributeSetByVM('maxLength')) {
              maxLength = decoratorNode.attribute('maxLength');
              if (maxLength === 0) {
                // 0 means 'disable maxLength'
                maxLength = null;
              }
            }

            if (decoratorNode.isAttributeSetByVM('autoNext') && decoratorNode.attribute('autoNext') === 1) {
              if (data.nextFieldHandler) {
                data.nextFieldHandler();
              }
              data.nextFieldHandler = widget.when(context.constants.widgetEvents.keyUp, this._onkeyUp.bind(this, controller, data));
            }

            widget.setMaxLength(maxLength);
          }
        },

        _detach: function(controller, data) {
          if (data.nextFieldHandler) {
            data.nextFieldHandler();
            data.nextFieldHandler = null;
          }
        },

        _onkeyUp: function(controller, data, e) {
          var inputElement = controller.getWidget().getInputElement();
          if (inputElement) {
            var decoratorNode = controller.getNodeBindings().decorator;
            var maxLength = 0;
            if (decoratorNode.isAttributeSetByVM('maxLength')) {
              maxLength = decoratorNode.attribute('maxLength');
              if (maxLength === 0) {
                // 0 means 'disable maxLength'
                return;
              }
            } else {
              maxLength = decoratorNode.attribute('width');
            }
            var valueLength = inputElement.value ? inputElement.value.length : 0;
            var endReached = inputElement.selectionStart === inputElement.selectionEnd &&
              inputElement.selectionEnd + 1 >= maxLength &&
              inputElement.selectionStart + 1 >= maxLength;

            //Do nothing if arrow left/right: return
            var key = cls.KeyboardApplicationService.keymap[e.data[0].which];
            if (key && key !== "space") { // modifiers shouldn't execute nextfield
              return;
            }

            if (valueLength >= maxLength && endReached) {
              if (controller._nodeBindings) {
                controller.getAnchorNode().getApplication().keyboard.processKey("Tab");
              }
            }
          }
        },
      };
    });
  });
;
"use strict";

modulum('MenuEnabledVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Behavior controlling the widget's Menu
     * @class MenuEnabledVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.MenuEnabledVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.MenuEnabledVMBehavior.prototype */ {
        __name: "MenuEnabledVMBehavior",

        usedStyleAttributes: ["actionPanelPosition", "ringMenuPosition"],

        watchedAttributes: {
          anchor: ['active']
        },

        /**
         * Updates the widget's visibility depending on the AUI tree information
         */
        _apply: function(controller, data) {
          var thisWidget = controller.getWidget();
          if (!thisWidget) {
            return;
          }
          var anchorNode = controller.getAnchorNode();
          var isActive = anchorNode.attribute('active') === 1;

          if (thisWidget.setEnabled) {
            thisWidget.setEnabled(isActive);
          }
        }
      };
    });
  });
;
"use strict";

modulum('MessageTextVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class MessageTextVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.MessageTextVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.MessageTextVMBehavior.prototype */ {
        __name: "MessageTextVMBehavior",

        watchedAttributes: {
          anchor: ['text'],
          decorator: ['text']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.setText) {
            var bindings = controller.getNodeBindings();
            var textNode = bindings.decorator && bindings.decorator.isAttributeSetByVM('text') ? bindings.decorator : bindings.anchor;
            var text = textNode.attribute('text');
            widget.setText(text);
          }
        }
      };
    });
  });
;
"use strict";

modulum('MultiRowSelectionVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class MultiRowSelectionVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.MultiRowSelectionVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.MultiRowSelectionVMBehavior.prototype */ {
        __name: "MultiRowSelectionVMBehavior",

        watchedAttributes: {
          anchor: ['multiRowSelection']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          var tableWidget = controller.getWidget();
          if (tableWidget && tableWidget.setMultiRowSelectionEnabled) {
            var anchorNode = controller.getAnchorNode();
            tableWidget.setMultiRowSelectionEnabled(anchorNode.attribute('multiRowSelection') !== 0);
          }
        }
      };
    });
  });
;
"use strict";

modulum('NativeScrollVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class NativeScrollVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.NativeScrollVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.NativeScrollVMBehavior.prototype */ {
        __name: "NativeScrollVMBehavior",

        watchedAttributes: {
          anchor: ['offset', 'size', 'pageSize', 'active']
        },
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var node = controller.getAnchorNode();
          var widget = controller.getWidget();

          if (widget && widget.updateContentPosition) {
            controller.requestOffsetPending = false;
            var active = node.attribute('active');
            var pageSize = node.attribute('pageSize');
            // If the container isn't active, consider it as empty.
            // The DVM doesn't set size and offset to 0 when exiting the current dialog (DISPLAY ARRAY or INPUT ARRAY)
            // This avoids the container to remain scrollable on inactive Tables and ScrollGrids
            var size = active ? node.attribute('size') : 0;
            var offset = active ? node.attribute('offset') : 0;
            widget.updateContentPosition(size, pageSize, offset);
          }
        }
      };
    });
  });
;
"use strict";

modulum('NotNullVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Handle field validation: NotNull
     * @class NotNullVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.NotNullVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.NotNullVMBehavior.prototype */ {
        __name: "NotNullVMBehavior",

        watchedAttributes: {
          container: ['notNull']
        },

        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.setNotNull) {
            var containerNode = controller.getNodeBindings().container;
            var notNull = containerNode.attribute('notNull') === 1;
            widget.setNotNull(notNull);
          }
        }
      };
    });
  });
;
"use strict";

modulum('OrientationVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class OrientationVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.OrientationVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.OrientationVMBehavior.prototype */ {
        __name: "OrientationVMBehavior",

        watchedAttributes: {
          decorator: ['orientation']
        },

        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.setOrientation) {
            var decoratorNode = controller.getNodeBindings().decorator;
            var orientation = decoratorNode.attribute('orientation');
            widget.setOrientation(orientation);

            if (widget.isInstanceOf(cls.SliderWidget)) {
              var node = controller.getAnchorNode();
              var layoutService = node.getApplication().layout;

              if (data._afterLayoutHandler) {
                data._afterLayoutHandler();
                data._afterLayoutHandler = null;
              }
              data._afterLayoutHandler = layoutService.afterLayout(function() {
                widget.setOrientation(orientation, true);
              }.bind(this));
            }
          }
        },

        _detach: function(controller, data) {
          if (data._afterLayoutHandler) {
            data._afterLayoutHandler();
            data._afterLayoutHandler = null;
          }
        }
      };
    });
  });
;
"use strict";

modulum('PageSizeVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Behavior
     * @class PageSizeVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.PageSizeVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.PageSizeVMBehavior.prototype */ {
        __name: "PageSizeVMBehavior",

        watchedAttributes: {
          anchor: ['pageSize']
        },

        /**
         * Updates pageSize
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.setPageSize) {
            var anchorNode = controller.getAnchorNode();
            var pageSize = anchorNode.attribute('pageSize');
            widget.setPageSize(pageSize);
          }
        }
      };
    });
  });
;
"use strict";

modulum('PictureVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class PictureVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.PictureVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.PictureVMBehavior.prototype */ {
        __name: "PictureVMBehavior",

        watchedAttributes: {
          decorator: ['picture'],
          container: ['dialogType']
        },

        /**
         * Apply PICTURE rules on the widget. Bind handlers on its input field
         * @param controller
         * @param data
         * @private
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.getInputElement) {
            var decoratorNode = controller.getNodeBindings().decorator;
            var containerNode = controller.getNodeBindings().container;
            var input = widget.getInputElement();
            if (input) {
              if (decoratorNode && decoratorNode.isAttributeSetByVM('picture') && containerNode && containerNode.attribute(
                  'dialogType') !== "Construct" && decoratorNode.attribute("picture").length > 0) {
                // Analyse picture and create rule (group) for each character of the mask
                var mask = decoratorNode.attribute('picture');
                data.groups = [];

                for (var i = 0; i < mask.length; i++) {
                  data.groups.push(this._createGroup(mask[i]));
                }

                if (!window.isAndroid()) {
                  // Android keyboards don't provide pressed key info in keydown/keyup. Workarouds aren't satisfying either.
                  // Picture is thus disabled on this platform until proper support of keydown/keyup events

                  // Bind on paste event and prevent drag event
                  // Catch paste event to update value if it's respecting picture format
                  input.off('paste.PictureVMBehavior');
                  input.on('paste.PictureVMBehavior', this._onPicturePaste.bind(this, controller, data));

                  // Disable text selection dragging
                  input.off("dragstart.PictureVMBehavior");
                  input.on("dragstart.PictureVMBehavior", this._onDragStart.bind(this));

                  // Override widget manageKeyDown method
                  if (!data.manageKeyDown) {
                    data.manageKeyDown = widget.manageKeyDown;
                  }
                  widget.manageKeyDown = function(keyString, domKeyEvent, repeat) {
                    return this._manageKeyDown.call(this, controller, data, keyString, domKeyEvent, repeat);
                  }.bind(this);
                }
              } else {
                input.off('paste.PictureVMBehavior');
                input.off("dragstart.PictureVMBehavior");
              }
            }
          }
        },

        /**
         * Detach input handlers and restore initial widget manageKeyDown
         * @param controller
         * @param data
         * @private
         */
        _detach: function(controller, data) {
          var widget = controller && controller.getWidget();
          if (widget) {
            var input = widget.getInputElement && widget.getInputElement();
            if (input) {
              input.off('paste.PictureVMBehavior');
              input.off("dragstart.PictureVMBehavior");
            }
            if (data.manageKeyDown) {
              widget.manageKeyDown = data.manageKeyDown;
            }
          }
        },

        /**
         * Override widget manageKeyDown method.
         * @param {object} controller
         * @param {object} data
         * @param {string} keyString - key combinaison
         * @param {object} domKeyEvent
         * @param {boolean} repeat
         * @returns {boolean} true if key has been processed
         * @private
         */
        _manageKeyDown: function(controller, data, keyString, domKeyEvent, repeat) {
          var keyProcessed = false;
          var widget = controller.getWidget();

          if (widget.isEnabled() && !widget.isReadOnly()) {

            var input = widget.getInputElement();
            var start = input.selectionStart;
            var value = input.value;
            var cursor = this._getNextCursor(data, start, value.length);

            // First manage picture specific special keys (left, right, backspace, del), then execute widget manageKeyDown rules.
            // Finally, if no special key has to be be managed, we let picturevmbehavior manage the key depending of the picture mask
            switch (keyString) {
              case widget.getStart():
                cursor = this._getPreviousCursor(data, start);
                if (cursor) {
                  input.setCursorPosition(cursor.start, cursor.start + 1);
                  keyProcessed = true;
                }
                break;
              case widget.getEnd():
                cursor = this._getNextCursor(data, start, value.length);
                if (cursor) {
                  input.setCursorPosition(cursor.start, cursor.start + 1);
                  keyProcessed = true;
                }
                break;
              case "backspace":
                keyProcessed = this._onPictureBackspace(controller, data);
                break;
              case "del":
                keyProcessed = this._onPictureDelete(controller, data);
                break;
              default:
                keyProcessed = data.manageKeyDown.call(widget, keyString, domKeyEvent, repeat);
            }
          }

          if (keyProcessed) {
            return true;
          } else if (cls.KeyboardHelper.isSpecialCommand(keyString)) { // let browser manages native combinaison
            return false;
          } else {
            return this._onPictureKeydown(controller, data, domKeyEvent.gbcKey);
          }
        },

        /**
         * Insert typed key at correct position if allowed by PICTURE mask. Otherwise do nothing
         * @param controller
         * @param data
         * @param {string} keyString
         * @returns {boolean}
         * @private
         */
        _onPictureKeydown: function(controller, data, keyString) {
          var pictureWidget = controller.getWidget();
          var input = pictureWidget.getInputElement();
          var start = input.selectionStart;

          var value = input.value;
          var cursor = this._getNextCursor(data, start, value.length);

          // start at first editable position from cursor position (editable group)
          while (data.groups[start] && !data.groups[start].isEditable) {
            var separator = data.groups[start].separator;
            if (value[start] !== separator) {
              input.value = value = (value.substr(0, start) + separator + value.substr(start + 1));
              cursor = this._getNextCursor(data, start + 1, value.length);
            }
            start++;
          }
          // Validate current pressed key
          var currentGroup = data.groups[start];
          if (currentGroup && currentGroup.isValid) {
            if (cls.KeyboardHelper.isChar(keyString)) { // char is fully managed by picture behvior
              if (currentGroup.isValid(keyString)) {
                // Place cursor to new permitted position
                var char = this._applyShift(controller, keyString);
                input.value = (value.substr(0, start) + char + value.substr(start + 1));
                input.setCursorPosition(cursor.start, cursor.end);
                pictureWidget._editingTime = Date.now();
                pictureWidget.setEditing(pictureWidget.isEditing() || pictureWidget.getValue() !== pictureWidget._oldValue);
              }
              return true;
            } else { // unknown combination, we let browser manage it
              return false;
            }
          }
          // current group is undefined => we reached end of the picture mask. key flaged as processed to prevent default
          return true;
        },

        /**
         * Manage backspace key. Erase previous key if allowed to.
         * @param controller
         * @param data
         * @returns {boolean}
         * @private
         */
        _onPictureBackspace: function(controller, data) {
          var pictureWidget = controller.getWidget();
          var input = pictureWidget.getInputElement();
          var start = input.selectionStart;
          var end = input.selectionEnd;

          var manyselected = end - start > 1;

          var cursor = this._getPreviousCursor(data, start);
          if (cursor || manyselected) {
            var value = input.value;

            // Correctly remove many char at the same time
            if (manyselected) {
              this._removeManyChars(data, input);
            } else {
              input.value = (value.substr(0, cursor.start) + ' ' + value.substr(cursor.start + 1));
              input.setCursorPosition(cursor.start, cursor.start + 1);
              pictureWidget._editingTime = Date.now();
              pictureWidget.setEditing(pictureWidget.isEditing() || pictureWidget.getValue() !== pictureWidget._oldValue);
            }
          }
          return true;
        },

        /**
         * Manage delete key. Remove current key if allowed to. Otherwise move to next editable char
         * @param controller
         * @param data
         * @returns {boolean}
         * @private
         */
        _onPictureDelete: function(controller, data) {
          var pictureWidget = controller.getWidget();
          var input = pictureWidget.getInputElement();
          var start = input.selectionStart;
          var end = input.selectionEnd;

          var value = input.value;
          var cursor = {
            start: start,
            end: start + 1
          };
          var manyselected = end - start > 1;
          if (manyselected) {
            this._removeManyChars(data, input);
          } else {
            if (start < value.length) {
              if (data.groups[start].isEditable) {
                input.value = (value.substr(0, start) + ' ' + value.substr(start + 1));
              } else {
                cursor = this._getNextCursor(data, start, value.length);
              }
              input.setCursorPosition(cursor.start, cursor.end);
              pictureWidget._editingTime = Date.now();
              pictureWidget.setEditing(pictureWidget.isEditing() || pictureWidget.getValue() !== pictureWidget._oldValue);
            }
          }
          return true;
        },

        /**
         * Manange paste of value. Try to insert each char of the copied value into the PICTURE field
         * @param controller
         * @param data
         * @param e
         * @private
         */
        _onPicturePaste: function(controller, data, e) { // paste
          var pictureWidget = controller.getWidget();
          var input = pictureWidget.getInputElement();
          var pastedText = null;
          // Get pasted value
          if (window.clipboardData && window.clipboardData.getData) { // IE
            pastedText = window.clipboardData.getData('Text');
          } else if (e.clipboardData && e.clipboardData.getData) {
            pastedText = e.clipboardData.getData('text/plain');
          }

          // Build new value till no conflict is met. when one conflict is met, take mask value for all remaining length.
          var newValue = "";
          var j = 0;
          var decoratorNode = controller.getNodeBindings().decorator;
          var mask = decoratorNode.attribute('picture');
          var pastedTextLength = pastedText.length;
          // Get cursor positions
          var start = input.selectionStart;

          var length = pastedTextLength; // loop length will depend of parsedText length. If parsedText length is higher than mask (data.groups), we take mask length

          var i = start;
          while (j < length) { // loop on each pastedText char from starting cursor position
            if (i === data.groups.length) { // end of editable zone
              break;
            }
            var group = data.groups[i];
            if (!group.isEditable) { // separator are kept intact --> copy them into new value
              var separator = mask[i];
              newValue += separator;
              if (separator === pastedText[j]) { // if current pasted char == current group seperator, we will not analyse it afterward
                j++;
              }
            } else { // current group is editable, check if current pasted char is valid
              var char = pastedText[j];
              if (group.isValid && group.isValid(char)) {
                // if previously no conflict met and current char is valid, we add it to new value
                char = this._applyShift(controller, char);
                newValue += char;
                j++;
              } else { // char is not valid, take mask value (whitespace since it's not a separator)
                break;
              }
            }
            i++;
          }

          var existingValue = input.value;

          // Set input new value
          input.value = existingValue.substring(0, start) + newValue + existingValue.substring(start + newValue.length);
          input.setCursorPosition(i, i + 1);
          pictureWidget._editingTime = Date.now();
          pictureWidget.setEditing(pictureWidget.isEditing() || pictureWidget.getValue() !== pictureWidget._oldValue);

          event.preventCancelableDefault();
        },

        /**
         * Prevent drag/drop of selection over the PICTURE mask
         * @param event
         * @private
         */
        _onDragStart: function(event) {
          event.preventCancelableDefault();
        },

        /**
         * Remove all selected chars from PICTURE mask
         * @param data
         * @param input
         * @private
         */
        _removeManyChars: function(data, input) {
          var value = input.value;
          var start = input.selectionStart;
          var end = input.selectionEnd;

          var resultArray = value.split("");
          var tmpStart = start;

          while (data.groups.length > tmpStart && tmpStart !== end) {
            if (data.groups[tmpStart].isEditable) {
              resultArray[tmpStart] = " ";
            }
            tmpStart++;
          }
          var jumpStart = 0;
          var jumpStop = 0;

          // Set the cursor correctly
          while (data.groups[start + jumpStart] && !data.groups[start + jumpStart].isEditable) {
            jumpStart++;
          }
          while (data.groups[end + jumpStop - 1] && !data.groups[end + jumpStop - 1].isEditable) {
            jumpStop++;
          }
          input.value = resultArray.join("");
          input.setCursorPosition(start + jumpStart, end - jumpStop);
        },

        /**
         * Get previous editing position
         * @param data
         * @param ind
         * @returns {*}
         * @private
         */
        _getPreviousCursor: function(data, ind) {
          if (ind === 0) {
            return null;
          }
          var start = ind;
          var jump = false;
          while (start > 0 && !data.groups[start - 1].isEditable) {
            jump = true;
            start--;
          }
          return {
            start: start - 1,
            jump: jump
          };
        },

        /**
         * Get next editing position
         * @param data
         * @param ind
         * @param length
         * @returns {{start: *, end: *, jump: boolean}}
         * @private
         */
        _getNextCursor: function(data, ind, length) {
          var start = ind + 1;
          var jump = false;
          while (data.groups.length > start && !data.groups[start].isEditable) {
            jump = true;
            start++;
          }
          var end = start;
          if (start < length) {
            end = start + 1;
          }
          return {
            start: start,
            end: end,
            jump: jump
          };
        },

        /**
         * Parse the PICTURE letter and get a corresponding group rule
         * @param type
         * @returns {{}}
         * @private
         */
        _createGroup: function(type) {
          var group = {};
          switch (type) {
            case 'A': // Alpha numeric
              group.isEditable = true;
              group.isValid = cls.KeyboardHelper.isLetter;
              break;
            case '#': // Numeric only
              group.isEditable = true;
              group.isValid = cls.KeyboardHelper.isNumeric;
              break;
            case 'X': // All
              group.isEditable = true;
              group.isValid = cls.KeyboardHelper.isChar;
              break;
            default: // Mask separator
              group.isEditable = false;
              group.isValid = null;
              group.separator = type;
          }
          return group;
        },

        /**
         * Apply shift attribute (if set) over the char
         * @param controller
         * @param char
         * @returns {*}
         * @private
         */
        _applyShift: function(controller, char) {
          var decoratorNode = controller.getNodeBindings().decorator;
          var shiftAttr = decoratorNode.attribute('shift');
          if (shiftAttr !== "none") {
            switch (shiftAttr) {
              case 'up':
                char = char.toUpperCase();
                break;
              case 'down':
                char = char.toLowerCase();
                break;
            }
          }
          return char;
        }

      };
    });
  });
;
"use strict";

modulum('PlaceholderVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Behavior controlling the widget's Menu
     * @class PlaceholderVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.PlaceholderVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.PlaceholderVMBehavior.prototype */ {
        __name: "PlaceholderVMBehavior",

        watchedAttributes: {
          container: ['active', 'dialogType', 'currentRow', 'offset'],
          table: ['currentRow', 'offset'],
          decorator: ['placeholder']
        },
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          var activeNode = null;

          if (widget && widget.setPlaceHolder) {
            var decoratorNode = controller.getNodeBindings().decorator;
            if (decoratorNode && decoratorNode.isAttributeSetByVM('placeholder')) {
              var bindings = controller.getNodeBindings();
              if (bindings.container) {
                activeNode = bindings.container;
              } else if (bindings.anchor.isAttributePresent('active')) {
                activeNode = bindings.anchor;
              }
              var placeholder = "";
              if (activeNode) {
                var activeValue = activeNode.attribute('active');
                var dialogType = bindings.container.attribute("dialogType");

                // Only enabled widget in Input, Construct or InputArray should have placeholder visible. In InputArray only current row widget does
                if (activeValue === 1 && dialogType !== "Display" && dialogType !== "DisplayArray") {
                  if (controller.isInTable() || controller.isInMatrix()) { // only widget being in focused in current should have its placeholder visible
                    var container = controller.isInTable() ? bindings.table : bindings.container;
                    var currentRow = container.attribute("currentRow");
                    var offset = container.attribute("offset");
                    var size = container.attribute("size");
                    if (currentRow < size && currentRow - offset === bindings.anchor.getIndex()) {
                      placeholder = decoratorNode.attribute('placeholder');
                    }
                  } else {
                    placeholder = decoratorNode.attribute('placeholder');
                  }
                }
              }
              widget.setPlaceHolder(placeholder);
            }
          }
        },

      };
    });
  });
;
"use strict";

modulum('PropertyVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Behavior controlling the widget's Property
     * @class PropertyVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.PropertyVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.PropertyVMBehavior.prototype */ {
        __name: "PropertyVMBehavior",

        _attrChangedHandlers: [],
        /**
         * Updates the widget's visibility depending on the AUI tree information
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget._setProperty) {
            var webComponentNode = controller.getNodeBindings().decorator;
            var children = webComponentNode.getChildren();
            if (children.length > 0) {
              var property = this._propertyToJson(children[0]);
              widget._setProperty(JSON.stringify(property));
            }
          }
        },

        _attach: function(controller, data) {
          var node = controller.getNodeBindings().decorator;
          data.nodeCreatedHandler = node.onNodeCreated(this._onNodeCreated.bind(this, controller, data), "Property");
          var webComponentNode = controller.getNodeBindings().decorator;
          var children = webComponentNode.getDescendants("Property");
          if (children.length > 0) {
            children.forEach(function(propChild) {
              this._attrChangedHandlers.push(propChild.onAttributeChanged("value", function(event, node, data) {
                this._apply(controller, data);
              }.bind(this)));

            }.bind(this));
          }
        },

        _detach: function(controller, data) {
          this._attrChangedHandlers.forEach(function(attrChangedHandle) {
            attrChangedHandle();
          });
          this._attrChangedHandlers.length = 0;
          if (data.nodeCreatedHandler) {
            data.nodeCreatedHandler();
            data.nodeCreatedHandler = null;
          }
        },

        _onNodeCreated: function(controller, data, event, src, node) {
          node.onNodeCreated(this._onNodeCreated.bind(this, controller, data));
          this._attrChangedHandlers.push(node.onAttributeChanged("value", function(event, node, data) {
            this._apply(controller, data);
          }.bind(this)));
          this._apply(controller, data);
        },

        /**
         * Convert PropertyDict node to JSON property
         * @param node
         * @returns {{}}
         * @private
         */
        _propertyToJson: function(node) {
          var jsonProperties = {};
          var childNode = null;
          var children = node.getChildren();
          var count = children && children.length || 0;
          for (var i = 0; i < count; i++) {
            childNode = children[i];
            if (childNode._tag === "Property") {
              jsonProperties[childNode.attribute("name")] = childNode.attribute("value");
            } else if (childNode._tag === "PropertyArray") {
              jsonProperties[childNode.attribute("name")] = this._propertyArrayToJson(childNode);
            } else if (childNode._tag === "PropertyDict") {
              jsonProperties[childNode.attribute("name")] = this._propertyToJson(childNode);
            }
          }
          return jsonProperties;
        },

        /**
         * Convert PropertyArray node to JSON property
         * @param node
         * @returns {Array}
         * @private
         */
        _propertyArrayToJson: function(node) {
          var propertyArray = [];
          var childNode = null;
          var children = node.getChildren();
          var count = children && children.length || 0;
          for (var i = 0; i < count; i++) {
            childNode = children[i];
            propertyArray.push(childNode.attribute("value"));
          }
          return propertyArray;
        }
      };
    });
  });
;
"use strict";

modulum('QAInfoVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class QAInfoVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.QAInfoVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.QAInfoVMBehavior.prototype */ {
        __name: "QAInfoVMBehavior",

        watchedAttributes: {
          anchor: ['name', 'value'],
          container: ['name'],
          table: ['offset']
        },
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var bindings = controller.getNodeBindings();
          var node = bindings.container || bindings.anchor;
          var widget = controller.getWidget();
          if (widget && widget.setQAInfo) {
            var name = node.attribute('name') || node.attribute('tabName');
            widget.setQAInfo('name', name);
            var value = bindings.anchor.attribute('value');
            widget.setQAInfo('value', value);

            widget.setQAInfo('aui-id', node._id);

            var offsetNode = null;
            if (bindings.container &&
              (bindings.container.getTag() === 'TableColumn' || bindings.container.getTag() === 'Matrix')) {
              offsetNode = bindings.container.getParentNode();
            }
            if (offsetNode) {
              var offset = offsetNode.attribute('offset') || 0;
              widget.setQAInfo('index', offset + controller.getAnchorNode().getParentNode().getChildren().indexOf(controller
                .getAnchorNode()));
            }
            var tabIndex = node.attribute('tabIndex');
            if (!!tabIndex) {
              widget.setQAInfo('tabindex', tabIndex);
            }
          }
        }
      };
    });
  });
;
"use strict";

modulum('QueryEditableVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class QueryEditableVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.QueryEditableVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.QueryEditableVMBehavior.prototype */ {
        __name: "QueryEditableVMBehavior",

        watchedAttributes: {
          decorator: ['queryEditable']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.setQueryEditable) {
            var bindings = controller.getNodeBindings();
            var queryEditableNode = bindings.decorator ? bindings.decorator : bindings.anchor;
            var queryEditable = !!queryEditableNode.attribute('queryEditable');

            widget.setQueryEditable(queryEditable);
          }
        }
      };
    });
  });
;
"use strict";

modulum('RangeVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class RangeVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.RangeVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.RangeVMBehavior.prototype */ {
        __name: "RangeVMBehavior",

        watchedAttributes: {
          decorator: ['valueMin', 'valueMax', 'step']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          var decoratorNode = controller.getNodeBindings().decorator;
          if (widget && widget.setMax) {
            var valueMax = decoratorNode.attribute('valueMax');
            widget.setMax(valueMax);
          }
          if (widget && widget.setMin) {
            var valueMin = decoratorNode.attribute('valueMin');
            widget.setMin(valueMin);
          }
          if (widget && widget.setStep) {
            var step = decoratorNode.attribute('step');
            widget.setStep(step);
          }
        }
      };
    });
  });
;
"use strict";

modulum('RequiredVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Handle field validation: Required
     * @class RequiredVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.RequiredVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.RequiredVMBehavior.prototype */ {
        __name: "RequiredVMBehavior",

        watchedAttributes: {
          container: ['required']
        },

        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.setRequired) {
            var containerNode = controller.getNodeBindings().container;
            var required = containerNode.attribute('required') === 1;
            widget.setRequired(required);
          }
        }
      };
    });
  });
;
"use strict";

modulum('RipGraphicTypeVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class RipGraphicTypeVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.RipGraphicTypeVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.RipGraphicTypeVMBehavior.prototype */ {
        __name: "RipGraphicTypeVMBehavior",

        watchedAttributes: {
          anchor: ['type']
        },
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          controller.getWidget().setType(controller.getAnchorNode().attribute('type'));
        }
      };
    });
  });
;
"use strict";

modulum('RowSelectedVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class RowSelectedVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.RowSelectedVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.RowSelectedVMBehavior.prototype */ {
        __name: "RowSelectedVMBehavior",

        watchedAttributes: {
          anchor: ['selected'],
          table: ['multiRowSelection']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          var bindings = controller.getNodeBindings();

          var tableWidget = bindings.table.getController().getWidget();
          if (tableWidget && tableWidget.setRowSelected) {
            var multiRowSelection = bindings.table.attribute('multiRowSelection');
            var selected = multiRowSelection && bindings.anchor.attribute('selected');
            tableWidget.setRowSelected(bindings.anchor.getIndex(), selected);
          }
        }
      };
    });
  });
;
"use strict";

modulum('RuntimeStatusVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class RuntimeStatusVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.RuntimeStatusVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.RuntimeStatusVMBehavior.prototype */ {
        __name: "RuntimeStatusVMBehavior",

        watchedAttributes: {
          anchor: ['runtimeStatus']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          var uiNode = controller.getAnchorNode();
          var app = uiNode.getApplication();
          if (!!app) {
            var runtimeStatus = uiNode.attribute('runtimeStatus');
            if (runtimeStatus !== "childstart" && runtimeStatus !== "processing") {
              app.setIdle();
            }
            if (runtimeStatus === "childstart") {
              app.newTask();
            }
          }
        }
      };
    });
  });
;
"use strict";

modulum('ScrollBarsVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class ScrollBarsVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.ScrollBarsVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.ScrollBarsVMBehavior.prototype */ {
        __name: "ScrollBarsVMBehavior",

        watchedAttributes: {
          decorator: ['scrollBars']
        },

        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.setScrollBars) {
            var decoratorNode = controller.getNodeBindings().decorator;
            var scrollBars = decoratorNode.isAttributeSetByVM('scrollBars') ? decoratorNode.attribute('scrollBars').toLowerCase() :
              'auto';
            widget.setScrollBars(scrollBars);
          }
        }
      };
    });
  });
;
"use strict";

modulum('ScrollVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class ScrollVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.ScrollVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.ScrollVMBehavior.prototype */ {
        __name: "ScrollVMBehavior",

        watchedAttributes: {
          anchor: ['offset', 'size', 'pageSize']
        },
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var node = controller.getAnchorNode();
          var widget = controller.getWidget();
          if (widget && widget.setPageSize && widget.setSize) {
            controller.requestOffsetPending = false;
            var pageSize = node.attribute('pageSize');
            var size = node.attribute('size');
            var offset = node.attribute('offset');
            widget.setOffset(offset);
            widget.setSize(size);
            widget.setTotalHeight((widget.getRowHeight ? widget.getRowHeight() : widget._lineHeight) * size);
            if (widget.refreshScroll) {
              widget.refreshScroll();
            }

            if (data.onScrollHandler) {
              data.onScrollHandler();
              data.onScrollHandler = null;
            }
            var layoutService = node.getApplication().layout;
            data.onScrollHandler = layoutService.afterLayout(function() {
              widget.setPageSize(pageSize);
              // Beware setPageSize function change the value of widget._lineHeight !!!!
              widget.setTotalHeight((widget.getRowHeight ? widget.getRowHeight() : widget._lineHeight) * size);
              widget.setSize(size);

              // update scrollarea & scroller height & refresh scrollWidget
              if (widget.refreshScroll) {
                widget.refreshScroll();
              }
              layoutService.prepareApplyLayout(widget);

              if (data.onScrollHandler) {
                data.onScrollHandler();
                data.onScrollHandler = null;
              }
            });
          }
        },
        /**
         * @inheritDoc
         */
        _detach: function(controller, data) {
          if (data.onScrollHandler) {
            data.onScrollHandler();
            data.onScrollHandler = null;
          }
        }
      };
    });
  });
;
"use strict";

modulum('SplitterVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class SplitterVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.SplitterVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.SplitterVMBehavior.prototype */ {
        __name: "SplitterVMBehavior",

        watchedAttributes: {
          anchor: ['splitter']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.switchSplitters) {
            var activateSplitters = controller.getAnchorNode().attribute('splitter');
            var storedSettingsSplitterId = this._getIdentifier(controller);
            //Check if we force default Settings
            var forcedSettings = controller.getNodeBindings().parent.getStyleAttribute("forceDefaultSettings");
            widget.ignoreStoredSettings(forcedSettings === 1 || forcedSettings === "yes" || forcedSettings === "true");
            widget.switchSplitters(activateSplitters, storedSettingsSplitterId);
          }
        },

        /**
         * Get an unique id for a Hbox / Vbox node
         * @param controller
         * @returns {{formName:string, id:string}} identifier of the splitter (i.e: "Grid0_VBox0")
         * @private
         */
        _getIdentifier: function(controller) {
          var identifier = [];
          var bindings = controller.getNodeBindings();
          var anchor = bindings.anchor;
          var index = 0;
          var parentNode = anchor.getParentNode();
          var siblings = null;
          var formName = "";

          // Goes up in AUI tree to get position of each splitter in VBox, HBox and Grid
          while (parentNode !== null) {
            if (["VBox", "HBox", "Grid"].indexOf(anchor.getTag()) >= 0) {
              siblings = parentNode.getDescendants(anchor.getTag());
              //more than one siblings
              if (siblings.length > 1) {
                index = siblings.indexOf(anchor);
                identifier.push(anchor.getTag() + index);
              } else {
                //only one sibling
                identifier.push(anchor.getTag() + "0");
              }
            } else if (anchor.getTag() === "Form") {
              formName = anchor.attribute("name");
            }

            anchor = parentNode;
            parentNode = anchor.getParentNode();
          }
          return {
            formName: formName,
            id: identifier.reverse().join("_")
          };
        }

      };
    });
  });
;
"use strict";

modulum('StackLabelVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class StackLabelVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.StackLabelVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.StackLabelVMBehavior.prototype */ {
        __name: "StackLabelVMBehavior",

        watchedAttributes: {
          anchor: ['text']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.getParentWidget() && widget.getParentWidget().setStackLabelText) {
            var bindings = controller.getNodeBindings();
            var textNode = bindings.anchor;
            var text = textNode.attribute('text');
            widget.getParentWidget().setStackLabelText(widget, text);
          }
        }
      };
    });
  });
;
"use strict";

modulum('StretchableScrollGridPageSizeVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class StretchableScrollGridPageSizeVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.StretchableScrollGridPageSizeVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.StretchableScrollGridPageSizeVMBehavior.prototype */ {
        __name: "StretchableScrollGridPageSizeVMBehavior",

        watchedAttributes: {
          anchor: ['wantFixedPageSize', 'size', 'offset', 'pageSize', 'bufferSize']
        },
        /**
         *
         * @param controller
         * @param data
         */
        setup: function(controller, data) {
          data.linesCount = 0;
        },

        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          if (data.animationFrameOffset) {
            window.cancelAnimationFrame(data.animationFrameOffset);
          }
          // This requestAnimationFrame is needed as we have to create lines only once the layout has been done
          data.animationFrameOffset = window.requestAnimationFrame(
            function() { // TODO Check if we can use LayoutApplicationService.onAfterLayout
              data.animationFrameOffset = 0;
              context.styler.bufferize();
              var scrollGridNode = controller.getAnchorNode();
              if (scrollGridNode) {
                var size = scrollGridNode.attribute('size');
                var pageSize = scrollGridNode.attribute('pageSize');
                var bufferSize = scrollGridNode.attribute('bufferSize');
                var offset = scrollGridNode.attribute('offset');
                var count = Math.max(pageSize, bufferSize);
                var lineIndex;
                var lineController;
                var linesCount = controller.getLineControllersCount();
                if (linesCount !== count) {
                  for (lineIndex = linesCount; lineIndex < count; ++lineIndex) {
                    // Add widgets
                    lineController = new cls.ScrollGridLineController(scrollGridNode, lineIndex);
                    scrollGridNode.getController().getWidget().addChildWidget(lineController.getWidget());
                    controller.pushLineController(lineController);
                  }
                  for (lineIndex = linesCount - 1; lineIndex >= count; --lineIndex) {
                    // Remove Widgets
                    lineController = controller.popLineController();
                    lineController.destroy();
                  }
                  controller.getWidget().updateHighlight();
                }
                // Add the new line to the DOM but set its visibility to hidden.
                // It will be displayed in the after layout handler below.
                // This avoids flashs with SVG images during the initial render.
                for (lineIndex = 0; lineIndex < controller.getLineControllersCount(); ++lineIndex) {
                  lineController = controller.getLineController(lineIndex);
                  var hidden = offset + lineIndex >= size;
                  lineController.getWidget().setHidden(hidden);
                  lineController.getWidget().addClass('loading-line');
                }
                context.styler.flush();
                var layoutService = scrollGridNode.getApplication().layout;
                layoutService.refreshLayout({
                  resize: true
                });
                layoutService.afterLayout(function() {
                  for (lineIndex = 0; lineIndex < controller.getLineControllersCount(); ++lineIndex) {
                    lineController = controller.getLineController(lineIndex);
                    if (!!lineController) {
                      var lineWidget = lineController.getWidget();
                      if (!!lineWidget && lineWidget.getElement()) {
                        lineWidget.removeClass('loading-line');
                      }
                    }
                  }
                }.bind(this), true);
              }
            }.bind(this));
        },

        /**
         * @inheritDoc
         */
        _detach: function(controller, data) {
          if (data.animationFrameOffset) {
            window.cancelAnimationFrame(data.animationFrameOffset);
            data.animationFrameOffset = 0;
          }
        },
      };
    });
  }
);
;
"use strict";

modulum('StyleVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class StyleVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.StyleVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.StyleVMBehavior.prototype */ {
        __name: "StyleVMBehavior",

        watchedAttributes: {
          anchor: ['style'],
          decorator: ['style']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          var bindings = controller.getNodeBindings();
          var styleNode = bindings.decorator ? bindings.decorator : bindings.anchor;
          if (widget) {
            var style = styleNode.attribute('style');
            if (widget.getRawStyles() === style) {
              return;
            }

            styleNode.getApplication().styleAttributesChanged.push(styleNode);
            if (style !== undefined) {
              widget.setApplicationStyles(style);
            }
          }
          controller.setStyleBasedBehaviorsDirty();
        }
      };
    });
  });
;
"use strict";

modulum('TableCurrentVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class TableCurrentVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.TableCurrentVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.TableCurrentVMBehavior.prototype */ {
        __name: "TableCurrentVMBehavior",

        watchedAttributes: {
          anchor: ['currentRow', 'currentColumn', 'offset']
        },

        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.setCurrentRow) {
            var tableNode = controller.getAnchorNode();
            var app = tableNode.getApplication();
            var uiNode = app.uiNode();
            var currentRow = tableNode.attribute('currentRow');

            if (!app.typeahead.hasPendingNavigationCommands()) {
              var offset = tableNode.attribute('offset');
              var size = tableNode.attribute('size');
              var localCurrentRow = currentRow - offset;

              var ensureRowVisible = (currentRow !== data.oldCurrentRow && localCurrentRow === 0 && size > 0);
              widget.setCurrentRow(localCurrentRow, ensureRowVisible);

              if (widget.setCurrentColumn) {
                var currentColumn = tableNode.attribute('currentColumn');
                widget.setCurrentColumn(currentColumn);
              }
            }

            var hasFocus = tableNode.getId() === uiNode.attribute("focus");
            var parentForm = tableNode.getAncestor("Form");
            var visibleId = null;
            if (parentForm) {
              visibleId = parentForm.attribute("visibleId");
            }
            // if table has vm focus and no visibleId is set on its parent form, then we display it
            if (hasFocus && (!visibleId || visibleId === -1)) {
              controller.ensureVisible();
            }

            // =====================================
            if (controller.updateMultiRowSelectionRoot) {
              controller.multiRowSelectionRoot = currentRow;
            }
            controller.updateMultiRowSelectionRoot = true;
            // =====================================

            data.oldCurrentRow = currentRow;
          }
        }
      };
    });
  });
;
"use strict";

modulum('TableDialogTypeVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class TableDialogTypeVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.TableDialogTypeVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.TableDialogTypeVMBehavior.prototype */ {
        __name: "TableDialogTypeVMBehavior",

        watchedAttributes: {
          anchor: ['dialogType']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget) {
            var dialogType = controller.getAnchorNode().attribute('dialogType');

            if (widget._resetItemsSelection) {
              widget._resetItemsSelection();
            }

            if (widget.setInputMode) {
              widget.setInputMode(!(dialogType === "Display" || dialogType === "DisplayArray"));
            }
            if (widget.setDndItemEnabled) {
              widget.setDndItemEnabled(dialogType === "DisplayArray");
            }
          }

        }
      };
    });
  });
;
"use strict";

modulum('TableImageVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class TableImageVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.TableImageVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.TableImageVMBehavior.prototype */ {
        __name: "TableImageVMBehavior",

        watchedAttributes: {
          anchor: ['image']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (!widget) {
            return;
          }
          var tableItemWidget = widget.getParentWidget();
          if (tableItemWidget && tableItemWidget.setImage) {

            var tableColumnNode = controller.getNodeBindings().container;
            var tableNode = tableColumnNode.getParentNode();
            var isListView = tableNode.getController().isListView();
            // for list view use only first column for images
            if (!isListView || tableNode.getChildren("TableColumn").indexOf(tableColumnNode) === 0) {
              var image = controller.getAnchorNode().attribute('image');
              tableItemWidget.setImage(context.__wrapper.wrapResourcePath(image));
            }
          }
        }
      };
    });
  });
;
"use strict";

modulum('TableItemCurrentRowVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class TableItemCurrentRowVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.TableItemCurrentRowVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.TableItemCurrentRowVMBehavior.prototype */ {
        __name: "TableItemCurrentRowVMBehavior",

        watchedAttributes: {
          table: ['currentRow', 'offset', 'dialogType', 'active']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.setEnabled) {
            var tableNode = controller.getNodeBindings().table;
            var dialogType = tableNode.attribute('dialogType');

            if (dialogType === "Input" || dialogType === "Construct") {
              var currentRow = tableNode.attribute('currentRow');
              var offset = tableNode.attribute('offset');
              var itemNode = controller.getAnchorNode();
              var index = itemNode.getParentNode().getChildren().indexOf(itemNode);
              var enabled = (index === (currentRow - offset)) && (itemNode.getParentNode().getParentNode().attribute('active') ===
                1);
              widget.setEnabled(enabled);
            }
          }
        }
      };
    });
  });
;
"use strict";

modulum('TableRowHeightVMBehavior', ['BehaviorBase'],
  /**
   * Manage "height" attribute on widgets to set table row height
   * @param {gbc} context
   * @param {classes} cls
   */
  function(context, cls) {
    /**
     * @class TableRowHeightVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.TableRowHeightVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.TableRowHeightVMBehavior.prototype */ {
        __name: "TableRowHeightVMBehavior",

        watchedAttributes: {
          decorator: ['height']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.setRowHeight) {
            var decoratorNode = controller.getNodeBindings().decorator;
            var height = decoratorNode.attribute('height');
            if (data.savedHeight !== height && height > 1) {
              data.savedHeight = height;
              // Transform nb of characters to pixels
              var fontInfo = cls.Measurement.fontInfo(widget.getElement());
              height = cls.Measurement.measuredHeight(fontInfo["font-family"], fontInfo["font-size"], height);

              widget.setRowHeight(height);
            }
          }
        }
      };
    });
  });
;
"use strict";

modulum('TableSizeVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Behavior controlling the the change of size in a table
     * @class TableSizeVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.TableSizeVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.TableSizeVMBehavior.prototype */ {
        __name: "TableSizeVMBehavior",

        watchedAttributes: {
          table: ['size']
        },
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          if (!!controller && controller.changeWidgetKind) {
            var tableColumnNode = controller.getNodeBindings().container;
            var dialogType = tableColumnNode.attribute('dialogType');
            var active = tableColumnNode.attribute('active');
            var hasChanged = controller.changeWidgetKind(dialogType, active);
            var widget = controller.getWidget();
            if (widget && widget.getParentWidget() && widget.getParentWidget().updateVisibility) {
              widget.getParentWidget().updateVisibility();
            }
            var treeItem = controller.getNodeBindings().treeItem;
            if (!!treeItem) {
              treeItem.applyBehaviors(null, true, true);
            }
            return hasChanged; // return true to force apply of next behaviors
          }
          return false;
        }
      };
    });
  });
;
"use strict";

modulum('TableSortVMBehavior', ['BehaviorBase'],
  /**
   * Manage "sortType" & "sortColumn" attribute
   * @param {gbc} context
   * @param {classes} cls
   */
  function(context, cls) {
    /**
     * @class TableSortVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.TableSortVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.TableSortVMBehavior.prototype */ {
        __name: "TableSortVMBehavior",

        watchedAttributes: {
          anchor: ['sortType', 'sortColumn']
        },

        /**
         * @param {classes.ControllerBase} controller
         * @param {Object} data
         */
        setup: function(controller, data) {
          data.firstApply = true;
        },

        /**
         *
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.setSort) {
            var tableNode = controller.getAnchorNode();

            var sortType = null;
            var sortColumn = null;

            var storedSortType = data.firstApply ? controller.getStoredSetting("sortType") : null;
            var storedSortColumn = data.firstApply ? controller.getStoredSetting("sortColumn") : null;

            if (storedSortType !== null && storedSortColumn !== null) {
              sortType = storedSortType;
              sortColumn = storedSortColumn;

              // Send stored sort values to VM
              var event = new cls.VMConfigureEvent(tableNode.getId(), {
                sortColumn: sortColumn,
                sortType: sortType
              });
              tableNode.getApplication().dvm.onOrdersManaged(function() {
                tableNode.getApplication().typeahead.event(event, tableNode);
              }.bind(this), true);
            } else {
              sortType = tableNode.attribute('sortType');
              sortColumn = tableNode.attribute('sortColumn');
            }

            widget.setSort(sortType, sortColumn);
          }
          data.firstApply = false;
        }
      };
    });
  });
;
"use strict";

modulum('TableTabIndexVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class TableTabIndexVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.TableTabIndexVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.TableTabIndexVMBehavior.prototype */ {
        __name: "TableTabIndexVMBehavior",

        watchedAttributes: {
          anchor: ['tabIndex']
        },

        /**
         * @param {classes.ControllerBase} controller
         * @param {Object} data
         */
        setup: function(controller, data) {
          data.firstApply = true;
        },

        /**
         *
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.setOrder) {

            if (data.firstApply) { // first time we receive tabIndex we load visual index from stored settings and resent new index to VM
              var storedTabIndex = controller.getStoredSetting("tabIndex");
              if (!!storedTabIndex && storedTabIndex >= 0) {
                widget.emit(context.constants.widgetEvents.tableOrderColumn, storedTabIndex); // Emit an event to send the col tabIndex to VM
                widget.setOrder(storedTabIndex);
              }
            }
          }
          data.firstApply = false;
        }
      };
    });
  });
;
"use strict";

modulum('TableTextVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class TableTextVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.TableTextVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.TableTextVMBehavior.prototype */ {
        __name: "TableTextVMBehavior",

        watchedAttributes: {
          anchor: ['text']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.setText) {
            var bindings = controller.getNodeBindings();
            var text = bindings.anchor.attribute('text');
            widget.setText(text);
          }
        }
      };
    });
  });
;
"use strict";

modulum('TextActionVMBehavior', ['BehaviorBase'],
  /**
   * Manage "Text" attribute only for Action widgets
   * @param {gbc} context
   * @param {classes} cls
   */
  function(context, cls) {
    /**
     * @class TextActionVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.TextActionVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.TextActionVMBehavior.prototype */ {
        __name: "TextActionVMBehavior",

        watchedAttributes: {
          anchor: ['name', 'comment', 'text', 'actionIdRef'],
          decorator: ['action', 'actionIdRef']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && (widget.setText || widget.setActionTitle)) {
            var anchorNode = controller.getAnchorNode();
            var actionName;
            if (controller._widgetType === "ButtonEdit") {
              anchorNode = controller.getNodeBindings().decorator;
              actionName = anchorNode.attribute('action');
            } else {
              actionName = anchorNode.attribute('name');
            }
            var text = anchorNode.attribute('text');
            var isTextDefined = anchorNode.isAttributeSetByVM('text');
            // for actions if there is no anchor attribute 'text' we use action attribute 'text'
            if (!isTextDefined || controller._widgetType === "ButtonEdit") { // Button edit too
              if (actionName) {
                var actionNode = anchorNode.getApplication().getActionApplicationService().getActiveDialogAction(actionName);
                if (!!actionNode) {
                  isTextDefined = actionNode.isAttributeSetByVM('text');
                  //Comment attribute should be use in priority, text as fallback
                  text = actionNode.attribute('comment');
                  if (text.length <= 0) {
                    text = actionNode.attribute('text');
                  }
                }
              }
            }

            // if there is no text defined for action
            if (!isTextDefined) {
              var chromeBarTheme = controller.isInChromeBar();
              var image = anchorNode.attribute('image');

              // case where we case use name instead of text
              var nameAllowed = chromeBarTheme ||
                (anchorNode.getTag() === "Action" && !image) ||
                (anchorNode.getTag() === "Menu" && !image) ||
                (anchorNode.getTag() === "MenuAction" && !image) ||
                (anchorNode.getTag() === "TableAction");

              if (nameAllowed) { // no text we use name attribute
                text = anchorNode.attribute('name');
              }
            }

            var accelerator = anchorNode.attribute('acceleratorName');
            if (accelerator && widget.setComment) {
              widget.setComment(accelerator);
            }

            //remove first occurence of & symbol (quick shortcut not available in webclient)
            text = text ? text.toString().replace(/&(.)/g, "$1") : "";

            if (widget.setText) {
              widget.setText(text);
            }
            if (widget.setActionTitle) {
              widget.setActionTitle(text);
            }

          }
        }
      };
    });
  });
;
"use strict";

modulum('TextAlignVMBehavior', ['BehaviorBase'],
  function(context, cls) {

    /**
     * @class TextAlignVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.TextAlignVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.TextAlignVMBehavior.prototype */ {
        __name: "TextAlignVMBehavior",

        watchedAttributes: {
          anchor: ['numAlign'],
          container: ['numAlign'],
          decorator: ['justify']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          var bindings = controller.getNodeBindings();
          var justifyNode = bindings.decorator ? bindings.decorator : bindings.anchor;
          var numAlignNode = bindings.container ? bindings.container : bindings.anchor;
          var widget = controller.getWidget();

          if (widget && widget.setTextAlign) {
            var textAlign = null;

            if (justifyNode.isAttributeSetByVM('justify')) {
              textAlign = justifyNode.attribute('justify');
            } else if (numAlignNode.attribute('numAlign') === 1) {
              textAlign = 'right';
            }

            widget.setTextAlign(textAlign);

          }
        }
      };
    });
  });
;
"use strict";

modulum('TextButtonVMBehavior', ['BehaviorBase'],
  /**
   * Manage "Text" attribute only for Button
   * @param {gbc} context
   * @param {classes} cls
   */
  function(context, cls) {
    /**
     * @class TextButtonVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.TextButtonVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.TextButtonVMBehavior.prototype */ {
        __name: "TextButtonVMBehavior",

        watchedAttributes: {
          anchor: ['text', 'name', 'actionIdRef']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.setText) {
            var anchorNode = controller.getAnchorNode();
            var text = anchorNode.attribute('text');
            var isTextDefined = anchorNode.isAttributeSetByVM('text');
            if (!isTextDefined) { // for actions if there is no text we use name attribute
              var actionName = anchorNode.attribute('name');
              if (actionName) {
                var actionNode = anchorNode.getApplication().getActionApplicationService().getActiveDialogAction(actionName);
                if (!!actionNode) {
                  text = actionNode.attribute('text');
                }
              }
            }
            //remove first occurence of & symbol (quick shortcut not available in webclient)
            text = text.toString().replace(/&(.)/g, "$1");
            widget.setText(text);
          }
        }
      };
    });
  });
;
"use strict";

modulum('TextDecorationVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class TextDecorationVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.TextDecorationVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.TextDecorationVMBehavior.prototype */ {
        __name: "TextDecorationVMBehavior",

        watchedAttributes: {
          anchor: ['underline'],
          decorator: ['underline']
        },

        usedStyleAttributes: ["textDecoration"],

        /**
         *
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.setTextDecoration) {
            var bindings = controller.getNodeBindings();
            var underlineNode = null;
            if (bindings.anchor.isAttributeSetByVM('underline')) {
              underlineNode = bindings.anchor;
            } else if (bindings.decorator) {
              if (bindings.decorator.isAttributeSetByVM('underline')) {
                underlineNode = bindings.decorator;
              }
            }
            if (underlineNode) {
              var underline = underlineNode.attribute('underline') === 1;
              widget.setTextDecoration(underline ? "underline" : null);
            } else {
              var textDeco = controller.getAnchorNode().getStyleAttribute('textDecoration');
              widget.setTextDecoration(textDeco);
            }
          }
        }
      };
    });
  });
;
"use strict";

modulum('TextEditRowsVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class TextEditRowsVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.TextEditRowsVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.TextEditRowsVMBehavior.prototype */ {
        __name: "TextEditRowsVMBehavior",

        watchedAttributes: {
          decorator: ['gridHeight']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.setRows) {
            var decoratorNode = controller.getNodeBindings().decorator;
            var gridHeight = decoratorNode.attribute('gridHeight');
            widget.setRows(gridHeight);
          }
        }
      };
    });
  });
;
"use strict";

modulum('TextLabelVMBehavior', ['BehaviorBase'],
  /**
   * Manage "Text" attribute only for Label widgets
   * @param {gbc} context
   * @param {classes} cls
   */
  function(context, cls) {
    /**
     * @class TextLabelVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.TextLabelVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.TextLabelVMBehavior.prototype */ {
        __name: "TextLabelVMBehavior",

        watchedAttributes: {
          anchor: ['text']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.setValue) { // for label the function to change text is setValue
            var textNode = controller.getAnchorNode();
            var text = textNode.attribute('text');
            widget.setValue(text);
          }
        }
      };
    });
  });
;
"use strict";

modulum('TextTransformVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class TextTransformVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.TextTransformVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.TextTransformVMBehavior.prototype */ {
        __name: "TextTransformVMBehavior",

        watchedAttributes: {
          decorator: ['shift']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.setTextTransform && widget.removeTextTransform) {
            var bindings = controller.getNodeBindings();
            var shiftNode = bindings.decorator ? bindings.decorator : bindings.anchor;
            var shift = shiftNode.attribute('shift');
            widget.removeTextTransform();
            if (shift !== "none") {
              widget.setTextTransform(shift);
            }
          }
        }
      };
    });
  });
;
"use strict";

modulum('TextVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class TextVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.TextVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.TextVMBehavior.prototype */ {
        __name: "TextVMBehavior",

        watchedAttributes: {
          anchor: ['text'],
          decorator: ['text']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.setText) {
            var bindings = controller.getNodeBindings();
            var textNode = bindings.decorator && bindings.decorator.isAttributeSetByVM('text') ? bindings.decorator : bindings.anchor;
            var text = textNode.attribute('text');
            widget.setText(text);
          }
        }
      };
    });
  });
;
"use strict";

modulum('TitleVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class TitleVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.TitleVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.TitleVMBehavior.prototype */ {
        __name: "TitleVMBehavior",

        watchedAttributes: {
          anchor: ['comment', 'name', 'actionIdRef'],
          decorator: ['comment', 'actionIdRef']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.setTitle) {
            var bindings = controller.getNodeBindings();
            var commentNode = bindings.decorator ? bindings.decorator : bindings.anchor;
            var isDefined = commentNode.isAttributeSetByVM('comment');
            var text = commentNode.attribute('comment');
            if (!isDefined && controller.getAnchorNode().getTag() !== 'StartMenuCommand') {
              var actionName = commentNode.attribute('name');
              if (actionName) {
                var actionNode = commentNode.getApplication().getActionApplicationService().getActiveDialogAction(actionName);
                if (!!actionNode) {
                  isDefined = actionNode.isAttributeSetByVM('comment');
                  text = actionNode.attribute('comment');
                }
              }
            }
            if (isDefined) {
              widget.setTitle(text);
            }
          }
        }
      };
    });
  });
;
"use strict";

modulum('TraditionalFormSizingVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class TraditionalFormSizingVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.TraditionalFormSizingVMBehavior = context.oo.Singleton(cls.BehaviorBase, function() {
      return /** @lends classes.TraditionalFormSizingVMBehavior.prototype */ {
        __name: "TraditionalFormSizingVMBehavior",

        watchedAttributes: {
          parent: ['width', 'height', 'posX', 'posY']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          var window = controller.getAnchorNode().getParentNode();
          var widget = controller.getWidget();
          var baseheight =
            parseFloat(context.ThemeService.getValue("theme-field-default-height")) +
            2 * parseFloat(context.ThemeService.getValue("theme-field-height-ratio"));
          var left = window.attribute("posX");
          var top = (window.attribute("posY")) * baseheight;
          var width = window.attribute("width");
          var height = (window.attribute("height")) * baseheight;
          var letterSpacing = context.ThemeService.getValue("theme-traditional-mode-letter-spacing");
          widget.setStyle({
            position: 'absolute',
            top: top + 'px !important',
            left: 'calc(' + left + 'ch + ' + left + ' * ' + letterSpacing + ') !important',
            height: height + 'px !important',
            width: 'calc(' + width + 'ch + ' + width + ' * ' + letterSpacing + ') !important'
          });
        }
      };
    });
  }
);
;
"use strict";

modulum('TreeItemDecorationVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class TreeItemDecorationVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.TreeItemDecorationVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.TreeItemDecorationVMBehavior.prototype */ {
        __name: "TreeItemDecorationVMBehavior",

        watchedAttributes: {
          anchor: ['expanded', 'hasChildren', 'row']
        },

        /**
         * @param {classes.ControllerBase} controller
         * @param {Object} data
         */
        setup: function(controller, data) {
          data.depth = 0;
          var n = controller.getAnchorNode().getParentNode();
          while (n && n.getTag() === 'TreeItem') {
            n = n.getParentNode();
            ++data.depth;
          }
        },
        /**
         *
         */
        _apply: function(controller, data) {
          var treeItemNode = controller.getAnchorNode();
          var treeViewColumnNode = treeItemNode.getAncestor('Table').getFirstChild('TableColumn');
          treeItemNode.getAncestor('Table').getWidget().setAriaRole("tree");
          var treeItemChildren = treeItemNode.getParentNode().getChildren();
          var row = treeItemNode.attribute('row');
          if (row !== -1) {
            var valueList = treeViewColumnNode.getFirstChild("ValueList");
            if (valueList) {
              var valueNode = valueList.getChildren()[row];
              if (valueNode) {
                valueNode.getController().getNodeBindings().treeItem = treeItemNode; // set treeItem binding for value node
                var hasChildren = treeItemNode.attribute('hasChildren') !== 0;
                var isExpanded = hasChildren && treeItemNode.attribute('expanded') !== 0;
                var treeViewColumnWidget = treeViewColumnNode.getController().getWidget(),
                  cellWidget = treeViewColumnWidget.getColumnItem(row);
                if (cellWidget) {
                  cellWidget.setAriaRole("treeitem");
                  cellWidget.setAriaAttribute("setsize", treeItemChildren.length);
                  cellWidget.setAriaAttribute("posinset", treeItemChildren.indexOf(treeItemNode) + 1);
                  cellWidget.setDepth(data.depth);
                  cellWidget.setLeaf(!hasChildren);
                  if (hasChildren) {
                    cellWidget.setAriaExpanded(isExpanded.toString());
                    cellWidget.setExpanded(isExpanded);
                  }
                }
              }
            }
          }
        }
      };
    });
  });
;
"use strict";

modulum('UnhidableVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class UnhidableVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.UnhidableVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.UnhidableVMBehavior.prototype */ {
        __name: "UnhidableVMBehavior",

        watchedAttributes: {
          anchor: ['unhidable'],
          parent: ['unhidableColumns']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          var columnWidget = controller.getWidget();
          if (columnWidget && columnWidget.setUnhidable) {
            var anchorNode = controller.getAnchorNode();
            var parentNode = anchorNode.getParentNode();
            columnWidget.setUnhidable(anchorNode.attribute('unhidable') !== 0 || parentNode.attribute('unhidableColumns') !== 0);
          }
        }
      };
    });
  });
;
"use strict";

modulum('UnmovableVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class UnmovableVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.UnmovableVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.UnmovableVMBehavior.prototype */ {
        __name: "UnmovableVMBehavior",

        watchedAttributes: {
          anchor: ['unmovable'],
          parent: ['unmovableColumns']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          var columnWidget = controller.getWidget();
          if (columnWidget && columnWidget.setMovable) {
            var anchorNode = controller.getAnchorNode();
            var parentNode = anchorNode.getParentNode();
            columnWidget.setMovable(anchorNode.attribute('unmovable') === 0 && parentNode.attribute('unmovableColumns') === 0);
          }
        }
      };
    });
  });
;
"use strict";

modulum('UnsizableVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class UnsizableVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.UnsizableVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.UnsizableVMBehavior.prototype */ {
        __name: "UnsizableVMBehavior",

        watchedAttributes: {
          anchor: ['unsizable'],
          parent: ['unsizableColumns']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          var columnWidget = controller.getWidget();
          if (columnWidget && columnWidget.setSizable) {
            var anchorNode = controller.getAnchorNode();
            var parentNode = anchorNode.getParentNode();
            columnWidget.setSizable(anchorNode.attribute('unsizable') === 0 && parentNode.attribute('unsizableColumns') === 0);
          }
        }
      };
    });
  });
;
"use strict";

modulum('ValueVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class ValueVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.ValueVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.ValueVMBehavior.prototype */ {
        __name: "ValueVMBehavior",

        watchedAttributes: {
          anchor: ['value'],
          completer: ['size']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.setValue) {
            var anchorNode = controller.getAnchorNode(),
              decoratorNode = controller.getNodeBindings().decorator;
            var auiValue = anchorNode.attribute('value');

            if (!widget.isEditing) { // if widget is not a TextWidgetBase, simply setValue and return
              if (decoratorNode && decoratorNode.getTag() === "Image") {
                widget.setValue(context.__wrapper.wrapResourcePath(auiValue), true);
              } else {
                widget.setValue(auiValue, true);
              }
              return;
            }

            var typeahead = anchorNode.getApplication().typeahead;
            if (typeahead.hasPendingValueCommands(anchorNode)) {
              return; // if there are pending commands do nothing
            }

            var lastCommandTime = anchorNode.getApplication().typeahead.getLastCommandTime();
            if (!widget.isEditing() || lastCommandTime >= widget.getEditingTime()) {
              if (decoratorNode && decoratorNode.getTag() === "Image") {
                widget.setValue(context.__wrapper.wrapResourcePath(auiValue), true);
              } else {
                widget.setValue(auiValue, true);
              }
              if (widget.hasFocus() && widget.hasCursors()) { // need to set correct cursor (QA GBC-937)
                var containerNode = controller.getNodeBindings().container;
                var cursor = containerNode.attribute('cursor');
                var cursor2 = containerNode.attribute('cursor2');
                widget.setCursors(cursor, cursor2);
              }
            }
          }
        }
      };
    });
  });
;
"use strict";

modulum('VisibleIdVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class VisibleIdVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.VisibleIdVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.VisibleIdVMBehavior.prototype */ {
        __name: "VisibleIdVMBehavior",

        watchedAttributes: {
          anchor: ['visibleId']
        },

        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var formNode = controller.getAnchorNode();
          var visibleId = formNode.attribute('visibleId');
          if (visibleId >= 0) {
            var visibleNode = formNode.getApplication().getNode(visibleId);
            if (visibleNode) {
              var ctrl = visibleNode.getController();
              var parentNode = visibleNode.getParentNode();
              while (!ctrl && parentNode) {
                ctrl = parentNode.getController();
                parentNode = parentNode.getParentNode();
              }
              if (ctrl) {
                ctrl.ensureVisible(true);
              }
            }
          }
        }
      };
    });
  });
;
"use strict";

modulum('VisibleMenuVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Behavior controlling the widget's visibility
     * @class VisibleMenuVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.VisibleMenuVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.VisibleMenuVMBehavior.prototype */ {
        __name: "VisibleMenuVMBehavior",

        watchedAttributes: {
          anchor: ['hidden']
        },

        /**
         * Updates the widget's visibility depending on the AUI tree information
         */
        _apply: function(controller, data) {
          var thisWidget = controller.getWidget();
          if (!thisWidget) {
            return;
          }
          var anchorNode = controller.getAnchorNode();
          var isHidden = anchorNode.attribute('hidden') === 1;

          if (thisWidget.setHidden) {
            thisWidget.setHidden(isHidden);
          }
        }
      };
    });
  });
;
"use strict";

modulum('VisibleRowsVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class VisibleRowsVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.VisibleRowsVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.VisibleRowsVMBehavior.prototype */ {
        __name: "VisibleRowsVMBehavior",

        watchedAttributes: {
          anchor: ['size', 'offset', 'bufferSize', 'dialogType']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          var tableWidget = controller.getWidget();
          if (tableWidget && tableWidget.setVisibleRows) {
            var tableNode = controller.getAnchorNode();
            var size = tableNode.attribute('size');
            var offset = tableNode.attribute('offset');
            var bufferSize = tableNode.attribute('bufferSize');
            var currentRow = tableNode.attribute('currentRow');

            var visibleRows = Math.min(bufferSize, size - offset);
            var dialogType = tableNode.attribute('dialogType');
            if ((dialogType === "Construct" || dialogType === "Input" || (dialogType === "InputArray" && currentRow === 0)) &&
              visibleRows === 0) {
              visibleRows = 1;
            }
            tableWidget.setVisibleRows(visibleRows);
          }
        }
      };
    });
  });
;
"use strict";

modulum('WantFixedPageSizeVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Behavior controlling the stretchable scrollGrid
     * @class WantFixedPageSizeVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.WantFixedPageSizeVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.WantFixedPageSizeVMBehavior.prototype */ {
        __name: "WantFixedPageSizeVMBehavior",

        watchedAttributes: {
          anchor: ['wantFixedPageSize']
        },

        /**
         * Updates the widget's visibility depending on the AUI tree information
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.setFixedPageSize) {
            var anchorNode = controller.getAnchorNode();
            var wantFixedPageSize = anchorNode.attribute('wantFixedPageSize');
            widget.setFixedPageSize(wantFixedPageSize === 1);
          }
        }
      };
    });
  });
;
"use strict";

modulum('WantReturnsVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Behavior controlling wantTabs attribute in textedit
     * @class WantReturnsVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.WantReturnsVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.WantReturnsVMBehavior.prototype */ {
        __name: "WantReturnsVMBehavior",

        watchedAttributes: {
          anchor: ['wantReturns']
        },

        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.setWantReturns) {
            var decoratorNode = controller.getNodeBindings().decorator;
            var wantReturns = decoratorNode.attribute('wantReturns');
            widget.setWantReturns(wantReturns === 1);
          }
        }
      };
    });
  });
;
"use strict";

modulum('WantTabsVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Behavior controlling wantTabs attribute in textedit
     * @class WantTabsVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.WantTabsVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.WantTabsVMBehavior.prototype */ {
        __name: "WantTabsVMBehavior",

        watchedAttributes: {
          anchor: ['wantTabs']
        },

        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.setWantTabs) {
            var decoratorNode = controller.getNodeBindings().decorator;
            var wantTabs = decoratorNode.attribute('wantTabs');
            widget.setWantTabs(wantTabs === 1);
          }
        }
      };
    });
  });
;
"use strict";

modulum('WebComponentCursorsVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class WebComponentCursorsVMBehavior
     * Will override the cursor behavior since it's handled differently for webcomponents
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.WebComponentCursorsVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.WebComponentCursorsVMBehavior.prototype */ {
        __name: "WebComponentCursorsVMBehavior",

        watchedAttributes: {
          container: ['cursor', 'cursor2']
        },

        /**
         * Set cursors position to the widget input field
         * @param controller
         * @param data
         * @private
         */
        _apply: function(controller, data) {
          var widget = null;
          var containerNode = controller.getNodeBindings().container;

          if (widget && widget.hasCursors()) {
            var cursor = containerNode.attribute('cursor');
            var cursor2 = containerNode.attribute('cursor2');
            widget.setCursors(cursor, cursor2);
          }
        },

      };
    });
  });
;
"use strict";

modulum('WebComponentLayoutInfoVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class WebComponentLayoutInfoVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.WebComponentLayoutInfoVMBehavior = context.oo.Singleton(cls.BehaviorBase, function() {
      return /** @lends classes.WebComponentLayoutInfoVMBehavior.prototype */ {
        __name: "WebComponentLayoutInfoVMBehavior",

        watchedAttributes: {
          anchor: ['height']
        },

        /**
         *
         */
        _apply: function(controller) {
          var widget = controller.getWidget(),
            anchorNode = controller.getNodeBindings().anchor,
            layoutInfoNode = controller.getNodeBindings().decorator || anchorNode;
          if (widget && widget.getLayoutInformation) {
            var info = widget.getLayoutInformation();
            if (info) {

              info.getStretched().setDefaultX(true);
              info.getStretched().setDefaultY(true);
              info.setXStretched(true);
              info.setYStretched(true);
              info.forcedMinimalWidth = 300;
              info.forcedMinimalHeight = 300;
              info.forceMinimalFixedHeight = !layoutInfoNode.attribute('height');
            }
          }
        }
      };
    });
  });
;
"use strict";

modulum('WebComponentStateChangedVMBehavior', ['BackgroundColorVMBehavior'],
  function(context, cls) {
    /**
     * @class WebComponentStateChangedVMBehavior
     * @memberOf classes
     * @extends classes.BackgroundColorVMBehavior
     */
    cls.WebComponentStateChangedVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.WebComponentStateChangedVMBehavior.prototype */ {
        __name: "WebComponentStateChangedVMBehavior",

        watchedAttributes: {
          container: ['active', 'dialogType']
        },

        /**
         * Applies the background color only if it has been defined by the VM, use default value otherwise.
         */
        _apply: function(controller, data) {
          var widget = controller.getWidget();
          if (widget && widget.onStateChanged) {
            var containerNode = controller.getNodeBindings().container;
            var active = containerNode.attribute('active');
            var dialogType = containerNode.attribute('dialogType');
            widget.onStateChanged(active, dialogType);
          }

        }
      };
    });
  });
;
"use strict";

modulum('WindowCanCloseVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class WindowCanCloseVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.WindowCanCloseVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.WindowCanCloseVMBehavior.prototype */ {
        /** @type {string} */
        __name: "WindowCanCloseVMBehavior",

        watchedAttributes: {
          parent: ['active'],
          anchor: ['active']
        },
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var anchorNode = controller.getAnchorNode();
          var windowWidget = anchorNode.getAncestor('Window').getController().getWidget();
          if (windowWidget && windowWidget.setClosable) {
            var activeValue = anchorNode.attribute('active');
            windowWidget.setClosable(activeValue);
          }
        },

        /**
         * @inheritDoc
         */
        _detach: function(controller) {
          var anchorNode = controller.getAnchorNode();
          var windowWidget = anchorNode.getAncestor('Window').getController().getWidget();
          if (windowWidget && windowWidget.setClosable) {
            windowWidget.setClosable(false);
          }
        }
      };
    });
  });
;
"use strict";

modulum('WindowParentVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Behavior controlling the widget's Menu
     * @class WindowParentVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.WindowParentVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.WindowParentVMBehavior.prototype */ {
        __name: "WindowParentVMBehavior",

        watchedAttributes: {
          anchor: ['parent']
        },

        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          var anchorNode = controller.getAnchorNode();
          var windowWidget = controller.getWidget();
          windowWidget.setParentWindowId(anchorNode.attribute('parent'));
          anchorNode.getApplication().uiNode().getWidget()._syncCurrentWindow();
        },
      };
    });
  });
;
"use strict";

modulum('WindowTitleVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class WindowTitleVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.WindowTitleVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.WindowTitleVMBehavior.prototype */ {
        __name: "WindowTitleVMBehavior",

        watchedAttributes: {
          anchor: ['name', 'text']
        },

        /**
         * Switches the current window
         */
        _apply: function(controller, data) {
          var anchorNode = controller.getAnchorNode();
          var text = anchorNode.attribute('text');
          var name = anchorNode.attribute('name');
          controller.getWidget().getSidebarWidget().setWindowName(text || name);
        }
      };
    });
  });
;
"use strict";

modulum('WindowTypeVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class WindowTypeVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.WindowTypeVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.WindowTypeVMBehavior.prototype */ {
        __name: "WindowTypeVMBehavior",

        usedStyleAttributes: ["windowType"],

        watchedAttributes: {
          anchor: ['style']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          var windowNode = controller.getAnchorNode();
          if ((!windowNode.isAttributeSetByVM("active") || windowNode.attribute("active") === 1) &&
            (!windowNode.isAttributeSetByVM("hidden") || windowNode.attribute("hidden") === 0)) {
            var widget = windowNode.getController().getWidget();
            if (widget && widget.setAsModal) {
              var windowTypeAttr = windowNode.attribute("style");
              if (!this._isMenuSpecial(widget, windowTypeAttr)) {
                windowTypeAttr = windowNode.getStyleAttribute("windowType");
              }
              if (this._isMenuSpecial(widget, windowTypeAttr)) {
                widget.setAsModal(windowTypeAttr);
                var freeHandle = windowNode.getApplication().layout.afterLayout(function() {
                  widget._updateModalPosition();
                });
                widget.when(context.constants.widgetEvents.destroyed, function() {
                  freeHandle();
                });
              } else if (widget.isInstanceOf(cls.WindowWidget) && windowNode.isModal()) {
                var modalWidget = widget.setAsModal();

                if (modalWidget) {
                  var app = windowNode.getApplication();
                  modalWidget.when(context.constants.widgetEvents.modalResize, function() {
                    app.getUI().getWidget().getLayoutInformation().invalidateMeasure();
                    app.layout.refreshLayout({
                      resize: true
                    });
                  }.bind(this));
                }

                var sidebarApplicationItemWidget = windowNode.getApplication().getUI().getWidget().getSidebarWidget();
                modalWidget.onClose(sidebarApplicationItemWidget.unfreeze.bind(sidebarApplicationItemWidget));
                sidebarApplicationItemWidget.freeze();
              }
            }
          }
        },

        _isMenuSpecial: function(widget, styleAttr) {
          return (widget.isInstanceOf(cls.MenuWidget) && (styleAttr === "winmsg" || styleAttr === "dialog" || styleAttr === "popup"));
        }
      };
    });
  });
;
"use strict";

modulum('ChromeBarItemLayoutEngine', ['LayoutEngineBase'],
  function(context, cls) {
    /** Use empty layout definition to enable measure mechanism
     * @class ChromeBarItemLayoutEngine
     * @memberOf classes
     * @extends classes.LayoutEngineBase
     */
    cls.ChromeBarItemLayoutEngine = context.oo.Class(cls.LayoutEngineBase, function($super) {
      return /** @lends classes.ChromeBarItemLayoutEngine.prototype */ {
        __name: "ChromeBarItemLayoutEngine",

      };
    });
  });
;
"use strict";

modulum('ChromeBarLayoutEngine', ['LayoutEngineBase'],
  function(context, cls) {
    /**
     * @class ChromeBarLayoutEngine
     * @memberOf classes
     * @extends classes.LayoutEngineBase
     */
    cls.ChromeBarLayoutEngine = context.oo.Class(cls.LayoutEngineBase, function($super) {
      return /** @lends classes.ChromeBarLayoutEngine.prototype */ {
        __name: "ChromeBarLayoutEngine",

        /**
         * @inheritDoc
         */
        constructor: function(widget) {
          $super.constructor.call(this, widget);
        },

        /**
         * @inheritDoc
         */
        measureDecoration: function() {
          this._getLayoutInfo().setDecorating(
            this._widget.getElement().clientWidth - this._widget.getContainerElement().clientWidth,
            this._widget.getElement().clientHeight - this._widget.getContainerElement().clientHeight
          );
        },

        /**
         * @inheritDoc
         */
        notifyLayoutApplied: function() {
          $super.notifyLayoutApplied.call(this);
          // Refresh chromeBar to put overflown widgets in sidebar
          this._widget.refresh(); // true to force a refresh without conditions

        },

      };
    });
  });
;
"use strict";

modulum('DBoxLayoutEngine', ['LayoutEngineBase'],
  function(context, cls) {
    /**
     * Base laxout engine clarr for HBoxLayoutEngine and VBoxLayoutEngine
     * @class DBoxLayoutEngine
     * @memberOf classes
     * @extends classes.LayoutEngineBase
     */
    cls.DBoxLayoutEngine = context.oo.Class(cls.LayoutEngineBase, function($super) {
      return /** @lends classes.DBoxLayoutEngine.prototype */ {
        __name: "DBoxLayoutEngine",
        /**
         * main measure size getter name
         * @type {?string}
         * @protected
         */
        _mainSizeGetter: null,
        /**
         * main measure size setter name
         * @type {?string}
         * @protected
         */
        _mainSizeSetter: null,
        /**
         * main has measure size getter name
         * @type {?string}
         * @protected
         */
        _mainHasSizeGetter: null,
        /**
         * main stretch info getter name
         * @type {?string}
         * @protected
         */
        _mainStretch: null,
        /**
         * opposite measure size getter name
         * @type {?string}
         * @protected
         */
        _oppositeSizeGetter: null,
        /**
         * opposite measure size setter name
         * @type {?string}
         * @protected
         */
        _oppositeSizeSetter: null,
        /**
         * opposite has measure size getter name
         * @type {?string}
         * @protected
         */
        _oppositeHasSizeGetter: null,
        /**
         * opposite stretch info getter name
         * @type {?string}
         * @protected
         */
        _oppositeStretch: null,
        /**
         * calculated split hints
         * @type {Array<number>}
         */
        _splitHints: null,
        /**
         * reference split hints
         * @type {Array<number>}
         * @protected
         */
        _referenceSplitHints: null,
        /**
         * currenty splitter index
         * @type {?number}
         * @protected
         */
        _currentlySplitting: -1,
        /**
         * flag of whether or not it contains spacers
         * @type {boolean}
         * @protected
         */
        _hasSpacer: false,
        /**
         * registered children widgets
         * @type {classes.WidgetBase[]}
         * @protected
         */
        _registeredWidgets: null,
        /**
         * stylesheet id
         * @protected
         */
        _styleSheetId: null,
        /**
         * @inheritDoc
         * @constructs
         */
        constructor: function(widget) {
          $super.constructor.call(this, widget);
          this._styleSheetId = "boxLayout_" + widget.getUniqueIdentifier();
          this._splitHints = [];
          this._registeredWidgets = [];
          this._referenceSplitHints = [];
        },
        /**
         * @inheritDoc
         */
        destroy: function() {
          for (var i = this._registeredWidgets.length - 1; i > -1; i--) {
            var wi = this._registeredWidgets[i];
            wi.destroy();
            this.unregisterChild(wi);
          }
          this._splitHints = null;
          this._registeredWidgets.length = 0;
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        reset: function(recursive) {
          $super.reset.call(this, recursive);
          this._splitHints = this._referenceSplitHints.slice();
        },

        initSplitHints: function(initial) {
          this._referenceSplitHints = (initial || []).map(function(item) {
            return isNaN(item) ? 0 : item;
          });
        },

        startSplitting: function(splitterIndex) {
          this._currentlySplitting = splitterIndex;
          this._referenceSplitHints = [];
          for (var i = 0; i < this._registeredWidgets.length; i++) {
            var widget = this._registeredWidgets[i];
            if (!(widget instanceof cls.SplitterWidget)) {
              var idx = i / 2;
              this._referenceSplitHints[idx] = this._getAvailableSize(widget, true);
            }
          }
          this._splitHints = this._referenceSplitHints.slice();

        },

        stopSplitting: function() {
          this._referenceSplitHints = this._splitHints;
          this._currentlySplitting = -1;
        },

        splitting: function(delta) {
          var
            widget1 = this._registeredWidgets[this._currentlySplitting * 2],
            widget2 = this._registeredWidgets[(this._currentlySplitting + 1) * 2],
            min1 = this._getMinimalSize(widget1, true) || 1,
            min2 = this._getMinimalSize(widget2, true) || 1;

          for (var i = 0; i < this._registeredWidgets.length; i++) {
            var widget = this._registeredWidgets[i];
            if (!(widget instanceof cls.SplitterWidget)) {
              var idx = i / 2;
              this._splitHints[idx] = this._referenceSplitHints[idx];
            }
          }
          var extra = 0;
          var size1 = this._splitHints[this._currentlySplitting],
            size2 = this._splitHints[this._currentlySplitting + 1];
          if ((size1 + delta) < min1) {
            extra = delta;
            delta = min1 - size1;
            extra -= delta;
          }
          if ((size2 - delta) < min2) {
            extra = delta;
            delta = size2 - min2;
            extra -= delta;
          }
          this._splitHints[this._currentlySplitting] += delta;
          this._splitHints[this._currentlySplitting + 1] -= delta;

          if (!!extra) {
            var currentIndex, currentMin, currentSize, canReduce;
            if (extra < 0) {
              currentIndex = this._currentlySplitting - 1;
              while (!!extra && (currentIndex >= 0)) {
                currentMin = this._getMinimalSize(this._registeredWidgets[currentIndex * 2], true) || 1;
                currentSize = this._splitHints[currentIndex];
                canReduce = currentSize - currentMin;
                if (canReduce > 0) {
                  if (-extra < canReduce) {
                    this._splitHints[currentIndex] += extra;
                    this._splitHints[this._currentlySplitting + 1] -= extra;
                    extra = 0;
                  } else {
                    extra += canReduce;
                    this._splitHints[currentIndex] -= canReduce;
                    this._splitHints[this._currentlySplitting + 1] += canReduce;
                  }
                }
                currentIndex--;
              }
            } else {
              currentIndex = this._currentlySplitting + 2;
              while (!!extra && (currentIndex < this._splitHints.length)) {
                currentMin = this._getMinimalSize(this._registeredWidgets[currentIndex * 2], true) || 1;
                currentSize = this._splitHints[currentIndex];
                canReduce = currentSize - currentMin;
                if (canReduce > 0) {
                  if (extra < canReduce) {
                    this._splitHints[currentIndex] -= extra;
                    this._splitHints[this._currentlySplitting] += extra;
                    extra = 0;
                  } else {
                    extra -= canReduce;
                    this._splitHints[currentIndex] -= canReduce;
                    this._splitHints[this._currentlySplitting] += canReduce;
                  }
                }
                currentIndex++;
              }

            }
          }
        },
        /**
         * @inheritDoc
         * @param {classes.WidgetBase} widget child widget
         * @param {number} position the wanted position
         */
        registerChild: function(widget, position) {
          if (this._registeredWidgets.indexOf(widget) < 0) {
            this._registeredWidgets.splice(position, 0, widget);
          }
        },

        /**
         * @inheritDoc
         */
        unregisterChild: function(widget) {
          this._registeredWidgets.remove(widget);
        },

        /**
         * @inheritDoc
         */
        prepareAdjustments: function() {
          var widgets = this._registeredWidgets;
          for (var i = 0, j = 2; j < widgets.length;) {
            var widget = widgets[i];
            var widget2 = widgets[j];
            var isSpacer1 = widget instanceof cls.SpacerItemWidget,
              isSpacer2 = widget2 instanceof cls.SpacerItemWidget;
            if (widget.isVisible() && widget2.isVisible()) {
              widgets[i + 1].setHidden(isSpacer1 || isSpacer2);
              i += 2;
              j += 2;
            } else if (!widget.isVisible() && widget2.isVisible()) {
              widgets[i + 1].setHidden(true);
              i += 2;
              j += 2;
            } else if (widget.isVisible() && !widget2.isVisible()) {
              widgets[j - 1].setHidden(true);
              j += 2;
            } else {
              widgets[j - 1].setHidden(true);
              i += 2;
              j += 2;
            }
          }
        },
        /**
         * @inheritDoc
         */
        adjustMeasure: function() {
          var widgets = this._registeredWidgets;
          this._hasSpacer = false;
          this._getLayoutInfo().setPreferred(0, 0);
          var layoutInfo = this._getLayoutInfo(),
            position = 0,
            minimal = 0,
            minOppositeSize = 0,
            oppositeSize = 0,
            maxSize = 0,
            maxOppositeSize = 0;
          for (var i = 0; i < widgets.length; i++) {
            var widget = widgets[i];
            if (!widget.isVisible()) {
              continue;
            }
            var hasMaxSize = this._hasMaximalSize(widget),
              hasOppositeMaxSize = this._hasOppositeMaximalSize(widget),
              isSpacer = widget instanceof cls.SpacerItemWidget;
            if (isSpacer) {
              this._hasSpacer = true;
            }

            if (hasMaxSize || isSpacer) {
              maxSize += this._getMaximalSize(widget, true);
            } else {
              maxSize = cls.Size.maximal;
              this._setPreferredSize(this._widget,
                this._getPreferredSize(this._widget, true) +
                this._getPreferredSize(widget, true)
              );
            }
            if (hasOppositeMaxSize) {
              if (maxOppositeSize !== cls.Size.maximal) {
                maxOppositeSize = Math.max(maxOppositeSize, this._getOppositeMaximalSize(widget, true));
              }
            } else {
              maxOppositeSize = cls.Size.maximal;
            }
            var size = this._getMeasuredSize(widget, true),
              minimalSize = this._getMinimalSize(widget, true),
              opposite = this._getOppositeMeasuredSize(widget, true),
              minOpposite = this._getOppositeMinimalSize(widget, true);
            oppositeSize = Math.max(oppositeSize, opposite);
            minOppositeSize = Math.max(minOppositeSize, minOpposite);
            position += Math.max(minimalSize, size);
            minimal += minimalSize;
          }
          this._applyMeasure(position, oppositeSize);
          layoutInfo.getMinimal()[this._mainSizeSetter](minimal);
          layoutInfo.getMinimal()[this._oppositeSizeSetter](minOppositeSize);

          this._setMaximalSize(this._widget, maxSize);
          this._setOppositeMaximalSize(this._widget, maxOppositeSize);
        },

        /**
         * @inheritDoc
         */
        adjustStretchability: function() {
          var layoutInfo = this._getLayoutInfo();
          var oppositeStretch = 0;
          for (var i = 0; i < this._registeredWidgets.length; i++) {
            var widget = this._registeredWidgets[i],
              widgetInfo = widget.getLayoutInformation();
            if (!widget.isVisible()) {
              continue;
            }
            var hasOppositeMaxSize = this._hasOppositeMaximalSize(widget);
            if (widgetInfo.isXStretched() || widgetInfo.isChildrenXStretched()) {
              layoutInfo.addChildrenStretchX(widgetInfo);
            }
            if (widgetInfo.isYStretched() || widgetInfo.isChildrenYStretched()) {
              layoutInfo.addChildrenStretchY(widgetInfo);
            }

            if (!hasOppositeMaxSize) {
              if (oppositeStretch < this._getOppositePreferredSize(widget)) {
                oppositeStretch = this._getOppositePreferredSize(widget);
              }
            }
          }

          if (this._getOppositeMaximalSize() === cls.Size.maximal && oppositeStretch === 0) {
            oppositeStretch = 1;
          }
          if (oppositeStretch > 0) {
            this._setOppositePreferredSize(this._widget, oppositeStretch);
          }

        },

        _prepareApplyWhenSplitting: function(widgets) {
          for (var i = 0; i < widgets.length; i++) {
            var widget = widgets[i];
            if (widget.isVisible()) {
              if (!(widget instanceof cls.SplitterWidget)) {
                this._setAvailableSize(widget, this._splitHints[this._widget.getIndexOfChild(widget)]);
              }
            }
          }
        },

        _prepareApplyWithStretch: function(widgets) {
          var availableSize = this._getAvailableSize(),
            initialFullRatio = 0,
            fullRatio = 0,
            initialStretched = 0,
            stretched = 0,
            ratios = new Map(),
            i, widget, preferred, msize;

          for (i = 0; i < widgets.length; i++) {
            widget = widgets[i];
            if (widget.isVisible()) {
              this._setOppositeAvailableSize(widget, this._getOppositeAvailableSize());
              msize = this._getMinimalSize(widget, true);
              preferred = this._getPreferredSize(widget, true);
              if (this._isStretched(widget) && !widget.isInstanceOf(cls.SplitterWidget)) {
                ratios.set(widget, {
                  widget: widget,
                  preferred: preferred,
                  minimal: msize
                });
                initialFullRatio += preferred;
                fullRatio += preferred;
                initialStretched++;
                stretched++;
              } else {
                // if not stretchable, apply minimal size
                this._setAvailableSize(widget, msize);
                availableSize -= msize;
              }
            }
          }
          var sizableCount = 0,
            reducer = function(ratio, widget, map) {
              ratio.part = initialFullRatio ? (ratio.preferred || 0) / initialFullRatio : initialStretched ? (1 /
                  initialStretched) :
                0;
              ratio.initialDistribution = availableSize * ratio.part;
              if (ratio.initialDistribution <= ratio.minimal) {
                this._setAvailableSize(widget, ratio.minimal);
                availableSize -= ratio.minimal;
                fullRatio -= ratio.preferred;
                stretched--;
                map.delete(widget);
              } else {
                sizableCount++;
              }
            }.bind(this);

          // seeking all stretchables that should strecch smaller than their minimal size
          while (ratios.size !== sizableCount) {
            sizableCount = 0;
            ratios.forEach(reducer);
            initialFullRatio = fullRatio;
            initialStretched = stretched;
          }

          ratios.forEach(function(ratio, widget, map) {
            var part = fullRatio ? (ratio.preferred || 0) / fullRatio : stretched ? (1 / stretched) : 0;
            this._setAvailableSize(widget, availableSize * part);
            map.delete(widget);
          }.bind(this));
        },

        _prepareApplyWithoutStretch: function(widgets) {
          var i, items = [],
            distributedSize = {},
            available = this._getAvailableSize(),
            accumulated = 0,
            currentLevel = 0,
            distibutableLevel = -1;

          for (var it = 0; it < widgets.length; it++) {
            if (!widgets[it].isHidden()) {
              if ((this._hasSpacer && (widgets[it] instanceof cls.SpacerItemWidget)) ||
                (!this._hasSpacer && !(widgets[it] instanceof cls.SplitterWidget))) {
                items.push(widgets[it]);
              } else {
                available -= this._getMeasuredSize(widgets[it], true);
              }
            }
          }

          var count = items.length;

          items.sort(this._sortItems.bind(this));

          while (distibutableLevel === -1 && currentLevel < count) {
            var minimalCurrent = this._getMinimalSize(items[currentLevel], true);
            if (available >= (accumulated + minimalCurrent * (count - currentLevel))) {
              distibutableLevel = currentLevel;
            } else {
              accumulated += minimalCurrent;
              distributedSize[items[currentLevel].getUniqueIdentifier()] = minimalCurrent;
              currentLevel++;
            }
          }
          if (distibutableLevel >= 0) {
            var distributablePart = (available - accumulated) / (count - distibutableLevel);
            for (i = distibutableLevel; i < count; i++) {
              distributedSize[items[i].getUniqueIdentifier()] = distributablePart;
            }
          }
          for (i = 0; i < widgets.length; i++) {
            var widget = widgets[i];
            if (widget.isVisible()) {
              if (distributedSize.hasOwnProperty(widget.getUniqueIdentifier())) {
                this._setAvailableSize(widget, distributedSize[widget.getUniqueIdentifier()]);
              }
              this._setOppositeAvailableSize(widget, this._getOppositeAvailableSize());
            } else {
              this._setAvailableSize(widget, 0);
              this._setOppositeAvailableSize(widget, 0);
            }
          }
        },
        /**
         * @inheritDoc
         */
        prepareApplyLayout: function() {
          var widgets = this._registeredWidgets,
            i, widget, wSize, oppositeWSize,
            position = 0,
            reallyAllocatedSpace = 0,
            stretchablesOnNeed = 0,
            extraSpace = 0;
          if (this._currentlySplitting >= 0) {
            // user is currently splitting
            this._prepareApplyWhenSplitting(widgets);
          } else if ( // box has been previously splitted, keep ratios
            this._referenceSplitHints.length &&
            (this._referenceSplitHints.length === ((widgets.length + 1) / 2))) {
            this._redistributeSplittedSpace(widgets);
          } else if (this._isStretched(this._widget)) {
            // some elements are stretchables
            this._prepareApplyWithStretch(widgets);
          } else {
            // no elements are stretchables
            this._prepareApplyWithoutStretch(widgets);
          }

          for (i = 0; i < widgets.length; i++) {
            widget = widgets[i];
            if (widget.isVisible()) {
              wSize = Math.max(this._getAvailableSize(widget, true), this._getMinimalSize(widget, true));
              reallyAllocatedSpace += wSize;
              if (!wSize) {
                stretchablesOnNeed++;
              }
            }
          }
          if (stretchablesOnNeed) {
            extraSpace =
              (Math.max(this._getAvailableSize(null, true), this._getMinimalSize(null, true)) - reallyAllocatedSpace) /
              stretchablesOnNeed;
          }
          for (i = 0; i < widgets.length; i++) {
            widget = widgets[i];
            if (widget.isVisible()) {
              wSize = Math.max(this._getAvailableSize(widget, true), this._getMinimalSize(widget, true));
              if (!wSize) {
                wSize = extraSpace;
              }
              this._setAllocatedSize(widget, wSize);
              oppositeWSize = this._getOppositeAvailableSize();
              if (!this._getOppositeStretched() || this._getLayoutInfo().willOverflowContainerIfNeeded()) {
                oppositeWSize = Math.max(oppositeWSize, this._getOppositeMinimalSize());
              }
              this._setOppositeAllocatedSize(widget, oppositeWSize);
              this._setOppositeAvailableSize(widget, oppositeWSize);
              this._setItemClass(i, position, wSize);
              position += wSize;
            } else {
              this._setOppositeAllocatedSize(widget, 0);
              this._setOppositeAvailableSize(widget, 0);
              this._setItemClass(i, position, 0);
            }
          }

          var width = Math.max(this._getLayoutInfo().getAvailable().getWidth(true), this._getLayoutInfo().getMinimal().getWidth(
            true));
          var height = Math.max(this._getLayoutInfo().getAvailable().getHeight(true), this._getLayoutInfo().getMinimal().getHeight(
            true));
          this._getLayoutInfo().setAllocated(width, height);

          for (i = 0; i < widgets.length; i++) {
            widget = widgets[i];
            if (widget.isVisible()) {
              this._setItemOppositeClass(i);
              this._setOppositeAllocatedSize(widget, this._getOppositeAllocatedSize());
            } else {
              this._setItemOppositeClass(i);
              this._setOppositeAllocatedSize(widget, 0);
            }
          }
          this._styleRules[".g_measured #w_" + this._widget.getUniqueIdentifier() + ".g_measureable"] = {
            width: this._getLayoutInfo().getAllocated().getWidth() + "px",
            height: this._getLayoutInfo().getAllocated().getHeight() + "px"
          };
        },

        _redistributeSplittedSpace: function(widgets) {
          var i, widget, total = this._getAvailableSize(),
            totalSplitters = 0;
          for (i = 0; i < widgets.length; i++) {
            widget = widgets[i];
            if (widget.isVisible()) {
              if (widget instanceof cls.SplitterWidget) {
                var s = this._getMeasuredSize(widget);
                total -= s;
                totalSplitters += s;
              }
            }
          }
          if (this._getMinimalSize() < (total + totalSplitters)) {
            var sum = this._referenceSplitHints.reduce(function(acc, b, idx) {
                if (idx === 1 && !widgets[0].isVisible()) {
                  acc = 0;
                }
                if (!widgets[idx * 2].isVisible()) {
                  b = 0;
                }
                return acc + b;
              }.bind(this)),
              availableWeight = sum,
              ratioed = this._referenceSplitHints.map(function(a, idx) {
                var relative = total * a / sum,
                  min = this._getMinimalSize(widgets[idx * 2]),
                  delta = relative - min;
                return {
                  weight: a,
                  min: min,
                  size: min,
                  relative: relative,
                  delta: delta,
                  index: idx
                };
              }, this).sort(function(a, b) {
                return a.delta < b.delta ? -1 : a.delta > b.delta ? 1 : 0;
              });
            var pos = 0,
              debt = 0;
            while (pos < ratioed.length) {
              if (ratioed[pos].delta < 0) {
                debt -= ratioed[pos].delta;
                availableWeight -= ratioed[pos].weight;
                pos++;
              } else {
                var weightDebt = debt * ratioed[pos].weight / availableWeight;
                if (weightDebt > ratioed[pos].delta) {
                  ratioed[pos].delta -= weightDebt;
                  debt -= weightDebt;
                } else {
                  debt -= weightDebt;
                  ratioed[pos].delta -= weightDebt;
                  ratioed[pos].size = ratioed[pos].min + ratioed[pos].delta;
                  availableWeight -= ratioed[pos].weight;
                  pos++;
                }
              }
            }
            for (i = 0; i < ratioed.length; i++) {
              widget = widgets[ratioed[i].index * 2];
              if (widget.isVisible()) {
                if (!(widget instanceof cls.SplitterWidget)) {
                  this._setAvailableSize(widget, ratioed[i].size);
                }
              }
            }
          } else {
            for (i = 0; i < widgets.length; i++) {
              widget = widgets[i];
              if (widget.isVisible()) {
                if (!(widget instanceof cls.SplitterWidget)) {
                  this._setAvailableSize(widget, this._getMinimalSize(widget));
                }
              }
            }
          }
          for (i = 0; i < widgets.length; i++) {
            widget = widgets[i];
            if (widget.isVisible()) {
              this._setOppositeAvailableSize(widget, this._getOppositeAvailableSize());
            }
          }
        },
        /**
         * @inheritDoc
         */
        applyLayout: function() {
          context.styler.appendStyleSheet(this._styleRules, this._styleSheetId, true,
            this.getLayoutSheetId());
        },

        /**
         * get main hint size of given widget or owner if none
         * @param {classes.WidgetBase} [widget] the widget
         * @param {boolean} [useFallback] true to get fallback value if needed
         * @returns {number} the size
         * @protected
         */
        _getPreferredSize: function(widget, useFallback) {
          var idx = this._widget.getIndexOfChild(widget);
          if (idx >= 0 && this._splitHints[idx]) {
            return this._splitHints[idx];
          }
          return this._getLayoutInfo(widget).getPreferred()[this._mainSizeGetter](useFallback);
        },
        /**
         * get opposite hint size of given widget or owner if none
         * @param {classes.WidgetBase} [widget] the widget
         * @param {boolean} [useFallback] true to get fallback value if needed
         * @returns {number} the size
         * @protected
         */
        _getOppositePreferredSize: function(widget, useFallback) {
          return this._getLayoutInfo(widget).getPreferred()[this._oppositeSizeGetter](useFallback);
        },

        _setPreferredSize: function(widget, size) {
          return this._getLayoutInfo(widget).getPreferred()[this._mainSizeSetter](size);
        },

        _setOppositePreferredSize: function(widget, size) {
          return this._getLayoutInfo(widget).getPreferred()[this._oppositeSizeSetter](size);
        },

        /**
         * get main allocated size of given widget or owner if none
         * @param {classes.WidgetBase} [widget] the widget
         * @param {boolean} [useFallback] true to get fallback value if needed
         * @returns {number} the size
         * @protected
         */
        _getAllocatedSize: function(widget, useFallback) {
          return this._getLayoutInfo(widget).getAllocated()[this._mainSizeGetter](useFallback);

        },

        /**
         * set main allocated size of given widget or owner if none
         * @param {classes.WidgetBase} widget the widget
         * @param {number} size the size
         * @protected
         */
        _setAllocatedSize: function(widget, size) {
          return this._getLayoutInfo(widget).getAllocated()[this._mainSizeSetter](size);
        },
        /**
         * set main maximal size of given widget or owner if none
         * @param {classes.WidgetBase} widget the widget
         * @param {number} size the size
         * @protected
         */
        _setMaximalSize: function(widget, size) {
          return this._getLayoutInfo(widget).getMaximal()[this._mainSizeSetter](size);
        },
        /**
         * set opposite maximal size of given widget or owner if none
         * @param {classes.WidgetBase} widget the widget
         * @param {number} size the size
         * @protected
         */
        _setOppositeMaximalSize: function(widget, size) {
          return this._getLayoutInfo(widget).getMaximal()[this._oppositeSizeSetter](size);
        },
        /**
         * get main measured size of given widget or owner if none
         * @param {classes.WidgetBase} [widget] the widget
         * @param {boolean} [useFallback] true to get fallback value if needed
         * @returns {number} the size
         * @protected
         */
        _getMeasuredSize: function(widget, useFallback) {
          if (!(widget instanceof cls.SplitterWidget)) {
            var idx = this._widget.getIndexOfChild(widget);
            if (idx >= 0 && this._splitHints[idx]) {
              return this._splitHints[idx];
            }
          }
          return this._getLayoutInfo(widget).getMeasured()[this._mainSizeGetter](useFallback);
        },
        /**
         * get opposite measured size of given widget or owner if none
         * @param {classes.WidgetBase} [widget] the widget
         * @param {boolean} [useFallback] true to get fallback value if needed
         * @returns {number} the size
         * @protected
         */
        _getOppositeMeasuredSize: function(widget, useFallback) {
          return this._getLayoutInfo(widget).getMeasured()[this._oppositeSizeGetter](!!useFallback);
        },
        /**
         * get main minimal size of given widget or owner if none
         * @param {classes.WidgetBase} [widget] the widget
         * @param {boolean} [useFallback] true to get fallback value if needed
         * @returns {number} the size
         * @protected
         */
        _getMinimalSize: function(widget, useFallback) {
          return this._getLayoutInfo(widget).getMinimal()[this._mainSizeGetter](!!useFallback);
        },
        /**
         * get opposite minimal size of given widget or owner if none
         * @param {classes.WidgetBase} [widget] the widget
         * @param {boolean} [useFallback] true to get fallback value if needed
         * @returns {number} the size
         * @protected
         */
        _getOppositeMinimalSize: function(widget, useFallback) {
          return this._getLayoutInfo(widget).getMinimal()[this._oppositeSizeGetter](!!useFallback);
        },
        /**
         * get main maximal size of given widget or owner if none
         * @param {classes.WidgetBase} [widget] the widget
         * @param {boolean} [useFallback] true to get fallback value if needed
         * @returns {number} the size
         * @protected
         */
        _getMaximalSize: function(widget, useFallback) {
          return this._getLayoutInfo(widget).getMaximal()[this._mainSizeGetter](useFallback);
        },
        /**
         * get opposite maximal size of given widget or owner if none
         * @param {classes.WidgetBase} [widget] the widget
         * @param {boolean} [useFallback] true to get fallback value if needed
         * @returns {number} the size
         * @protected
         */
        _getOppositeMaximalSize: function(widget, useFallback) {
          return this._getLayoutInfo(widget).getMaximal()[this._oppositeSizeGetter](useFallback);
        },
        /**
         * test if given widget or owner if none has main maximal size
         * @param {classes.WidgetBase} [widget] the widget
         * @returns {number} the size
         * @protected
         */
        _hasMaximalSize: function(widget) {
          return this._getLayoutInfo(widget).getMaximal()[this._mainHasSizeGetter](true);
        },
        /**
         * test if given widget or owner if none has opposite maximal size
         * @param {classes.WidgetBase} [widget] the widget
         * @returns {number} the size
         * @protected
         */
        _hasOppositeMaximalSize: function(widget) {
          return this._getLayoutInfo(widget).getMaximal()[this._oppositeHasSizeGetter](true);
        },
        /**
         * get main available size of given widget or owner if none
         * @param {classes.WidgetBase} [widget] the widget
         * @param {boolean} [useFallback] true to get fallback value if needed
         * @returns {number} the size
         * @protected
         */
        _getAvailableSize: function(widget, useFallback) {
          var availableSize = this._getLayoutInfo(widget).getAvailable();
          return availableSize[this._mainSizeGetter](useFallback);
        },
        /**
         * set main available size of given widget or owner if none
         * @param {classes.WidgetBase} widget the widget
         * @param {number} size the size
         * @protected
         */
        _setAvailableSize: function(widget, size) {
          var availableSize = this._getLayoutInfo(widget).getAvailable();
          availableSize[this._mainSizeSetter](size);
        },
        /**
         * get opposite available size of given widget or owner if none
         * @param {classes.WidgetBase} [widget] the widget
         * @param {boolean} [useFallback] true to get fallback value if needed
         * @returns {number} the size
         * @protected
         */
        _getOppositeAvailableSize: function(widget, useFallback) {
          var availableSize = this._getLayoutInfo(widget).getAvailable();
          return availableSize[this._oppositeSizeGetter](useFallback);
        },
        /**
         * set opposite available size of given widget or owner if none
         * @param {classes.WidgetBase} widget the widget
         * @param {number} size the size
         * @protected
         */
        _setOppositeAvailableSize: function(widget, size) {
          var availableSize = this._getLayoutInfo(widget).getAvailable();
          availableSize[this._oppositeSizeSetter](size);
        },
        /**
         * get opposite allocated size of given widget or owner if none
         * @param {classes.WidgetBase} [widget] the widget
         * @param {boolean} [useFallback] true to get fallback value if needed
         * @returns {number} the size
         * @protected
         */
        _getOppositeAllocatedSize: function(widget, useFallback) {
          var allocatedSize = this._getLayoutInfo(widget).getAllocated();
          return allocatedSize[this._oppositeSizeGetter](useFallback);
        },
        /**
         * set opposite allocated size of given widget or owner if none
         * @param {classes.WidgetBase} widget the widget
         * @param {number} size the size
         * @protected
         */
        _setOppositeAllocatedSize: function(widget, size) {
          var allocatedSize = this._getLayoutInfo(widget).getAllocated();
          allocatedSize[this._oppositeSizeSetter](size);
        },
        /**
         * set item css rules for main size
         * @param {number} position child widget position in children list
         * @param {number} start render start position
         * @param {number} size render size
         * @protected
         */
        _setItemClass: function(position, start, size) {

        },
        /**
         * set item css rules for opposite size
         * @param {number} position child widget position in children list
         * @param {number} start render start position
         * @param {number} size render size
         * @protected
         */
        _setItemOppositeClass: function(position, start, size) {

        },
        /**
         * apply css rules
         * @param {number} mainSize owner main size
         * @param {number} oppositeSize owner opposite size
         * @protected
         */
        _applyMeasure: function(mainSize, oppositeSize) {

        },
        /**
         * get main stretchability from size of given widget or owner if none
         * @param {classes.WidgetBase} [widget] the widget
         * @returns {boolean} the stretchability info
         * @protected
         */
        _isStretched: function(widget) {
          return false;
        },
        /**
         * get main stretch info of given widget or owner if none
         * @param {classes.WidgetBase} [widget] the widget
         * @returns {boolean} the stretch info
         * @protected
         */
        _getMainStretched: function(widget) {
          var mainStretched = this._getLayoutInfo(widget).getStretched();
          return mainStretched["get" + this._mainStretch]();
        },
        /**
         * get opposite stretch info of given widget or owner if none
         * @param {classes.WidgetBase} [widget] the widget
         * @returns {boolean} the stretch info
         * @protected
         */
        _getOppositeStretched: function(widget) {
          var oppositeStretched = this._getLayoutInfo(widget).getStretched();
          return oppositeStretched["get" + this._oppositeStretch]();
        },
        /**
         * sort function for children widget by their main minimal size
         * @param {classes.WidgetBase} a the first widget
         * @param {classes.WidgetBase} b the second widget
         * @return {number} sort value
         * @private
         */
        _sortItems: function(a, b) {
          return this._getMinimalSize(b) - this._getMinimalSize(a);
        }
      };
    });
  });
;
"use strict";

modulum('HBoxLayoutEngine', ['DBoxLayoutEngine'],
  function(context, cls) {
    /**
     * @class HBoxLayoutEngine
     * @memberOf classes
     * @extends classes.DBoxLayoutEngine
     */
    cls.HBoxLayoutEngine = context.oo.Class(cls.DBoxLayoutEngine, function() {
      return /** @lends classes.HBoxLayoutEngine.prototype */ {
        __name: "HBoxLayoutEngine",
        _mainSizeGetter: "getWidth",
        _mainSizeSetter: "setWidth",
        _mainHasSizeGetter: "hasWidth",
        _mainStretch: "X",
        _oppositeSizeGetter: "getHeight",
        _oppositeSizeSetter: "setHeight",
        _oppositeHasSizeGetter: "hasHeight",
        _oppositeStretch: "Y",

        /**
         * @inheritDoc
         */
        _setItemClass: function(position, start, size) {
          var selector = ".g_measured .gbc_HBoxWidget" + this._widget._getCssSelector() +
            ">div>.containerElement>.g_BoxElement:nth-of-type(" + (position +
              1) + ")";
          var pos = cls.Size.cachedPxImportant(start);
          this._styleRules[selector] = {};
          this._styleRules[selector][this._widget.getStart()] = pos;
          this._styleRules[selector].width = cls.Size.cachedPxImportant(size);
        },

        /**
         * @inheritDoc
         */
        _setItemOppositeClass: function(position) {
          this._styleRules[".g_measured .gbc_HBoxWidget" + this._widget._getCssSelector() +
            ">div>.containerElement>.g_BoxElement:nth-of-type(" + (
              position + 1) +
            ")"].height = cls.Size.cachedPxImportant(this._getLayoutInfo().getAllocated().getHeight());
        },

        /**
         * @inheritDoc
         */
        _applyMeasure: function(mainSize, oppositeSize) {
          this._styleRules[".g_measured #w_" + this._widget.getUniqueIdentifier() + ".g_measureable"] = {
            width: mainSize + "px",
            height: oppositeSize + "px"
          };
          this._getLayoutInfo().setMeasured(mainSize, oppositeSize);
        },

        /**
         * @inheritDoc
         */
        _isStretched: function(widget) {
          return widget.getLayoutEngine().isXStretched();
        }
      };
    });
  });
;
"use strict";

modulum('SplitViewLayoutEngine', ['LayoutEngineBase'],
  function(context, cls) {
    /**
     * @class SplitViewLayoutEngine
     * @memberOf classes
     * @extends classes.LayoutEngineBase
     */
    cls.SplitViewLayoutEngine = context.oo.Class(cls.LayoutEngineBase, function($super) {
      return /** @lends classes.SplitViewLayoutEngine.prototype */ {
        __name: "SplitViewLayoutEngine",
        /**
         * registered children widgets
         * @type {classes.WidgetBase[]}
         * @protected
         */
        _registeredWidgets: null,
        /**
         * stylesheet id
         * @protected
         */
        _styleSheetId: null,
        /**
         * @inheritDoc
         * @constructs
         */
        constructor: function(widget) {
          $super.constructor.call(this, widget);
          this._styleSheetId = "boxLayout_" + widget.getUniqueIdentifier();
          this._registeredWidgets = [];
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          for (var i = this._registeredWidgets.length - 1; i > -1; i--) {
            var wi = this._registeredWidgets[i];
            wi.destroy();
            this.unregisterChild(wi);
          }
          this._registeredWidgets.length = 0;
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        reset: function(recursive) {
          $super.reset.call(this, recursive);
          context.styler.removeStyleSheet(this.getLayoutSheetId());
        },

        /**
         * @inheritDoc
         */
        resetSizes: function() {
          $super.resetSizes.call(this);
          this._getLayoutInfo().setPreferred(0, 0);
        },

        /**
         * @inheritDoc
         */
        registerChild: function(widget) {
          if (!(widget instanceof cls.SplitterWidget)) {
            if (this._registeredWidgets.indexOf(widget) === -1) {
              this._registeredWidgets.push(widget);
            }
          }
        },

        /**
         * @inheritDoc
         */
        unregisterChild: function(widget) {
          this._registeredWidgets.remove(widget);
        },

        /**
         * Get list of all registered widget being a SplitView item
         * @returns {classes.WidgetBase[]}
         */
        getRegisteredWidgets: function() {
          return this._registeredWidgets;
        },

        /**
         * @inheritDoc
         */
        adjustMeasure: function() {
          var layoutInfo = this._getLayoutInfo();
          var availWidth = layoutInfo.getAvailable().getWidth();
          var availHeight = layoutInfo.getAvailable().getHeight();
          var decoratingWidth = layoutInfo.getDecorating().getWidth();
          var decoratingHeight = layoutInfo.getDecorating().getHeight();
          var width = availWidth - decoratingWidth;
          var height = availHeight - decoratingHeight;

          for (var i = 0; i < this._registeredWidgets.length; i++) {
            var widgetInfo = this._getLayoutInfo(this._registeredWidgets[i]);
            widgetInfo.setAvailable(width, height);
            widgetInfo.setAllocated(width, height);
          }
          layoutInfo.setAllocated(width, height);
        },

        /**
         * @inheritDoc
         */
        prepareApplyLayout: function() {
          var layoutInfo = this._getLayoutInfo();

          this._styleRules[".g_measured #w_" + this._widget.getUniqueIdentifier() + ".g_measureable>.splitViewContent"] = {
            height: layoutInfo.getAllocated().getHeight() + "px",
            width: layoutInfo.getAllocated().getWidth() + "px",
            top: layoutInfo.getDecoratingOffset().getHeight() + "px",
            left: layoutInfo.getDecoratingOffset().getWidth() + "px"
          };
          this._styleRules[".g_measured #w_" + this._widget.getUniqueIdentifier() +
            ".g_measureable>.splitViewContent>.containerElement"] = {
            height: layoutInfo.getAllocated().getHeight() + "px",
            width: layoutInfo.getAllocated().getWidth() + "px"
          };
        },

        /**
         * @inheritDoc
         */
        applyLayout: function() {
          context.styler.appendStyleSheet(this._styleRules, this._styleSheetId, true, this.getLayoutSheetId());
        },
      };
    });
  });
;
"use strict";

modulum('VBoxLayoutEngine', ['DBoxLayoutEngine'],
  function(context, cls) {
    /**
     * @class VBoxLayoutEngine
     * @memberOf classes
     * @extends classes.DBoxLayoutEngine
     */
    cls.VBoxLayoutEngine = context.oo.Class(cls.DBoxLayoutEngine, function($super) {
      return /** @lends classes.VBoxLayoutEngine.prototype */ {
        __name: "VBoxLayoutEngine",
        _mainSizeGetter: "getHeight",
        _mainSizeSetter: "setHeight",
        _mainHasSizeGetter: "hasHeight",
        _mainStretch: "Y",
        _oppositeSizeGetter: "getWidth",
        _oppositeSizeSetter: "setWidth",
        _oppositeHasSizeGetter: "hasWidth",
        _oppositeStretch: "X",

        /**
         * @inheritDoc
         */
        _setItemClass: function(position, start, size) {
          this._styleRules[".g_measured .gbc_VBoxWidget" + this._widget._getCssSelector() +
            ">div>.containerElement>.g_BoxElement:nth-of-type(" + (
              position + 1) +
            ")"] = {
            top: cls.Size.cachedPxImportant(start),
            height: cls.Size.cachedPxImportant(size)
          };
        },
        /**
         * @inheritDoc
         */
        _setItemOppositeClass: function(position) {
          this._styleRules[".g_measured .gbc_VBoxWidget" + this._widget._getCssSelector() +
            ">div>.containerElement>.g_BoxElement:nth-of-type(" + (
              position + 1) +
            ")"].width = cls.Size.cachedPxImportant(this._getLayoutInfo().getAllocated().getWidth());
        },

        /**
         * @inheritDoc
         */
        _applyMeasure: function(mainSize, oppositeSize) {
          this._styleRules[".g_measured #w_" + this._widget.getUniqueIdentifier() + ".g_measureable"] = {
            height: mainSize + "px",
            width: oppositeSize + "px"
          };
          this._getLayoutInfo().setMeasured(oppositeSize, mainSize);
        },

        /**
         * @inheritDoc
         */
        _isStretched: function(widget) {
          return widget.getLayoutEngine().isYStretched();
        },

        /**
         * @inheritDoc
         */
        _setOppositeMaximalSize: function(widget, size) {
          var isSelfWidgetChildrenStretched = widget === this._widget &&
            this._widget.getLayoutInformation().isChildrenXStretched();
          return $super._setOppositeMaximalSize.call(this, widget, isSelfWidgetChildrenStretched ? cls.Size.maximal : size);
        }
      };
    });
  });
;
"use strict";

modulum('FlowItemLayoutEngine', ['LayoutEngineBase'],
  function(context, cls) {

    /**
     * Layout engine for items in flowing container
     * This is empty, just to use measurement mechanism of items
     * @class FlowItemLayoutEngine
     * @memberOf classes
     * @extends classes.LayoutEngineBase
     */
    cls.FlowItemLayoutEngine = context.oo.Class(cls.LayoutEngineBase, function($super) {
      return /** @lends classes.FlowItemLayoutEngine.prototype */ {
        __name: "FlowItemLayoutEngine",

      };
    });
  });
;
"use strict";

modulum('FlowLayoutEngine', ['LayoutEngineBase'],
  function(context, cls) {

    /**
     * Layout engine for container that will flow items in continuous dropdown
     * Note that it should be applied to WidgetGroupBase widgets only
     * @class FlowLayoutEngine
     * @memberOf classes
     * @extends classes.LayoutEngineBase
     */
    cls.FlowLayoutEngine = context.oo.Class(cls.LayoutEngineBase, function($super) {
      return /** @lends classes.FlowLayoutEngine.prototype */ {
        __name: "FlowLayoutEngine",

        /** @type {Number} */
        _childrenWidth: 0,

        /** @type {Number} */
        _containerWidth: 0,

        /** @type {classes.FlowDecoratorWidget} **/
        _flowDecoratorWidget: null,

        /**
         * Define the widget used for flowing (usually 3dots)
         * @param {classes.FlowDecoratorWidget} flowDecoratorWidget
         */
        setFlowDecoratorWidget: function(flowDecoratorWidget) {
          this._flowDecoratorWidget = flowDecoratorWidget;
        },

        /**
         * Get the widget used for flowing
         * @return {classes.FlowDecoratorWidget}
         */
        getFlowDecoratorWidget: function() {
          return this._flowDecoratorWidget;
        },

        /**
         * @inheritDoc
         */
        notifyLayoutApplied: function() {
          $super.notifyLayoutApplied.call(this);

          this._registerAnimationFrame(function() {
            this._registerAnimationFrame(function() {
              if (this._needRefresh()) { // No need to refresh everytime
                if (this._throttle) {
                  window.clearTimeout(this._throttle);
                }
                this._throttle = this._registerTimeout(function() {
                  this._refresh();
                  this._throttle = null;
                }.bind(this), 30);
              }
            }.bind(this));
          }.bind(this));
        },

        /**
         * Refresh the flowing items
         * @private
         */
        _refresh: function() {
          var containerWidth = this.getContainerWidth();
          var childrenTotalWidth = this.getChildrenWidth() + this.getFlowingChildrenWidth();
          // If the children width is more than the container width, we need to flow some children
          this._flowItems(childrenTotalWidth > containerWidth);
        },

        /**
         * Flow or unflow items
         * @param {Boolean} flow - true to flow items if necessary, false to unflow them
         * @private
         */
        _flowItems: function(flow) {
          var widget = this._widget;
          var flowDecoratorWidget = this.getFlowDecoratorWidget();
          var childrenWidth = this.getChildrenWidth();
          var containerWidth = this.getContainerWidth();

          flowDecoratorWidget.enable(flow);
          // Flow items after size calculation: add to the dropdown
          var currentChildrenWidth = this.getChildrenWidth(),
            children = null,
            currentChildWidth = 0,
            i = 0;
          if (containerWidth > childrenWidth) {
            children = flowDecoratorWidget.getFlowingChildren();
            currentChildWidth = children.length && children[i].getLayoutInformation().getRawMeasure().getWidth();
            while (i < children.length && (currentChildrenWidth + currentChildWidth) < containerWidth) {
              flowDecoratorWidget.flowChild(children[i], false); // unflow this child
              currentChildrenWidth += currentChildWidth;
              i++;
              currentChildWidth = children[i] && children[i].getLayoutInformation().getRawMeasure().getWidth();
            }
          } else {
            children = widget.getChildren().slice(0);
            i = children.length - 1;
            while (i >= 0 && currentChildrenWidth > containerWidth) {
              flowDecoratorWidget.flowChild(children[i], true); // flow this child
              currentChildrenWidth -= children[i].getLayoutInformation().getRawMeasure().getWidth();
              i--;
            }
          }
        },

        /**
         * Check if refresh is necessary
         * @return {boolean} true if need a refresh, false otherwise
         * @private
         */
        _needRefresh: function() {
          var currentChildrenWidth = this.getChildrenWidth() + this.getFlowingChildrenWidth();
          var currentContainerWidth = this.getContainerWidth();

          // No need to refresh if either of container and/or children total width did not change
          if (this._childrenWidth !== currentChildrenWidth || this._containerWidth !== currentContainerWidth) {
            // If changed, update those values
            this._childrenWidth = currentChildrenWidth;
            this._containerWidth = currentContainerWidth;
            return true;
          } else {
            return false;
          }
        },

        /**
         * Calculate the total width of the children
         * @return {*}
         */
        getChildrenWidth: function() {
          return this._widget.getChildren().slice(1).reduce(function(prev, child) {
            return prev + child.getLayoutInformation().getRawMeasure().getWidth();
          }, 0);
        },

        /**
         * Calculate the total width of the children
         * @return {*}
         */
        getFlowingChildrenWidth: function() {
          return this._widget.getFlowDecoratorWidget().getFlowingChildren().reduce(function(prev, child) {
            return prev + child.getLayoutInformation().getRawMeasure().getWidth();
          }, 0);
        },

        /**
         * Calculate the container Width, take the 3dots icon into account
         * @return {number}
         */
        getContainerWidth: function() {
          // Modal case: get the previously set toolbar width
          if (this._widget.getWindowWidget() && this._widget.getWindowWidget().isModal) {
            return this._widget.getFormWidget().getLayoutInformation().getToolbarAllocatedWidth() - this._widget
              .getDecoratorWidth();
          }
          return this._widget.getFormWidget().getLayoutInformation().getRawMeasure().getWidth() - this._widget.getDecoratorWidth();
        },

      };
    });
  });
;
"use strict";

modulum('AccordionFolderLayoutEngine', ['FolderLayoutEngine'],
  /**
   * @param {gbc} context
   * @param {classes} cls
   */
  function(context, cls) {
    /**
     * @class AccordionFolderLayoutEngine
     * @memberOf classes
     * @extends classes.FolderLayoutEngine
     */
    cls.AccordionFolderLayoutEngine = context.oo.Class(cls.FolderLayoutEngine, function($super) {
      return /** @lends classes.AccordionFolderLayoutEngine.prototype */ {
        __name: "AccordionFolderLayoutEngine",

        /**
         * @inheritDoc
         */
        measureDecoration: function() {
          var decorationHeight = 0;
          var decorationWidth = 0;
          var pageDecorationHeight = 0;
          var pageDecorationWidth = 0;
          var visiblePageCount = this._widget.getVisiblePageCount();
          if (visiblePageCount > 0) {
            var pageWithDecorationElement = this._widget.getElement().child("gbc_AccordionElement");
            var pageWithoutDecorationElement = pageWithDecorationElement.child("gbc_AccordionPage");

            var oneTitleHeight = pageWithDecorationElement.clientHeight - pageWithoutDecorationElement.clientHeight;
            decorationHeight = visiblePageCount * oneTitleHeight;
            decorationWidth = pageWithDecorationElement.clientWidth - pageWithoutDecorationElement.clientWidth;

            var pageMargin = parseInt(context.ThemeService.getValue("gbc-AccordionFolderWidget-page-margin"), 10);

            pageDecorationWidth = pageMargin * 2;
            pageDecorationHeight = pageMargin * 2;
          }

          this._getLayoutInfo().setDecorating(
            this._widget.getElement().clientWidth - this._widget.getContainerElement().clientWidth + decorationWidth +
            pageDecorationWidth,
            this._widget.getElement().clientHeight - this._widget.getContainerElement().clientHeight + decorationHeight +
            pageDecorationHeight
          );

          for (var i = 0; i < this._widget._children.length; ++i) {
            var child = this._widget._children[i];
            child.getLayoutInformation().setDecorating(
              pageDecorationWidth,
              pageDecorationHeight
            );
          }
        },

        /**
         * @inheritDoc
         */
        prepareApplyLayout: function() {
          $super.prepareApplyLayout.call(this);

          var visiblePageCount = this._widget.getVisiblePageCount();
          var pageHeight = 0;

          if (visiblePageCount > 0) {
            // fix height of current page (this is necessary for css animation (transition on height))
            pageHeight = this._widget.getCurrentPage().getLayoutInformation().getAvailable().getHeight();
            pageHeight = pageHeight + this._widget.getCurrentPage().getLayoutInformation().getDecorating().getHeight();
          }

          this._widget.setStyle({
            selector: ".gbc_AccordionPage.currentPage",
            appliesOnRoot: false
          }, {
            "height": pageHeight + "px"
          });
        },
      };
    });
  });
;
"use strict";

modulum('FolderLayoutEngine', ['LayoutEngineBase'],
  function(context, cls) {
    /**
     * @class FolderLayoutEngine
     * @memberOf classes
     * @extends classes.LayoutEngineBase
     */
    cls.FolderLayoutEngine = context.oo.Class(cls.LayoutEngineBase, function($super) {
      return /** @lends classes.FolderLayoutEngine.prototype */ {
        __name: "FolderLayoutEngine",
        /**
         * stylesheet id
         */
        _styleSheetId: null,

        /**
         * @inheritDoc
         * @constructs
         */
        constructor: function(widget) {
          $super.constructor.call(this, widget);
          this._styleSheetId = "folderLayout_" + widget.getUniqueIdentifier();
        },

        /**
         * @inheritDoc
         */
        reset: function(recursive) {
          $super.reset.call(this, recursive);
          context.styler.removeStyleSheet(this.getLayoutSheetId());
          if (this._widget) {
            this._widget.addPagesInDom();
          }
        },

        /**
         * @inheritDoc
         */
        resetSizes: function() {
          $super.resetSizes.call(this);
          this._getLayoutInfo().setPreferred(0, 0);
        },

        /**
         * @inheritDoc
         */
        getRenderableChildren: function() {
          if (!this._widget.isMinified) {
            return $super.getRenderableChildren.call(this);
          } else {
            return [this._widget.getCurrentPage()];
          }
        },

        /**
         * @inheritDoc
         */
        DOMMeasure: function() {
          $super.DOMMeasure.call(this);
          if (this._widget.getTabsTitlesHostElement) {
            var info = this._getLayoutInfo(),
              container = this._widget.getTabsTitlesHostElement().getBoundingClientRect();
            info.setTitlesContainerDeltaWidth(info.getRawMeasure().getWidth() - container.width);
            info.setTitlesContainerDeltaHeight(info.getRawMeasure().getHeight() - container.height);
          }
        },
        /**
         * @inheritDoc
         */
        measureDecoration: function() {
          this._getLayoutInfo().setDecorating(
            this._widget.getElement().clientWidth - this._widget.getContainerElement().clientWidth,
            this._widget.getElement().clientHeight - this._widget.getContainerElement().clientHeight
          );
          this._getLayoutInfo().setDecoratingOffset(
            this._widget.getContainerElement().offsetLeft - this._widget.getElement().offsetLeft,
            this._widget.getContainerElement().offsetTop - this._widget.getElement().offsetTop
          );
        },

        /**
         * @inheritDoc
         */
        adjustMeasure: function() {
          var layoutInfo = this._getLayoutInfo(),
            measureX = 0,
            measureY = 0,
            minX = 0,
            minY = 0,
            maxX = 0,
            maxY = 0,
            decorateX = layoutInfo.getDecorating().getWidth(),
            decorateY = layoutInfo.getDecorating().getHeight(),
            preferredX = 0,
            preferredY = 0;

          var children = this._widget.getChildren();
          for (var i = 0; i < children.length; i++) {
            if (!children[i].isHidden()) {
              var widgetInfo = this._getLayoutInfo(children[i]);
              measureX = Math.max(measureX, widgetInfo.getMeasured().getWidth());
              measureY = Math.max(measureY, widgetInfo.getMeasured().getHeight());
              minX = Math.max(minX, widgetInfo.getMinimal().getWidth());
              minY = Math.max(minY, widgetInfo.getMinimal().getHeight());
              maxX = Math.max(maxX, widgetInfo.getMaximal().getWidth());
              maxY = Math.max(maxY, widgetInfo.getMaximal().getHeight());
              preferredX = Math.max(preferredX, widgetInfo.getPreferred().getWidth());
              preferredY = Math.max(preferredY, widgetInfo.getPreferred().getHeight());
            }
          }
          layoutInfo.setMeasured(measureX + decorateX, measureY + decorateY);
          layoutInfo.setPreferred(Math.max(preferredX, measureX + decorateX), Math.max(preferredY, measureY + decorateY));
          layoutInfo.setMinimal(minX + decorateX, minY + decorateY);
          layoutInfo.setMaximal(maxX + decorateX, cls.Size.maximal);
        },

        /**
         * @inheritDoc
         */
        adjustStretchability: function() {
          var layoutInfo = this._getLayoutInfo(),
            children = this._widget.getChildren();
          for (var i = 0; i < children.length; i++) {
            var widgetInfo = this._getLayoutInfo(children[i]);
            if (widgetInfo.isXStretched() || widgetInfo.isChildrenXStretched()) {
              layoutInfo.addChildrenStretchX(widgetInfo);
            }
            if (widgetInfo.isYStretched() || widgetInfo.isChildrenYStretched()) {
              layoutInfo.addChildrenStretchY(widgetInfo);
            }
          }
        },

        /**
         * @inheritDoc
         */
        prepareApplyLayout: function() {
          var layoutInfo = this._getLayoutInfo(),
            decorateX = layoutInfo.getDecorating().getWidth(),
            decorateY = layoutInfo.getDecorating().getHeight(),
            children = this._widget.getChildren(),
            minx = Math.max(layoutInfo.getAvailable().getWidth(), layoutInfo.getMinimal().getWidth()),
            miny = Math.max(layoutInfo.getAvailable().getHeight(), layoutInfo.getMinimal().getHeight());
          for (var i = 0; i < children.length; i++) {
            if (!children[i].isHidden()) {
              var widgetInfo = this._getLayoutInfo(children[i]);
              widgetInfo.setAvailable(
                minx - decorateX,
                miny - decorateY
              );
              widgetInfo.setAllocated(minx - decorateX, miny - decorateY);
            }
          }
          layoutInfo.setAllocated(minx, miny);
          this._styleRules[".g_measured #w_" + this._widget.getUniqueIdentifier() + ".g_measureable"] = {
            height: layoutInfo.getAllocated().getHeight() + "px",
            width: layoutInfo.getAllocated().getWidth() + "px"
          };
          this._styleRules[".g_measured #w_" + this._widget.getUniqueIdentifier() + ".g_measureable>.containerElement"] = {
            height: (layoutInfo.getAllocated().getHeight() - decorateY) + "px",
            width: (layoutInfo.getAllocated().getWidth() - decorateX) + "px"
          };
        },

        /**
         * @inheritDoc
         */
        applyLayout: function() {
          context.styler.appendStyleSheet(this._styleRules, this._styleSheetId, true, this.getLayoutSheetId());
        }
      };
    });
  });
;
"use strict";

modulum('PageLayoutEngine', ['LayoutEngineBase'],
  function(context, cls) {
    /**
     * @class PageLayoutEngine
     * @memberOf classes
     * @extends classes.LayoutEngineBase
     */
    cls.PageLayoutEngine = context.oo.Class(cls.LayoutEngineBase, function($super) {
      return /** @lends classes.PageLayoutEngine.prototype */ {
        __name: "PageLayoutEngine",

        /**
         * @inheritDoc
         */
        resetSizes: function() {
          $super.resetSizes.call(this);
          this._getLayoutInfo().setPreferred(0, 0);
        },

        /**
         * @inheritDoc
         */
        DOMMeasure: function() {
          $super.DOMMeasure.call(this);
          if (this._widget._title) {
            var info = this._getLayoutInfo(),
              title = this._widget._title.getElement().getBoundingClientRect();
            info.setTitleMeasureWidth(title.width);
            info.setTitleMeasureHeight(title.height);
          }
        },

        /**
         * @inheritDoc
         */
        adjustMeasure: function() {
          var layoutInfo = this._getLayoutInfo(),
            child = this._widget.getChildren()[0];
          if (child) {
            var widgetInfo = this._getLayoutInfo(child);
            layoutInfo.setMeasured(widgetInfo.getMeasured().getWidth(), widgetInfo.getMeasured().getHeight());
            layoutInfo.setMinimal(widgetInfo.getMinimal().getWidth(), widgetInfo.getMinimal().getHeight());
            layoutInfo.setMaximal(widgetInfo.getMaximal().getWidth(), widgetInfo.getMaximal().getHeight());
            layoutInfo.setPreferred(widgetInfo.getPreferred().getWidth(), widgetInfo.getPreferred().getHeight());
          }
        },

        /**
         * @inheritDoc
         */
        adjustStretchability: function() {
          var layoutInfo = this._getLayoutInfo(),
            child = this._widget.getChildren()[0];
          if (child) {
            var widgetInfo = this._getLayoutInfo(child);
            if (widgetInfo.isXStretched() || widgetInfo.isChildrenXStretched()) {
              layoutInfo.addChildrenStretchX(this._widget.getLayoutInformation());
            }
            if (widgetInfo.isYStretched() || widgetInfo.isChildrenYStretched()) {
              layoutInfo.addChildrenStretchY(this._widget.getLayoutInformation());
            }
          }
        },

        /**
         * @inheritDoc
         */
        prepareApplyLayout: function() {
          var layoutInfo = this._getLayoutInfo(),
            child = this._widget.getChildren()[0];
          if (child) {
            var widgetInfo = this._getLayoutInfo(child);
            widgetInfo.setAvailable(
              layoutInfo.getAvailable().getWidth(),
              layoutInfo.getAvailable().getHeight()
            );
            widgetInfo.setAllocated(
              layoutInfo.getAvailable().getWidth(),
              layoutInfo.getAvailable().getHeight()
            );
          }
        }
      };
    });
  });
;
"use strict";

modulum('TabbedContainerLayoutEngine', ['LayoutEngineBase'],
  function(context, cls) {
    /**
     * @class TabbedContainerLayoutEngine
     * @memberOf classes
     * @extends classes.LayoutEngineBase
     */
    cls.TabbedContainerLayoutEngine = context.oo.Class(cls.LayoutEngineBase, function($super) {
      return /** @lends classes.TabbedContainerLayoutEngine.prototype */ {
        __name: "TabbedContainerLayoutEngine",

        /**
         * @inheritDoc
         */
        DOMMeasure: function() {
          $super.DOMMeasure.call(this);
          if (this._widget.getTabsTitlesHostElement) {
            var info = this._getLayoutInfo(),
              container = this._widget.getTabsTitlesHostElement().getBoundingClientRect();
            info.setTitlesContainerDeltaWidth(info.getRawMeasure().getWidth() - container.width);
            info.setTitlesContainerDeltaHeight(info.getRawMeasure().getHeight() - container.height);
          }
        }
      };
    });
  });
;
"use strict";

modulum('FormLayoutEngine', ['LayoutEngineBase'],
  function(context, cls) {
    /**
     * @class FormLayoutEngine
     * @memberOf classes
     * @extends classes.LayoutEngineBase
     */
    cls.FormLayoutEngine = context.oo.Class(cls.LayoutEngineBase, function($super) {
      return /** @lends classes.FormLayoutEngine.prototype */ {
        __name: "FormLayoutEngine",
        _initialRenderSize: null,
        /**
         * Auto overflow mode. Active when the form is taller than the browser viewport
         * @type {boolean}
         */
        _autoOverflowMode: false,
        /**
         * stylesheet id
         */
        _styleSheetId: null,
        /**
         * @inheritDoc
         * @constructs
         */
        constructor: function(widget) {
          $super.constructor.call(this, widget);
          this._styleSheetId = "formLayout_" + widget.getUniqueIdentifier();
        },
        /**
         * @inheritDoc
         */
        reset: function(recursive) {
          $super.reset.call(this, recursive);
          this._initialRenderSize = null;
          this._autoOverflowMode = false;
          var modal = this._widget && this._widget.getParentWidget() && this._widget.getParentWidget().getModal();
          if (modal) {
            modal.resetLayout();
            modal._hasBeenSized = false;
            context.styler.removeStyleSheet(this.getLayoutSheetId());
          }
        },
        _getMinHintWidth: function() {
          var layoutInfo = this._getLayoutInfo();
          return cls.CharSize.translate(layoutInfo.getMinSizeHint().getWidth(), layoutInfo.getCharSize().getWidthM(),
            layoutInfo.getCharSize().getWidth0());
        },
        _getMinHintHeight: function() {
          var layoutInfo = this._getLayoutInfo();
          return cls.Size.translate(layoutInfo.getMinSizeHint().getHeight(), layoutInfo.getCharSize().getHeight());
        },

        /**
         * @inheritDoc
         */
        prepareMeasure: function() {
          var modal = this._widget && this._widget.getParentWidget() && this._widget.getParentWidget().getModal();
          if (modal) {
            var element = this._widget.getElement();
            if (!this._initialRenderSize) {
              this._initialRenderSize = {
                x: element.offsetWidth,
                y: element.offsetHeight
              };
            } else {
              if ((this._initialRenderSize.x !== element.offsetWidth) || (this._initialRenderSize.y !== element.offsetHeight)) {
                modal.getElement().toggleClass("left-realign", false);
                modal.getElement().toggleClass("top-realign", false);

                modal._removeInitialContainment();
              }
            }
          }
        },

        /**
         * @inheritDoc
         */
        measure: function() {
          if (this._widget.getParentWidget().isModal) {
            this._measureModal();
          } else {
            this._measure();
          }
        },
        _measure: function() {
          var layoutInfo = this._getLayoutInfo();
          layoutInfo.setMeasured(
            layoutInfo.getRawMeasure().getWidth(true),
            layoutInfo.getRawMeasure().getHeight(true)
          );
          var childInfo = this._getLayoutInfo(this._widget.getChildren()[0]);
          if (childInfo) {
            var measured = layoutInfo.getMeasured();
            childInfo.wouldOverflowContainerIfNeeded(true);
            childInfo.setAvailable(measured.getWidth(), measured.getHeight());
          }
        },
        _measureModal: function() {
          var layoutInfo = this._getLayoutInfo(),
            width = this._getMinHintWidth(),
            height = this._getMinHintHeight();

          layoutInfo.setMinimal(width, height);
          layoutInfo.setMeasured(width, height);
        },

        /**
         * @inheritDoc
         */
        adjustMeasure: function(lastInvalidated, layoutApplicationService) {
          var windowWidget = this._widget.getWindowWidget(),
            isInModal = windowWidget && windowWidget.isModal;
          if (isInModal) {
            this._adjustMeasureModal();
          } else {
            this._adjustMeasure();
          }
        },
        _adjustMeasure: function() {
          var windowWidget = this._widget.getWindowWidget(),
            parentLayoutInformation = windowWidget.getLayoutInformation(),
            childInfo = this._getLayoutInfo(this._widget.getChildren()[0]);

          if (childInfo) {
            childInfo.wouldOverflowContainerIfNeeded(true);
            var measure = parentLayoutInformation.isSizable() ? this._getLayoutInfo().getMeasured() : childInfo.getMeasured(),
              willXScroll = childInfo.getMeasured().getWidth() > measure.getWidth(),
              willYScroll = childInfo.getMeasured().getHeight() > measure.getHeight();

            childInfo.setAvailable(
              measure.getWidth() - (willYScroll ? window.scrollBarSize : 0),
              measure.getHeight() - (willXScroll ? window.scrollBarSize : 0)
            );

            if (parentLayoutInformation.isSizable()) {
              var minimal = childInfo.getMinimal();
              if (minimal.getHeight(true) > measure.getHeight(true)) {
                if (!this._statuses.adjusted) {
                  this._autoOverflowMode = true;
                }
              }
            }
          }
        },
        _adjustMeasureModal: function() {
          var childInfo = this._getLayoutInfo(this._widget.getChildren()[0]);
          if (childInfo) {
            var windowWidget = this._widget.getWindowWidget(),
              childMeasure = childInfo.getMeasured();
            childInfo.wouldOverflowContainerIfNeeded(true);
            if (windowWidget.getLayoutInformation().isSizable()) {
              var modal = windowWidget.getModal(),
                childPreferred = childInfo.getPreferred(),
                formMeasured = this._getLayoutInfo().getMeasured(),
                sizedX = 0,
                sizedY = 0;

              if (modal._hasBeenSized) {
                var childMinimal = childInfo.getMinimal(),
                  sizingInfo = modal._sizingPositions;
                sizedX = sizingInfo.size.x - sizingInfo.decoration.x;
                sizedY = sizingInfo.size.y - sizingInfo.decoration.y;

                formMeasured.setWidth(Math.max(childPreferred.getWidth(true), sizedX - window.scrollBarSize, childMinimal.getWidth(
                  true)));
                formMeasured.setHeight(Math.max(childPreferred.getHeight(true), sizedY - window.scrollBarSize, childMinimal
                  .getHeight(
                    true)));
              }
              var availableX = Math.max(childMeasure.getWidth(true), formMeasured.getWidth(true)),
                availableY = Math.max(childMeasure.getHeight(true), formMeasured.getHeight(true));
              childInfo.setAvailable(
                sizedX || Math.max(modal._hasBeenSized ? 0 : childPreferred.getWidth(true), availableX),
                sizedY || Math.max(modal._hasBeenSized ? 0 : childPreferred.getHeight(true), availableY)
              );
            } else {
              childInfo.setAvailable(childMeasure.getWidth(), childMeasure.getHeight());
            }
          }
        },

        /**
         * @inheritDoc
         */
        applyLayout: function() {
          var parentWidget = this._widget.getParentWidget(),
            isInModal = parentWidget && parentWidget.isModal,
            modal = parentWidget && parentWidget.getModal();

          if (isInModal) {
            var childInfo = this._getLayoutInfo(this._widget.getChildren()[0]);
            if (modal) {
              modal._sizingPositions.contentMin = {
                x: Math.max(childInfo.getMinimal().getWidth(true), this._getMinHintWidth()),
                y: Math.max(childInfo.getMinimal().getHeight(true), this._getMinHintHeight())
              };
            }
          }
        },

        /**
         * @inheritDoc
         */
        notifyLayoutApplied: function() {
          $super.notifyLayoutApplied.call(this);
          this._registerAnimationFrame(this._onNotified.bind(this));
        },

        _onNotified: function() {
          var widget = this._widget,
            windowWidget = widget && widget.getWindowWidget();
          if (windowWidget) {
            if (windowWidget.isModal) {
              this._notifyModal();
            } else {
              this._notify();
            }
          }
        },

        _notify: function() {
          var style = {},
            overflownX = false,
            overflownY = false,
            widget = this._widget,
            windowWidget = widget && widget.getWindowWidget(),
            element = widget.getElement();
          if (widget) {
            // need to check : if disabled: don't do that, but if visible behind modal, do that!
            if (windowWidget && !windowWidget._disabled) {
              var measured = widget.getLayoutInformation().getMeasured(),
                childWidget = widget.getChildren() && widget.getChildren()[0],
                childAllocated = childWidget && childWidget.getLayoutInformation().getAllocated(),
                childAllocatedWidth = childAllocated ? childAllocated.getWidth() : 0,
                childAllocatedHeight = childAllocated ? childAllocated.getHeight() : 0,
                dWidth = measured.getWidth() - childAllocatedWidth,
                dHeight = measured.getHeight() - childAllocatedHeight;
              context.styler.appendStyleSheet(style, this._styleSheetId, true, this.getLayoutSheetId());

              overflownX = dWidth < -0.9;
              overflownY = dHeight < -0.9;
            }
            element
              .toggleClass("notOverflownX", !overflownX)
              .toggleClass("notOverflownY", !overflownY)
              .toggleClass("overflownX", overflownX)
              .toggleClass("overflownY", overflownY);
          }
        },
        _notifyModal: function() {
          var widget = this._widget,
            element = widget.getElement(),
            layoutInformation = widget.getLayoutInformation(),
            windowWidget = widget.getWindowWidget(),
            modal = windowWidget.getModal(),
            modalElement = modal.getElement(),
            modalpane = modalElement && modalElement.child("mt-dialog-pane"),
            modalcontent = modalpane && modalpane.child("mt-dialog-content");
          if (modalcontent) {
            var deltaWidth = modalpane.offsetWidth - modalElement.offsetWidth,
              deltaHeight = modalpane.offsetHeight - modalElement.offsetHeight,
              menuContainers = windowWidget.getMenuContainers();
            if (window.browserInfo.isSafari) {
              element.addClass("safariMeasure");
            }
            var measure = layoutInformation.getMeasured(),
              firstChild = widget.getChildren()[0],
              childInfo = firstChild && firstChild.getLayoutInformation(),
              childMeasure = childInfo && childInfo.getMeasured(),

              referenceWidth = modal._hasBeenSized ? 0 : childInfo.getPreferred().getWidth(true),
              referenceHeight = modal._hasBeenSized ? 0 : childInfo.getPreferred().getHeight(true);

            measure.setWidth(Math.max(referenceWidth,
              childMeasure && childMeasure.getWidth() || (element.clientWidth - (deltaWidth > 0 ? deltaWidth : 0)),
              this._getMinHintWidth()
            ));
            measure.setHeight(Math.max(referenceHeight,
              childMeasure && childMeasure.getHeight() || (element.clientHeight - (deltaHeight > 0 ? deltaHeight : 0)),
              this._getMinHintHeight()
            ));
            if (window.browserInfo.isSafari) {
              this._widget.getElement().removeClass("safariMeasure");
            }

            var menusXWidth = Math.max(0, menuContainers.left.offsetWidth + menuContainers.right.offsetWidth - 1),
              menusYHeight = Math.max(0, menuContainers.top.offsetHeight + menuContainers.bottom.offsetHeight - 1),
              minWidth = Math.max(referenceWidth, childInfo.getMinimal().getWidth() + menusXWidth + window.scrollBarSize,
                this._getMinHintWidth()),
              minHeight = Math.max(referenceHeight, childInfo.getMinimal().getHeight() + menusYHeight + window.scrollBarSize,
                this._getMinHintHeight());
            modalElement.toggleClass("left-realign", minWidth > modalElement.offsetWidth);
            modalElement.toggleClass("top-realign", minHeight > modalElement.offsetHeight);
            var minStyle = {},
              style = {};
            minStyle[".g_measured #w_" + modal.getUniqueIdentifier() + ".g_measureable .mt-dialog-pane"] = {
              "min-width": cls.Size.cachedPxImportant(minWidth),
              "min-height": cls.Size.cachedPxImportant(minHeight)
            };
            context.styler.appendStyleSheet(minStyle, "formLayout_" + modal.getUniqueIdentifier(), true, this.getLayoutSheetId());

            var modalContentWidth = modalcontent.offsetWidth - menusXWidth,
              modalContentHeight = modalcontent.offsetHeight - menusYHeight;
            style[".g_measured .gbc_ModalWidget #w_" + this._widget.getUniqueIdentifier() + ".g_measureable"] = {
              width: cls.Size.cachedPxImportant(modal._hasBeenSized ? modalContentWidth : (measure.getWidth() + window
                .scrollBarSize)),
              height: cls.Size.cachedPxImportant(modal._hasBeenSized ? modalContentHeight : (measure.getHeight() + window
                .scrollBarSize))
            };

            var contentMaxWidth = Math.max(measure.getWidth() + window.scrollBarSize + menusXWidth, this._getMinHintWidth());
            var calculatedWidth = (modal._hasBeenSized ? modalContentWidth : contentMaxWidth);
            this._widget.getLayoutInformation().setToolbarAllocatedWidth(calculatedWidth);

            if (windowWidget._toolBarWidget) {
              windowWidget._toolBarWidget.setStyle({
                "width": calculatedWidth + "px"
              });
            }
            if (modal.setHeaderMaxWidth) {
              modal.setHeaderMaxWidth(modal._hasBeenSized ? modalcontent.offsetWidth : contentMaxWidth);
            }
            context.styler.appendStyleSheet(style, this._styleSheetId, true, this.getLayoutSheetId());
            if (!modal._hasBeenMoved) {
              this._registerAnimationFrame(function() {
                if (modal) {
                  modal._initMoved();
                }
              });
            }
            modalElement.removeClass('g_needLayout');
          }
        },

        /**
         * @inheritDoc
         */
        invalidateMeasure: function(invalidation) {
          var invalidated = !invalidation || this._invalidatedMeasure < invalidation;
          $super.invalidateMeasure.call(this, invalidation);
          if (invalidated) {
            this.invalidateAllocatedSpace(this._invalidatedMeasure);
          }
        },

        /**
         * @inheritDoc
         */
        invalidateAllocatedSpace: function(invalidation) {
          var invalidated = !invalidation || this._invalidatedAllocatedSpace < invalidation;
          $super.invalidateAllocatedSpace.call(this, invalidation);
          if (invalidated) {
            this.invalidateMeasure(this._invalidatedAllocatedSpace);
          }
        },

        /**
         * @return {boolean} true when the form is taller than the browser viewport
         */
        isAutoOverflowActivated: function() {
          return this._autoOverflowMode;
        },

        /**
         * @inheritDoc
         */
        needMeasureSwitching: function() {
          return false;
        },

        /**
         * @inheritDoc
         */
        needMeasure: function() {
          return true;
        }
      };
    });
  });
;
"use strict";

modulum('FormLayoutInformation', ['LayoutInformation'],
  function(context, cls) {
    /**
     * @class FormLayoutInformation
     * @memberOf classes
     * @extends classes.LayoutInformation
     */
    cls.FormLayoutInformation = context.oo.Class(cls.LayoutInformation, function($super) {
      return /** @lends classes.FormLayoutInformation.prototype */ {
        __name: "FormLayoutInformation",
        /**
         * Min size hint (minWidth, minHeight)
         * @type {classes.Size}
         */
        _minSizeHint: null,

        /** @type {Number} */
        _toolbarAllocatedWidth: 0,

        /**
         *
         * @param {classes.WidgetBase} widget
         */
        constructor: function(widget) {
          this._minSizeHint = new cls.Size();
          $super.constructor.call(this, widget);
        },

        /**
         * @inheritDoc
         */
        reset: function(soft) {
          $super.reset.call(this, soft);
          this._minSizeHint.reset();
        },

        /**
         *
         * @returns {classes.Size}
         */
        getMinSizeHint: function() {
          return this._minSizeHint;
        },

        /**
         *
         * @param {number} width
         * @param {number} height
         */
        setMinSizeHint: function(width, height) {
          this._minSizeHint.setWidth(width);
          this._minSizeHint.setHeight(height);
        },

        /**
         * Set width allocated for toolbar
         * @param {Number} width - width of the allocated space
         */
        setToolbarAllocatedWidth: function(width) {
          this._toolbarAllocatedWidth = width;
        },

        /**
         * Get width allocated for toolbar
         * @return {number}
         */
        getToolbarAllocatedWidth: function() {
          return this._toolbarAllocatedWidth;
        }
      };
    });
  });
;
"use strict";

modulum('GridDimensionManager',
  function(context, cls) {
    /**
     * Determine one dimension unit of a grid (e.g. column or line)
     * @class GridDimensionElement
     * @memberOf classes
     */
    cls.GridDimensionElement = context.oo.Class(function() {
      return /** @lends classes.GridDimensionElement.prototype */ {
        __name: "GridDimensionElement",
        /**
         * the position of this dimensionElement
         * @type {number}
         */
        position: 0,

        /**
         * Minimal mandatory size (without gaps) of this dimensionElement
         * @type {number}
         */
        intrinsicSize: 0,

        /**
         * Preferred size (without gaps) of this dimensionElement
         * @type {number}
         */
        hintSize: 0,

        /**
         * Miximal size (without gaps) of this dimensionElement
         * @type {number}
         */
        maxSize: 0,

        /**
         * Minimal size (without gaps) of this dimensionElement
         * @type {number}
         */
        minSize: 0,

        /**
         * Maximum bonus to apply to this dimensionElement
         * @type {number}
         */
        maxBonus: 0,

        /**
         * Maximum malus to apply to this dimensionElement
         * @type {number}
         */
        maxMalus: 0,

        /**
         * Minimal size of gap before this dimensionElement
         * @type {number}
         */
        minimalBeforeGap: 0,
        /**
         * Minimal size of gap after this dimensionElement
         * @type {number}
         */
        minimalAfterGap: 0,
        /**
         * Size amount that is eventually added to the intrinsicSize
         * @type {number}
         */
        bonusSize: 0,
        /**
         * Actual size of gap before this dimensionElement
         * @type {number}
         */
        beforeGap: 0,
        /**
         * Actual size of gap after this dimensionElement
         * @type {number}
         */
        afterGap: 0,
        /**
         * list of slots that starts on this dimensionElement
         * @type {classes.GridDimensionSlot[]}
         */
        slots: null,
        /**
         * Actual extra size of gap before this dimensionElement
         * @type {number}
         */
        extraBeforeGap: 0,
        /**
         * Actual extra size of gap after this dimensionElement
         * @type {number}
         */
        extraAfterGap: 0,
        /**
         * Incremental index to count number of unstretchable slots on this dimensionElement
         * @type {number}
         */
        unstretchable: 0,
        /**
         * Whether os not this dimensionElement is stretchable (i.e. one of its slots is)
         * @type {boolean}
         */
        stretchable: false,

        /**
         * @constructs
         * @param {number} position position of this dimensionElement
         */
        constructor: function(position) {
          this.position = position;
          this.slots = [];
        },
        /**
         * reset all information of this dimensionElement
         * @param {boolean} [swipeGaps] true to swipe gaps
         * @param {boolean} [resetIntrinsicSize] true to reset intrinsic size
         */
        resetSize: function(swipeGaps, resetIntrinsicSize) {
          this.unstretchable = 0;
          this.stretchable = false;
          this.bonusSize = 0;
          this.maxBonus = 0;
          this.maxMalus = 0;
          if (resetIntrinsicSize) {
            this.intrinsicSize = 0;
            this.hintSize = 0;
            this.maxSize = 0;
            this.minSize = 0;
          }
          if (swipeGaps) {
            this.resetGaps();
            this.updateGaps();
          }
        },
        /**
         * reset gaps
         */
        resetGaps: function() {
          this.beforeGap = 0;
          this.minimalBeforeGap = 0;
          this.afterGap = 0;
          this.minimalAfterGap = 0;
        },
        /**
         * Find out whether or not grid would render
         * @return {boolean} true if will render
         * @private
         */
        _shouldRender: function() {
          var i = 0,
            len = this.slots.length;
          for (; i < len; i++) {
            if (this.slots[i].displayed) {
              return true;
            }
          }
          return false;
        },

        /**
         * Get the total gap before this dimensionElement
         * @return {number} the total gap before this dimensionElement
         */
        getBeforeGap: function() {
          return this._shouldRender() ? this.beforeGap + this.extraBeforeGap : 0;
        },

        /**
         * Get the total gap after this dimensionElement
         * @return {number} the total gap after this dimensionElement
         */
        getAfterGap: function() {
          return this._shouldRender() ? this.afterGap + this.extraAfterGap : 0;
        },
        /**
         * Get the computed total size of this dimensionElement
         * @param {boolean} [withBeforeGap] add total before gap
         * @param {boolean} [withAfterGap] add total after gap
         * @return {number} the computed total size of this dimensionElement
         */
        getSize: function(withBeforeGap, withAfterGap) {
          return this.intrinsicSize + this.bonusSize + (!!withBeforeGap ? this.beforeGap + this.extraBeforeGap : 0) + (!!
            withAfterGap ? this.afterGap + this.extraAfterGap : 0);
        },

        /**
         * attach a slot to this dimensionElement
         * @param {classes.GridDimensionSlot} slot slot to attach
         */
        attach: function(slot) {
          var insertIndex = 0,
            size = this.slots.length,
            slotSize = slot.getSize();
          for (; insertIndex < size && this.slots[insertIndex].getSize() < slotSize;) {
            insertIndex++;
          }
          this.slots.add(slot, insertIndex);
          this.updateGaps();
        },

        /**
         * detach a slot from this dimensionElement
         * @param {classes.GridDimensionSlot} slot slot to detach
         */
        detach: function(slot) {
          var index = this.slots.indexOf(slot);
          if (index >= 0) {
            this.slots.splice(index, 1);
          }
          this.updateGaps();
        },

        /**
         * update the gaps depending on attached slots
         */
        updateGaps: function() {
          this.resetGaps();
          this.extraBeforeGap = 0;
          this.extraAfterGap = 0;
          var i = 0,
            len = this.slots.length;
          for (; i < len; i++) {
            var slot = this.slots[i];
            if (slot.displayed && slot.getPosition() === this.position) {
              this.extraBeforeGap = Math.max(this.extraBeforeGap, slot.extraBeforeGap);
              this.beforeGap = this.minimalBeforeGap = Math.max(this.minimalBeforeGap, slot.minimalBeforeGap);
            }
            if (slot.displayed && slot.getLastPosition() === this.position) {
              this.extraAfterGap = Math.max(this.extraAfterGap, slot.extraAfterGap);
              this.afterGap = this.minimalAfterGap = Math.max(this.minimalAfterGap, slot.minimalAfterGap);
            }
          }
        },

        /**
         * adjust the intrinsic size given a new size
         * @param size new size to manage
         */
        adjustIntrinsicSize: function(size) {
          this.intrinsicSize = Math.max(this.intrinsicSize, size);
        },

        /**
         * adjust the preferred size given a new size
         * @param size new size to manage
         */
        adjustHintSize: function(size) {
          this.hintSize = Math.max(this.hintSize, size);
        },

        /**
         * adjust the maximal size given a new size
         * @param size new size to manage
         */
        adjustMaxSize: function(size) {
          if (this.maxSize !== cls.Size.maximal) {
            this.maxSize = size === cls.Size.maximal || this.maxSize === 0 ? size : Math.min(this.maxSize, size);
          }
        },

        /**
         * adjust the minimal size given a new size
         * @param size new size to manage
         */
        adjustMinSize: function(size) {
          this.minSize = Math.max(this.minSize, size);
        },

        /**
         * destroy all slots
         */
        destroy: function() {
          while (this.slots.length) {
            this.slots.pop().destroy();
          }
        }
      };
    });
  });
;
"use strict";

modulum('GridDimensionManager',
  function(context, cls) {
    /**
     *
     * slots:             [       ]   [           ]
     * elements (unit): |_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|
     * @class GridDimensionManager
     * @memberOf classes
     */
    cls.GridDimensionManager = context.oo.Class(function() {
      return /** @lends classes.GridDimensionManager.prototype */ {
        __name: "GridDimensionManager",

        /**
         * handle registration for theme change
         * @type {HandleRegistration}
         */
        _themeWatcher: null,

        /**
         * dimension elements
         * @type {classes.GridDimensionElement[]}
         */
        dimensionElements: null,

        /**
         * gutter size (minimal space between elements)
         * @type {number}
         */
        _gutterSize: 0,

        /**
         * empty element size
         * @type {number}
         */
        _emptyElementSize: 0,

        /**
         * will force uniform distribution while stretching
         * @type {boolean}
         */
        _uniformDistribution: false,

        /**
         * slots
         * @type {classes.GridDimensionSlot[]}
         */
        slots: null,

        /**
         * dimension size
         * @type {number}
         */
        _size: 0,

        /**
         * is dimension meant to stretch
         * @type {boolean}
         */
        stretchable: false,

        /**
         * @constructs
         * @param {?boolean} [uniformDistribution] will force uniform distribution while stretching
         */
        constructor: function(uniformDistribution) {
          this._uniformDistribution = !!uniformDistribution;
          this._gutterSize = context.ThemeService.getValue("theme-grid-inner-gutter");
          this._themeWatcher = context.ThemeService.whenThemeChanged(function() {
            this._gutterSize = context.ThemeService.getValue("theme-grid-inner-gutter");
          }.bind(this));
          this.slots = [];
          this.dimensionElements = [];
        },

        /**
         * get the dimension size
         * @return {number} the dimension size
         */
        getSize: function() {
          return this._size;
        },

        /**
         * Get the computed preferred size
         * @param {number} [from] from position (or start)
         * @param {number} [to] to position (or end)
         * @param {boolean} [includeFirstBeforeGap] true to include first before gap
         * @param {boolean} [includeLastAfterGap] true to include last after gap
         * @return {number} the computed preferred size
         */
        getHintSize: function(from, to, includeFirstBeforeGap, includeLastAfterGap) {
          from = Object.isNumber(from) ? from : 0;
          to = Object.isNumber(to) ? to : this._size - 1;
          includeFirstBeforeGap = includeFirstBeforeGap !== false;
          includeLastAfterGap = includeLastAfterGap !== false;

          var total = 0;
          var totalGaps = 0;
          for (var i = from; i <= to; i++) {
            total += this.dimensionElements[i].hintSize;
            totalGaps +=
              ((i !== from || includeFirstBeforeGap) ? this.dimensionElements[i].getBeforeGap() : 0) +
              ((i !== to || includeLastAfterGap) ? this.dimensionElements[i].getAfterGap() : 0);
          }
          if (!total) {
            if (this.getMaxSize() === cls.Size.maximal) {
              total = totalGaps;
            }
          } else {
            total += totalGaps;
          }
          if (includeLastAfterGap && from === 0 && to === (this._size - 1) && total > this._gutterSize) {
            total -= this._gutterSize;
          }
          return total;
        },

        /**
         * Get the computed maximum size
         * @param {number} [from] from position (or start)
         * @param {number} [to] to position (or end)
         * @param {boolean} [includeFirstBeforeGap] true to include first before gap
         * @param {boolean} [includeLastAfterGap] true to include last after gap
         * @return {number} the computed maximum size
         */
        getMaxSize: function(from, to, includeFirstBeforeGap, includeLastAfterGap) {
          from = Object.isNumber(from) ? from : 0;
          to = Object.isNumber(to) ? to : this._size - 1;
          includeFirstBeforeGap = includeFirstBeforeGap !== false;
          includeLastAfterGap = includeLastAfterGap !== false;

          var total = 0;
          for (var i = from; i <= to; i++) {
            total += this.dimensionElements[i].maxSize +
              ((i !== from || includeFirstBeforeGap) ? this.dimensionElements[i].getBeforeGap() : 0) +
              ((i !== to || includeLastAfterGap) ? this.dimensionElements[i].getAfterGap() : 0);
          }
          if (includeLastAfterGap && from === 0 && to === (this._size - 1) && total > this._gutterSize) {
            total -= this._gutterSize;
          }
          return total;
        },

        /**
         * Get the computed minimum size
         * @param {number} [from] from position (or start)
         * @param {number} [to] to position (or end)
         * @param {boolean} [includeFirstBeforeGap] true to include first before gap
         * @param {boolean} [includeLastAfterGap] true to include last after gap
         * @return {number} the computed minimum size
         */
        getMinSize: function(from, to, includeFirstBeforeGap, includeLastAfterGap) {
          from = Object.isNumber(from) ? from : 0;
          to = Object.isNumber(to) ? to : this._size - 1;
          includeFirstBeforeGap = includeFirstBeforeGap !== false;
          includeLastAfterGap = includeLastAfterGap !== false;

          var total = 0;
          for (var i = from; i <= to; i++) {
            total += this.dimensionElements[i].minSize +
              ((i !== from || includeFirstBeforeGap) ? this.dimensionElements[i].getBeforeGap() : 0) +
              ((i !== to || includeLastAfterGap) ? this.dimensionElements[i].getAfterGap() : 0);
          }
          if (includeLastAfterGap && from === 0 && to === (this._size - 1) && total > this._gutterSize) {
            total -= this._gutterSize;
          }
          return Number.isNaN(total) ? 0 : total;
        },
        /**
         * Get the computed size
         * @param {number} [from] from position (or start)
         * @param {number} [to] to position (or end)
         * @param {boolean} [includeFirstBeforeGap] true to include first before gap
         * @param {boolean} [includeLastAfterGap] true to include last after gap
         * @return {number} the computed size
         */
        getCalculatedSize: function(from, to, includeFirstBeforeGap, includeLastAfterGap) {
          from = Object.isNumber(from) ? from : 0;
          to = Object.isNumber(to) ? to : this._size - 1;
          includeFirstBeforeGap = includeFirstBeforeGap !== false;
          includeLastAfterGap = includeLastAfterGap !== false;

          var total = 0;
          for (var i = from; i <= to; i++) {
            total +=
              ((i !== from || includeFirstBeforeGap) ? this.dimensionElements[i].getBeforeGap() : 0) +
              ((this.dimensionElements[i].intrinsicSize + this.dimensionElements[i].bonusSize) || this._emptyElementSize) +
              ((i !== to || includeLastAfterGap) ? this.dimensionElements[i].getAfterGap() : 0);
          }
          if (includeLastAfterGap && from === 0 && to === (this._size - 1) && total > this._gutterSize) {
            total -= this._gutterSize;
          }
          return total;
        },

        /**
         * set a new dimension size
         * @param {number} newSize the new size
         * @param {boolean} [destroyDimensionElements] destroy current dimension elements
         */
        setSize: function(newSize, destroyDimensionElements) {
          var size = this._size;
          if (newSize > size) {
            for (var addingIndex = this.dimensionElements.length; addingIndex < newSize; addingIndex++) {
              this.dimensionElements[addingIndex] = new cls.GridDimensionElement(addingIndex);
            }
          }
          if (!!destroyDimensionElements) {
            for (var i = newSize; i < this.dimensionElements.length; i++) {
              this.dimensionElements[i].destroy();
            }
            this.dimensionElements.length = newSize;
          }
          this._size = newSize;
        },

        /**
         * Ensure given size
         * @param {number} size the size to ensure
         */
        ensureSize: function(size) {
          if (this.getSize() < size) {
            this.setSize(size);
          }
        },

        /**
         * Set the dimension as stretchable
         * @param stretchable the stretchable state
         */
        setStretchable: function(stretchable) {
          this.stretchable = stretchable;
        },

        /**
         * reset elements
         * @param {boolean} [swipeGaps] true to swipe gaps
         * @param {boolean} [resetIntrinsicSizes] true to reset intrinsic sizes
         */
        resetDimensionSizes: function(swipeGaps, resetIntrinsicSizes) {
          var size = this.getSize();
          for (var i = 0; i < size; i++) {
            this.dimensionElements[i].resetSize(swipeGaps, resetIntrinsicSizes);
          }
        },

        /**
         * Add slot usage on the dimension
         * @param {classes.GridDimensionSlot} slot
         */
        addSlot: function(slot) {
          this.ensureSize(slot.getLastPosition() + 1);
          var insertIndex = 0,
            size = this.slots.length;
          for (; insertIndex < size && this.slots[insertIndex].getPosition() < slot.getPosition();) {
            insertIndex++;
          }
          for (; insertIndex < size && this.slots[insertIndex].getSize() < slot.getSize();) {
            insertIndex++;
          }
          this.slots.add(slot, insertIndex);
          slot.attach(this);
          for (var i = slot.getPosition(); i <= slot.getLastPosition(); i++) {
            this.dimensionElements[i].attach(slot);
          }
        },
        /**
         * Remove slot usage on the dimension
         * @param {classes.GridDimensionSlot} slot
         */
        removeSlot: function(slot) {
          for (var i = slot.getPosition(); i <= slot.getLastPosition(); i++) {
            this.dimensionElements[i].detach(slot);
          }
          slot.detach();
          var index = this.slots.indexOf(slot);
          if (index >= 0) {
            this.slots.splice(index, 1);
          }
          return slot;
        },

        /**
         * update gaps of all elements
         */
        updateGaps: function() {
          var size = this.getSize();
          for (var i = 0; i < size; i++) {
            this.dimensionElements[i].updateGaps();
          }
        },
        /**
         * compute intrinsic sizes (natural measured sizes)
         */
        updateIntrinsicSizes: function() {
          this.resetDimensionSizes(true, true);
          var size = this.slots.length;
          for (var i = 0; i < size; i++) {
            var slot = this.slots[i],
              slotSize = slot.getSize(),
              pos = slot.getPosition(),
              lastPos = slot.getLastPosition();
            if (slot.displayed) {
              var totalGapSizes = this.getGapSizing(pos, lastPos);
              var elementMaxSize = slot.maxSize / slotSize;
              var elementMinSize = slot.minSize / slotSize;

              var lambdaUnitSize = Math.max((slot.desiredMinimalSize - totalGapSizes) / slotSize, elementMinSize);

              for (var position = pos; position <= lastPos; position++) {
                var dimensionElement = this.dimensionElements[position];
                dimensionElement.adjustMinSize(elementMinSize);
                dimensionElement.adjustMaxSize(elementMaxSize);
                dimensionElement.adjustIntrinsicSize(lambdaUnitSize);
              }
            }
          }
        },
        /**
         * adjust elements stretchability and preferred sizes
         */
        updateStretchability: function() {
          var size = this.slots.length;
          for (var i = 0; i < size; i++) {
            var slot = this.slots[i],
              slotSize = slot.getSize(),
              pos = slot.getPosition(),
              lastPos = slot.getLastPosition();
            if (slot.displayed) {
              var totalGapSizes = this.getGapSizing(pos, lastPos);
              var slotHint = (slot.hintSize - totalGapSizes) / slotSize;
              for (var position = pos; position <= lastPos; position++) {
                var dimensionElement = this.dimensionElements[position];
                if (slot.stretchable) {
                  dimensionElement.adjustHintSize(slotHint);
                  dimensionElement.stretchable = true;
                } else {
                  if (!slot.opportunisticStretchable) {
                    dimensionElement.unstretchable++;
                  }
                }
              }
            }
          }
        },

        /**
         * distribute space to remove to slots (when grid needs to stretch)
         * @param sizeToDistribute the total difference to add
         * @return {boolean}
         */
        updateBonusSize: function(sizeToDistribute) {
          var result = false,
            dimensionElement = null,
            i = 0,
            totalWeights = this._getTotalWeights();
          if (totalWeights > 0) {
            var unstretchable = Number.POSITIVE_INFINITY;
            for (i = 0; i < this._size; i++) {
              dimensionElement = this.dimensionElements[i];
              if (dimensionElement.stretchable) {
                unstretchable = Math.min(unstretchable, dimensionElement.unstretchable);
              }
            }

            var totalLocalWeights = 0,
              stretchableElements = [],
              len;
            for (i = 0; i < this._size; i++) {
              dimensionElement = this.dimensionElements[i];
              if (dimensionElement.stretchable && (this._uniformDistribution || (dimensionElement.unstretchable === unstretchable))) {
                stretchableElements.push(dimensionElement);
                totalLocalWeights += dimensionElement.intrinsicSize;
                dimensionElement.maxBonus = dimensionElement.maxSize - dimensionElement.intrinsicSize;
              }
            }
            stretchableElements.sort(function(a, b) {
              return a.maxBonus > b.maxBonus ? -1 : (a.maxBonus < b.maxBonus ? 1 : 0);
            });
            len = stretchableElements.length;
            for (i = 0; i < len; i++) {
              dimensionElement = stretchableElements[i];
              var delta = sizeToDistribute * (dimensionElement.intrinsicSize / totalLocalWeights);
              dimensionElement.bonusSize = delta;
              sizeToDistribute -= delta;
              totalLocalWeights -= dimensionElement.intrinsicSize;
              result = true;
            }
          } else {
            if (this.stretchable && this._size > 0) {
              for (var e = 0; e < this._size; e++) {
                dimensionElement = this.dimensionElements[e];
                dimensionElement.bonusSize = sizeToDistribute / this._size;
                result = true;
              }
            }
          }
          return result;
        },

        /**
         * distribute space to remove to slots (when grid needs to shrink)
         * @param sizeToDistribute the total difference to remove
         * @return {boolean}
         */
        updateMalusSize: function(sizeToDistribute) {
          var result = false,
            dimensionElement = null,
            i = 0,
            maxMalus = 0,
            totalWeights = this._getTotalWeights();
          if (totalWeights > 0) {
            var unstretchable = Number.POSITIVE_INFINITY;
            for (i = 0; i < this._size; i++) {
              dimensionElement = this.dimensionElements[i];
              if (dimensionElement.stretchable) {
                unstretchable = Math.min(unstretchable, dimensionElement.unstretchable);
              }
            }

            var totalLocalWeights = 0,
              stretchableElements = [],
              len;
            for (i = 0; i < this._size; i++) {
              dimensionElement = this.dimensionElements[i];
              if (dimensionElement.stretchable && (this._uniformDistribution || (dimensionElement.unstretchable === unstretchable))) {
                stretchableElements.push(dimensionElement);
                totalLocalWeights += dimensionElement.intrinsicSize;
                dimensionElement.maxMalus = dimensionElement.intrinsicSize - dimensionElement.minSize;
              }
            }
            stretchableElements.sort(function(a, b) {
              return a.maxMalus < b.maxMalus ? -1 : (a.maxMalus > b.maxMalus ? 1 : 0);
            });
            len = stretchableElements.length;
            for (i = 0; i < len; i++) {
              dimensionElement = stretchableElements[i];
              var delta = -sizeToDistribute * (dimensionElement.intrinsicSize / totalLocalWeights);
              if (dimensionElement.maxMalus > delta) {
                dimensionElement.bonusSize = -delta;
                sizeToDistribute += delta;
                totalLocalWeights -= dimensionElement.intrinsicSize;
              } else {
                dimensionElement.bonusSize = -dimensionElement.maxMalus;
                sizeToDistribute += dimensionElement.maxMalus;
                totalLocalWeights -= dimensionElement.intrinsicSize;
              }
              result = true;
            }
          } else {
            if (this.stretchable && this._size > 0) {
              for (var e = 0; e < this._size; e++) {
                dimensionElement = this.dimensionElements[e];
                dimensionElement.bonusSize = sizeToDistribute / this._size;
                maxMalus = dimensionElement.intrinsicSize - dimensionElement.minSize;
                if ((-dimensionElement.bonusSize) > maxMalus) {
                  dimensionElement.bonusSize = -maxMalus;
                }
                result = true;
              }
            }
          }
          return result;
        },

        /**
         * compute all slots positions and sizes to apply to css
         * @return {{regularPositions: Array, regular: {}}}
         */
        render: function() {
          var result = {
            regularPositions: [],
            regular: {}
          };
          for (var i = 0; i < this.slots.length; i++) {
            var slot = this.slots[i];
            if (!result.regular[slot.getPosition()]) {
              result.regularPositions.push(slot.getPosition());
              result.regular[slot.getPosition()] = {
                position: this.getCalculatedSize(0, slot.getPosition() - 1, true, true),
                beforeGap: this.dimensionElements[slot.getPosition()].beforeGap,
                regularLengths: [],
                lengths: {},
                lengthsWithGaps: {}
              };
            }
            if (!Object.isNumber(result.regular[slot.getPosition()].lengths[slot.getSize()])) {
              result.regular[slot.getPosition()].regularLengths.push(slot.getSize());
              result.regular[slot.getPosition()].lengths[slot.getSize()] = this.getCalculatedSize(slot.getPosition(), slot.getLastPosition(),
                false, false);
              result.regular[slot.getPosition()].lengthsWithGaps[slot.getSize()] = this.getCalculatedSize(slot.getPosition(),
                slot.getLastPosition(),
                true, true);
            }
          }
          return result;
        },

        /**
         * get the total weight that determines how to distribute space
         * @return {number} the total weight in the dimension
         * @private
         */
        _getTotalWeights: function() {
          var result = 0,
            dimensionElement = null,
            unstretchable = Number.POSITIVE_INFINITY;
          for (var i = 0; i < this._size; i++) {
            dimensionElement = this.dimensionElements[i];
            if (dimensionElement.stretchable) {
              unstretchable = Math.min(unstretchable, dimensionElement.unstretchable);
            }
          }
          for (i = 0; i < this._size; i++) {
            dimensionElement = this.dimensionElements[i];
            if (dimensionElement.stretchable && (this._uniformDistribution || (dimensionElement.unstretchable === unstretchable))) {
              result += dimensionElement.intrinsicSize;
            }
          }
          return result;
        },

        /**
         * Get the computed total gap size
         * @param {number} [from] from position (or start)
         * @param {number} [to] to position (or end)
         * @param {boolean} [includeFirstBeforeGap] true to include first before gap
         * @param {boolean} [includeLastAfterGap] true to include last after gap
         * @return {number} the computed total gap size
         */
        getGapSizing: function(from, to, includeFirstBeforeGap, includeLastAfterGap) {
          var total = 0;
          for (var i = from; i <= to; i++) {
            total +=
              ((i !== from || includeFirstBeforeGap) ? this.dimensionElements[i].getBeforeGap() : 0) +
              ((i !== to || includeLastAfterGap) ? this.dimensionElements[i].getAfterGap() : 0);
          }
          return total;
        },

        /**
         * destroy
         */
        destroy: function() {
          if (this._themeWatcher) {
            this._themeWatcher();
            this._themeWatcher = null;
          }
          this.setSize(0, true);
        }
      };
    });
  });
;
"use strict";

modulum('GridDimensionSlot',
  function(context, cls) {
    /**
     *
     * @class GridDimensionSlot
     * @memberOf classes
     */
    cls.GridDimensionSlot = context.oo.Class(function() {
      return /** @lends classes.GridDimensionSlot.prototype */ {
        __name: "GridDimensionSlot",

        /**
         * handle registration for theme change
         * @type {HandleRegistration}
         */
        _themeWatcher: null,

        /**
         * default minimal gap to apply before this slot
         * @type {number}
         */
        defaultMinimalBeforeGap: 0,

        /**
         * default minimal gap to apply after this slot
         * @type {number}
         */
        defaultMinimalAfterGap: 0,

        /**
         * starting position of the slot
         * @type {number}
         */
        position: 0,

        /**
         * slot size
         * @type {number}
         */
        size: 0,

        /**
         * Desired slot size (calculated in pixels from raw width/height hint)
         * @type {number}
         */
        desiredMinimalSize: 0,

        /**
         * Minimal slot size
         * @type {number}
         */
        minSize: 0,

        /**
         * Maximal slot size
         * @type {number}
         */
        maxSize: 0,

        /**
         * Preferred slot size
         * @type {number}
         */
        hintSize: 0,

        /**
         * Owner
         * @type {classes.GridDimensionManager}
         */
        dimensionManager: null,

        /**
         * minimal gap to apply before this slot
         * @type {number}
         */
        minimalBeforeGap: 0,

        /**
         * minimal gap to apply after this slot
         * @type {number}
         */
        minimalAfterGap: 0,

        /**
         * extra gap to apply before this slot
         * @type {number}
         */
        extraBeforeGap: 0,

        /**
         * extra gap to apply after this slot
         * @type {number}
         */
        extraAfterGap: 0,

        /**
         * is this slot stretchable?
         * @type {boolean}
         */
        stretchable: false,

        /**
         * is this slot opportunistic stretchable?
         * (e.g. will only stretch if some other slot sharing dimension elements stretches)
         * @type {boolean}
         */
        opportunisticStretchable: false,

        /**
         * is this slot displayed?
         * @type {boolean}
         */
        displayed: true,
        /**
         * @constructs
         * @param {number} position the position
         * @param {number} size the size
         */
        constructor: function(position, size) {
          this.position = position;
          this.size = size;
          this.defaultMinimalAfterGap = context.ThemeService.getValue("theme-grid-inner-gutter");
          this.minimalAfterGap = context.ThemeService.getValue("theme-grid-inner-gutter");
        },

        /**
         * reset the slot
         * @param {number} position the new position
         * @param {number} size the new size
         * @return {classes.GridDimensionSlot} this
         */
        reset: function(position, size) {
          this.position = position;
          this.size = size;
          return this;
        },

        /**
         * get the first position of the slot
         * @return {number} the first position of the slot
         */
        getPosition: function() {
          return this.position;
        },
        /**
         * get the last position of the slot
         * @return {number} the last position of the slot
         */
        getLastPosition: function() {
          return this.position + this.size - 1;
        },

        /**
         * get the size of the slot
         * @return {number} the size of the slot
         */
        getSize: function() {
          return this.size;
        },

        /**
         * set the desired minimal size
         * @param {number} desiredMinimalSize calculated in pixels from raw width/height hint
         */
        setDesiredMinimalSize: function(desiredMinimalSize) {
          this.desiredMinimalSize = desiredMinimalSize || 0;
        },

        /**
         * Set the slot as stretchable
         * @param stretchable stretchable value
         */
        setStretchable: function(stretchable) {
          this.stretchable = stretchable;
        },

        /**
         * Set the slot as opportunistic stretchable
         * @param stretchable stretchable value
         */
        setOpportunisticStretchable: function(stretchable) {
          this.opportunisticStretchable = stretchable;
        },

        /**
         * Set maximal size
         * @param maxSize maximal size
         */
        setMaxSize: function(maxSize) {
          this.maxSize = maxSize;
        },

        /**
         * Set minimal size
         * @param minSize minimal size
         */
        setMinSize: function(minSize) {
          this.minSize = minSize;
        },

        /**
         * Set preferred size
         * @param hintSize preferred size
         */
        setHintSize: function(hintSize) {
          this.hintSize = hintSize;
        },

        /**
         * Set displayed state
         * @param displayed displayed state
         */
        setDisplayed: function(displayed) {
          this.displayed = displayed;
        },

        /**
         * set minimum gap before the slot
         * @param {number} value the minimum gap before the slot
         */
        setMinimumBeforeGap: function(value) {
          if (Object.isNumber(value)) {
            this.minimalBeforeGap = value;
          } else {
            this.minimalBeforeGap = this.defaultMinimalBeforeGap;
          }
        },

        /**
         * set minimum gap after the slot
         * @param {number} value the minimum gap after the slot
         */
        setMinimumAfterGap: function(value) {
          if (Object.isNumber(value)) {
            this.minimalAfterGap = value;
          } else {
            this.minimalAfterGap = this.defaultMinimalAfterGap;
          }
        },
        /**
         * attach to dimension manager
         * @param {classes.GridDimensionManager} dimensionManager dimension manager
         */
        attach: function(dimensionManager) {
          this.dimensionManager = dimensionManager;
          if (this._themeWatcher) {
            this._themeWatcher();
          }
          this._themeWatcher = context.ThemeService.whenThemeChanged(function() {
            this.defaultMinimalAfterGap = context.ThemeService.getValue("theme-grid-inner-gutter");
            this.minimalAfterGap = context.ThemeService.getValue("theme-grid-inner-gutter");
          }.bind(this));
        },

        /**
         * detach from dimension manager
         */
        detach: function() {
          if (this._themeWatcher) {
            this._themeWatcher();
            this._themeWatcher = null;
          }
          this.dimensionManager = null;
        },

        /**
         * destroy
         */
        destroy: function() {
          if (this._themeWatcher) {
            this._themeWatcher();
            this._themeWatcher = null;
          }
          this.dimensionManager = null;
        }
      };
    });
  });
;
"use strict";

modulum('GridLayoutEngine', ['LayoutEngineBase'],
  function(context, cls) {
    /**
     * @class GridLayoutEngine
     * @memberOf classes
     * @extends classes.LayoutEngineBase
     */
    cls.GridLayoutEngine = context.oo.Class(cls.LayoutEngineBase, function($super) {
      return /** @lends classes.GridLayoutEngine.prototype */ {
        __name: "GridLayoutEngine",
        /**
         * list of registered childrn widgets
         * @type {classes.WidgetBase[]}
         */
        _registeredWidgets: null,
        /**
         * map of registered grid dimension slots
         * @type {object<string, ?classes.XYDimensionSlot>}
         */
        _registeredSlots: null,
        /**
         * map of widgets handle registration
         * @type {object<Number, HandleRegistration>}
         */
        _registeredWidgetWatchers: null,
        /**
         * X dimension sub engine
         * @type {classes.GridLayoutEngineX}
         */
        _xspace: null,
        /**
         * Y dimension sub engine
         * @type {classes.GridLayoutEngineY}
         */
        _yspace: null,

        /**
         * stylesheet id
         */
        _styleSheetId: null,
        /**
         * set to false to avoid render children
         * @type {boolean}
         */
        _willRenderContent: true,
        /**
         * @inheritDoc
         * @constructs
         */
        constructor: function(widget) {
          $super.constructor.call(this, widget);
          this._styleSheetId = "gridLayout_" + widget.getUniqueIdentifier();
          this._registeredWidgets = [];
          this._registeredSlots = {};
          this._registeredWidgetWatchers = {};
          this._xspace = new cls.GridLayoutEngineX(widget);
          this._yspace = new cls.GridLayoutEngineY(widget);
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          for (var w in this._registeredWidgetWatchers) {
            var watch = this._registeredWidgetWatchers[w];
            if (watch) {
              watch();
            }
          }
          for (var i = this._registeredWidgets.length - 1; i > -1; i--) {
            var wi = this._registeredWidgets[i];
            wi.destroy();
            this.unregisterChild(wi);
          }
          for (var s in this._registeredSlots) {
            var slot = this._registeredSlots[s];
            if (slot) {
              slot.x.destroy();
              slot.y.destroy();
            }
          }
          this._xspace.destroy();
          this._yspace.destroy();
          this._xspace = null;
          this._yspace = null;
          this._registeredSlots = null;
          this._registeredWidgetWatchers = null;
          this._registeredWidgets.length = 0;
          $super.destroy.call(this);
        },

        /**
         * whether or not to render content
         * @return {boolean}  true if content has to be rendered
         */
        willRenderContent: function() {
          var parentEngine = this._widget && this._widget.getParentWidget() &&
            this._widget.getParentWidget().isInstanceOf(cls.GroupWidget) &&
            this._widget.getParentWidget().getLayoutEngine(),
            hasWillRenderContent = parentEngine && parentEngine.willRenderContent;
          return this._willRenderContent && (!hasWillRenderContent || parentEngine.willRenderContent());
        },
        /**
         * set hint size
         * @param {number|string} widthHint the width
         * @param {number|string} heightHint the height
         */
        setHint: function(widthHint, heightHint) {
          this._widget.getLayoutInformation().setSizeHint(
            ((typeof(widthHint) === "undefined") || widthHint === null || widthHint === "") ? 1 : widthHint,
            ((typeof(heightHint) === "undefined") || heightHint === null || heightHint === "") ? 1 : heightHint
          );
        },

        /**
         *
         * @param {classes.LayoutInformation} widgetLayoutInformation
         * @param {?{x:classes.GridDimensionSlot, y:classes.GridDimensionSlot}} slotRecycle
         * @return {classes.GridDimensionSlot}
         */
        getSlotX: function(widgetLayoutInformation, slotRecycle) {
          var gridX = widgetLayoutInformation.getGridX(),
            gridWidth = widgetLayoutInformation.getGridWidth(),
            result = null;
          if (slotRecycle && slotRecycle.x) {
            result = slotRecycle.x.reset(gridX, gridWidth);
          } else {
            result = new cls.GridDimensionSlot(gridX, gridWidth);
          }
          return result;
        },

        /**
         *
         * @param {classes.LayoutInformation} widgetLayoutInformation
         * @param {?{x:classes.GridDimensionSlot, y:classes.GridDimensionSlot}} slotRecycle
         * @return {classes.GridDimensionSlot}
         */
        getSlotY: function(widgetLayoutInformation, slotRecycle) {
          var gridY = widgetLayoutInformation.getGridY(),
            gridHeight = widgetLayoutInformation.getGridHeight(),
            result = null;
          if (slotRecycle && slotRecycle.y) {
            result = slotRecycle.y.reset(gridY, gridHeight);
          } else {
            result = new cls.GridDimensionSlot(gridY, gridHeight);
          }
          return result;
        },

        /**
         * @inheritDoc
         */
        registerChild: function(widget) {
          var slotRecycle = null;
          if (this._registeredWidgets.indexOf(widget) >= 0) {
            slotRecycle = this.unregisterChild(widget);
          }
          var widgetLayoutInformation = widget.getLayoutInformation(),
            id = widget.getUniqueIdentifier();
          if (!this._registeredSlots[id]) {
            this._registeredWidgets.push(widget);
            var slotX = this.getSlotX(widgetLayoutInformation, slotRecycle);
            var slotY = this.getSlotY(widgetLayoutInformation, slotRecycle);
            this._registeredSlots[id] = {
              x: this._xspace.registerSlot(slotX),
              y: this._yspace.registerSlot(slotY)
            };
            this._registeredWidgetWatchers[id] = widgetLayoutInformation.onGridInfoChanged(this.registerChild.bind(this, widget));
          }
        },

        hasChangesInSlot: function(widget) {
          var id = widget.getUniqueIdentifier(),
            widgetLayoutInformation = widget.getLayoutInformation();
          if (this._registeredSlots[id]) {
            var slotX = this._registeredSlots[id].x;
            var slotY = this._registeredSlots[id].y;
            return slotX.getPosition() !== widgetLayoutInformation.getGridX() ||
              slotX.getSize() !== widgetLayoutInformation.getGridWidth() ||
              slotY.getPosition() !== widgetLayoutInformation.getGridY() ||
              slotY.getSize() !== widgetLayoutInformation.getGridHeight();
          } else {
            return true;
          }
        },
        /**
         * @inheritDoc
         */
        unregisterChild: function(widget) {
          var id = widget.getUniqueIdentifier();
          if (this._registeredSlots[id]) {
            var slotRecycle = {};
            this._registeredWidgetWatchers[id]();
            this._registeredWidgetWatchers[id] = null;
            var index = this._registeredWidgets.indexOf(widget);
            if (index >= 0) {
              this._registeredWidgets.splice(index, 1);
            }
            slotRecycle.x = this._xspace.unregisterSlot(this._registeredSlots[id].x);
            slotRecycle.y = this._yspace.unregisterSlot(this._registeredSlots[id].y);
            this._registeredSlots[id] = null;
            return slotRecycle;
          }
          return null;
        },

        /**
         * @inheritDoc
         */
        beforeLayout: function() {
          var layoutInformation = this._getLayoutInfo(),
            i = 0,
            currentVirtualY = 0,
            widget = null,
            widgetLayoutInformation = null,
            list = null,
            hasChanges = false;
          if (this._registeredWidgets.length) {
            for (; i < this._registeredWidgets.length; i++) {
              widget = this._registeredWidgets[i];
              widgetLayoutInformation = widget && widget.getLayoutInformation();
              if (widgetLayoutInformation) {
                widgetLayoutInformation.setChildOfGridAutomaticStack(layoutInformation.isStacked(), true);
              }
            }
            if (layoutInformation.isStacked()) {
              list = this._registeredWidgets.slice().sort(function(a, b) {
                var ax = a.getLayoutInformation().getRawInformation().getPosX(),
                  ay = a.getLayoutInformation().getRawInformation().getPosY(),
                  bx = b.getLayoutInformation().getRawInformation().getPosX(),
                  by = b.getLayoutInformation().getRawInformation().getPosY();
                return Number.compare(ay, by) || Number.compare(ax, bx);
              });
              for (i = 0; i < list.length; i++) {
                widget = list[i];
                widgetLayoutInformation = widget && widget.getLayoutInformation();
                if (widgetLayoutInformation) {
                  widgetLayoutInformation.setVirtualGridY(currentVirtualY, true);
                  currentVirtualY += widgetLayoutInformation.getGridHeight();
                }
              }
            }

            list = this._registeredWidgets.slice();
            for (i = 0; i < list.length; i++) {
              widget = list[i];
              /*   hasChanges = hasChanges || this.hasChangesInSlot(widget);
               }
               if(hasChanges) {
                 for (i = 0; i < list.length; i++) {
                   widget = list[i];*/
              this.registerChild(widget);
              //  }
            }
          }
        },

        /**
         * @inheritDoc
         */
        measureDecoration: function() {
          var layoutInformation = this._getLayoutInfo();
          var element = this._widget.getElement(),
            container = this._widget.getContainerElement();
          layoutInformation.setDecorating(
            element.clientWidth - container.clientWidth,
            element.clientHeight - container.clientHeight
          );
          layoutInformation.setDecoratingOffset(
            container.offsetLeft - element.offsetLeft,
            container.offsetTop - element.offsetTop
          );
        },

        /**
         * @inheritDoc
         */
        adjustMeasure: function() {
          var layoutInformation = this._getLayoutInfo();
          if (!!this._registeredWidgets.length) {
            for (var i = 0; i < this._registeredWidgets.length; i++) {
              var widget = this._registeredWidgets[i],
                widgetLayoutInformation = widget.getLayoutInformation(),
                owningGrid = widgetLayoutInformation.getOwningGrid(),
                isOwningGridDisplayed = !owningGrid || owningGrid.isVisible(),
                isOwningGridNoContentRender = !owningGrid || owningGrid.getLayoutEngine().willRenderContent(),
                isDisplayed = widget.isVisible() && isOwningGridDisplayed,
                widgetSlot = this._registeredSlots[widget.getUniqueIdentifier()];

              if (isDisplayed && isOwningGridNoContentRender && this.willRenderContent()) {
                widgetSlot.x.setDisplayed(true);
                widgetSlot.y.setDisplayed(true);
                widgetSlot.x.setMinimumBeforeGap();
                widgetSlot.x.setMinimumAfterGap();
                widgetSlot.y.setMinimumBeforeGap();
                widgetSlot.y.setMinimumAfterGap();
                var
                  measured = widgetLayoutInformation.getMeasured(),
                  maxSize = widgetLayoutInformation.getMaximal(),
                  minSize = widgetLayoutInformation.getMinimal();

                widgetSlot.x.setMinSize(minSize.getWidth());
                widgetSlot.y.setMinSize(minSize.getHeight());
                widgetSlot.x.setMaxSize(maxSize.getWidth());
                widgetSlot.y.setMaxSize(maxSize.getHeight());

                widgetSlot.x.setDesiredMinimalSize(measured.getWidth() || widgetLayoutInformation.forcedMinimalWidth);
                widgetSlot.y.setDesiredMinimalSize(measured.getHeight() || widgetLayoutInformation.forcedMinimalHeight);

                if (widget.isGridChildrenInParent && widget.isGridChildrenInParent()) {
                  widgetSlot.x.setMinimumBeforeGap(widgetLayoutInformation.getDecoratingOffset().getWidth());
                  widgetSlot.x.setMinimumAfterGap(widgetLayoutInformation.getDecorating().getWidth() - widgetLayoutInformation
                    .getDecoratingOffset()
                    .getWidth());
                  widgetSlot.y.setMinimumBeforeGap(widgetLayoutInformation.getDecoratingOffset().getHeight());
                  widgetSlot.y.setMinimumAfterGap(widgetLayoutInformation.getDecorating().getHeight() - widgetLayoutInformation
                    .getDecoratingOffset()
                    .getHeight());
                } else {
                  widgetSlot.x.setMinimumBeforeGap(null);
                  widgetSlot.x.setMinimumAfterGap(null);
                  widgetSlot.y.setMinimumBeforeGap(null);
                  widgetSlot.y.setMinimumAfterGap(null);
                }

                var extra = widgetLayoutInformation._extraGap;
                if (!!extra) {
                  widgetSlot.x.extraBeforeGap = Math.max(widgetSlot.x.extraBeforeGap, extra.beforeX || 0);
                  widgetSlot.x.extraAfterGap = Math.max(widgetSlot.x.extraAfterGap, extra.afterX || 0);
                  widgetSlot.y.extraBeforeGap = Math.max(widgetSlot.y.extraBeforeGap, extra.beforeY || 0);
                  widgetSlot.y.extraAfterGap = Math.max(widgetSlot.y.extraAfterGap, extra.afterY || 0);
                }
              } else {
                widgetSlot.x.setDisplayed(false);
                widgetSlot.y.setDisplayed(false);
              }
            }
            layoutInformation.setMeasured(this._xspace.adjustMeasure() + layoutInformation.getDecorating().getWidth(true),
              this._yspace.adjustMeasure() + layoutInformation.getDecorating().getHeight(true));
            layoutInformation.setMinimal(
              this._xspace.getMinSize() + layoutInformation.getDecorating().getWidth(true),
              this._yspace.getMinSize() + layoutInformation.getDecorating().getHeight(true));
            layoutInformation.setMaximal(this._xspace.getMaxSize(), this._yspace.getMaxSize());
          } else {
            layoutInformation.setMeasured(
              layoutInformation.getDecorating().getWidth(true),
              layoutInformation.getDecorating().getHeight(true)
            );
            layoutInformation.setMinimal(layoutInformation.getMeasured().getWidth(), layoutInformation.getMeasured().getHeight());
            layoutInformation.setMaximal(layoutInformation.getMeasured().getWidth(), layoutInformation.getMeasured().getHeight());
          }
        },

        /**
         * @inheritDoc
         */
        adjustStretchability: function() {
          var layoutInformation = this._getLayoutInfo();
          if (!!this._registeredWidgets.length) {
            for (var i = 0; i < this._registeredWidgets.length; i++) {
              var widget = this._registeredWidgets[i],
                widgetLayoutEngine = widget.getLayoutEngine(),
                widgetLayoutInformation = widget.getLayoutInformation(),
                owningGrid = widgetLayoutInformation.getOwningGrid(),
                isOwningGridDisplayed = !owningGrid || owningGrid.isVisible(),
                isOwningGridNoContentRender = !owningGrid || owningGrid.getLayoutEngine().willRenderContent(),
                isDisplayed = widget.isVisible() && isOwningGridDisplayed,
                widgetSlot = this._registeredSlots[widget.getUniqueIdentifier()];

              if (isDisplayed && isOwningGridNoContentRender && this.willRenderContent()) {

                var hintSize = widgetLayoutInformation.getPreferred();
                widgetSlot.x.setHintSize(hintSize.getWidth());
                widgetSlot.y.setHintSize(hintSize.getHeight());
                if (widgetLayoutEngine.isXStretched()) {
                  widgetSlot.x.setStretchable(true);
                  layoutInformation.addChildrenStretchX(widgetLayoutInformation);
                }
                if (widgetLayoutEngine.isYStretched()) {
                  widgetSlot.y.setStretchable(true);
                  layoutInformation.addChildrenStretchY(widgetLayoutInformation);
                }
                widgetSlot.x.setOpportunisticStretchable(widgetLayoutInformation.getStretched().getOpportunisticX());
                widgetSlot.y.setOpportunisticStretchable(widgetLayoutInformation.getStretched().getOpportunisticY());
              }
            }
            this._xspace.adjustStretchability();
            this._yspace.adjustStretchability();
          }
          layoutInformation.setPreferred(this._xspace.getHintSize(), this._yspace.getHintSize());
        },

        /**
         * @inheritDoc
         */
        prepareApplyLayout: function() {
          var layoutInfo = this._widget.getLayoutInformation();
          var size = layoutInfo.getMeasured();
          var availableSize = layoutInfo.getAvailable().clone(true);
          var minimalSize = layoutInfo.getMinimal();
          if (minimalSize.getWidth() > availableSize.getWidth()) {
            availableSize.setWidth(minimalSize.getWidth());
          }
          if (minimalSize.getHeight() > availableSize.getHeight()) {
            availableSize.setHeight(minimalSize.getHeight());
          }
          var diffSize = availableSize.minus(size);
          if (diffSize.getWidth() >= 0) {
            var children = this._widget.getChildren() && this._widget.getChildren().filter(function(item) {
              return item && item.isHidden && !item.isHidden();
            });
            this._xspace.setStretchable(true);
            if (layoutInfo.getPreferred().hasWidth() || (children.length === 1 && (children[0] instanceof cls.VBoxWidget))) {
              this._xspace.doStretch(diffSize.getWidth());
            }
          } else {
            if (layoutInfo.getPreferred().hasWidth()) {
              this._xspace.doShrink(diffSize.getWidth());
            }
          }
          if (diffSize.getHeight() >= 0) {
            this._yspace.setStretchable(true);
            if (layoutInfo.getPreferred().hasHeight()) {
              this._yspace.doStretch(diffSize.getHeight());
            }
          } else {
            if (layoutInfo.getPreferred().hasHeight()) {
              this._yspace.doShrink(diffSize.getHeight());
            }
          }

          var hasGridChildrenInParentChildren = this._widget.getChildren() && this._widget.getChildren().filter(function(item) {
            return item && item.isHidden && !item.isHidden() && item.isGridChildrenInParent && item.isGridChildrenInParent();
          }).length;
          for (var i = 0; i < this._registeredWidgets.length; i++) {
            var widget = this._registeredWidgets[i];
            var slot = this._registeredSlots[widget.getUniqueIdentifier()];
            var widgetLayoutInformation = this._getLayoutInfo(widget);
            widgetLayoutInformation.setAvailable(
              this._xspace.adjustAvailableMeasure(slot.x),
              this._yspace.adjustAvailableMeasure(slot.y)
            );
            widgetLayoutInformation.setAllocated(widgetLayoutInformation.getAvailable().getWidth(), widgetLayoutInformation
              .getAvailable()
              .getHeight());
            var isChildOfGridWithGridChildrenInParent = !(!widget.isGridChildrenInParent || widget.isGridChildrenInParent()) &&
              !!hasGridChildrenInParentChildren;
            widgetLayoutInformation.getHostElement()
              .toggleClass("gl_gridElementHidden", !slot.x.displayed)
              .toggleClass("g_gridChildrenInParent", !!(widget.isGridChildrenInParent && widget.isGridChildrenInParent()))
              .toggleClass("g_gridChildrenInParentChild", !!widgetLayoutInformation.getOwningGrid())
              .toggleClass("g_decoratingElement", !!widgetLayoutInformation._extraGap)
              .toggleClass("g_childOfGridWithGridChildrenInParent", isChildOfGridWithGridChildrenInParent);
          }
          if (!this._widget._isGridChildrenInParent) {
            layoutInfo.setAllocated(
              this._xspace.getCalculatedSize() + layoutInfo.getDecorating().getWidth(true),
              this._yspace.getCalculatedSize() + layoutInfo.getDecorating().getHeight(true)
            );
          }
          this._styleRules[".g_measured #w_" + this._widget.getUniqueIdentifier() + ".g_measureable"] = {
            "min-height": layoutInfo.getAllocated().getHeight() + "px",
            "min-width": layoutInfo.getAllocated().getWidth() + "px"
          };
        },

        /**
         * @inheritDoc
         */
        applyLayout: function() {
          var prefix = ".gl_" + this._widget.getUniqueIdentifier() + "_";
          this._xspace.applyStyles(this._styleRules, prefix);
          this._yspace.applyStyles(this._styleRules, prefix);
          context.styler.appendStyleSheet(this._styleRules, this._styleSheetId, true, this.getLayoutSheetId());
        }
      };
    });
  });
;
"use strict";

modulum('GridLayoutEngineX',
  function(context, cls) {
    /**
     * @class GridLayoutEngineX
     * @memberOf classes
     */
    cls.GridLayoutEngineX = context.oo.Class(
      /** @lends classes.GridLayoutEngineX.prototype */
      {
        __name: "GridLayoutEngineX",
        /**
         * @type {classes.WidgetBase}
         */
        _widget: null,

        /**
         * @type classes.GridDimensionManager
         */
        dimensionManager: null,

        /**
         *
         * @param {classes.WidgetBase} widget
         */
        constructor: function(widget) {
          this._widget = widget;
          this.dimensionManager = new cls.GridDimensionManager(true);
        },
        destroy: function() {
          this.dimensionManager.destroy();
          this.dimensionManager = null;
          this._widget = null;
        },

        /**
         *
         * @param {classes.GridDimensionSlot} slot
         * @returns {classes.GridDimensionSlot} the same slot
         */
        registerSlot: function(slot) {
          this.dimensionManager.addSlot(slot);
          return slot;
        },

        /**
         *
         * @param {classes.GridDimensionSlot} slot
         */
        unregisterSlot: function(slot) {
          return this.dimensionManager.removeSlot(slot);
        },

        setStretchable: function(stretchable) {
          this.dimensionManager.setStretchable(stretchable);
        },

        /**
         *
         * @param {number} widthToDistribute
         * @returns {boolean}
         */
        doStretch: function(widthToDistribute) {
          return this.dimensionManager.updateBonusSize(widthToDistribute);
        },

        /**
         *
         * @param {number} widthToRemove
         * @returns {boolean}
         */
        doShrink: function(widthToRemove) {
          return this.dimensionManager.updateMalusSize(widthToRemove);
        },

        /**
         *
         * @returns {number} the calculated size
         */
        adjustMeasure: function() {
          this.dimensionManager.updateGaps();
          this.dimensionManager.updateIntrinsicSizes();
          return this.dimensionManager.getCalculatedSize();
        },

        adjustStretchability: function() {
          this.dimensionManager.updateStretchability();
        },

        getHintSize: function() {
          return this.dimensionManager.getHintSize(null, null, true, true);
        },

        getMaxSize: function() {
          return this.dimensionManager.getMaxSize(null, null, true, true);
        },
        getMinSize: function() {
          return this.dimensionManager.getMinSize(null, null, true, true);
        },

        getCalculatedSize: function() {
          return this.dimensionManager.getCalculatedSize();
        },
        /**
         *
         * @param {classes.GridDimensionSlot} slot
         */
        adjustAvailableMeasure: function(slot) {
          return this.dimensionManager.getCalculatedSize(slot.getPosition(), slot.getLastPosition(), false, false);
        },

        applyStyles: function(styleRules, prefix) {
          var rendering = this.dimensionManager.render();
          this.applyRegularStyles(rendering, styleRules, prefix);
        },

        applyRegularStyles: function(rendering, styleRules, prefix) {
          for (var regularIndex = 0; regularIndex < rendering.regularPositions.length; regularIndex++) {
            var position = rendering.regularPositions[regularIndex];
            var positionInfo = rendering.regular[position];

            var pxPos = cls.Size.cachedPxImportant(positionInfo.position);
            var pxPosWithGap = cls.Size.cachedPxImportant(positionInfo.position + positionInfo.beforeGap);

            var selector = prefix + "x_" + position;
            var selectorGrid = prefix + "x_" + position + ".g_gridChildrenInParent";
            var selectorGridChildOf = prefix + "x_" + position + ".g_childOfGridWithGridChildrenInParent";
            var selectorElem = prefix + "x_" + position + ".g_decoratingElement";
            var selectorGridChild = prefix + "x_" + position + ".g_gridChildrenInParentChild";

            styleRules[selector] = {};
            styleRules[selectorGrid] = {};
            styleRules[selectorElem] = {};
            styleRules[selectorGridChild] = {};
            styleRules[selectorGridChildOf] = {};
            styleRules[selector][this._widget.getStart()] = pxPos;
            styleRules[selectorGrid][this._widget.getStart()] = pxPos;
            styleRules[selectorElem][this._widget.getStart()] = pxPosWithGap;
            styleRules[selectorGridChild][this._widget.getStart()] = pxPosWithGap;
            styleRules[selectorGridChildOf][this._widget.getStart()] = pxPos;

            for (var regularLengthIndex = 0; regularLengthIndex < positionInfo.regularLengths.length; regularLengthIndex++) {
              var length = positionInfo.regularLengths[regularLengthIndex];
              var size = positionInfo.lengths[length];
              styleRules[prefix + "w_" + position + "_" + length] = {
                width: cls.Size.cachedPxImportant(size)
              };
              styleRules[prefix + "w_" + position + "_" + length + ".g_gridChildrenInParent"] = {
                width: cls.Size.cachedPxImportant(positionInfo.lengthsWithGaps[length])
              };
              styleRules[prefix + "w_" + position + "_" + length + ".g_childOfGridWithGridChildrenInParent"] = {
                width: cls.Size.cachedPxImportant(positionInfo.lengthsWithGaps[length])
              };
              styleRules[prefix + "w_" + position + "_" + length + ".g_decoratingElement"] = {
                width: cls.Size.cachedPxImportant(positionInfo.lengthsWithGaps[length])
              };
              styleRules[prefix + "w_" + position + "_" + length + ".g_gridChildrenInParentChild"] = {
                width: cls.Size.cachedPxImportant(positionInfo.lengths[length])
              };
            }
          }
        }
      });
  });
;
"use strict";

modulum('GridLayoutEngineY',
  function(context, cls) {
    /**
     * @class GridLayoutEngineY
     * @memberOf classes
     */
    cls.GridLayoutEngineY = context.oo.Class(
      /** @lends classes.GridLayoutEngineY.prototype */
      {
        __name: "GridLayoutEngineY",
        /**
         * @type {classes.WidgetBase}
         */
        _widget: null,

        /**
         * @type classes.GridDimensionManager
         */
        dimensionManager: null,

        /**
         *
         * @param {classes.WidgetBase} widget
         */
        constructor: function(widget) {
          this._widget = widget;
          this.dimensionManager = new cls.GridDimensionManager();
        },
        destroy: function() {
          this.dimensionManager.destroy();
          this.dimensionManager = null;
          this._widget = null;
        },

        /**
         *
         * @param {classes.GridDimensionSlot} slot
         * @returns {classes.GridDimensionSlot} the same slot
         */
        registerSlot: function(slot) {
          this.dimensionManager.addSlot(slot);
          return slot;
        },

        /**
         *
         * @param {classes.GridDimensionSlot} slot
         */
        unregisterSlot: function(slot) {
          return this.dimensionManager.removeSlot(slot);
        },

        setStretchable: function(stretchable) {
          this.dimensionManager.setStretchable(stretchable);
        },

        /**
         *
         * @param {number} heightToDistribute
         * @returns {boolean}
         */
        doStretch: function(heightToDistribute) {
          return this.dimensionManager.updateBonusSize(heightToDistribute);
        },

        /**
         *
         * @param {number} heightToRemove
         * @returns {boolean}
         */
        doShrink: function(heightToRemove) {
          return this.dimensionManager.updateMalusSize(heightToRemove);
        },

        /**
         *
         * @returns {number} the calculated size
         */
        adjustMeasure: function() {
          this.dimensionManager.updateGaps();
          this.dimensionManager.updateIntrinsicSizes();
          return this.dimensionManager.getCalculatedSize();
        },

        adjustStretchability: function() {
          this.dimensionManager.updateStretchability();
        },

        getHintSize: function() {
          return this.dimensionManager.getHintSize(null, null, true, true);
        },

        getMaxSize: function() {
          return this.dimensionManager.getMaxSize(null, null, true, true);
        },
        getMinSize: function() {
          return this.dimensionManager.getMinSize(null, null, true, true);
        },

        getCalculatedSize: function() {
          return this.dimensionManager.getCalculatedSize();
        },

        /**
         *
         * @param {classes.GridDimensionSlot} slot
         */
        adjustAvailableMeasure: function(slot) {
          return this.dimensionManager.getCalculatedSize(slot.getPosition(), slot.getLastPosition(), false, false);
        },

        applyStyles: function(styleRules, prefix) {
          var rendering = this.dimensionManager.render();
          this.applyRegularStyles(rendering, styleRules, prefix);
        },

        applyRegularStyles: function(rendering, styleRules, prefix) {
          for (var regularIndex = 0; regularIndex < rendering.regularPositions.length; regularIndex++) {
            var position = rendering.regularPositions[regularIndex];
            var positionInfo = rendering.regular[position];
            styleRules[prefix + "y_" + position] = {
              top: cls.Size.cachedPxImportant(positionInfo.position)
            };
            styleRules[prefix + "y_" + position + ".g_gridChildrenInParent"] = {
              top: cls.Size.cachedPxImportant(positionInfo.position)
            };
            styleRules[prefix + "y_" + position + ".g_childOfGridWithGridChildrenInParent"] = {
              top: cls.Size.cachedPxImportant(positionInfo.position)
            };
            styleRules[prefix + "y_" + position + ".g_decoratingElement"] = {
              top: cls.Size.cachedPxImportant(positionInfo.position)
            };
            styleRules[prefix + "y_" + position + ".g_gridChildrenInParentChild"] = {
              top: cls.Size.cachedPxImportant(positionInfo.position + positionInfo.beforeGap)
            };
            for (var regularLengthIndex = 0; regularLengthIndex < positionInfo.regularLengths.length; regularLengthIndex++) {
              var length = positionInfo.regularLengths[regularLengthIndex];
              var size = positionInfo.lengths[length];
              styleRules[prefix + "h_" + position + "_" + length] = {
                height: cls.Size.cachedPxImportant(size)
              };
              styleRules[prefix + "h_" + position + "_" + length + ".g_gridChildrenInParent"] = {
                height: cls.Size.cachedPxImportant(positionInfo.lengthsWithGaps[length])
              };
              styleRules[prefix + "h_" + position + "_" + length + ".g_childOfGridWithGridChildrenInParent"] = {
                height: cls.Size.cachedPxImportant(positionInfo.lengthsWithGaps[length])
              };
              styleRules[prefix + "h_" + position + "_" + length + ".g_decoratingElement"] = {
                height: cls.Size.cachedPxImportant(positionInfo.lengthsWithGaps[length])
              };
              styleRules[prefix + "h_" + position + "_" + length + ".g_gridChildrenInParentChild"] = {
                height: cls.Size.cachedPxImportant(positionInfo.lengths[length])
              };
            }
          }
        }
      });
  });
;
"use strict";

modulum('GroupLayoutEngine', ['GridLayoutEngine'],
  function(context, cls) {
    /**
     * @class GroupLayoutEngine
     * @memberOf classes
     * @extends classes.GridLayoutEngine
     */
    cls.GroupLayoutEngine = context.oo.Class(cls.GridLayoutEngine, function($super) {
      return /** @lends classes.GroupLayoutEngine.prototype */ {
        __name: "GroupLayoutEngine",

        _titleWidth: 0,

        /**
         * @inheritDoc
         */
        measure: function(invalidation) {
          $super.measure.call(this);
          if (this._widget._title.getLayoutEngine().isInvalidatedMeasure(invalidation)) {
            this._titleWidth = this._widget._title.getElement().clientWidth + this._getLayoutInfo().getDecorating().getWidth(true);
          }
        },

        /**
         * @inheritDoc
         */
        adjustMeasure: function() {
          $super.adjustMeasure.call(this);
          if (this.willRenderContent() && this._widget && this._widget.getParentWidget() &&
            !this._widget.getParentWidget().isInstanceOf(cls.BoxWidget) &&
            this._widget.getParentWidget().getChildren().length === 1) {
            this._getLayoutInfo().setMaximal(null, null);
          }
          if (!this.willRenderContent()) {
            this._getLayoutInfo().setMaximal(
              this._getLayoutInfo().getMeasured().getWidth(true),
              this._getLayoutInfo().getMeasured().getHeight(true)
            );
          }
          var layoutInfo = this._getLayoutInfo();
          var minimal = layoutInfo.getMinimal().getWidth(true);
          layoutInfo.getMinimal().setWidth(Math.max(this._titleWidth, minimal));
        },

        /**
         * @inheritDoc
         */
        adjustStretchability: function() {
          $super.adjustStretchability.call(this);
          var layoutInfo = this._widget.getLayoutInformation();
          layoutInfo.getStretched().setOpportunisticX(true);
          layoutInfo.getStretched().setOpportunisticY(true);
        },

        /**
         * @inheritDoc
         */
        prepareApplyLayout: function() {
          var layoutInfo = this._widget.getLayoutInformation();
          var allocatedW = layoutInfo.getAllocated().getWidth(true);
          var allocatedH = layoutInfo.getAllocated().getHeight(true);
          $super.prepareApplyLayout.call(this);

          if (this.willRenderContent()) {
            var visibleChildren = this.getRenderableChildren().filter(function(item) {
              return item && item.isHidden && !item.isHidden();
            });
            if (visibleChildren.length === 1 && (visibleChildren[0] instanceof cls.VBoxWidget)) {
              visibleChildren[0].getLayoutInformation().getAvailable().setWidth(layoutInfo.getAvailable().getWidth() - layoutInfo.getDecorating()
                .getWidth(true));
            }
          }

          if (!this._widget._isGridChildrenInParent) {
            layoutInfo.setAllocated(
              Math.max(
                Math.min(
                  Math.max(this._xspace.getCalculatedSize() + layoutInfo.getDecorating().getWidth(true), allocatedW),
                  layoutInfo.getAvailable().getWidth(true)
                ),
                layoutInfo.getMinimal().getWidth(true)
              ),
              this.willRenderContent() ?
              Math.max(
                Math.min(
                  Math.max(this._yspace.getCalculatedSize() + layoutInfo.getDecorating().getHeight(true), allocatedH),
                  layoutInfo.getAvailable().getHeight(true)
                ),
                layoutInfo.getMinimal().getHeight(true)
              ) :
              layoutInfo.getMinimal().getHeight(true)
            );
          }

          if (this._widget && this._widget.getParentWidget() && this._widget.getParentWidget().isInstanceOf(cls.FormWidget)) {
            layoutInfo.setAllocated(
              Math.max(
                layoutInfo.getAvailable().getWidth(true),
                layoutInfo.getMinimal().getWidth(true)
              ),
              this.willRenderContent() ?
              Math.max(
                layoutInfo.getAvailable().getHeight(true),
                layoutInfo.getMinimal().getHeight(true)
              ) :
              layoutInfo.getMinimal().getHeight(true)
            );
            this._styleRules[".g_measured #w_" + this._widget.getUniqueIdentifier() + ".g_measureable"] = {
              "height": layoutInfo.getAllocated().getHeight() + "px !important",
              "width": layoutInfo.getAllocated().getWidth() + "px !important"
            };
          }
        },

        /**
         * @inheritDoc
         */
        updateInvalidated: function(invalidation) {
          $super.updateInvalidated.call(this, invalidation);
          this._widget._title.getLayoutEngine().updateInvalidated(invalidation);
        }
      };
    });
  });
;
"use strict";

modulum('ScrollGridLayoutEngine', ['GridLayoutEngine'],
  function(context, cls) {
    /**
     * @class ScrollGridLayoutEngine
     * @memberOf classes
     * @extends classes.GridLayoutEngine
     */
    cls.ScrollGridLayoutEngine = context.oo.Class(cls.GridLayoutEngine, function($super) {
      return /** @lends classes.ScrollGridLayoutEngine.prototype */ {
        __name: "ScrollGridLayoutEngine",
        /**
         * @inheritDoc
         * @constructs
         */
        constructor: function(widget) {
          $super.constructor.call(this, widget);
        },

        /**
         * @inheritDoc
         */
        adjustMeasure: function() {
          $super.adjustMeasure.call(this);
          var layoutInfo = this._getLayoutInfo();
          if (!layoutInfo.lineHeight) {
            layoutInfo.lineHeight = layoutInfo.getMeasured().getHeight();
          }
          layoutInfo.getMinimal().setHeight(layoutInfo.lineHeight + layoutInfo.getDecorating()
            .getHeight(true));
        },

        /**
         * @inheritDoc
         */
        measure: function() {
          $super.measure.call(this);
          var decorating = this._getLayoutInfo().getDecorating();
          decorating.setWidth(decorating.getWidth() + window.scrollBarSize);
        },

        /**
         * @inheritDoc
         */
        prepareApplyLayout: function() {
          $super.prepareApplyLayout.call(this);
          var layoutInfo = this._widget.getLayoutInformation();
          var rules = this._styleRules[".g_measured #w_" + this._widget.getUniqueIdentifier() + ".g_measureable"];
          rules.height = layoutInfo.getAllocated().getHeight() + "px";
          rules.width = layoutInfo.getAllocated().getWidth() + "px";
        }
      };
    });
  });
;
"use strict";

modulum('FolderLayoutInformation', ['EventListener', 'LayoutInformation'],
  function(context, cls) {
    /**
     * Folder layout information
     * This is an advanced class, be careful while using it
     * @class FolderLayoutInformation
     * @memberOf classes
     * @extends classes.LayoutInformation
     * @publicdoc Base
     */
    cls.FolderLayoutInformation = context.oo.Class(cls.LayoutInformation, function($super) {
      return /** @lends classes.FolderLayoutInformation.prototype */ {
        __name: "FolderLayoutInformation",

        /** @type {number} */
        _titlesContainerDeltaWidth: 0,
        /** @type {number} */
        _titlesContainerDeltaHeight: 0,

        /**
         * @inheritDoc
         * @constructs
         */
        constructor: function(widget) {
          $super.constructor.call(this, widget);
        },
        /**
         * @inheritDoc
         */
        reset: function(soft) {
          $super.reset.call(this, soft);
          this._titlesContainerDeltaWidth = 0;
          this._titlesContainerDeltaHeight = 0;
        },

        /**
         * get the difference between folder width and titles container width
         * @returns {number}
         */
        getTitlesContainerDeltaWidth: function() {
          return this._titlesContainerDeltaWidth;
        },
        /**
         * set the difference between folder width and titles container width
         * @param {number} titlesContainerDeltaWidth the width
         */
        setTitlesContainerDeltaWidth: function(titlesContainerDeltaWidth) {
          this._titlesContainerDeltaWidth = titlesContainerDeltaWidth;
        },

        /**
         * get the difference between folder height and titles container height
         * @returns {number}
         */
        getTitlesContainerDeltaHeight: function() {
          return this._titlesContainerDeltaHeight;
        },
        /**
         * get the difference between folder height and titles container height
         * @param {number} titlesContainerDeltaHeight the height
         */
        setTitlesContainerDeltaHeight: function(titlesContainerDeltaHeight) {
          this._titlesContainerDeltaHeight = titlesContainerDeltaHeight;
        }
      };
    });
  });
;
"use strict";

modulum('GridLayoutInformation', ['EventListener'],
  function(context, cls) {
    /**
     * Grid layout information
     * This is an advanced class, be careful while using it
     * @class GridLayoutInformation
     * @memberOf classes
     * @extends classes.EventListener
     * @publicdoc Base
     */
    cls.GridLayoutInformation = context.oo.Class(cls.EventListener, function($super) {
      return /** @lends classes.GridLayoutInformation.prototype */ {
        __name: "GridLayoutInformation",

        _useVirtual: false,

        _gridX: null,
        _gridY: null,
        _gridWidth: null,
        _gridHeight: null,

        _virtualGridX: null,
        _virtualGridY: null,
        _virtualGridWidth: null,
        _virtualGridHeight: null,

        /**
         * @inheritDoc
         * @constructs
         */
        constructor: function() {
          $super.constructor.call(this);
          this.reset();
        },
        /**
         * reset the values for object reuse purpose
         */
        reset: function() {
          this._gridX = 0;
          this._gridY = 0;
          this._gridWidth = 1;
          this._gridHeight = 1;

          this._virtualGridX = 0;
          this._virtualGridY = 0;
          this._virtualGridWidth = 1;
          this._virtualGridHeight = 1;
        },

        isUsingVirtualCoordinates: function() {
          return Boolean(this._useVirtual);
        },
        useVirtualCoordinates: function(useVirtual) {
          useVirtual = Boolean(useVirtual);
          if (this._useVirtual !== useVirtual) {
            this._useVirtual = useVirtual;
            this.invalidateInfos();
          }
        },

        getX: function() {
          return this._useVirtual ? this._virtualGridX : this._gridX;
        },
        getY: function() {
          return this._useVirtual ? this._virtualGridY : this._gridY;
        },
        getWidth: function() {
          return this._useVirtual ? this._virtualGridWidth : this._gridWidth;
        },
        getHeight: function() {
          return this._useVirtual ? this._virtualGridHeight : this._gridHeight;
        },

        getGridX: function() {
          return this._gridX;
        },
        setGridX: function(gridX) {
          if (this._gridX !== gridX) {
            this._gridX = gridX;
            this.invalidateInfos();
          }
        },

        getGridY: function() {
          return this._gridY;
        },
        setGridY: function(gridY) {
          if (this._gridY !== gridY) {
            this._gridY = gridY;
            this.invalidateInfos();
          }
        },

        getGridWidth: function() {
          return this._gridWidth;
        },
        setGridWidth: function(gridWidth) {
          if (this._gridWidth !== gridWidth) {
            this._gridWidth = gridWidth;
            this.invalidateInfos();
          }
        },

        getGridHeight: function() {
          return this._gridHeight;
        },
        setGridHeight: function(gridHeight) {
          if (this._gridHeight !== gridHeight) {
            this._gridHeight = gridHeight;
            this.invalidateInfos();
          }
        },

        getVirtualGridX: function() {
          return this._virtualGridX;
        },
        setVirtualGridX: function(gridX) {
          if (this._virtualGridX !== gridX) {
            this._virtualGridX = gridX;
            this.invalidateInfos();
          }
        },

        getVirtualGridY: function() {
          return this._virtualGridY;
        },
        setVirtualGridY: function(gridY) {
          if (this._virtualGridY !== gridY) {
            this._virtualGridY = gridY;
            this.invalidateInfos();
          }
        },

        getVirtualGridWidth: function() {
          return this._virtualGridWidth;
        },
        setVirtualGridWidth: function(gridWidth) {
          if (this._virtualGridWidth !== gridWidth) {
            this._virtualGridWidth = gridWidth;
            this.invalidateInfos();
          }
        },

        getVirtualGridHeight: function() {
          return this._virtualGridHeight;
        },
        setVirtualGridHeight: function(gridHeight) {
          if (this._virtualGridHeight !== gridHeight) {
            this._virtualGridHeight = gridHeight;
            this.invalidateInfos();
          }
        },

        /**
         * fired when grid information changed
         * @param {Hook} hook the hook
         * @return {HandleRegistration} the handle registration
         */
        onGridLayoutInformationChanged: function(hook) {
          return this.when(context.constants.widgetEvents.layoutInformationChanged, hook);
        },
        /**
         * invalidate information
         */
        invalidateInfos: function() {
          this.emit(context.constants.widgetEvents.layoutInformationChanged);
        }
      };
    });
  });
;
"use strict";

modulum('LayoutInformation', ['EventListener'],
  function(context, cls) {
    /**
     * Layout information
     * This is an advanced class, be careful while using it
     * @class LayoutInformation
     * @memberOf classes
     * @extends classes.EventListener
     * @publicdoc Base
     */
    cls.LayoutInformation = context.oo.Class(cls.EventListener, function($super) {
      return /** @lends classes.LayoutInformation.prototype */ {
        __name: "LayoutInformation",
        /**
         * the widget
         * @type {classes.WidgetBase}
         */
        _widget: null,

        /**
         * @type {classes.RawLayoutInformation}
         */
        _rawInformation: null,

        /**
         * @type {classes.GridLayoutInformation}
         */
        _gridInformation: null,

        _isAutomaticStack: false,
        _isChildOfAutomaticStack: false,

        /**
         * Has a grid width set in the AUI
         * @type {boolean}
         */
        _hasRawGridWidth: false,
        /**
         * Initial size preferred by design
         * @type {classes.Size}
         */
        _preferred: null,
        /**
         * is the element sizable
         * @type boolean
         */
        _sizable: true,
        /**
         * Size hint //TODO this value should never be change by any LayoutEngine as it comes from VM
         * @type {classes.Size}
         */
        _sizeHint: null,
        /**
         * measured char size
         * @type {classes.CharSize}
         */
        _charSize: null,
        /**
         * Measure in current state
         * @type {classes.Size}
         */
        _measured: null,
        /**
         * Raw element measure
         * @type {classes.Size}
         */
        _rawMeasure: null,
        /**
         * Till which size i can shrink
         * @type {classes.Size}
         */
        _minimal: null,
        /**
         * Till which size i can grow
         * @type {classes.Size}
         */
        _maximal: null,
        /**
         * The space i will effectively take
         * @type {classes.Size}
         */
        _allocated: null,
        /**
         * The space my host reserved for me
         * @type {classes.Size}
         */
        _available: null,

        /**
         * widget overflow behavior when container is not big enough
         * @type {boolean}
         */
        _willOverflowContainerIfNeeded: false,

        /**
         * In case of a container, the space reserved for decoration(borders, title, ...)
         * @type {classes.Size}
         */
        _decorating: null,
        /**
         * In case of a container, the offset of the containerElement
         * @type {classes.Size}
         */
        _decoratingOffset: null,
        /**
         * x and y stretchability
         * @type {classes.Stretch}
         */
        _stretched: null,
        /**
         * list of children info that stretches x
         * @type {Array<classes.LayoutInformation>}
         */
        _childrenStretchX: null,
        /**
         * list of children info that stretches y
         * @type {Array<classes.LayoutInformation>}
         */
        _childrenStretchY: null,
        /**
         * classes applied to the host element
         * @type {?{x:?string, y:?string, width:?string, height:?string}}
         */
        _classes: null,
        /**
         * the host element
         * @type {HTMLElement}
         */
        _hostElement: null,
        /**
         * the size policy config
         * @type {classes.SizePolicyConfig}
         */
        _sizePolicyConfig: null,
        _needMeasure: true,
        _needValuedMeasure: false,
        _initialMeasure: false,
        /**
         * owning grid if any
         * @type {classes.WidgetGridLayoutBase}
         */
        _owningGrid: null,

        hasBeenFixed: false,

        forcedMinimalWidth: 1,
        forcedMinimalHeight: 1,

        /**
         * If widget content contains only a single line
         * @type {boolean}
         */
        _singleLineContentOnly: false,

        /** Number of cols reserved for decoration (done by VM)
         * @type {number}
         */
        _reservedDecorationSpace: 0,

        /**
         * @inheritDoc
         * @constructs
         * @param {classes.WidgetBase} widget Owner
         */
        constructor: function(widget) {
          $super.constructor.call(this);
          this._rawInformation = new cls.RawLayoutInformation();
          this._gridInformation = new cls.GridLayoutInformation();
          this._widget = widget;
          this._childrenStretchX = [];
          this._childrenStretchY = [];
          this._sizeHint = new cls.Size();
          this._charSize = new cls.CharSize();
          this._preferred = new cls.Size();
          this._measured = new cls.Size();
          this._rawMeasure = new cls.Size();
          this._minimal = new cls.Size();
          this._maximal = new cls.Size({
            undefinedValue: cls.Size.maximal
          });
          this._allocated = new cls.Size();
          this._available = new cls.Size();
          this._decorating = new cls.Size();
          this._decoratingOffset = new cls.Size();
          this._stretched = new cls.Stretch();
          this._sizePolicyConfig = new cls.SizePolicyConfig();
          this._classes = {
            x: null,
            y: null,
            width: null,
            height: null
          };
          this.reset();
        },
        /**
         * @inheritDoc
         */
        destroy: function() {
          this._widget = null;
          this._rawInformation.destroy();
          this._rawInformation = null;
          this._gridInformation.destroy();
          this._gridInformation = null;
          $super.destroy.call(this);
        },
        /**
         * reset the values for object reuse purpose
         * @param {boolean} [soft] true to keep information given by the VM
         */
        reset: function(soft) {
          if (!soft) {
            this._rawInformation.reset();
            this._gridInformation.reset();

            this._classes.x = null;
            this._classes.y = null;
            this._classes.width = null;
            this._classes.height = null;

            this._stretched.reset();
            this._sizePolicyConfig.reset();

            this.resetChildrenStretch();

            this._sizeHint.reset();
          }

          this._initialMeasure = false;
          this.hasBeenFixed = false;

          this._charSize.reset();
          this._preferred.reset();
          this._measured.reset();
          this._rawMeasure.reset();
          this._minimal.reset();
          this._maximal.reset();
          this._allocated.reset();
          this._available.reset();
          this._decorating.reset();
          this._decoratingOffset.reset();
        },

        /**
         *
         * @return {classes.RawLayoutInformation}
         */
        getRawInformation: function() {
          return this._rawInformation;
        },
        /**
         * returns true if the layout engine must measure element
         * @return {boolean} true if need measure
         */
        needMeasure: function() {
          if (this._needMeasure || this._needValuedMeasure) {
            this._needMeasure = false;
            this._needValuedMeasure = false;
            return true;
          }
          return !this._measured.hasWidth() && !this._measured.hasHeight();
        },
        /**
         * get the owning grid
         * @return {classes.WidgetGridLayoutBase} the owning grid
         */
        getOwningGrid: function() {
          return this._owningGrid;
        },
        /**
         * set the owning grid
         * @param {classes.WidgetGridLayoutBase} grid the grid
         */
        setOwningGrid: function(grid) {
          this._owningGrid = grid;
        },
        /**
         * force measure invalidation
         */
        invalidateMeasure: function() {
          this._needMeasure = true;
        },
        /**
         * force initial measure invalidation (for size policy initial purpose)
         * @param {boolean} hadValue true if had value once
         * @param {boolean} hasValue true if has currently a value
         */
        invalidateInitialMeasure: function(hadValue, hasValue) {
          if (this.getSizePolicyConfig().isDynamic()) {
            this._needValuedMeasure = true;
            this._initialMeasure = true;
          } else if (this.getSizePolicyConfig().isFixed()) {
            this._needValuedMeasure = false;
          } else if (!this._initialMeasure) {
            this._needValuedMeasure = true;
            if (!hadValue && hasValue) {
              this._initialMeasure = true;
            }
          }
        },
        /**
         * Get the raw element measure
         * @returns {classes.Size} the raw element measure
         */
        getRawMeasure: function() {
          return this._rawMeasure;
        },
        /**
         * Set the raw element measure
         * @param {number} width the width
         * @param {number} height the height
         */
        setRawMeasure: function(width, height) {
          this._rawMeasure.setWidth(width);
          this._rawMeasure.setHeight(height);
        },
        /**
         * Get the measured size
         * @returns {classes.Size} the measured size
         */
        getMeasured: function() {
          return this._measured;
        },
        /**
         * Set the measured size
         * @param {number} width the width
         * @param {number} height the height
         */
        setMeasured: function(width, height) {
          this._measured.setWidth(width);
          this._measured.setHeight(height);
        },
        /**
         * Get the minimal size
         * @returns {classes.Size} the minimal size
         */
        getMinimal: function(containerOnly) {
          if (containerOnly) {
            return this._minimal.minus(this._decorating);
          } else {
            return this._minimal;
          }
        },
        /**
         * Set the minimal size
         * @param {number} width the width
         * @param {number} height the height
         */
        setMinimal: function(width, height) {
          this._minimal.setWidth(width);
          this._minimal.setHeight(height);
        },
        /**
         * Get the maximal size
         * @returns {classes.Size} the maximal size
         */
        getMaximal: function() {
          return this._maximal;
        },
        /**
         * Set the maximal size
         * @param {number} width the width
         * @param {number} height the height
         */
        setMaximal: function(width, height) {
          this._maximal.setWidth(width);
          this._maximal.setHeight(height);
        },
        /**
         * Get the allocated size
         * @returns {classes.Size} the allocated size
         */
        getAllocated: function() {
          return this._allocated;
        },
        /**
         * Set the allocated size
         * @param {number} width the width
         * @param {number} height the height
         */
        setAllocated: function(width, height) {
          this._allocated.setWidth(width);
          this._allocated.setHeight(height);
        },
        /**
         * Get the decorating size
         * @returns {classes.Size} the decorating size
         */
        getDecorating: function() {
          return this._decorating;
        },
        /**
         * Set the decorating size
         * @param {number} width the width
         * @param {number} height the height
         */
        setDecorating: function(width, height) {
          this._decorating.setWidth(width);
          this._decorating.setHeight(height);
        },
        /**
         * Get the decorating offset
         * @returns {classes.Size} the decorating offset
         */
        getDecoratingOffset: function() {
          return this._decoratingOffset;
        },
        /**
         * Set the decorating offset
         * @param {number} width the width
         * @param {number} height the height
         */
        setDecoratingOffset: function(width, height) {
          this._decoratingOffset.setWidth(width);
          this._decoratingOffset.setHeight(height);
        },
        /**
         * Get the available size
         * @returns {classes.Size} the available size
         */
        getAvailable: function(containerOnly) {
          if (containerOnly) {
            return this._available.minus(this._decorating);
          } else {
            return this._available;
          }
        },
        /**
         * Set the available size
         * @param {number} width the width
         * @param {number} height the height
         */
        setAvailable: function(width, height) {
          this._available.setWidth(width);
          this._available.setHeight(height);
        },

        /**
         * get whether or not the widget would overflow its container if this one is not big enough
         * @return {boolean} true if the widget would overflow its container if this one is not big enough
         */
        willOverflowContainerIfNeeded: function() {
          /* // sample test of using context.DebugService.count
             // todo : see if feature is interesting
          if (this._willOverflowContainerIfNeeded) {
            context.DebugService.count("willOverflowContainerIfNeeded");
          }
          */
          return this._willOverflowContainerIfNeeded;
        },

        /**
         * set whether or not the widget would overflow its container if this one is not big enough
         * @param {boolean} willOverflowContainerIfNeeded - true to let the widget overflow its container if this one is not big enough
         */
        wouldOverflowContainerIfNeeded: function(willOverflowContainerIfNeeded) {
          this._willOverflowContainerIfNeeded = willOverflowContainerIfNeeded;
        },
        /**
         * Get the preferred size
         * @returns {classes.Size} the prefered size
         */
        getPreferred: function() {
          return this._preferred;
        },
        /**
         * Set the prefered size
         * @param {number} width the width
         * @param {number} height the height
         */
        setPreferred: function(width, height) {
          this._preferred.setWidth(width);
          this._preferred.setHeight(height);
        },

        /**
         * is the element sizable
         * @returns {boolean} true if it is sizable
         */
        isSizable: function() {
          return this._sizable;
        },

        /**
         * Set if the element is sizable
         * @param {boolean} sizable true if it is sizable
         */
        setSizable: function(sizable) {
          this._sizable = sizable;
        },

        /**
         * get the char size
         * @returns {classes.CharSize} the char size
         */
        getCharSize: function() {
          return this._charSize;
        },

        /**
         * Set the char size
         * @param {number} widthM witth of M
         * @param {number} width0 width of 0
         * @param {number} height height of M
         */
        setCharSize: function(widthM, width0, height) {
          this._charSize.setWidthM(widthM);
          this._charSize.setWidth0(width0);
          this._charSize.setHeight(height);
          this.updatePreferred();
        },

        /**
         * get the size hint
         * @returns {classes.Size} the size hint
         */
        getSizeHint: function() {
          return this._sizeHint;
        },

        /**
         * Set the size hint
         * @param {number} width the width
         * @param {number} height the height
         */
        setSizeHint: function(width, height) {
          this._sizeHint.setWidth(width);
          this._sizeHint.setHeight(height);
          this.updatePreferred();
        },

        /**
         * update prefered from size hint and char size
         */
        updatePreferred: function() {
          this._preferred.setWidth(cls.CharSize.translate(this._sizeHint.getWidth(true), this._charSize.getWidthM(), this._charSize
            .getWidth0()));
          this._preferred.setHeight(cls.Size.translate(this._sizeHint.getHeight(true), this._charSize.getHeight()));
        },

        /**
         * get the size policy config
         * @returns {classes.SizePolicyConfig} the size policy config
         */
        getSizePolicyConfig: function() {
          return this._sizePolicyConfig;
        },
        /**
         * get the current size policy
         * @returns {classes.SizePolicy} the current size policy
         */
        getCurrentSizePolicy: function() {
          return this._sizePolicyConfig.getMode();
        },
        /**
         * set the size policy mode
         * @param {string} policy the size policy mode
         */
        setSizePolicyMode: function(policy) {
          this._sizePolicyConfig.setMode(policy);
        },
        /**
         * get the x position in grid
         * @returns {number} the x position in grid
         */
        getGridX: function() {
          var delta = 0;
          if (this._owningGrid && !this.isInAutomaticStack()) {
            delta = this._owningGrid.getLayoutInformation().getGridX() || 0;
          }
          return this._gridInformation.getX() + delta;
        },

        /**
         * set the x position in grid
         * @param {number} x the x position in grid
         * @param {?boolean} [noEvent] true to avoid sending {context.constants.widgetEvents.gridInfoChanged}
         * @return {?boolean} true if the value has been changed
         */
        setGridX: function(x, noEvent) {
          if (x !== this._gridInformation.getGridX()) {
            this._gridInformation.setGridX(x || 0);
            this.setGridXClass(this.getPositionClassName("x", this.getGridX()));
            this.setGridWidthClass(this.getLengthClassName("w", this.getGridX(), this.getGridWidth()));
            if (!noEvent) {
              this.emit(context.constants.widgetEvents.gridInfoChanged);
            }
            return true;
          }
        },
        /**
         * get the y position in grid
         * @returns {number} the y position in grid
         */
        getGridY: function() {
          var delta = 0;
          if (this._owningGrid && !this.isInAutomaticStack()) {
            delta = this._owningGrid.getLayoutInformation().getGridY() || 0;
          }
          return this._gridInformation.getY() + delta;
        },
        /**
         * set the y position in grid
         * @param {number} y the y position in grid
         * @param {?boolean} [noEvent] true to avoid sending {context.constants.widgetEvents.gridInfoChanged}
         * @return {?boolean} true if the value has been changed
         */
        setGridY: function(y, noEvent) {
          if (y !== this._gridInformation.getGridY()) {
            this._gridInformation.setGridY(y || 0);
            this.setGridYClass(this.getPositionClassName("y", this.getGridY()));
            this.setGridHeightClass(this.getLengthClassName("h", this.getGridY(), this.getGridHeight()));
            if (!noEvent) {
              this.emit(context.constants.widgetEvents.gridInfoChanged);
            }
            return true;
          }
        },

        setVirtualGridY: function(y, no) {
          this._gridInformation.setVirtualGridY(y);
          this._gridInformation.setVirtualGridHeight(this._gridInformation.getGridHeight());
          this.setGridXClass(this.getPositionClassName("x", this.getGridX()));
          this.setGridWidthClass(this.getLengthClassName("w", this.getGridX(), this.getGridWidth()));
          this.setGridYClass(this.getPositionClassName("y", this.getGridY()));
          this.setGridHeightClass(this.getLengthClassName("h", this.getGridY(), this.getGridHeight()));
          if (!no) {
            this.emit(context.constants.widgetEvents.gridInfoChanged);
          }
          return true;
        },
        /**
         * get the width in grid
         * @returns {number} the width in grid
         */
        getGridWidth: function() {
          return this._gridInformation.getWidth();
        },

        /**
         * set the width in grid
         * @param {number} width the width in grid
         * @param {?boolean} [noEvent] true to avoid sending {context.constants.widgetEvents.gridInfoChanged}
         * @return {?boolean} true if the value has been changed
         */
        setGridWidth: function(width, noEvent) {
          this._hasRawGridWidth = !!width;
          if (width !== this._gridInformation.getGridWidth()) {
            this._gridInformation.setGridWidth(width || (width === 0 ? 0 : 1));
            this.setGridWidthClass(this.getLengthClassName("w", this.getGridX(), this.getGridWidth()));
            if (!noEvent) {
              this.emit(context.constants.widgetEvents.gridInfoChanged);
            }
            return true;
          }
        },

        /**
         * Returns if layout has a grid width in the AUI (generally it should mean thant widget is in a grid)
         * @returns {boolean} true is has a grid width in the AUI
         */
        hasRawGridWidth: function() {
          return this._hasRawGridWidth;
        },

        /**
         * get the height in grid
         * @returns {number} the height in grid
         */
        getGridHeight: function() {
          return this._gridInformation.getHeight();
        },
        /**
         * set the height in grid
         * @param {number} height the height in grid
         * @param {?boolean} [noEvent] true to avoid sending {context.constants.widgetEvents.gridInfoChanged}
         * @return {?boolean} true if the value has been changed
         */
        setGridHeight: function(height, noEvent) {
          if (height !== this._gridInformation.getGridHeight()) {
            this._gridInformation.setGridHeight(height || (height === 0 ? 0 : 1));
            this.setGridHeightClass(this.getLengthClassName("h", this.getGridY(), this.getGridHeight()));
            if (!noEvent) {
              this.emit(context.constants.widgetEvents.gridInfoChanged);
            }
            return true;
          }
        },
        /**
         * get the host element
         * @returns {HTMLElement} the host element
         */
        getHostElement: function() {
          return this._hostElement;
        },
        /**
         * set the host element
         * @param {HTMLElement} hostElement the host element
         */
        setHostElement: function(hostElement) {
          this._hostElement = hostElement;
          this.setGridXClass(this.getPositionClassName("x", this.getGridX()));
          this.setGridYClass(this.getPositionClassName("y", this.getGridY()));
          this.setGridWidthClass(this.getLengthClassName("w", this.getGridX(), this.getGridWidth()));
          this.setGridHeightClass(this.getLengthClassName("h", this.getGridY(), this.getGridHeight()));
        },
        /**
         * set the grid x class on host element
         * @param {string} className the classname
         */
        setGridXClass: function(className) {
          if (this._classes.x) {
            if (this._hostElement) {
              this._hostElement.removeClass(this._classes.x);
            }
          }
          this._classes.x = className;
          if (this.isGridItem()) {
            if (this._hostElement) {
              this._hostElement.addClass(this._classes.x);
            }
          }
        },
        /**
         * set the grid y class on host element
         * @param {string} className the classname
         */
        setGridYClass: function(className) {
          if (this._classes.y) {
            if (this._hostElement) {
              this._hostElement.removeClass(this._classes.y);
            }
          }
          this._classes.y = className;
          if (this.isGridItem()) {
            if (this._hostElement) {
              this._hostElement.addClass(this._classes.y);
            }
          }
        },
        /**
         * set the grid width class on host element
         * @param {string} className the classname
         */
        setGridWidthClass: function(className) {
          if (this._classes.width) {
            if (this._hostElement) {
              this._hostElement.removeClass(this._classes.width);
            }
          }
          this._classes.width = className;
          if (this.isGridItem()) {
            if (this._hostElement) {
              this._hostElement.addClass(this._classes.width);
            }
          }
        },
        /**
         * set the grid height class on host element
         * @param {string} className the classname
         */
        setGridHeightClass: function(className) {
          if (this._classes.height) {
            if (this._hostElement) {
              this._hostElement.removeClass(this._classes.height);
            }
          }
          this._classes.height = className;
          if (this.isGridItem()) {
            if (this._hostElement) {
              this._hostElement.addClass(this._classes.height);
            }
          }
        },
        /**
         * test if item is in a grid layout
         * @todo check the test
         * @return {boolean} true if is a grid item
         */
        isGridItem: function() {
          return !!this._widget.getParentWidget() && (this._widget.getParentWidget().getLayoutEngine() instanceof cls.GridLayoutEngine ||
            this._widget.getParentWidget().getLayoutEngine() instanceof cls.ScrollGridLayoutEngine);
        },

        /**
         * get the position classname
         * @param {string} way the wy (x/y)
         * @param {number} pos the position
         * @return {?string} the classname
         */
        getPositionClassName: function(way, pos) {
          if (this._widget.getParentWidget()) {
            var uuid = this._widget.getParentWidget().getUniqueIdentifier();
            return ["gl_", uuid, "_", way, "_", pos].join("");
          } else {
            return null;
          }
        },
        /**
         * get the position classname
         * @param {string} way the wy (width/height)
         * @param {number} pos the position
         * @param {number} len the length
         * @return {?string} the classname
         */
        getLengthClassName: function(way, pos, len) {
          if (this._widget.getParentWidget()) {
            var uuid = this._widget.getParentWidget().getUniqueIdentifier();
            return ["gl_", uuid, "_", way, "_", pos, "_", len].join("");
          } else {
            return null;
          }
        },

        /**
         * Set if widget content contains only a single line
         * @param {boolean} b true if widget content contains only a single line
         */
        setSingleLineContentOnly: function(b) {
          this._singleLineContentOnly = b;
        },

        /**
         * Returns if widget content contains only a single line
         * @returns {boolean} true if widget content contains only a single line
         */
        hasSingleLineContentOnly: function() {
          return this._singleLineContentOnly;
        },

        /**
         * Sets number of cols reserved for decoration by VM
         * @param {number} n number of cols reserved for decoration by VM
         */
        setReservedDecorationSpace: function(n) {
          this._reservedDecorationSpace = n;
        },

        /**
         * Returns number of cols reserved for decoration by VM
         * @returns {number} number of cols reserved for decoration by VM
         */
        getReservedDecorationSpace: function() {
          return this._reservedDecorationSpace;
        },

        /**
         * Get stretchability info
         * @returns {classes.Stretch} stretchability info
         */
        getStretched: function() {
          return this._stretched;
        },
        /**
         * get whether or not is x stretched
         * @returns {boolean} true if is x stretched
         */
        isXStretched: function() {
          return this.isInAutomaticStack() || this._stretched.getX(true);
        },
        /**
         * Set if is x stretched
         * @param {boolean} stretch true if is x stretched
         */
        setXStretched: function(stretch) {
          if (this._stretched.getX() !== stretch) {
            this._stretched.setX(stretch);
            this.emit(context.constants.widgetEvents.gridInfoChanged);
          }
        },
        /**
         * get whether or not is y stretched
         * @returns {boolean} true if is y stretched
         */
        isYStretched: function() {
          return this._stretched.getY(true);
        },
        /**
         * get whether or not at least one child is x stretchable
         * @returns {boolean} true if at least one child is x stretchable
         */
        isChildrenXStretched: function() {
          return !!this._childrenStretchX.length;
        },
        /**
         * get whether or not at least one child is y stretchable
         * @returns {boolean} true if at least one child is y stretchable
         */
        isChildrenYStretched: function() {
          return !!this._childrenStretchY.length;
        },
        /**
         * Set if is y stretched
         * @param {boolean} stretch true if is y stretched
         */
        setYStretched: function(stretch) {
          if (this._stretched.getY() !== stretch) {
            this._stretched.setY(stretch);
            this.emit(context.constants.widgetEvents.gridInfoChanged);
          }
        },
        /**
         * reset x and y stretchable list
         */
        resetChildrenStretch: function() {
          this._childrenStretchX.length = 0;
          this._childrenStretchY.length = 0;
        },
        /**
         * add child info to x stretchables
         * @param {classes.LayoutInformation} val the child info
         */
        addChildrenStretchX: function(val) {
          this._childrenStretchX.push(val);
        },
        /**
         * add child info to y stretchables
         * @param {classes.LayoutInformation} val the child info
         */
        addChildrenStretchY: function(val) {
          this._childrenStretchY.push(val);
        },
        /**
         * fired when grid information changed
         * @param {Hook} hook the hook
         * @return {HandleRegistration} the handle registration
         */
        onGridInfoChanged: function(hook) {
          return this.when(context.constants.widgetEvents.gridInfoChanged, hook);
        },

        setGridAutomaticStack: function(automaticStack, no) {
          if (this._isAutomaticStack !== automaticStack) {
            this._isAutomaticStack = automaticStack;
            if (this._hostElement) {
              this._hostElement.setAttribute("grid-renderer", this._isAutomaticStack ? "stack" : "grid");
            }
            if (!no) {
              this.emit(context.constants.widgetEvents.gridInfoChanged);
            }
          }
        },

        setChildOfGridAutomaticStack: function(automaticStack, no) {
          if (this._isChildOfAutomaticStack !== automaticStack) {
            this._isChildOfAutomaticStack = automaticStack;
            this._gridInformation.useVirtualCoordinates(automaticStack);
            if (this._hostElement) {
              this._hostElement.setAttribute("grid-parent-renderer", this._isChildOfAutomaticStack ? "stack" : "grid");
            }
            if (!no) {
              this.emit(context.constants.widgetEvents.gridInfoChanged);
            }
          }
        },

        isStacked: function() {
          return this._isAutomaticStack;
        },

        isInAutomaticStack: function() {
          return this._isChildOfAutomaticStack;
        },
        /**
         * invalidate information
         */
        invalidateInfos: function() {
          this.emit(context.constants.widgetEvents.gridInfoChanged);
        }
      };
    });
  });
;
"use strict";

modulum('PageLayoutInformation', ['EventListener', 'LayoutInformation'],
  function(context, cls) {
    /**
     * Page layout information
     * This is an advanced class, be careful while using it
     * @class PageLayoutInformation
     * @memberOf classes
     * @extends classes.LayoutInformation
     * @publicdoc Base
     */
    cls.PageLayoutInformation = context.oo.Class(cls.LayoutInformation, function($super) {
      return /** @lends classes.PageLayoutInformation.prototype */ {
        __name: "PageLayoutInformation",

        /** @type {number} */
        _titleMeasureWidth: 0,
        /** @type {number} */
        _titleMeasureHeight: 0,

        /**
         * @inheritDoc
         * @constructs
         */
        constructor: function(widget) {
          $super.constructor.call(this, widget);
        },
        /**
         * @inheritDoc
         */
        reset: function(soft) {
          $super.reset.call(this, soft);
          this._titleMeasureWidth = 0;
          this._titleMeasureHeight = 0;
        },

        /**
         * get the page title width
         * @returns {number}
         */
        getTitleMeasureWidth: function() {
          return this._titleMeasureWidth;
        },

        /**
         * set the page title width
         * @param titleMeasureWidth
         */
        setTitleMeasureWidth: function(titleMeasureWidth) {
          this._titleMeasureWidth = titleMeasureWidth;
        },

        /**
         * get the page title height
         * @returns {number}
         */
        getTitleMeasureHeight: function() {
          return this._titleMeasureHeight;
        },

        /**
         * set the page title height
         * @param titleMeasureHeight
         */
        setTitleMeasureHeight: function(titleMeasureHeight) {
          this._titleMeasureHeight = titleMeasureHeight;
        }
      };
    });
  });
;
"use strict";

modulum('RawLayoutInformation', ['EventListener'],
  function(context, cls) {
    /**
     * Raw layout information
     * This is an advanced class, be careful while using it
     * @class RawLayoutInformation
     * @memberOf classes
     * @extends classes.EventListener
     * @publicdoc Base
     */
    cls.RawLayoutInformation = context.oo.Class(cls.EventListener, function($super) {
      return /** @lends classes.RawLayoutInformation.prototype */ {
        __name: "RawLayoutInformation",

        /**
         * is autoscale
         * @type {?number}
         */
        _autoScale: null,
        /**
         * The visible width of an object in character cells. For some objects like windows, tables and images, it can be followed by an optional unit (co,ln,pt,px). Default unit is character cells.
         * @type {?string}
         */
        _width: null,
        _height: null,
        _gridWidth: null,
        _gridHeight: null,
        _posX: null,
        _posY: null,
        _minWidth: null,
        _minHeight: null,
        _stepX: null,
        _stepY: null,
        _columnCount: null,
        _stretch: null,
        _wantFixedPageSize: null,
        _gridChildrenInParent: null,
        _childOfGridChildrenInParent: null,
        /**
         * the size policy config
         * @type {?string}
         */
        _sizePolicy: null,

        /**
         * @inheritDoc
         * @constructs
         */
        constructor: function() {
          $super.constructor.call(this);
          this.reset();
        },
        /**
         * @inheritDoc
         */
        destroy: function() {
          $super.destroy.call(this);
        },
        /**
         * reset the values for object reuse purpose
         */
        reset: function() {},

        /**
         *
         * @return {?string}
         */
        getSizePolicy: function() {
          return this._sizePolicy;
        },
        /**
         *
         * @param {?string} sizePolicy
         */
        setSizePolicy: function(sizePolicy) {
          if (this._sizePolicy !== sizePolicy) {
            this._sizePolicy = sizePolicy;
            this.invalidateInfos();
          }
        },

        getAutoScale: function() {
          return this._autoScale;
        },
        setAutoScale: function(autoScale) {
          if (this._autoScale !== autoScale) {
            this._autoScale = autoScale;
            this.invalidateInfos();
          }
        },

        getWidth: function() {
          return this._width;
        },
        setWidth: function(width) {
          if (this._width !== width) {
            this._width = width;
            this.invalidateInfos();
          }
        },

        getHeight: function() {
          return this._height;
        },
        setHeight: function(height) {
          if (this._height !== height) {
            this._height = height;
            this.invalidateInfos();
          }
        },

        getGridWidth: function() {
          return this._gridWidth;
        },
        setGridWidth: function(gridWidth) {
          if (this._gridWidth !== gridWidth) {
            this._gridWidth = gridWidth;
            this.invalidateInfos();
          }
        },

        getGridHeight: function() {
          return this._gridHeight;
        },
        setGridHeight: function(gridHeight) {
          if (this._gridHeight !== gridHeight) {
            this._gridHeight = gridHeight;
            this.invalidateInfos();
          }
        },

        getPosX: function() {
          return this._posX;
        },
        setPosX: function(posX) {
          if (this._posX !== posX) {
            this._posX = posX;
            this.invalidateInfos();
          }
        },

        getPosY: function() {
          return this._posY;
        },
        setPosY: function(posY) {
          if (this._posY !== posY) {
            this._posY = posY;
            this.invalidateInfos();
          }
        },

        getMinWidth: function() {
          return this._minWidth;
        },
        setMinWidth: function(minWidth) {
          if (this._minWidth !== minWidth) {
            this._minWidth = minWidth;
            this.invalidateInfos();
          }
        },

        getMinHeight: function() {
          return this._minHeight;
        },
        setMinHeight: function(minHeight) {
          if (this._minHeight !== minHeight) {
            this._minHeight = minHeight;
            this.invalidateInfos();
          }
        },

        getStepX: function() {
          return this._stepX;
        },
        setStepX: function(stepX) {
          if (this._stepX !== stepX) {
            this._stepX = stepX;
            this.invalidateInfos();
          }
        },

        getStepY: function() {
          return this._stepY;
        },
        setStepY: function(stepY) {
          if (this._stepY !== stepY) {
            this._stepY = stepY;
            this.invalidateInfos();
          }
        },

        getColumnCount: function() {
          return this._columnCount;
        },
        setColumnCount: function(columnCount) {
          if (this._columnCount !== columnCount) {
            this._columnCount = columnCount;
            this.invalidateInfos();
          }
        },

        getStretch: function() {
          return this._stretch;
        },
        setStretch: function(stretch) {
          if (this._stretch !== stretch) {
            this._stretch = stretch;
            this.invalidateInfos();
          }
        },

        getWantFixedPageSize: function() {
          return this._wantFixedPageSize;
        },
        setWantFixedPageSize: function(wantFixedPageSize) {
          if (this._wantFixedPageSize !== wantFixedPageSize) {
            this._wantFixedPageSize = wantFixedPageSize;
            this.invalidateInfos();
          }
        },

        getGridChildrenInParent: function() {
          return this._gridChildrenInParent;
        },
        setGridChildrenInParent: function(gridChildrenInParent) {
          if (this._gridChildrenInParent !== gridChildrenInParent) {
            this._gridChildrenInParent = gridChildrenInParent;
            this.invalidateInfos();
          }
        },

        getChildOfGridChildrenInParent: function() {
          return this._childOfGridChildrenInParent;
        },
        setChildOfGridChildrenInParent: function(childOfGridChildrenInParent) {
          if (this._childOfGridChildrenInParent !== childOfGridChildrenInParent) {
            this._childOfGridChildrenInParent = childOfGridChildrenInParent;
            this.invalidateInfos();
          }
        },

        /**
         * fired when grid information changed
         * @param {Hook} hook the hook
         * @param {boolean} [once] fires only once
         * @return {HandleRegistration} the handle registration
         */
        onRawLayoutInformationChanged: function(hook, once) {
          return this.when(context.constants.widgetEvents.layoutInformationChanged, hook, Boolean(once));
        },
        /**
         * invalidate information
         */
        invalidateInfos: function() {
          this.emit(context.constants.widgetEvents.layoutInformationChanged);
        }
      };
    });
  });
;
"use strict";

modulum('LayoutEngineBase', ['EventListener', 'LayoutInvalidationService'],
  function(context, cls) {
    /**
     * Definition of Layout Engine
     * This is an advanced class, be careful while using it
     * @class LayoutEngineBase
     * @memberOf classes
     * @extends classes.EventListener
     * @publicdoc Base
     */
    cls.LayoutEngineBase = context.oo.Class(cls.EventListener, function($super) {
      return /** @lends classes.LayoutEngineBase.prototype */ {
        __name: "LayoutEngineBase",

        /**
         * owner widget
         * @protected
         * @type {classes.WidgetBase}
         */
        _widget: null,

        /**
         * flag to know if widget's char size has been measured
         * @type {boolean}
         */
        _charMeasured: false,

        /**
         * buffered css rules
         * @type {Object}
         * @protected
         */
        _styleRules: null,

        /**
         * layout statuses
         * @type {?classes.LayoutStatus}
         * @protected
         */
        _statuses: null,

        /**
         * the current measure invalidation timestamp
         * @type {number}
         */
        _invalidatedMeasure: context.LayoutInvalidationService.getInitialInvalidation(),

        /**
         * the current allocated space invalidation timestamp
         * @type {number}
         */
        _invalidatedAllocatedSpace: context.LayoutInvalidationService.getInitialInvalidation(),

        /**
         * flag to know if this layout has to force parent layout measure invalidation
         * @type {boolean}
         */
        _forceParentInvalidateMeasure: false,

        /**
         * flag to know if this layout needs measure
         * @type {boolean}
         */
        _needMeasure: true,

        /**
         * @inheritDoc
         * @constructs
         * @param {classes.WidgetBase} widget Owner widget
         */
        constructor: function(widget) {
          $super.constructor.call(this);
          this._widget = widget;
          this._styleRules = {};
          this._statuses = {
            measured: false,
            adjusted: false,
            layouted: false
          };
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._destroyStyle();
          this._widget = null;
          this._styleRules = null;
          this._statuses = null;
          $super.destroy.call(this);
        },

        /**
         * Destroy style sheet related to widget layout engine
         * @private
         */
        _destroyStyle: function() {
          if (this._styleSheetId) {
            var stylingContext = this._widget.getStylingContext();
            if (stylingContext === "window") {
              var win = this._widget.getWindowWidget();
              var sheetId = win && win.getUniqueIdentifier() || this._appHash || "_";
              context.styler.appendStyleSheet({}, this._styleSheetId, true, sheetId);
            } else if (stylingContext === "widget") {
              context.styler.removeStyleSheet(this._styleSheetId);
            }
          }
        },

        /**
         * Resets all precalculated layout data
         * @param {boolean} recursive is the reset need to be applied to children recursively
         */
        reset: function(recursive) {
          this._statuses.layouted = false;
          this._statuses.measured = false;
          this._statuses.adjusted = false;

          this._invalidatedMeasure = context.LayoutInvalidationService.getInitialInvalidation();
          this._invalidatedAllocatedSpace = context.LayoutInvalidationService.getInitialInvalidation();
          this._forceParentInvalidateMeasure = false;
          this._needMeasure = true;
          this._charMeasured = false;
          this._getLayoutInfo().reset(true);
          if (recursive) {
            var children = this._widget && this._widget.getChildren && this._widget.getChildren(),
              i = 0,
              len = children && children.length || 0;
            for (; i < len; i++) {
              var engine = children[i].getLayoutEngine();
              if (engine) {
                engine.reset(recursive);
              }
            }
          }
        },

        /**
         * Get layout information of the given widget, or owner widget if not given
         * @param {classes.WidgetBase=} widget the widget
         * @returns {classes.LayoutInformation} thi information
         */
        _getLayoutInfo: function(widget) {
          var w = widget || this._widget;
          if (!w) {
            return null;
          }
          return w.getLayoutInformation();
        },

        /**
         * The layout engine cannot have a child
         * @param {classes.WidgetBase} widget child widget
         */
        registerChild: function(widget) {},

        /**
         * The layout engine cannot have a child
         * @param {classes.WidgetBase} widget child widget
         */
        unregisterChild: function(widget) {},

        /**
         * reset
         */
        resetSizes: function() {
          var layoutInfo = this._widget.getLayoutInformation();
          layoutInfo.getMinimal().reset();
          layoutInfo.getMaximal().reset();
          layoutInfo.getMeasured().reset();
          layoutInfo.getAllocated().reset();
          layoutInfo.getAvailable().reset();
        },

        /**
         * action entry point to deal with layout information, children widget layout information/placement before any layout computing is done
         */
        beforeLayout: function() {},

        /**
         * prepare measure self widget
         */
        prepareMeasure: function() {},

        /**
         * measure char size in widget
         */
        measureChar: function() {
          if (!this._ignoreLayout && !this._charMeasured) {
            var MMMlen = this._widget.__charMeasurer1.getBoundingClientRect(),
              _000len = this._widget.__charMeasurer2.getBoundingClientRect();
            this._getLayoutInfo().setCharSize(MMMlen.width / 10, _000len.width / 10, MMMlen.height / 10);
            if (_000len.width > 0 && MMMlen.height > 0) {
              this._charMeasured = true;
            }
          }
        },
        /**
         * raw measure widget DOM element
         */
        DOMMeasure: function() {
          var layoutInfo = this._widget.getLayoutInformation(),
            element = this._widget.getElement(),
            elemRects = element.getBoundingClientRect();

          layoutInfo.setRawMeasure(elemRects.width, elemRects.height);
        },

        /**
         * measure self widget
         */
        measure: function() {},

        /**
         * measure widget decoration
         */
        measureDecoration: function() {

        },

        /**
         * called after measure.
         * Should not be overridden
         */
        afterMeasure: function() {
          this._statuses.measured = true;
        },

        /**
         * update information from children to parent
         */
        prepareAdjustments: function() {},

        /**
         * determine measured ('natural size') from children
         */
        adjustMeasure: function() {},

        /**
         * called after adjust.
         * Should not be overridden
         */
        afterAdjustMeasure: function() {
          this._statuses.adjusted = true;
        },

        /**
         * determine children stretchability
         */
        adjustStretchability: function() {},

        /**
         * determine stretched allocated size for children
         * @param {classes.LayoutApplicationService} [layoutApplicationService] layoutApplicationService
         */
        prepareApplyLayout: function(layoutApplicationService) {},

        /**
         * apply final sizes
         */
        applyLayout: function() {},

        /**
         * Notify layout was applied
         */
        notifyLayoutApplied: function() {
          this.emit(context.constants.widgetEvents.layoutApplied);
        },

        /**
         * Everytime layout is applied, launch a callback
         * @param {Hook} hook - callback to appy
         * @return {HandleRegistration}  a registration handle (for unbind purpose)
         */
        onLayoutApplied: function(hook) {
          return this.when(context.constants.widgetEvents.layoutApplied, hook);
        },

        /**
         * does the widget need measure
         * @return {boolean} true if the widget need measure
         */
        needMeasure: function() {
          return this._needMeasure;
        },

        /**
         * method that would return true if the engine does not want to force a measuring
         * @return {boolean} true if the engine does not want to force a measuring
         */
        ignoreMeasureInvalidation: function() {
          return false;
        },

        /**
         * force measure need
         */
        forceMeasurement: function() {
          this._needMeasure = true;
        },
        /**
         * invalidates measure of the linked widget against an invalidation increment
         * @param {number} [invalidation] the invalidation timestamp
         */
        invalidateMeasure: function(invalidation) {
          if (this._widget && this._widget.getElement() && !this._widget.getElement().isInDOM()) {
            this._invalidatedMeasure = context.LayoutInvalidationService.getInitialInvalidation();
          }
          this._invalidatedMeasure = this._prepareInvalidation(invalidation, this._invalidatedMeasure);
          if (this._widget && (this._forceParentInvalidateMeasure || !this._widget.isHidden())) {
            var parentWidget = this._widget && this._widget.getParentWidget(),
              parentEngine = parentWidget && parentWidget.getLayoutEngine();
            if (parentEngine) {
              parentEngine.invalidateMeasure(this._invalidatedMeasure, this);
            }
            this._forceParentInvalidateMeasure = false;
          }
        },

        /**
         * invalidates allocated space of the linked widget against an invalidation increment
         * @param {number} [invalidation] the invalidation timestamp
         */
        invalidateAllocatedSpace: function(invalidation) {
          this._invalidatedAllocatedSpace = this._prepareInvalidation(invalidation, this._invalidatedAllocatedSpace);
          if (this._widget && !this._widget.isHidden()) {
            var children = this.getRenderableChildren(),
              len = children.length;
            for (var i = 0; i < len; i++) {
              if (children[i]) {
                var layoutEngine = children[i].getLayoutEngine();
                if (layoutEngine) {
                  layoutEngine.invalidateAllocatedSpace(this._invalidatedAllocatedSpace);
                }
              }
            }
          }
        },

        _prepareInvalidation: function(invalidation, current) {
          if (current !== context.LayoutInvalidationService.getInitialInvalidation() && (!invalidation || current < invalidation)) {
            return invalidation || context.LayoutInvalidationService.nextInvalidation();
          }
          return current;
        },
        /**
         * test if layout must switch to measure mode
         * @return {boolean} true if measure mode is neede
         */
        needMeasureSwitching: function() {
          return true;
        },
        /**
         * test measure invalidation against a timestamp
         * @param {number} timestamp the timestamp
         * @return {boolean} true if measure is invalidated
         */
        isInvalidatedMeasure: function(timestamp) {
          return this.needMeasure() && !!this._widget && !this._widget.isHidden() && (this._invalidatedMeasure >= timestamp);
        },
        /**
         * test allocated space invalidation against a timestamp
         * @param {number} timestamp the timestamp
         * @return {boolean} true if allocated space is invalidated
         */
        isInvalidatedAllocatedSpace: function(timestamp) {
          return !!this._widget && !this._widget.isHidden() && (this._invalidatedAllocatedSpace >= timestamp);
        },
        /**
         * test invalidation against a timestamp
         * @param {number} timestamp the timestamp
         * @return {boolean} true if layout engine is invalidated
         */
        isInvalidated: function(timestamp) {
          var result = this.isInvalidatedMeasure(timestamp) || this.isInvalidatedAllocatedSpace(timestamp),
            windowWidget = this._widget && this._widget.getWindowWidget();

          return result && (!windowWidget || !windowWidget._disabled || windowWidget._forceVisible);
        },

        isXStretched: function() {
          var info = this._getLayoutInfo();
          return info && info.isXStretched() || info.isChildrenXStretched();
        },

        isYStretched: function() {
          var info = this._getLayoutInfo();
          return info && info.isYStretched() || info.isChildrenYStretched();
        },

        /**
         * get list of renderable children
         * @return {classes.WidgetBase[]} list of renderable children
         */
        getRenderableChildren: function() {
          return this._widget && this._widget.getChildren && this._widget.getChildren() || [];
        },
        /**
         * update invalidation information
         * @param {number} invalidation the invalidation timestamp
         */
        updateInvalidated: function(invalidation) {
          if (!!this._widget && this._widget.isLayoutMeasureable(true)) {
            this._invalidatedMeasure = this._getUpdatedInvalidation(invalidation, this._invalidatedMeasure);
            this._invalidatedAllocatedSpace = this._getUpdatedInvalidation(invalidation, this._invalidatedAllocatedSpace);
            if (this._getLayoutInfo().getSizePolicyConfig().isInitial()) {
              this._needMeasure = false;
            }
            this._statuses.layouted = true;
          }
        },

        _getUpdatedInvalidation: function(invalidation, current) {
          return Math.max(invalidation, current === context.LayoutInvalidationService.getInitialInvalidation() ? 1 : current);
        },

        /**
         * Inform the layout that visibility has changed
         */
        changeHidden: function() {
          this._forceParentInvalidateMeasure = true;
          if (this._widget && this._widget.getParentWidget() && this._widget.getParentWidget().getLayoutEngine()) {
            this._widget.getParentWidget().getLayoutEngine().invalidateMeasure();
            this._widget.getParentWidget().getLayoutEngine().invalidateAllocatedSpace();
          }
          this.invalidateMeasure();
        },

        /**
         * get a generated css sheet id
         * @return {string}
         */
        getLayoutSheetId: function() {
          return this._widget && this._widget.getStyleSheetId() || "_";
        }
      };
    });
  });
;
"use strict";

modulum("LayoutTriggerAttributes",
  function(context, cls) {

    /**
     * Nodes which imply a relayout. Used in 'add' and 'remove' command type
     * @type {Object}
     */
    var nodesWhichRelayout = {
      "Button": true,
      "HLine": true,
      "Label": true,
      "Image": true,
      "Message": true,
      "Folder": true,
      "Form": true,
      "Group": true,
      "Grid": true,
      "HBox": true,
      "Screen": true,
      "Stack": true,
      "VBox": true,
      "Window": true,
      "ScrollArea": true,
      "ScrollGrid": true,
      "UserInterface": true,
      "Action": true,
      "Dialog": true,
      "Menu": true,
      "MenuAction": true,
      "Table": true,
      "FormField": true,
      "Matrix": true,
      "Item": true
    };

    /**
     * Nodes which imply a relayout. Used in 'add' and 'remove' command type
     * @type {Object}
     */
    var attributesWhichRelayout = {
      height: true,
      hidden: true,
      minHeight: true,
      minWidth: true,
      pageSize: true, // relayout should be done only for ScrollGrid
      sample: true,
      sizePolicy: true,
      splitter: true,
      width: true,
      windowStyle: true,
      size: true // relayout should be done only for Table
    };

    /**
     * Enum of all VM attributes which imply relayout
     * @namespace classes.LayoutTriggerAttributes
     */
    cls.LayoutTriggerAttributes = {
      "add": nodesWhichRelayout,
      "remove": nodesWhichRelayout,
      "update": attributesWhichRelayout
    };
    Object.freeze(cls.LayoutTriggerAttributes);
  });
;
"use strict";

modulum('ButtonLayoutEngine', ['LeafLayoutEngine'],
  function(context, cls) {
    /**
     * @class ButtonLayoutEngine
     * @memberOf classes
     * @extends classes.LeafLayoutEngine
     */
    cls.ButtonLayoutEngine = context.oo.Class(cls.LeafLayoutEngine, function($super) {
      return /** @lends classes.ButtonLayoutEngine.prototype */ {
        __name: "ButtonLayoutEngine",

        /**
         * @inheritDoc
         */
        measure: function() {
          $super.measure.call(this);

          var layoutInfo = this._widget.getLayoutInformation();
          var preferedWidth = layoutInfo.getPreferred().getWidth() + layoutInfo.getDecorating().getWidth(true);
          var minSize = layoutInfo.getMinimal();
          var maxSize = layoutInfo.getMaximal();
          var measuredSize = layoutInfo.getMeasured();

          if (!layoutInfo.getCurrentSizePolicy().isFixed()) {
            var sizePolicy = layoutInfo.getSizePolicyConfig().mode;
            if (sizePolicy === "initial") {
              var width = preferedWidth > measuredSize.getWidth(true) ? preferedWidth : measuredSize.getWidth(true);
              minSize.setWidth(width);
              measuredSize.setWidth(width);
              maxSize.setWidth(width);
            }
          }
        }
      };
    });
  });
;
"use strict";

modulum('ComboBoxLayoutEngine', ['LeafLayoutEngine'],
  function(context, cls) {
    /**
     * @class ComboBoxLayoutEngine
     * @memberOf classes
     * @extends classes.LeafLayoutEngine
     */
    cls.ComboBoxLayoutEngine = context.oo.Class(cls.LeafLayoutEngine, function($super) {
      return /** @lends classes.ComboBoxLayoutEngine.prototype */ {
        __name: "ComboBoxLayoutEngine",

        /**
         * @inheritDoc
         */
        prepareDynamicMeasure: function() {
          if (this._dataContentMeasure) {
            if (!this._widget.getLayoutInformation().getCurrentSizePolicy().isFixed()) {
              var children = this._widget.getItems();
              var longestValue = this._textSample;
              for (var i = 0; i < children.length; i++) {
                var value = children[i].text;
                if (value) {
                  if (value.length > longestValue.length) {
                    longestValue = value;
                  }
                }
              }
              this._dataContentMeasure.textContent = longestValue;
            }
          }
        },
      };
    });
  });
;
"use strict";

modulum('ImageLayoutEngine', ['LeafLayoutEngine'],
  function(context, cls) {
    /**
     * @class ImageLayoutEngine
     * @memberOf classes
     * @extends classes.LeafLayoutEngine
     */
    cls.ImageLayoutEngine = context.oo.Class(cls.LeafLayoutEngine, function($super) {
      return /** @lends classes.ImageLayoutEngine.prototype */ {
        __name: "ImageLayoutEngine",

        __hasBeenConsideredAsFixed: false,

        /**
         * set natural size
         * @param {number} width the width
         * @param {number} height the height
         */
        setNaturalSize: function(width, height) {
          $super.setNaturalSize.call(this, width, height);
          var layoutInfo = this._widget.getLayoutInformation(),
            rawMeasure = layoutInfo.getRawMeasure(),
            measure = layoutInfo.getMeasured();
          if (!rawMeasure.hasWidth()) {
            rawMeasure.setWidth(width);
          }
          if (!rawMeasure.hasHeight()) {
            rawMeasure.setHeight(height);
          }
          if (!measure.hasWidth()) {
            measure.setWidth(width);
          }
          if (!measure.hasHeight()) {
            measure.setHeight(height);
          }
          var parentWidget = this._widget && this._widget.getParentWidget(),
            parentLayoutEngine = parentWidget && parentWidget.getLayoutEngine();
          if (parentLayoutEngine) {
            parentLayoutEngine.invalidateAllocatedSpace();
          }
        },

        /**
         * @inheritDoc
         */
        considerWidgetAsFixed: function() {
          var isFontImage = this._widget.isFontImage();
          this.__hasBeenConsideredAsFixed = this.__hasBeenConsideredAsFixed || isFontImage;
          return this.__hasBeenConsideredAsFixed;
        }
      };
    });
  });
;
"use strict";

modulum('LeafLayoutEngine', ['LayoutEngineBase'],
  function(context, cls) {

    /**
     * @class LeafLayoutEngine
     * @memberOf classes
     * @extends classes.LayoutEngineBase
     */
    cls.LeafLayoutEngine = context.oo.Class(cls.LayoutEngineBase, function($super) {
      return /** @lends classes.LeafLayoutEngine.prototype */ {
        __name: "LeafLayoutEngine",
        /**
         * data content placeholder is the DOM element that contains what is defined as widget's value
         * @type HTMLElement
         */
        _dataContentPlaceholder: null,
        /**
         * data content measure element is the DOM element that contains widget's value as text for measuring puurpose
         * @type HTMLElement
         */
        _dataContentMeasure: null,
        /**
         * text sample, used in measure
         * @type {?string}
         */
        _textSample: null,
        /**
         * text sample width (in characters)
         * @type {number}
         */
        _sampleWidth: 0,
        /**
         * text sample height (in characters)
         * @type {number}
         */
        _sampleHeight: 0,
        /**
         * value content natural width (to deal with images for example)
         * @type {number}
         */
        _naturalWidth: 0,
        /**
         * value content natural height (to deal with images for example)
         * @type {number}
         */
        _naturalHeight: 0,

        /**
         * set natural size
         * @param {number} width the width
         * @param {number} height the height
         */
        setNaturalSize: function(width, height) {
          this._naturalWidth = width;
          this._naturalHeight = height;
        },

        /**
         * test if this layout has a natural size
         * @return {boolean} true if this layout has a natural size
         */
        hasNaturalSize: function() {
          return !!this._naturalWidth && !!this._naturalHeight;
        },
        /**
         * set hint size
         * @param {number} widthHint the width
         * @param {number} heightHint the height
         */
        setHint: function(widthHint, heightHint) {
          this._widget.getLayoutInformation().setSizeHint(
            ((typeof(widthHint) === "undefined") || widthHint === null || widthHint === "") ? 1 : widthHint, ((typeof(
                heightHint) ===
              "undefined") || heightHint === null || heightHint === "") ? 1 : heightHint
          );
        },
        /**
         * @inheritDoc
         * @constructs
         */
        constructor: function(widget) {
          $super.constructor.call(this, widget);
          this.invalidateDataContentSelector(widget);
        },

        /**
         * @inheritDoc
         */
        reset: function(recursive) {
          $super.reset.call(this, recursive);
          this._widget.resetLayout();
        },

        /**
         * invalidate data content selector, creates it if needed
         * @param {classes.WidgetBase} widget this widget
         */
        invalidateDataContentSelector: function(widget) {
          if (widget.__dataContentPlaceholderSelector) {
            var element = this._widget.getElement();
            this._dataContentPlaceholder = widget.__dataContentPlaceholderSelector === cls.WidgetBase.selfDataContent ? element :
              element.getElementsByClassName(widget.__dataContentPlaceholderSelector.replace(".", ""))[0];
            if (this._dataContentPlaceholder) {
              this._dataContentPlaceholder.addClass("gbc_staticMeasure");
              this._dataContentPlaceholder.removeClass("gbc_dynamicMeasure");

              this._dataContentMeasure = this._dataContentPlaceholder.getElementsByClassName("gbc_dataContentMeasure")[0];
              if (!this._dataContentMeasure && !widget.ignoreLayout()) {
                this._dataContentMeasure = context.TemplateService.renderDOM("LeafLayoutMeasureElement");
                this._dataContentPlaceholder.appendChild(this._dataContentMeasure);
              }
            }
          }
        },

        /**
         * Returns Element containing the data to be measured
         * @returns {HTMLElement} element containing the data to be measured
         */
        getDataContentMeasureElement: function() {
          return this._dataContentMeasure;
        },

        /**
         * @inheritDoc
         */
        invalidateMeasure: function(invalidation) {
          var layoutInfo = this._getLayoutInfo(),
            currentSizePolicy = layoutInfo.getCurrentSizePolicy();
          if (!this._statuses.layouted || (!this.considerWidgetAsFixed() && !(currentSizePolicy.isFixed() && !layoutInfo
              ._fixedSizePolicyForceMeasure))) {
            $super.invalidateMeasure.call(this, invalidation);
            this._getLayoutInfo().invalidateMeasure();
          }
          layoutInfo.hasBeenFixed = false;
        },

        /**
         * sets measure as fixed measure
         * @private
         */
        _setFixedMeasure: function() {
          var layoutInfo = this._widget.getLayoutInformation();
          layoutInfo.setMeasured(
            layoutInfo.getPreferred().getWidth() + layoutInfo.getDecorating().getWidth(true),
            layoutInfo.getPreferred().getHeight() + layoutInfo.getDecorating().getHeight(true));
        },

        /**
         * @inheritDoc
         */
        beforeLayout: function() {
          $super.beforeLayout.call(this);
          // widgets contained in tables should not have a max height defined
          if (this._widget.isInTable()) {
            this._shouldFillHeight = true;
          }
        },

        /**
         * @inheritDoc
         */
        prepareMeasure: function() {
          if (this._dataContentMeasure) {
            var layoutInfo = this._widget.getLayoutInformation();
            var sizeHintWidth = layoutInfo.getSizeHint().getWidth();
            var width = (!layoutInfo.hasRawGridWidth() && cls.Size.isCols(sizeHintWidth)) ? parseInt(sizeHintWidth, 10) :
              layoutInfo.getGridWidth();

            // if a grid is present gridWidth send by VM add the reservedDecorationSpace automatically
            // so we need to remove it to correctly measure the widget
            if (layoutInfo.hasRawGridWidth() && width > layoutInfo.getReservedDecorationSpace()) {
              width -= layoutInfo.getReservedDecorationSpace();
            }
            if (width !== this._sampleWidth || layoutInfo.getGridHeight() !== this._sampleHeight) {
              var sample = cls.Measurement.getTextSample(width, layoutInfo.hasSingleLineContentOnly() ? 1 : layoutInfo
                .getGridHeight());
              this._sampleWidth = width;
              this._sampleHeight = layoutInfo.getGridHeight();
              this._textSample = sample;
              this._dataContentMeasure.textContent = sample;
            }
          }
          this.prepareDynamicMeasure();
        },

        /**
         * prepare widget for dynamic measure
         */
        prepareDynamicMeasure: function() {
          if (this._dataContentPlaceholder) {
            var layoutInfo = this._widget.getLayoutInformation(),
              isDynamic = layoutInfo._needValuedMeasure || !!layoutInfo.getCurrentSizePolicy().isDynamic();

            this._dataContentPlaceholder.toggleClass("gbc_staticMeasure", !isDynamic);
            this._dataContentPlaceholder.toggleClass("gbc_dynamicMeasure", isDynamic);
          }
        },

        /**
         * test if this widget is considered as fixed
         * @return {boolean} true if this widget is considered as fixed
         */
        considerWidgetAsFixed: function() {
          return false;
        },

        /**
         * @inheritDoc
         */
        measureDecoration: function() {
          var layoutInfo = this._widget.getLayoutInformation(),
            currentSizePolicy = layoutInfo.getCurrentSizePolicy();

          var element = this._widget.getElement();

          if (this._widget.isLayoutMeasureable(true) && this.considerWidgetAsFixed() || (currentSizePolicy.isFixed() && !layoutInfo
              ._fixedSizePolicyForceMeasure)) {
            if (this._widget.getElement().querySelector(".gbc-label-text-container") && this._dataContentPlaceholder) {
              var container = this._dataContentPlaceholder.hasClass("gbc_dynamicMeasure") ?
                this._widget.getElement().querySelector(".gbc-label-text-container") :
                this._dataContentMeasure;
              var containerRects = container.getBoundingClientRect();
              this._getLayoutInfo().setDecorating(
                layoutInfo.getRawMeasure().getWidth(true) - containerRects.width,
                layoutInfo.getRawMeasure().getHeight(true) - containerRects.height
              );
              this._getLayoutInfo().setDecoratingOffset(
                container.offsetLeft - element.offsetLeft,
                container.offsetTop - element.offsetTop
              );
            }
          }
        },

        /**
         * @inheritDoc
         */
        measure: function() {
          var layoutInfo = this._widget.getLayoutInformation(),
            currentSizePolicy = layoutInfo.getCurrentSizePolicy(),
            minSize = layoutInfo.getMinimal(),
            maxSize = layoutInfo.getMaximal(),
            measured = layoutInfo.getMeasured(),
            rawMeasure = layoutInfo.getRawMeasure();
          if (this._widget.isLayoutMeasureable(true)) {
            if (this.considerWidgetAsFixed() || (currentSizePolicy.isFixed() && !layoutInfo._fixedSizePolicyForceMeasure)) {
              if (!layoutInfo.hasBeenFixed) {
                this._setFixedMeasure();
                layoutInfo.hasBeenFixed = true;
              }
            } else {
              if (layoutInfo.getCurrentSizePolicy().isDynamic() || (layoutInfo._widget.isVisible() && layoutInfo.needMeasure())) {
                if (currentSizePolicy.isFixed() && layoutInfo._fixedSizePolicyForceMeasure) {
                  if (!layoutInfo.hasBeenFixed) {
                    layoutInfo.setMeasured(
                      this._naturalWidth || rawMeasure.getWidth(true),
                      this._naturalHeight || rawMeasure.getHeight(true)
                    );
                    layoutInfo.hasBeenFixed = true;
                  }
                } else {
                  var width = layoutInfo._forceFixedWidthMeasure ?
                    layoutInfo.getPreferred().getWidth(true) :
                    (this._naturalWidth || rawMeasure.getWidth(true));
                  layoutInfo.setMeasured(width, this._naturalHeight || rawMeasure.getHeight(true));
                }
              }
            }
            if (layoutInfo.getCurrentSizePolicy().isDynamic()) {
              layoutInfo.setMinimal(measured.getWidth(), measured.getHeight());
            } else {
              if (layoutInfo.isXStretched() || currentSizePolicy.canShrink()) {
                minSize.setWidth(layoutInfo.forcedMinimalWidth);
              } else {
                minSize.setWidth(measured.getWidth());
              }
              if (layoutInfo.isYStretched() || currentSizePolicy.canShrink()) {
                minSize.setHeight(layoutInfo.forcedMinimalHeight);
              } else {
                minSize.setHeight(measured.getHeight());
              }
            }
            if (layoutInfo.isXStretched()) {
              maxSize.setWidth(cls.Size.maximal);
            } else {
              maxSize.setWidth(measured.getWidth());
            }
            if (layoutInfo.isYStretched()) {
              maxSize.setHeight(cls.Size.maximal);
            } else {
              maxSize.setHeight(measured.getHeight());
            }

            if (this._getLayoutInfo().forceMinimalMeasuredHeight) {
              minSize.setHeight(Math.max(layoutInfo.getRawMeasure().getHeight(true), minSize.getHeight(true)));
            }
            currentSizePolicy.setInitialized();
          } else {
            layoutInfo.setMeasured(0, 0);
            layoutInfo.setMinimal(0, 0);
            layoutInfo.setMaximal(0, 0);
          }
        },

        /**
         * @inheritDoc
         */
        adjustStretchability: function() {
          var formWidget = this._widget.getFormWidget();
          if (formWidget && formWidget.getLayoutEngine().isAutoOverflowActivated()) {
            var layoutInfo = this._widget.getLayoutInformation();
            if (layoutInfo.isYStretched()) {
              layoutInfo.getMinimal().setHeight(Math.max(layoutInfo.getPreferred().getHeight(true), layoutInfo.getMeasured()
                .getHeight(
                  true)));
            }
            if (this._getLayoutInfo().forceMinimalFixedHeight) {
              layoutInfo.getMinimal().setHeight(Math.max(this._getLayoutInfo().forcedMinimalHeight, layoutInfo.getMinimal()
                .getHeight(
                  true)));
            }

          }
        },

        /**
         * @inheritDoc
         */
        prepareApplyLayout: function() {
          if (this._getLayoutInfo().isXStretched()) {
            this._widget.setStyle({
              preSelector: ".g_measured ",
              selector: ".g_measureable",
              appliesOnRoot: true
            }, {
              width: this._getLayoutInfo().getAvailable().getWidth() + "px"
            });
          }
          if (this._getLayoutInfo().isYStretched()) {
            this._widget.setStyle({
              preSelector: ".g_measured ",
              selector: ".g_measureable",
              appliesOnRoot: true
            }, {
              height: this._getLayoutInfo().getAvailable().getHeight() + "px"
            });
          } else if (this._getLayoutInfo().getMaximal().getHeight(true) && !this._shouldFillHeight) {
            this._widget.setStyle({
              preSelector: ".g_measured ",
              selector: ".g_measureable",
              appliesOnRoot: true
            }, {
              "max-height": this._getLayoutInfo().getMaximal().getHeight(true) + "px"
            });
          }
        },

        /**
         * @inheritDoc
         */
        getRenderableChildren: function() {
          return [];
        }
      };
    });
  });
;
"use strict";

modulum('ListViewLayoutEngine', ['TableLayoutEngineBase'],
  function(context, cls) {
    /**
     * @class ListViewLayoutEngine
     * @memberOf classes
     * @extends classes.TableLayoutEngineBase
     */
    cls.ListViewLayoutEngine = context.oo.Class(cls.TableLayoutEngineBase, function($super) {
      return /** @lends classes.ListViewLayoutEngine.prototype */ {
        __name: "ListViewLayoutEngine",

        /** @type boolean */
        _firstWidgetMeasured: false,

        /**
         * @inheritDoc
         */
        reset: function(recursive) {
          $super.reset.call(this, recursive);
          this._firstWidgetMeasured = false;
        },

        /**
         * @inheritDoc
         */
        measure: function() {
          $super.measure.call(this);
          var layoutInfo = this._widget.getLayoutInformation();

          var computePreferredWidth = 0;
          if (!this._firstWidgetMeasured && layoutInfo._charSize.hasSize()) {
            // measure first widget of first row to initialize row height of listview
            var rowWidget = this._widget.getChildren()[0];
            if (rowWidget) {
              var widget = rowWidget.getChildren()[0];
              if (widget) {
                widget._layoutInformation._charSize = layoutInfo._charSize;
                widget._layoutInformation.getSizePolicyConfig().mode = "fixed";
                widget._layoutInformation.updatePreferred();
                widget._layoutEngine.DOMMeasure();
                widget._layoutEngine.measureDecoration();
                widget._layoutEngine.measure();
                widget._layoutEngine.afterMeasure();

                var height = widget._layoutInformation.getMeasured().getHeight();
                if (rowWidget.getLineCount() === 1) {
                  height = height * cls.ListViewWidget.defaultOneLineHeightRatio;
                } else if (rowWidget.getLineCount() === 2) {
                  height = height * cls.ListViewWidget.defaultTwoLinesHeightRatio;
                }
                computePreferredWidth = widget._layoutInformation.getMeasured().getWidth();

                this._widget.setRowHeight(Math.round(height));

                this._firstWidgetMeasured = true;
              }
            }
          }

          // Compute preferred size
          if (!this._initialPreferredSize) {
            this._initialPreferredSize = true;
            var rowHeight = this._widget.getRowHeight();
            var sizeHint = layoutInfo.getSizeHint();
            layoutInfo.getPreferred().setWidth(Math.round(computePreferredWidth));
            if (!!sizeHint.getHeight()) {
              // translate height into number of rows
              var preferredPageSize = Math.max(this._translateHeight(sizeHint.getHeight(), layoutInfo.getCharSize().getHeight(),
                rowHeight), 1);
              this._widget._firstPageSize = preferredPageSize;
            }
            var h = this._widget._firstPageSize ? this._widget._firstPageSize * rowHeight : 1;
            layoutInfo.getPreferred().setHeight(Math.round(h + layoutInfo.getDecorating().getHeight()));
          }
        },

        /**
         * @inheritDoc
         */
        measureDecoration: function() {
          var scrollAreaElementHeight = this._widget.getScrollableArea().offsetHeight;
          var decorateHeight = this._widget.getElement().offsetHeight - scrollAreaElementHeight;
          var scrollAreaElementWidth = this._widget.getScrollableArea().offsetWidth;
          var decorateWidth = this._widget.getElement().offsetWidth - scrollAreaElementWidth;

          this._getLayoutInfo().setDecorating(decorateWidth + window.scrollBarSize, decorateHeight);
        }

      };
    });
  });
;
"use strict";

modulum('ScrollLayoutEngine', ['LayoutEngineBase'],
  function(context, cls) {
    /**
     * @class ScrollLayoutEngine
     * @memberOf classes
     * @extends classes.LayoutEngineBase
     */
    // TODO why it is a layoutEngienBase or why it is in leaf directory ?
    cls.ScrollLayoutEngine = context.oo.Class(cls.LayoutEngineBase, function() {
      return /** @lends classes.ScrollLayoutEngine.prototype */ {
        __name: "ScrollLayoutEngine",

        /**
         * @inheritDoc
         */
        prepareApplyLayout: function() {
          var parentWidget = this._widget.getParentWidget();
          var parentLayoutInfo = this._getLayoutInfo(parentWidget);
          // widget => scroll Widget

          // Calculate needed values
          var widgetHeight = parentLayoutInfo.getAllocated()._height;
          var lineHeight = parentWidget.getRowHeight ? parentWidget.getRowHeight() : (parseFloat(widgetHeight) / this._widget._pageSize) ||
            0;

          this._widget.setLineHeight(lineHeight);
          this._widget.setTotalHeight(lineHeight * this._widget._size);

          this._widget.setVisibleHeight(widgetHeight);
          if (this._widget.refreshScroll) {
            this._widget.refreshScroll();
          }
        }
      };
    });
  });
;
"use strict";

modulum('SliderLayoutEngine', ['LeafLayoutEngine'],
  function(context, cls) {

    /**
     * @class SliderLayoutEngine
     * @memberOf classes
     * @extends classes.LayoutEngineBase
     */
    cls.SliderLayoutEngine = context.oo.Class(cls.LeafLayoutEngine, function($super) {
      return /** @lends classes.SliderLayoutEngine.prototype */ {
        __name: "SliderLayoutEngine",

        /**
         * @inheritDoc
         */
        measure: function() {
          $super.measure.call(this);
          var layoutInfo = this._widget.getLayoutInformation();
          if (this._widget._orientation === "vertical") {
            layoutInfo.getMeasured().rotate();
            layoutInfo.getPreferred().rotate();
            layoutInfo.getMinimal().rotate();
            layoutInfo.getMaximal().rotate();
          }
        },

      };
    });
  });
;
"use strict";

modulum('StretchableScrollLayoutEngine', ['LayoutEngineBase'],
  function(context, cls) {
    /**
     * @class StretchableScrollLayoutEngine
     * @memberOf classes
     * @extends classes.LayoutEngineBase
     */
    cls.StretchableScrollLayoutEngine = context.oo.Class(cls.LeafLayoutEngine, function($super) {
      return /** @lends classes.StretchableScrollLayoutEngine.prototype */ {
        __name: "StretchableScrollLayoutEngine",

        /**
         * @inheritDoc
         */
        getRenderableChildren: function() {
          return this._widget && this._widget.getChildren && this._widget.getChildren() || [];
        },

        /**
         * @inheritDoc
         */
        measureDecoration: function() {
          $super.measureDecoration.call(this);
          var paginationWidget = this._widget.getPaginationWidget ? this._widget.getPaginationWidget() : null;
          var paginationHeight = paginationWidget ? paginationWidget.getElement().getBoundingClientRect().height : 0;
          var layoutInfo = this._widget.getLayoutInformation();
          layoutInfo.setDecorating(window.scrollBarSize, paginationHeight + window.scrollBarSize);
        },

        /**
         * @inheritDoc
         */
        measure: function() {
          $super.measure.call(this);

          if (!this._widget._firstPageSize) {
            this._widget._firstPageSize = this._widget._pageSize;
          }
        },

        /**
         * @inheritDoc
         */
        adjustMeasure: function() {
          var layoutInfo = this._widget.getLayoutInformation();
          var children = this.getRenderableChildren();
          var decorationHeight = layoutInfo.getDecorating().getHeight(true);

          if (children.length > 0) {
            var childMinimal = children[0].getLayoutInformation().getMinimal();
            var isNoSizableWindow = this._widget.getWindowWidget() && (this._widget.getWindowWidget().getLayoutInformation()
              .isSizable() ===
              false);

            // if window sizable=false --> height of stretchable scrollgrid must be fixed to initialPageSize (if any)
            if (isNoSizableWindow) {
              var rowHeight = childMinimal.getHeight(); // this._widget.getRowHeight();

              var preferredPageSize = this._widget._firstPageSize ? Math.max(this._widget._firstPageSize, 1) : 1;
              var minHeight = preferredPageSize * rowHeight + layoutInfo.getDecorating().getHeight();
              layoutInfo.getMinimal().setHeight(minHeight);
              layoutInfo.getMeasured().setHeight(minHeight);
              layoutInfo.getMaximal().setHeight(minHeight);
            }

            layoutInfo.getMinimal().setWidth(Math.max(layoutInfo.getMinimal().getWidth(true), childMinimal.getWidth(true) +
              layoutInfo.getDecorating().getWidth()));
          } else {
            layoutInfo.setMinimal(0, decorationHeight);
          }
          var sizeX = layoutInfo.getMinimal().getWidth(true);
          var sizeY = layoutInfo.getMinimal().getHeight(true);
          layoutInfo.setPreferred(sizeX, sizeY);
          layoutInfo.setMeasured(sizeX, sizeY);
        }
      };
    });
  });
;
"use strict";

modulum('TableColumnLayoutEngine', ['LeafLayoutEngine'],
  function(context, cls) {
    /**
     * @class TableColumnLayoutEngine
     * @memberOf classes
     * @extends classes.LeafLayoutEngine
     */
    cls.TableColumnLayoutEngine = context.oo.Class(cls.LeafLayoutEngine, function($super) {
      return /** @lends classes.TableColumnLayoutEngine.prototype */ {
        __name: "TableColumnLayoutEngine",

        /**
         * reset column first item width layout
         */
        reset: function(recursive) {
          $super.reset.call(this, recursive);
          var item = this._widget.getChildren()[0];
          if (item) {
            var widget = item.getChildren()[0];
            if (widget) {
              widget._layoutInformation.reset(true);
              widget._layoutEngine.reset(true);
            }
          }
        },

        /**
         * Set size policy mode as fixed on first column item widget
         */
        prepareMeasure: function() {
          $super.prepareMeasure.call(this);

          var item = this._widget.getChildren()[0];
          if (item) {
            var widget = item.getChildren()[0];
            if (widget) {
              widget.getLayoutInformation().setSizePolicyMode("fixed");

              var charSize = this._widget.getParentWidget().getLayoutInformation().getCharSize();
              widget.getLayoutInformation().setCharSize(charSize.getWidthM(), charSize.getWidth0(), charSize.getHeight());
            }
          }
        },

        /**
         * Get DOM measure of column first item widget and set it as row measure on column layout
         */
        DOMMeasure: function() {
          var item = this._widget.getChildren()[0];
          if (item) {
            var widget = item.getChildren()[0];
            if (widget) {
              var widgetRawMeasure = widget.getLayoutInformation().getRawMeasure();
              this._getLayoutInfo().setRawMeasure(widgetRawMeasure.getWidth(), widgetRawMeasure.getHeight());
            }
          }
        },

        /**
         * Measure column first item widget and copy its measure on column layout
         */
        measure: function() {
          $super.measure.call(this);

          if (!this._widget._firstWidgetMeasured) {
            var item = this._widget.getChildren()[0];
            if (item) {
              var widget = item.getChildren()[0];
              if (widget) {

                var measuredWidth = widget.getLayoutInformation().getMeasured().getWidth();
                var preferredWidth = widget.getLayoutInformation().getPreferred().getWidth();
                var measuredHeight = widget.getLayoutInformation().getMeasured().getHeight();
                var preferredHeight = widget.getLayoutInformation().getPreferred().getHeight();

                var width = Math.round(Math.max(measuredWidth, preferredWidth));
                this._widget.setInitialWidth(width);
                this._getLayoutInfo().setPreferred(width, preferredHeight);
                this._getLayoutInfo().setMeasured(width, measuredHeight);

                this._widget._firstWidgetMeasured = true;
              }
            }
          }

        },

        /**
         * Apply store settings or measured width if no store settings on column
         */
        applyLayout: function() {
          var defaultWidth = this._widget.getDefaultWidth();
          this._widget.setWidth(defaultWidth === null ? this._getLayoutInfo().getPreferred().getWidth() : defaultWidth);
        },

        /**
         * Returns column first item widget as renderable on first launch and then empty array to not measure anymore
         */
        getRenderableChildren: function() {
          var children = [];
          if (this._widget && !this._widget._firstWidgetMeasured && this._widget.getChildren) {
            var item = this._widget.getChildren()[0];
            if (item && item.getChildren) {
              children = item.getChildren();
            }
          }
          return children;
        }
      };
    });
  });
;
"use strict";

modulum('TableLayoutEngine', ['TableLayoutEngineBase'],
  function(context, cls) {
    /**
     * @class TableLayoutEngine
     * @memberOf classes
     * @extends classes.TableLayoutEngineBase
     */
    cls.TableLayoutEngine = context.oo.Class(cls.TableLayoutEngineBase, function($super) {
      return /** @lends classes.TableLayoutEngine.prototype */ {
        __name: "TableLayoutEngine",

        /**
         * reset table measured flag
         */
        invalidatePreferredSize: function() {
          this._initialPreferredSize = false;
        },

        /**
         * @inheritDoc
         */
        measure: function() {
          $super.measure.call(this);

          if (!this._initialPreferredSize) {

            var layoutInfo = this._widget.getLayoutInformation();

            // get measured width and height of each columns
            var columns = this._widget.getColumns(),
              len = columns.length,
              i, perVisibleColumn = [];
            var computePreferredWidth = 0;
            var rowHeight = 0;
            for (i = 0; i < len; i++) {
              var columnWidget = columns[i];

              // max measured column item height is used as global row height
              if (!columnWidget.isHidden()) {
                var height = columnWidget.getLayoutInformation().getMeasured().getHeight();
                if (Math.round(height) > rowHeight) {
                  rowHeight = height;
                  this._widget.setRowHeight(height);
                }

                // get sum of all columns width
                var width = columnWidget.getLayoutInformation().getPreferred().getWidth();
                perVisibleColumn.push(width);
                computePreferredWidth += width;
              }
            }

            // Compute preferred size
            this._initialPreferredSize = true;
            var sizeHint = layoutInfo.getSizeHint();
            if (!sizeHint.getWidth()) {
              layoutInfo.getPreferred().setWidth(Math.round(computePreferredWidth));
            } else if (cls.Size.isCols(sizeHint.getWidth())) {
              var count = parseInt(sizeHint.getWidth(), 10),
                colsLen = perVisibleColumn.slice(0, count).reduce(function(pv, cv) {
                  return pv + cv;
                }, 0);
              layoutInfo.getPreferred().setWidth(Math.round(colsLen));
            }
            if (!!sizeHint.getHeight()) {
              // translate height into number of rows
              var preferredPageSize = Math.max(this._translateHeight(sizeHint.getHeight(), layoutInfo.getCharSize().getHeight(),
                rowHeight), 1);
              this._widget._firstPageSize = preferredPageSize;
            }
            var h = this._widget._firstPageSize ? this._widget._firstPageSize * rowHeight : 1;
            layoutInfo.getPreferred().setHeight(Math.round(h + layoutInfo.getDecorating().getHeight()));
          }
        },

        /**
         * @inheritDoc
         */
        measureDecoration: function() {
          var footerElement = this._widget.hasFooter() ? this._widget.getColumnsFooter() : null;
          var scrollAreaElementWidth = this._widget.getScrollableArea().offsetWidth;
          if (this._widget.hasLeftFrozenColumns()) {
            scrollAreaElementWidth += this._widget.getLeftScrollableArea().offsetWidth;
          }
          if (this._widget.hasRightFrozenColumns()) {
            scrollAreaElementWidth += this._widget.getRightScrollableArea().offsetWidth;
          }

          // computation of decorationHeight and decorationWidth are not the same because of g_measuring css rules in TableWidget.scss
          var decorateHeight = this._widget.getElement().offsetHeight + (!!
            footerElement ?
            footerElement.offsetHeight : 0);
          var decorateWidth = this._widget.getElement().offsetWidth - scrollAreaElementWidth;

          this._getLayoutInfo().setDecorating(decorateWidth + window.scrollBarSize, decorateHeight + window.scrollBarSize);
        },

        /**
         * @inheritDoc
         */
        applyLayout: function() {
          // set correct width of the table when measuring to avoid reset of horizontal scrollbar
          $super.applyLayout.call(this);
          this._widget.setStyle({
            preSelector: ".g_measuring ",
            selector: ".g_measureable",
            appliesOnRoot: true
          }, {
            width: this._getLayoutInfo().getAllocated().getWidth() + "px !important",
          });
        },

        /**
         * Returns table columns as renderable children
         */
        getRenderableChildren: function() {
          var children = [];
          if (this._widget && this._widget.isElementInDOM() && this._widget.getChildren) {
            children = this._widget.getChildren();
          }
          return children;
        }
      };
    });
  });
;
"use strict";

modulum('TableLayoutEngineBase', ['LeafLayoutEngine'],
  function(context, cls) {
    /**
     * @class TableLayoutEngineBase
     * @memberOf classes
     * @extends classes.LeafLayoutEngine
     */
    cls.TableLayoutEngineBase = context.oo.Class(cls.LeafLayoutEngine, function($super) {
      return /** @lends classes.TableLayoutEngineBase.prototype */ {
        __name: "TableLayoutEngineBase",

        /** @type number */
        _minPageSize: 1,
        /** @type number */
        _minWidth: 60,
        /** @type boolean */
        _initialPreferredSize: false,

        /**
         * @inheritDoc
         */
        reset: function(recursive) {
          $super.reset.call(this, recursive);
          this._initialPreferredSize = false;
        },

        /**
         * @inheritDoc
         */
        invalidateAllocatedSpace: function(invalidation) {
          this._invalidatedAllocatedSpace = invalidation || context.LayoutInvalidationService.nextInvalidation();
        },

        // TODO check if this override is necessary
        /**
         * @inheritDoc
         */
        setHint: function(widthHint, heightHint) {
          this._widget.getLayoutInformation().setSizeHint(
            ((typeof(widthHint) === "undefined") || widthHint === null || widthHint === "") ? 0 : widthHint,
            ((typeof(heightHint) === "undefined") || heightHint === null || heightHint === "") ? 0 : heightHint
          );
        },
        needMeasureSwitching: function() {
          return this._widget.isVisibleRecursively();
        },

        /**
         * @inheritDoc
         */
        measureDecoration: function() {},

        /**
         * Translate table height into number of rows
         * @param {number} height - table height (ex: 10, 10 row, 10 em, ...)
         * @param {number} charHeight - height of a char (pixels)
         * @param {number} rowHeight - height of table rows (pixels)
         * @return {number} number of rows
         */
        _translateHeight: function(height, charHeight, rowHeight) {
          var rowResult = 0;
          if (!!height) {
            if (Object.isNumber(height)) {
              rowResult = height;
            } else {
              var result = cls.Size.valueRE.exec(height);
              if (result) {
                var numeric = +result[1],
                  unit = result[2];
                switch (unit) {
                  case "ln":
                  case "row":
                    rowResult = numeric;
                    break;
                  case "ch":
                  case "em":
                    var fontSizeRatio = parseFloat(context.ThemeService.getValue("theme-font-size-ratio"));
                    charHeight = +charHeight || (16 * fontSizeRatio);
                    rowResult = Object.isNumber(rowHeight) && rowHeight ? Math.ceil((numeric * charHeight) / rowHeight) : 0;
                    break;
                  case "px":
                    rowResult = Object.isNumber(rowHeight) && rowHeight ? Math.ceil(numeric / rowHeight) : 0;
                    break;
                  default:
                    rowResult = numeric;
                    break;
                }
              }
            }
          }
          return rowResult;
        },

        /**
         * @inheritDoc
         */
        adjustMeasure: function() {
          $super.adjustMeasure.call(this);
          var layoutInfo = this._widget.getLayoutInformation();
          var rowHeight = this._widget.getRowHeight();
          var formWidget = this._widget.getFormWidget();

          // default minimum height
          var minHeight = this.getMinPageSize() * rowHeight + layoutInfo.getDecorating().getHeight();

          // we don't want to override the min height if we are in auto overflow mode
          // because ths min height has been computed in the first adjustMeasure pass.
          if (!(formWidget && formWidget.getLayoutEngine().isAutoOverflowActivated())) {
            layoutInfo.getMinimal().setHeight(minHeight);
          }
          // default minimum width
          var minWidth = this.getMinWidth() + layoutInfo.getDecorating().getWidth();
          layoutInfo.getMinimal().setWidth(minWidth);

          var parentModalElement = this._widget.getElement().parent("gbc_ModalWidget");
          var isInModal = !!parentModalElement;

          // Set measured table height as preferred in modals to keep the good initial height
          if (isInModal) {
            layoutInfo.getMeasured().setHeight(layoutInfo.getPreferred().getHeight());
          }

          var windowWidget = this._widget.getWindowWidget(),
            isNoSizableWindow = windowWidget && windowWidget.getLayoutInformation().isSizable() === false;

          // if fixedPageSize or window sizable=false --> height of table must be fixed
          if (this._widget.isFixedPageSize() || isNoSizableWindow) {
            var preferredPageSize = this._widget._firstPageSize ? Math.max(this._widget._firstPageSize, 1) : 1;
            minHeight = preferredPageSize * rowHeight + layoutInfo.getDecorating().getHeight();
            layoutInfo.getMinimal().setHeight(minHeight);
            layoutInfo.getMeasured().setHeight(minHeight);
            layoutInfo.getMaximal().setHeight(minHeight);
          }

          // Set measured width
          layoutInfo.getMeasured().setWidth(Math.max(layoutInfo.getMinimal().getWidth(true), layoutInfo.getPreferred().getWidth(
            true)) + layoutInfo.getDecorating().getWidth());
        },

        /**
         * @inheritDoc
         */
        prepareApplyLayout: function() {
          $super.prepareApplyLayout.call(this);
          if (this._widget.isFixedPageSize()) {
            // Fix height when page size is fixed
            var layoutInfo = this._widget.getLayoutInformation();
            layoutInfo.getAllocated().setHeight(layoutInfo.getMinimal().getHeight());

            this._widget.setStyle({
              preSelector: ".g_measured ",
              selector: ".g_measureable",
              appliesOnRoot: true
            }, {
              height: this._getLayoutInfo().getAllocated().getHeight() + "px"
            });
          }
        },

        /**
         * Returns minimum page size
         * @return {number} min page size
         */
        getMinPageSize: function() {
          return this._minPageSize;
        },

        /**
         * Sets minimum page size
         * @param {number} minPageSize - min page size
         */
        setMinPageSize: function(minPageSize) {
          this._minPageSize = minPageSize;
        },

        /**
         * Returns minimum width (pixels)
         * @return {number} min width
         */
        getMinWidth: function() {
          return this._minWidth;
        },

        /**
         * Sets minimum width (pixels)
         * @param {number} minWidth - min width
         */
        setMinWidth: function(minWidth) {
          this._minWidth = minWidth;
        }

      };
    });
  });
;
"use strict";

modulum('MenuLayoutEngine', ['LayoutEngineBase'],
  function(context, cls) {
    /**
     * @class MenuLayoutEngine
     * @memberOf classes
     * @extends classes.LayoutEngineBase
     */
    cls.MenuLayoutEngine = context.oo.Class(cls.LayoutEngineBase, function($super) {
      return /** @lends classes.MenuLayoutEngine.prototype */ {
        __name: "MenuLayoutEngine",

        /**
         * @inheritDoc
         */
        needMeasureSwitching: function() {
          return !this._widget || !this._widget.isPopup || !this._widget.isPopup();
        },

        /**
         * @inheritDoc
         */
        ignoreMeasureInvalidation: function() {
          return this._widget && this._widget.isPopup && this._widget.isPopup();
        }
      };
    });
  });
;
"use strict";

modulum('NoLayoutEngine', ['LayoutEngineBase'],
  function(context, cls) {
    /**
     * @class NoLayoutEngine
     * @memberOf classes
     * @extends classes.LayoutEngineBase
     */
    cls.NoLayoutEngine = context.oo.Class(cls.LayoutEngineBase, function($super) {
      return /** @lends classes.NoLayoutEngine.prototype */ {
        __name: "NoLayoutEngine"
      };
    });
  });
;
"use strict";

modulum('StackGroupLayoutEngine', ['StackLayoutEngine'],
  function(context, cls) {
    /**
     * @class StackGroupLayoutEngine
     * @memberOf classes
     * @extends classes.StackLayoutEngine
     */
    cls.StackGroupLayoutEngine = context.oo.Class(cls.StackLayoutEngine, function($super) {
      return /** @lends classes.StackGroupLayoutEngine.prototype */ {
        __name: "StackGroupLayoutEngine",

        _titleWidth: 0,

        /**
         * @inheritDoc
         */
        measure: function(invalidation) {
          $super.measure.call(this);
          if (this._widget._title.getLayoutEngine().isInvalidatedMeasure(invalidation)) {
            this._titleWidth = this._widget._title.getElement().clientWidth + this._getLayoutInfo().getDecorating().getHeight(true);
          }
        },

        /**
         * @inheritDoc
         */
        adjustMeasure: function() {
          $super.adjustMeasure.call(this);
          var layoutInfo = this._getLayoutInfo();
          var minimal = layoutInfo.getMinimal().getWidth(true);
          layoutInfo.getMinimal().setWidth(Math.max(this._titleWidth, minimal));
        }
      };
    });
  });
;
"use strict";

modulum('StackLayoutEngine', ['LeafLayoutEngine'],
  function(context, cls) {
    /**
     * @class StackLayoutEngine
     * @memberOf classes
     * @extends classes.LeafLayoutEngine
     */
    cls.StackLayoutEngine = context.oo.Class(cls.LeafLayoutEngine, function($super) {
      return /** @lends classes.StackLayoutEngine.prototype */ {
        __name: "StackLayoutEngine",
        /**
         * @type {classes.WidgetBase[]}
         */
        _registeredWidgets: null,
        /**
         * set to false to avoid render children
         * @type {boolean}
         */
        _willRenderContent: true,
        /**
         * stylesheet id
         */
        _styleSheetId: null,

        /**
         * @inheritDoc
         * @constructs
         */
        constructor: function(widget) {
          $super.constructor.call(this, widget);
          this._registeredWidgets = [];
          this._styleSheetId = "stackLayout_" + this._widget.getUniqueIdentifier();
        },
        /**
         * @inheritDoc
         */
        destroy: function() {
          for (var i = this._registeredWidgets.length - 1; i > -1; i--) {
            var wi = this._registeredWidgets[i];
            this.unregisterChild(wi);
          }
          this._registeredWidgets.length = 0;
          $super.destroy.call(this);
        },

        /**
         * whether or not to render content
         * @return {boolean}  true if content has to be rendered
         */
        willRenderContent: function() {
          var parentEngine = this._widget && this._widget.getParentWidget() &&
            this._widget.getParentWidget().isInstanceOf(cls.GroupWidget) &&
            this._widget.getParentWidget().getLayoutEngine(),
            hasWillRenderContent = parentEngine && parentEngine.willRenderContent;
          return this._willRenderContent && (!hasWillRenderContent || parentEngine.willRenderContent());
        },

        /**
         * @inheritDoc
         */
        getRenderableChildren: function() {
          return this.willRenderContent() && this._registeredWidgets || [];
        },

        /**
         * @inheritDoc
         * @param {classes.WidgetBase} widget child widget
         * @param {number} position the wanted position
         */
        registerChild: function(widget, position) {
          if (this._registeredWidgets.indexOf(widget) < 0) {
            this._registeredWidgets.splice(position * 2, 0, widget.getLayoutInformation()._stackLabel, widget);
          }
        },

        /**
         * @inheritDoc
         */
        unregisterChild: function(widget) {
          this._registeredWidgets.remove(widget.getLayoutInformation()._stackLabel);
          this._registeredWidgets.remove(widget);
        },

        /**
         * @inheritDoc
         */
        prepareMeasure: function() {
          var parent = this._widget.getParentWidget(),
            foundStack = false;
          while (!foundStack && parent) {
            foundStack = !!(parent.getLayoutEngine() && parent.getLayoutEngine().isInstanceOf(cls.StackLayoutEngine));
            parent = parent.getParentWidget();
          }
          this._isTopStack = !foundStack;
        },

        /**
         * @inheritDoc
         */
        prepareAdjustments: function() {
          var children = this.getRenderableChildren();
          for (var i = 1; i < children.length; i += 2) {
            children[i - 1].setHidden(children[i].isHidden());
          }
        },

        /**
         * @inheritDoc
         */
        measureDecoration: function() {
          var element = this._widget.getElement(),
            container = this._widget.getContainerElement();
          this._getLayoutInfo().setDecorating(
            element.clientWidth - container.clientWidth,
            element.clientHeight - container.clientHeight
          );
          this._getLayoutInfo().setDecoratingOffset(
            container.offsetLeft - element.offsetLeft,
            container.offsetTop - element.offsetTop
          );
        },

        /**
         * @inheritDoc
         */
        adjustMeasure: function() {
          var layoutInfo = this._widget.getLayoutInformation();
          var children = this.getRenderableChildren();
          var minX = 0,
            minY = 0,
            preferredX = 0,
            preferredY = 0;

          this._visibleChildren = 0;
          for (var i = 0; i < children.length; i++) {
            if (children[i].isVisible() && this.willRenderContent()) {
              if (!children[i].isInstanceOf(cls.StackLabelWidget)) {
                this._visibleChildren++;
              }
              var childInfo = children[i].getLayoutInformation();
              var childHeight = Math.max(childInfo.getMinimal().getHeight(true), childInfo.getPreferred().getHeight(true));
              minX = Math.max(minX, childInfo.getMinimal().getWidth(true));
              minY += childHeight;
              preferredX = Math.max(preferredX, childInfo.getPreferred().getWidth(true));
              preferredY += childHeight;
            }
          }
          minX += layoutInfo.getDecorating().getWidth(true);
          minY += layoutInfo.getDecorating().getHeight(true);
          preferredX += layoutInfo.getDecorating().getWidth(true);
          preferredY += layoutInfo.getDecorating().getHeight(true);
          layoutInfo.setMinimal(minX, minY);
          layoutInfo.setMeasured(minX, minY);

          layoutInfo.setPreferred(preferredX, preferredY);
        },

        /**
         * @inheritDoc
         */
        prepareApplyLayout: function(layoutApplicationService) {
          var children = this.getRenderableChildren();
          var layoutInfo = this._widget.getLayoutInformation(),
            childInfo, i;
          var childrenWidth = layoutInfo.getAvailable().getWidth(true) - layoutInfo.getDecorating().getWidth(true);
          var minChildrenWidth = 0,
            columns = 1,
            maxHeight = 0,
            currentItemHeight = 0,
            currentLineHeight = 0;
          if (this._isTopStack) {
            minChildrenWidth = layoutInfo.getMinimal().getWidth(true);
            columns = Math.min(Math.floor(this._visibleChildren), Math.floor(childrenWidth / minChildrenWidth));
            if (columns > 1) {
              childrenWidth = childrenWidth / columns;
            }
            if (children.length === 2) {
              this._shouldStretch = true;
            }
          }
          for (i = 0; i < children.length; i++) {
            childInfo = children[i].getLayoutInformation();
            childInfo.getMaximal().setWidth(layoutInfo.getAvailable().getWidth(true));
            var childHeight = Math.max(childInfo.getMinimal().getHeight(true), childInfo.getPreferred().getHeight(true));
            if (layoutApplicationService && childInfo._keepRatio) {
              layoutApplicationService.activateBackLayout();
              childHeight = childInfo.getMaximal().getWidth() * childInfo._sizeRatio;
              childInfo.getMinimal().setHeight(childHeight);
              childInfo.getMeasured().setHeight(childHeight);
              childInfo.getMaximal().setHeight(childHeight);
            }
            if (i % (columns * 2) === 0) {
              maxHeight += currentLineHeight;
              currentLineHeight = 0;
            }
            currentItemHeight += childHeight;
            if (i % 2 === 1) {
              if (this._shouldStretch && childInfo.shouldFillStack) {
                var labelHeight = currentItemHeight - childHeight;
                childHeight = layoutInfo.getAvailable().getHeight(true) - labelHeight;
              }
              currentLineHeight = Math.max(currentLineHeight, currentItemHeight);
              currentItemHeight = 0;
            }
            childInfo.setAvailable(childrenWidth, childHeight);
            childInfo.setAllocated(childrenWidth, childHeight);

            this._styleRules[".g_measured #w_" + children[i].getUniqueIdentifier() + ".g_measureable"] = {
              "height": childHeight + "px",
              "width": childrenWidth + "px"
            };
          }
          maxHeight += currentLineHeight;
          layoutInfo.setAllocated(layoutInfo.getAvailable().getWidth(true), maxHeight);

        },

        /**
         * @inheritDoc
         */
        applyLayout: function() {
          context.styler.appendStyleSheet(this._styleRules, this._styleSheetId, true, this.getLayoutSheetId());
        }
      };
    });
  });
;
"use strict";

modulum('TraditionalLayoutEngine', ['LayoutEngineBase'],
  function(context, cls) {

    /**
     * @class TraditionalLayoutEngine
     * @memberOf classes
     * @extends classes.LayoutEngineBase
     */
    cls.TraditionalLayoutEngine = context.oo.Class(cls.LayoutEngineBase, function($super) {
      return /** @lends classes.TraditionalLayoutEngine.prototype */ {
        __name: "TraditionalLayoutEngine",

        _children: null,

        /**
         * @inheritDoc
         * @constructs
         */
        constructor: function(widget) {
          $super.constructor.call(this, widget);
          this._children = [];
        },

        /**
         * @inheritDoc
         */
        registerChild: function(widget) {
          this._children.push(widget);
          var li = widget.getLayoutInformation();
          li.className = 'tgl_' + widget.getUniqueIdentifier();
          li.styleRules = {};
          li.styleRulesContent = {};
          li.styleRules['.' + li.className] = li.styleRulesContent;
        },

        /**
         * @inheritDoc
         */
        unregisterChild: function(widget) {
          this._children.remove(widget);
        },

        /**
         * @inheritDoc
         */
        prepareApplyLayout: function() {
          var heightpadding = parseFloat(context.ThemeService.getValue("theme-field-height-ratio"));
          var fieldheight = parseFloat(context.ThemeService.getValue("theme-field-default-height"));
          for (var i = 0; i < this._children.length; ++i) {
            var child = this._children[i];
            var layoutInfo = child.getLayoutInformation();
            if (layoutInfo) {
              var left = layoutInfo.getGridX();
              var top = (layoutInfo.getGridY()) * (fieldheight + 2 * heightpadding) + heightpadding;
              var width = layoutInfo.getGridWidth();
              var height = layoutInfo.getGridHeight() * fieldheight;
              var li = child.getLayoutInformation();
              li.getHostElement().toggleClass(li.className, true);
              var letterSpacing = context.ThemeService.getValue("theme-traditional-mode-letter-spacing");
              li.styleRulesContent.left = 'calc(' + left + 'ch + ' + left + ' * ' + letterSpacing + ')';
              li.styleRulesContent.top = top + 'px';
              li.styleRulesContent.width = 'calc(' + width + 'ch + ' + width + ' * ' + letterSpacing + ')';
              li.styleRulesContent.height = height + 'px';
              context.styler.appendStyleSheet(li.styleRules, "traditionalGridLayout_" + child.getUniqueIdentifier(), true, this
                .getLayoutSheetId());
            }
          }
        },

        /**
         * @inheritDoc
         */
        getRenderableChildren: function() {
          return [];
        }
      };
    });
  });
;
"use strict";

/**
 * Size values' type. Should be a {number}
 * @typedef {?number} classes.SizeValue
 */

/**
 * Two dimension grid slot
 * @typedef {Object} classes.XYDimensionSlot
 * @property {classes.GridDimensionSlot} x X-dimension slot
 * @property {classes.GridDimensionSlot} y Y-dimension slot
 */

/**
 * Grid info
 * @typedef {Object} classes.GridInfo
 * @property {?number} x x coordinate
 * @property {?number} y y coordinate
 * @property {?number} width width in grid
 * @property {?number} height height in grid
 */

/**
 * Layout Statuses
 * @typedef {Object} classes.LayoutStatus
 * @property {boolean} measured has been measured
 * @property {boolean} adjusted has been adjusted
 * @property {boolean} layouted has been layouted
 */
;
"use strict";

modulum('UserInterfaceLayoutEngine', ['LayoutEngineBase'],
  function(context, cls) {
    /**
     * @class UserInterfaceLayoutEngine
     * @memberOf classes
     * @extends classes.LayoutEngineBase
     */
    cls.UserInterfaceLayoutEngine = context.oo.Class(cls.LayoutEngineBase, function($super) {
      return /** @lends classes.UserInterfaceLayoutEngine.prototype */ {
        __name: "UserInterfaceLayoutEngine",

        /**
         * @inheritDoc
         */
        invalidateMeasure: function(invalidation) {
          var invalidated = !invalidation || this._invalidatedMeasure < invalidation;
          $super.invalidateMeasure.call(this, invalidation);
          if (invalidated) {
            this.invalidateAllocatedSpace(this._invalidatedMeasure);
          }
        },

        /**
         * @inheritDoc
         */
        invalidateAllocatedSpace: function(invalidation) {
          var invalidated = !invalidation || this._invalidatedAllocatedSpace < invalidation;
          $super.invalidateAllocatedSpace.call(this, invalidation);
          if (invalidated) {
            this.invalidateMeasure(this._invalidatedAllocatedSpace);
          }
        }
      };
    });
  });
;
"use strict";

modulum("CharSize",
  function(context, cls) {
    /**
     * Data class to store sizes af character in terms of Genero layout.
     * Will store width of a "M", width of a "0", and height of a "M"
     * @class CharSize
     * @memberOf classes
     */
    cls.CharSize = context.oo.Class(function() {
      return /** @lends classes.CharSize.prototype */ {
        $static: /** @lends classes.CharSize */ {
          translate: function(size, widthM, width0) {
            return cls.Size.translate(size, function(s) {
              var result = Math.min(6, s) * widthM;
              if (s > 6) {
                result += (s - 6) * width0;
              }
              return result;
            });
          },
        },
        __name: "CharSize",
        /**
         * @type {classes.SizeValue}
         */
        _widthM: null,
        /**
         * @type {classes.SizeValue}
         */
        _width0: null,
        /**
         * @type {classes.SizeValue}
         */
        _height: null,
        /**
         * @type {number}
         */
        _defaultWidthM: 0,
        /**
         * @type {number}
         */
        _defaultWidth0: 0,
        /**
         * @type {number}
         */
        _defaultHeight: 0,
        /**
         *
         * @param {{widthM:number, width0:number, height:number}} [rawOptions]
         */
        constructor: function(rawOptions) {
          var opts = rawOptions || {};
          this._widthM = Object.isNumber(opts.widthM) ? opts.widthM : 0;
          this._width0 = Object.isNumber(opts.width0) ? opts.width0 : 0;
          this._height = Object.isNumber(opts.height) ? opts.height : 0;
        },

        /**
         * reset values to 0
         */
        reset: function() {
          this._widthM = 0;
          this._width0 = 0;
          this._height = 0;
        },

        /**
         * Return whether or not width of a "M" is set
         * @param {boolean} [considerZero] true to consider 0 as a value
         * @return {boolean} true if width of a "M" is set
         */
        hasWidthM: function(considerZero) {
          return considerZero && !this._widthM || this._widthM > 0;
        },

        /**
         * Return whether or not width of a "0" is set
         * @param {boolean} [considerZero] true to consider 0 as a value
         * @return {boolean} true if width of a "0" is set
         */
        hasWidth0: function(considerZero) {
          return considerZero && !this._width0 || this._width0 > 0;
        },

        /**
         * Return whether or not height of a "M" is set
         * @param {boolean} [considerZero] true to consider 0 as a value
         * @return {boolean} true if height of a "M" is set
         */
        hasHeight: function(considerZero) {
          return considerZero && !this._height || this._height > 0;
        },

        /**
         * Return whether or not widths or height is set
         * @param {boolean} [considerZero] true to consider 0 as a value
         * @return {boolean} true if either widths or height is set
         */
        hasSize: function(considerZero) {
          return (this.hasWidth0(considerZero) && this.hasWidthM(considerZero)) || this.hasHeight(considerZero);
        },

        /**
         * Get the width of a "M"
         * @param {boolean} [useFallback] true to return default "M" width value if not set
         * @return {?number} width of a "M"
         */
        getWidthM: function(useFallback) {
          if (!!useFallback && !this.hasWidthM(true)) {
            return this._defaultWidthM;
          }
          return this._widthM;
        },

        /**
         * Get the width of a "0"
         * @param {boolean} [useFallback] true to return default "0" width value if not set
         * @return {?number} width of a "0"
         */
        getWidth0: function(useFallback) {
          if (!!useFallback && !this.hasWidth0(true)) {
            return this._defaultWidth0;
          }
          return this._width0;
        },

        /**
         * Get the height of a "M"
         * @param {boolean} [useFallback] true to return default "M" height value if not set
         * @return {?number} height of a "M"
         */
        getHeight: function(useFallback) {
          if (!!useFallback && !this.hasHeight(true)) {
            return this._defaultHeight;
          }
          return this._height;
        },

        /**
         * Set the width of a "M"
         * @param {number} widthM the value
         */
        setWidthM: function(widthM) {
          this._widthM = widthM;
        },

        /**
         * Set the width of a "0"
         * @param {number} width0 the value
         */
        setWidth0: function(width0) {
          this._width0 = width0;
        },

        /**
         * Set the height of a "M"
         * @param {number} height the value
         */
        setHeight: function(height) {
          this._height = height;
        }
      };
    });
  });
;
"use strict";

(
  function(context, cls) {
    var _cache = {};

    var getCacheFor = function(fontFamily, fontSize) {
      _cache[fontFamily] = _cache[fontFamily] || {};
      return (_cache[fontFamily][fontSize] = _cache[fontFamily][fontSize] || {
        width: [],
        height: null
      });
    };

    var measureElement = document.createElement("div");
    measureElement.classList.add("measureTool");
    document.body.appendChild(measureElement);

    var measurementHost = document.createElement("div");
    measurementHost.classList.add("measurementHost");
    document.body.appendChild(measurementHost);

    var measureWidth = function(fontFamily, fontSize, size) {
      var cache = getCacheFor(fontFamily, fontSize);
      if (Object.isNumber(cache.width[size])) {
        return cache.width[size];
      } else {
        measureElement.style.fontFamily = fontFamily;
        measureElement.style.fontSize = fontSize;
        measureElement.textContent = cls.Measurement.getTextSample(size, 1);
        // TODO : look further for this add
        // add 7 pixels: to match the width needed for an input with just a 'W' character
        return (cache.width[size] = (measureElement.getBoundingClientRect().width + 7));
      }
    };

    var measureHeight = function(fontFamily, fontSize, size) {
      var cache = getCacheFor(fontFamily, fontSize);
      if (Object.isNumber(cache.height)) {
        return cache.height;
      } else {
        measureElement.style.fontFamily = fontFamily;
        measureElement.style.fontSize = fontSize;
        measureElement.textContent = "X";
        // TODO : look further for this add
        // add 4 pixels: to match the height needed for an input with borders and paddings
        return (cache.height = (Math.max(20, measureElement.getBoundingClientRect().height * size + 4)));
      }
    };

    /**
     * Tool for rendered size measurement
     * Caches measurements for perfs.
     * @namespace classes.Measurement
     */
    cls.Measurement = context.oo.StaticClass(function() {
      return /** @lends classes.Measurement */ {
        __name: "Measurement",
        _samples: {},
        /**
         *
         * @param element
         */
        fontInfo: function(element) {
          var style = window.getComputedStyle(element);
          return {
            "font-family": style.fontFamily,
            "font-size": style.fontSize,
            "font-weight": style.fontWeight
          };
        },
        measuredWidth: function(fontFamily, fontSize, size) {
          return measureWidth(fontFamily, fontSize, size);
        },
        measuredHeight: function(fontFamily, fontSize, size) {
          return measureHeight(fontFamily, fontSize, size);
        },

        getTextSample: function(width, height) {
          var result = this._samples["" + width + "x" + height];
          if (result) {
            return result;
          }
          var i,
            M = Math.min(6, width),
            O = Math.max(0, (width - 6)),
            H = Math.max(height - 1, 0);
          result = [];
          for (i = 0; i < M; i++) {
            result.push("M");
          }
          for (i = 0; i < O; i++) {
            result.push("0");
          }
          for (i = 0; i < H; i++) {
            result.push("\nM");
          }
          result = this._samples["" + width + "x" + height] = result.join("");
          return result;
        }
      };
    });
  })(gbc, gbc.classes);
;
"use strict";

modulum("Size",
  function(context, cls) {
    /**
     * size (width, height)
     * @class Size
     * @memberOf classes
     */
    cls.Size = context.oo.Class(function() {
      return /** @lends classes.Size.prototype */ {
        $static: /** @lends classes.Size */ {
          /**
           * common size value regular expression
           * @type {RegExp}
           */
          valueRE: /([0-9]+)(px|em|ch|ln|col|row)/,

          /**
           * column based size value regular expression
           * @type {RegExp}
           */
          colsRE: /^([0-9]+)(ch|col|co)?$/,

          /**
           * maximal value constant
           * @type {number}
           */
          maximal: Number.POSITIVE_INFINITY,
          /**
           * Test if given value is intented to be a value representing a number of columns
           * @param {string} value - the value to test
           * @return {boolean} true if given value is intented to be a value representing a number of columns
           */
          isCols: function(value) {
            return cls.Size.colsRE.test(value);
          },

          _defaultTranslate: function(size) {
            var ratio = parseFloat(context.ThemeService.getValue("theme-font-size-ratio"));
            if (Number.isNaN(ratio)) {
              ratio = 1;
            }
            return size * 16 * ratio;
          },

          /**
           * translates a raw size in pixels
           * @param {*} size raw size
           * @param {Function|number} baseSize a function that takes size in parameter, or size of an unit
           * @return {number} the pixel size
           */
          translate: function(size, baseSize) {
            var trans = cls.Size._defaultTranslate;
            if (!!baseSize) {
              if (baseSize instanceof Function) {
                trans = baseSize;
              } else if (!Number.isNaN(+baseSize) && (+baseSize > 0)) {
                trans = function(size) {
                  return size * (+baseSize);
                };
              }
            }
            var pxResult = 0;
            if (!!size) {
              if (Object.isNumber(size)) {
                pxResult = trans(size);
              } else {
                var result = cls.Size.valueRE.exec(size);
                if (result) {
                  var numeric = +result[1],
                    unit = result[2];
                  switch (unit) {
                    case "ln":
                      pxResult = trans(numeric);
                      break;
                    case "col":
                      // TODO : read col widths
                      pxResult = trans(numeric * 2);
                      break;
                    case "row":
                      pxResult = numeric * cls.TableWidget.defaultRowHeight;
                      break;
                    case "ch":
                    case "em":
                      pxResult = trans(numeric);
                      break;
                    default:
                      pxResult = numeric;
                      break;
                  }
                }
              }
            }
            return pxResult;
          },
          __cachedPxImportant: {},
          /**
           * get a cached string corresponding to the size en px
           * @param {number} val
           * @return {string}
           */
          cachedPxImportant: function(val) {
            if (!this.__cachedPxImportant[val]) {
              this.__cachedPxImportant[val] = [val, "px !important"].join("");
            }
            return this.__cachedPxImportant[val];
          }
        },
        __name: "Size",

        /**
         * the undefined value
         * @type {*}
         */
        _undefinedValue: null,
        /**
         * the width value
         * @type {classes.SizeValue}
         */
        _width: null,

        /**
         * the height value
         * @type {classes.SizeValue}
         */
        _height: null,

        /**
         * @type {number}
         */
        _defaultWidth: 0,
        /**
         * @type {number}
         */
        _defaultHeight: 0,
        /**
         *
         * @param {Object} [rawOptions] initialization options
         * @param {*} [rawOptions.undefinedValue] value when undefined
         * @param {number} [rawOptions.width] width to initialize
         * @param {number} [rawOptions.height] height to initialize
         * @constructs classes.Size
         */
        constructor: function(rawOptions) {
          var opts = rawOptions || {};
          this._undefinedValue = opts.undefinedValue || 0;
          this._width = Object.isNumber(opts.width) ? opts.width : this._undefinedValue;
          this._height = Object.isNumber(opts.height) ? opts.height : this._undefinedValue;
        },

        /**
         * reset values to undefined value
         */
        reset: function() {
          this._width = this._undefinedValue;
          this._height = this._undefinedValue;
        },

        /**
         * Return whether or not width is set
         * @param {boolean} [considerZero] true to consider 0 as a value
         * @return {boolean} true if width is set
         */
        hasWidth: function(considerZero) {
          return this._width !== this._undefinedValue && (!!considerZero || this._width > 0);
        },

        /**
         * Return whether or not height is set
         * @param {boolean} [considerZero] true to consider 0 as a value
         * @return {boolean} true if height is set
         */
        hasHeight: function(considerZero) {
          return this._height !== this._undefinedValue && (!!considerZero || this._height > 0);
        },

        /**
         * Return whether or not width or height is set
         * @param {boolean} [considerZero] true to consider 0 as a value
         * @return {boolean} true if either width or height is set
         */
        hasSize: function(considerZero) {
          return this.hasWidth(considerZero) || this.hasHeight(considerZero);
        },

        /**
         * Get the width.
         * @param {boolean} [useFallback] return undefined value if width value is not defined
         * @return {number} the width
         */
        getWidth: function(useFallback) {
          if (!!useFallback && !this.hasWidth(true)) {
            return this._defaultWidth;
          }
          return this._width;
        },

        /**
         * Get the height.
         * @param {boolean} [useFallback] return undefined value if height value is not defined
         * @return {number} the height
         */
        getHeight: function(useFallback) {
          if (!!useFallback && !this.hasHeight(true)) {
            return this._defaultHeight;
          }
          return this._height;
        },

        /**
         * Set the width
         * @param {number} width the width. If width is null, sets the undefined value
         */
        setWidth: function(width) {
          if (width === null) {
            this._width = this._undefinedValue;
          } else {
            this._width = width;
          }
        },

        /**
         * Set the height
         * @param {number} height the height. If height is null, sets the undefined value
         */
        setHeight: function(height) {
          if (height === null) {
            this._height = this._undefinedValue;
          } else {
            this._height = height;
          }
        },

        /**
         * Returns a new Size object with values from a substraction of each member
         * @param {classes.Size} size the other size to substract
         * @return {classes.Size} a new instance with the values resulting of a substraction
         */
        minus: function(size) {
          var result = new cls.Size({
            width: this.getWidth(true) - size.getWidth(true),
            height: this.getHeight(true) - size.getHeight(true)
          });
          result._defaultWidth = this._defaultWidth;
          result._defaultHeight = this._defaultHeight;
          return result;
        },

        /**
         * Returns a new Size object with the same values and default values
         * @param {boolean} [useFallback] use default value if value is not defined
         * @return {classes.Size} a new instance with the same values
         */
        clone: function(useFallback) {
          var result = new cls.Size({
            width: this.getWidth(useFallback),
            height: this.getHeight(useFallback)
          });
          result._defaultWidth = this._defaultWidth;
          result._defaultHeight = this._defaultHeight;
          return result;
        },

        /**
         * flip width and height values.
         */
        rotate: function() {
          var width = this.getHeight(true),
            height = this.getWidth(true);
          this._width = width;
          this._height = height;
        }
      };
    });
  });
;
"use strict";

modulum("SizePolicy",
  function(context, cls) {
    /**
     * Size Policy
     * @class SizePolicy
     * @memberOf classes
     */
    cls.SizePolicy = context.oo.Class(function() {
      return /** @lends classes.SizePolicy.prototype */ {
        __name: "SizePolicy",
        $static: /** @lends classes.SizePolicy */ {
          /**
           * @returns {classes.SizePolicy}
           */
          Fixed: function() {
            var result = new cls.SizePolicy();
            result._fixed = true;
            return result;
          },
          /**
           * @returns {classes.SizePolicy}
           */
          Initial: function() {
            var result = new cls.SizePolicy();
            result._growable = true;
            result._shrinkable = true;
            result._initialOnly = true;
            return result;
          },
          /**
           * @returns {classes.SizePolicy}
           */
          InitialGrow: function() {
            var result = new cls.SizePolicy();
            result._growable = true;
            result._initialOnly = true;
            return result;
          },
          /**
           * @returns {classes.SizePolicy}
           */
          InitialShrink: function() {
            var result = new cls.SizePolicy();
            result._shrinkable = true;
            result._initialOnly = true;
            return result;
          },
          /**
           * @returns {classes.SizePolicy}
           */
          Dynamic: function() {
            var result = new cls.SizePolicy();
            result._growable = true;
            result._shrinkable = true;
            result._dynamic = true;
            return result;
          },
          /**
           * @returns {classes.SizePolicy}
           */
          DynamicGrow: function() {
            var result = new cls.SizePolicy();
            result._growable = true;
            result._dynamic = true;
            return result;
          },
          /**
           * @returns {classes.SizePolicy}
           */
          DynamicShrink: function() {
            var result = new cls.SizePolicy();
            result._shrinkable = true;
            result._dynamic = true;
            return result;
          }
        },
        /**
         * @type {boolean}
         */
        _growable: false,
        /**
         * @type {boolean}
         */
        _dynamic: false,
        /**
         * @type {boolean}
         */
        _shrinkable: false,
        /**
         * @type {boolean}
         */
        _initialOnly: false,
        /**
         * @type {boolean}
         */
        _initialDone: false,
        /**
         * @type {boolean}
         */
        _fixed: false,

        /**
         *
         * @returns {boolean}
         */
        canGrow: function() {
          if (this._fixed || this._initialOnly) {
            return false;
          }
          return this._growable;
        },
        /**
         *
         * @returns {boolean}
         */
        canShrink: function() {
          if (this._fixed || this._initialOnly) {
            return false;
          }
          return this._shrinkable;
        },
        setInitialized: function() {
          this._initialDone = true;
        },
        isInitialized: function() {
          return this._initialOnly && this._initialDone;
        },
        isFixed: function() {
          return this._fixed;
        },
        isDynamic: function() {
          return this._dynamic;
        }
      };
    });
  });
;
"use strict";

modulum("SizePolicyConfig", ["SizePolicy"],
  function(context, cls) {
    /**
     * Size Policy Config
     * @class SizePolicyConfig
     * @memberOf classes
     */
    cls.SizePolicyConfig = context.oo.Class(function() {
      return /** @lends classes.SizePolicyConfig.prototype */ {
        __name: "SizePolicyConfig",

        /**
         * @type {classes.SizePolicy}
         */
        fixed: null,
        /**
         * @type {classes.SizePolicy}
         */
        initial: null,
        /**
         * @type {classes.SizePolicy}
         */
        dynamic: null,
        /**
         * @type {string}
         */
        mode: "initial",
        _defaultMode: "initial",
        /**
         * @type {boolean}
         */
        measured: false,
        /**
         *
         */
        constructor: function() {
          this.reset();
        },
        reset: function() {
          this.fixed = cls.SizePolicy.Fixed();
          this.initial = cls.SizePolicy.Initial();
          this.dynamic = cls.SizePolicy.Dynamic();
        },
        needMeasure: function() {
          var status = this.getMode();
          if (!!status.isFixed()) {
            return !this.measured;
          }
          return !status.isInitialized() || !this.measured;
        },
        setMeasured: function() {
          this.measured = true;
        },
        /**
         * @returns {classes.SizePolicy}
         */
        getMode: function() {
          return this[this.mode] || this.initial;
        },
        /**
         *
         * @param {string} mode
         */
        setMode: function(mode) {
          this.mode = mode || this._defaultMode;
        },

        isInitial: function() {
          return this.mode === "initial";
        },

        isDynamic: function() {
          return this.mode === "dynamic";
        },

        isFixed: function() {
          return this.mode === "fixed";
        }
      };
    });
  });
;
"use strict";

modulum("Stretch",
  function(context, cls) {
    /**
     * Stretch (x, y)
     * @class Stretch
     * @memberOf classes
     */
    cls.Stretch = context.oo.Class(function() {
      return /** @lends classes.Stretch.prototype */ {
        $static: /** @lends classes.Stretch */ {
          undef: {}
        },
        __name: "Stretch",
        /**
         * x-stretch value
         * @type {boolean|object}
         */
        _x: null,
        /**
         * y-stretch value
         * @type {boolean|object}
         */
        _y: null,
        /**
         * x-stretch opportunistic value
         * @type {boolean}
         */
        _opportunisticX: false,
        /**
         * y-stretch opportunistic value
         * @type {boolean}
         */
        _opportunisticY: false,
        /**
         * x-stretch default value
         * @type {boolean}
         */
        _defaultX: false,
        /**
         * y-stretch default value
         * @type {boolean}
         */
        _defaultY: false,
        /**
         * @constructs
         * @param {Object} [rawOptions] initialization options
         * @param {number} [rawOptions.x] x-stretch to initialize
         * @param {number} [rawOptions.y] y-stretch to initialize
         */
        constructor: function(rawOptions) {
          var opts = rawOptions || {};
          this._x = opts.x || cls.Stretch.undef;
          this._y = opts.y || cls.Stretch.undef;
        },

        /**
         * reset values
         */
        reset: function() {
          this._x = cls.Stretch.undef;
          this._y = cls.Stretch.undef;
          this._opportunisticX = false;
          this._opportunisticY = false;
        },

        /**
         * Returns whether or not has a x-stretch value
         * @return {boolean} true if has a x-stretch value
         */
        isXDefined: function() {
          return this._x !== cls.Stretch.undef;
        },

        /**
         * Returns whether or not has a y-stretch value
         * @return {boolean} true if has a y-stretch value
         */
        isYDefined: function() {
          return this._y !== cls.Stretch.undef;
        },

        /**
         * Get x-stretch value
         * @param {boolean} [useFallback] return default value if no value
         * @return {*} x-stretch value
         */
        getX: function(useFallback) {
          if (!!useFallback && !this.isXDefined()) {
            return this._defaultX;
          }
          return this._x;
        },

        /**
         * Get y-stretch value
         * @param {boolean} [useFallback] return default value if no value
         * @return {*} y-stretch value
         */
        getY: function(useFallback) {
          if (!!useFallback && !this.isYDefined()) {
            return this._defaultY;
          }
          return this._y;
        },

        /**
         * Set x-stretch value
         * @param {boolean} x value
         */
        setX: function(x) {
          if (x === null) {
            this._x = cls.Stretch.undef;
          } else {
            this._x = x;
          }
        },
        /**
         * Set y-stretch value
         * @param {boolean} y value
         */
        setY: function(y) {
          if (y === null) {
            this._y = cls.Stretch.undef;
          } else {
            this._y = y;
          }
        },

        /**
         * Get x opportunistic stretch value (e.g. would only stretch if other elements sharing stretching dimentsion stretches)
         * @return {boolean} x opportunistic stretch value
         */
        getOpportunisticX: function() {
          return this._opportunisticX;
        },

        /**
         * Get y opportunistic stretch value (e.g. would only stretch if other elements sharing stretching dimentsion stretches)
         * @return {boolean} y opportunistic stretch value
         */
        getOpportunisticY: function() {
          return this._opportunisticY;
        },

        /**
         * Set x opportunistic stretch value
         * @param {boolean} x opportunistic stretch value
         */
        setOpportunisticX: function(x) {
          this._opportunisticX = x;
        },

        /**
         * Set y opportunistic stretch value
         * @param {boolean} y opportunistic stretch value
         */
        setOpportunisticY: function(y) {
          this._opportunisticY = y;
        },

        /**
         * Set x-stretch default value
         * @param {boolean} x default value
         */
        setDefaultX: function(x) {
          this._defaultX = x;
        },

        /**
         * Set y-stretch default value
         * @param {boolean} y default value
         */
        setDefaultY: function(y) {
          this._defaultY = y;
        }
      };
    });
  });
;
"use strict";
modulum('ApplicationEnding',
  function(context, cls) {
    /**
     * application ending
     * @class ApplicationEnding
     * @memberOf classes
     */
    cls.ApplicationEnding = context.oo.Class(
      /** @lends classes.ApplicationEnding.prototype */
      {
        __name: "ApplicationEnding",
        normal: false,
        flag: null,
        message: null,
        constructor: function(isNormal, flag) {
          this.normal = isNormal;
          this.flag = flag;
        }
      });
    cls.ApplicationEnding.ok = new cls.ApplicationEnding(true);
    cls.ApplicationEnding.notok = function(message) {
      var result = new cls.ApplicationEnding(false, "notok");
      result.message = message;
      gbc.LogService.networkProtocol.error(message);
      return result;
    };
    cls.ApplicationEnding.notFound = new cls.ApplicationEnding(false, "notFound");
    cls.ApplicationEnding.forbidden = new cls.ApplicationEnding(false, "forbidden");
    cls.ApplicationEnding.uaProxy = function(message) {
      var result = new cls.ApplicationEnding(false, "uaProxy");
      result.message = message;
      return result;
    };
    cls.ApplicationEnding.autoLogout = function(message) {
      var result = new cls.ApplicationEnding(false, "autoLogout");
      result.message = message;
      return result;
    };
    cls.ApplicationEnding.logPlayer = new cls.ApplicationEnding(true, "hidden");

  });
;
"use strict";

modulum('ActionApplicationService', ['ApplicationServiceBase', 'ApplicationServiceFactory'],
  function(context, cls) {
    /**
     * @class ActionApplicationService
     * @memberOf classes
     * @extends classes.ApplicationServiceBase
     */
    cls.ActionApplicationService = context.oo.Class(cls.ApplicationServiceBase, function($super) {
      /** @lends classes.ActionApplicationService.prototype */
      return {
        __name: "ActionApplicationService",
        $static: /** @lends classes.ActionApplicationService */ {
          /**
           * list of local actions with corresponding key accelerator
           * @type {Object}
           */
          _localActions: {
            'nextfield': 'tab',
            'prevfield': 'shift-tab',
            'nextrow': 'down',
            'prevrow': 'up',
            'firstrow': 'home',
            'lastrow': 'end',
            'nextpage': 'next',
            'prevpage': 'prior',
            'nexttab': 'control-tab',
            'prevtab': 'control-shift-tab'
          },

          /**
           * Returns local action names
           *  @returns {String[]}
           */
          getLocalActionNames: function() {
            return Object.keys(this._localActions);
          },

          /**
           * Returns local action accelerators
           *  @returns {String[]}
           */
          getLocalActionAccelerators: function() {
            return Object.values(this._localActions);
          },

          /**
           * Returns default keyboard accelerator for a local action
           * @param {string} actionName
           * @returns {?string} accelerator
           */
          getLocalActionAccelerator: function(actionName) {
            return this._localActions[actionName];
          },

          /** Returns local action name for an accelerator
           * @param {string} acc
           * @returns {?string} actionName
           */
          getLocalActionName: function(acc) {
            var accelerators = this.getLocalActionAccelerators();
            var names = this.getLocalActionNames();
            for (var i = 0; i < accelerators.length; ++i) {
              if (acc === accelerators[i]) {
                return names[i];
              }
            }
            return null;
          },

          /**
           * Browser native actions
           * @type {String[]}
           */
          browserNativeActions: ["editcopy", "editcut", "editpaste"],

          /**
           * static list of special actions
           * @type {Map<string, Object>}
           */
          _specialActions: new Map(),

          /**
           * Add special action in the list
           * @param {string} name - action name
           * @param {Object} ctor - action class typeref
           */
          registerSpecialAction: function(name, ctor) {
            this._specialActions.set(name, ctor);
          },
          /**
           * Remove special action in the list
           * @param {string} name - action name
           */
          unregisterSpecialAction: function(name) {
            this._specialActions.delete(name);
          }
        },
        /**
         * list of special actions
         * @type {Map<string, Object>}
         */
        _specialActions: null,
        /**
         * list of actions
         * @type {Map<string, classes.ActionNode>}
         */
        _actions: null,

        /**
         * list of actions defaults
         * @type {Map<string, classes.ActionDefaultNode>}
         */
        _actionDefaults: null,

        /**
         * List of bound actions filtered by browser key
         * @type {Map<string, Array>}
         */
        _boundActions: null,

        /**
         * List of interrupt widgets
         * @type {Array}
         */
        _interruptWidgets: null,
        /**
         * @inheritDoc
         */
        constructor: function(app) {
          $super.constructor.call(this, app);
          this._interruptWidgets = [];
          this._actionDefaults = new Map();
          this._boundActions = new Map();
          this._actions = new Map();
          this._specialActions = new Map();
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._specialActions.clear();
          this._actions.clear();
          this._actionDefaults.clear();
          this._boundActions.clear();

          this._interruptWidgets = null;
          this._specialActions = null;
          this._actions = null;
          this._actionDefaults = null;
          this._boundActions = null;

          $super.destroy.call(this);
        },
        /**
         * Add a new action to this App Service
         * @param {classes.ActionNode} action node
         */
        registerAction: function(action) {
          var name = action.attribute("name");
          this._actions.set(name, action);
          this._bindAccelerators(action);
          if (cls.ActionApplicationService._specialActions.has(name)) {
            var actionConstructor = cls.ActionApplicationService._specialActions.get(name);
            this._specialActions.set(name, new actionConstructor(this));
          }
          if (name === "interrupt") {
            for (var i = 0; i < this._interruptWidgets.length; i++) {
              this._interruptWidgets[i].setInterruptable(false);
            }
          }

          // Add action to application contextMenu
          var applicationWidget = this._application.getUI().getWidget();
          if (applicationWidget && applicationWidget.getContextMenu()) {
            var contextMenuWidget = applicationWidget.getContextMenu();
            var contextMenu = action.attribute('contextMenu');
            var addInCtxMenu = contextMenu === 'yes' || contextMenu === 'auto';
            /*
            // GBC-1824 regression : need to handle this case
            var defaultView = action.attribute('defaultView');
            if(defaultView === 'no' && isActionInForm()){ // Need implementation of this isActionInForm method
              addInCtxMenu = false;
            }
            */
            if (addInCtxMenu) {
              // Do not add to contextMenu if not action (e.g MenuAction)
              if (action._tag === "Action") {
                var actionText = action.attribute("text").replace(/&(.)/g, "$1"); // Filter ampersand
                contextMenuWidget.addAction(action.attribute("name"),
                  actionText,
                  action.attribute("image"),
                  action.attribute("acceleratorName").toString(), {
                    clickCallback: function() {
                      contextMenuWidget.hide();
                      action.execute();
                    }.bind(this),
                    hidden: action.attribute("hidden")
                  });
              }
            }
          }
        },

        /**
         * Add a new actionDefault to this App Service
         * @param {classes.NodeBase} action node
         */
        registerActionDefault: function(action) {
          this._actionDefaults.set(action.attribute("name"), action);

          this._bindAccelerators(action);
        },

        /**
         * Bind an action to VM accelerators
         * @param {classes.NodeBase} action node
         */
        _bindAccelerators: function(action) {
          var key1 = cls.KeyboardHelper.convertVMKeyToBrowserKey(action.attribute("acceleratorName"));
          var key2 = cls.KeyboardHelper.convertVMKeyToBrowserKey(action.attribute("acceleratorName2"));
          var key3 = cls.KeyboardHelper.convertVMKeyToBrowserKey(action.attribute("acceleratorName3"));
          var key4 = cls.KeyboardHelper.convertVMKeyToBrowserKey(action.attribute("acceleratorName4"));

          if (key1) {
            this._bindAccelerator(key1, action);
          }
          // we make sure to not bind same action two times :
          // for example, Enter and Return VM accelerators are both considered as Enter key from browser
          // so we only have to bind one action to this key even if there are two accelerators defined on it
          if (key2 && key2 !== key1) {
            this._bindAccelerator(key2, action);
          }
          if (key3 && key3 !== key1 && key3 !== key2) {
            this._bindAccelerator(key3, action);
          }
          if (key4 && key4 !== key1 && key4 !== key2 && key4 !== key3) {
            this._bindAccelerator(key4, action);
          }
        },

        /**
         * Bind action to browser key
         * @param {string} key - DOM key combination
         * @param {classes.NodeBase} action node
         */
        _bindAccelerator: function(key, action) {
          //erase previous action to keep the last one
          this._boundActions.set(key, []);
          var actions = this._boundActions.get(key);
          if (!actions.contains(action._id)) {
            // push new action in the list
            actions.push(action._id);
          }
        },

        /**
         * Unbind an action from VM accelerators
         * @param {classes.NodeBase} action node
         */
        _unbindAccelerators: function(action) {
          // Remove all accelerator bound for this action...
          var key1 = cls.KeyboardHelper.convertVMKeyToBrowserKey(action.attribute("acceleratorName"));
          var key2 = cls.KeyboardHelper.convertVMKeyToBrowserKey(action.attribute("acceleratorName2"));
          var key3 = cls.KeyboardHelper.convertVMKeyToBrowserKey(action.attribute("acceleratorName3"));
          var key4 = cls.KeyboardHelper.convertVMKeyToBrowserKey(action.attribute("acceleratorName4"));

          if (key1) {
            this._unbindAccelerator(key1, action);
          }
          // we make sure to not unbind same action two times :
          // for example, Enter and Return VM accelerators are both considered as Enter key from browser
          // so we only have to unbind one action from this key even if there are two accelerators defined on it
          if (key2 && key2 !== key1) {
            this._unbindAccelerator(key2, action);
          }
          if (key3 && key3 !== key1 && key3 !== key2) {
            this._unbindAccelerator(key3, action);
          }
          if (key4 && key4 !== key1 && key4 !== key2 && key4 !== key3) {
            this._unbindAccelerator(key4, action);
          }
        },

        /**
         * Unbind action from browser key
         * @param {string} key browser key
         * @param {classes.NodeBase} action node
         */
        _unbindAccelerator: function(key, action) {
          var keyActionIdArray = this._boundActions.get(key);
          if (keyActionIdArray) {
            // remove action id from our active actions list
            keyActionIdArray.remove(action._id);
            if (keyActionIdArray.length === 0) {
              this._boundActions.delete(key);
            }
          }
        },

        /**
         * Get the action by its name
         * @param {?string} name of the action
         * @returns {classes.NodeBase} action node
         */
        getAction: function(name) {
          return this._actions.get(name);
        },

        /**
         * Test if the action is registered
         * @param {string} name of the action
         * @returns {boolean} action node
         */
        hasAction: function(name) {
          return this._actions.has(name);
        },

        /**
         * Remove the action and unbind accelerators
         * @param {classes.NodeBase} action
         */
        destroyAction: function(action) {
          this._unbindAccelerators(action);

          var name = action.attribute("name");
          this._actions.delete(name);
          if (this._specialActions.has(name)) {
            this._specialActions.get(name).destroy();
            this._specialActions.delete(name);
          }

          // Remove action from app contextMenu
          var applicationWidget = this._application.getUI().getWidget();
          if (applicationWidget && applicationWidget.getContextMenu()) {
            var contextMenu = applicationWidget.getContextMenu();
            contextMenu.removeAndDestroyAction(name, false);
          }
        },

        /**
         * Remove the actionDefault and unbind accelerators
         * @param {classes.NodeBase} action
         */
        destroyActionDefault: function(action) {
          this._unbindAccelerators(action);

          var acceleratorName = action.attribute("name");
          this._actionDefaults.delete(acceleratorName);
        },

        /**
         * Execute an action by knowing its name
         * @param {string} name of the action
         * @param {classes.NodeBase=} additionalValueNode an additional value node which value should be sent to the VM too. (CheckBox special case)
         * @param {object=} options
         */
        executeByName: function(name, additionalValueNode, options) {
          var action = this.getAction(name);
          if (!!action) {
            this.execute(action._id, additionalValueNode, options);
          } else {
            // TODO GBC-1760 why call this it is done in execute function
            this.executeActionDefaultByName(name);
          }
        },

        /**
         * Execute an action by knowing its name
         * @param {?string} name of the action
         * @param {object=} options
         */
        executeActionDefaultByName: function(name, options) {
          options = options || {};
          var actionEvent = null;

          // TODO: GBC-1760: for me this code seems to be wrong
          // TODO GBC-1760 why we don't do this in typeaheadAction
          // why for all local actions we don't execute same code ?
          if (cls.ActionApplicationService.getLocalActionNames().contains(name)) {
            switch (name) {
              case "nextfield":
                // what if local action AND action have the same name?
                actionEvent = new cls.VMKeyEvent("Tab");
                break;
              case "prevfield":
                actionEvent = new cls.VMKeyEvent("Shift-Tab");
                break;
              case "nextrow":
                actionEvent = new cls.VMKeyEvent("Down");
                break;
              case "prevrow":
                actionEvent = new cls.VMKeyEvent("Up");
                break;
              default:
                var action = this._actionDefaults.get(name);
                var accelerator = action && action.attribute("acceleratorName");
                if (accelerator && accelerator.toString().length > 0) {
                  actionEvent = new cls.VMKeyEvent(accelerator);
                }
                break;
            }
          }
          if (actionEvent) {
            actionEvent.noUserActivity = !!options.noUserActivity;

            this._registerAnimationFrame(function() {
              var focusedNode = this._application.getFocusedVMNode();
              var ctrl = focusedNode.getController();
              if (ctrl) {
                ctrl.sendWidgetCursors();
                ctrl.sendWidgetValue();
              }

              this._application.typeahead.event(actionEvent);
            }.bind(this));
          }
        },

        /**
         * Execute an action by knowing its ID
         * @param {number} idRef of the action
         * @param {classes.NodeBase=} additionalValueNode an additional value node which value should be sent to the VM too. (CheckBox special case)
         * @param {object=} options
         */
        execute: function(idRef, additionalValueNode, options) {
          options = options || {};
          var actionNode = this._application.getNode(idRef);
          var actionName = actionNode ? actionNode.attribute("name") : null;

          if (!this.getAction(actionName) && cls.ActionApplicationService.getLocalActionNames().contains(actionName)) {
            this.executeActionDefaultByName(actionName, options);
            return;
          }

          if (cls.ActionApplicationService.browserNativeActions.contains(actionName)) {
            return;
          }

          this._application.typeahead.startGroupCommand();

          var focusedNode = this._application.focus.getFocusedNode();
          if (focusedNode && options.sendValue) {
            var ctrl = focusedNode.getController();
            if (ctrl) {
              ctrl.sendWidgetCursors();
              ctrl.sendWidgetValue();
              // if there is an additionalValueNode must send its value
              if (additionalValueNode && focusedNode !== additionalValueNode && additionalValueNode.getController()) {
                additionalValueNode.getController().sendWidgetValue();
              }
            }
          }
          this._application.typeahead.action(actionNode, !!options.noUserActivity);
          this._application.typeahead.finishGroupCommand();
        },

        registerInterruptWidget: function(widget) {
          this._interruptWidgets.push(widget);
          widget.setInterruptableActive(this._application.isProcessing());
        },
        unregisterInterruptWidget: function(widget) {
          widget.setInterruptableActive(false);
          this._interruptWidgets.remove(widget);
        },
        setInterruptablesActive: function(isActive) {
          for (var i = 0; i < this._interruptWidgets.length; i++) {
            this._interruptWidgets[i].setInterruptableActive(isActive);
          }
        },
        /** Return the action node of active dialog for a given action name
         *
         * @param actionName the name of the action
         * @returns {?classes.NodeBase} an action node
         */
        getActiveDialogAction: function(actionName) {
          var uiNode = this._application.uiNode();
          if (uiNode) {
            var window = this._application.getVMWindow();
            if (window) { // search the action in the current dialog
              var dialog = window.getActiveDialog();
              if (dialog) {
                var actions = dialog.getChildren();
                for (var i = 0; i < actions.length; ++i) {
                  var action = actions[i];
                  var isActive = (action.attribute("active") !== 0);
                  if (isActive) {
                    if (action.attribute("name") === actionName) {
                      return action;
                    }
                  }
                }
              }
            }
          }
          return null;
        },
      };
    });
    cls.ApplicationServiceFactory.register("Action", cls.ActionApplicationService);
  });
;
"use strict";

modulum('ApplicationServiceBase', ['EventListener'],
  function(context, cls) {
    /**
     * Base class of application scoped services
     * @class ApplicationServiceBase
     * @memberOf classes
     * @extends classes.EventListener
     */
    cls.ApplicationServiceBase = context.oo.Class(cls.EventListener, function($super) {
      return /** @lends classes.ApplicationServiceBase.prototype */ {
        __name: "ApplicationServiceBase",
        /**
         * owner
         * @protected
         * @type classes.VMApplication
         */
        _application: null,
        /**
         *
         * @param {classes.VMApplication} app owner
         */
        constructor: function(app) {
          $super.constructor.call(this);
          this._application = app;
        },
        /**
         * frees memory hooks of this service (typically when application is destroyed)
         */
        destroy: function() {
          this._application = null;
          $super.destroy.call(this);
        },
        /**
         * Get owning application
         * @publicdoc
         * @return {classes.VMApplication} the owning application
         */
        getApplication: function() {
          return this._application;
        }
      };
    });
  });
;
"use strict";

modulum('ApplicationServiceFactory', ['Factory'],

  function(context, cls) {
    /**
     * @namespace classes.ApplicationServiceFactory
     */
    cls.ApplicationServiceFactory = context.oo.StaticClass(function() {
      var factory = new cls.Factory("Application Service");
      return /** @lends classes.ApplicationServiceFactory */ {
        /**
         *
         * @param {string} type
         * @param {Function} constructor
         */
        register: function(type, constructor) {
          factory.register(type, constructor);
        },
        /**
         *
         * @param {string} type
         */
        unregister: function(type) {
          factory.unregister(type);
        },
        /**
         *
         * @param {string} type
         * @param {...args} args
         * @returns {classes.ApplicationServiceBase}
         */
        create: function(type, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9) {
          return factory.create(type, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
        }
      };
    });
  });
;
"use strict";

modulum('AuiApplicationService', ['ApplicationServiceBase', 'ApplicationServiceFactory'],
  function(context, cls) {
    /**
     * AUI tree model store
     * @class AuiApplicationService
     * @memberOf classes
     * @extends classes.ApplicationServiceBase
     */
    cls.AuiApplicationService = context.oo.Class(cls.ApplicationServiceBase, function($super) {
      return /** @lends classes.AuiApplicationService.prototype */ {
        __name: "AuiApplicationService",
        nodeHash: null,
        // logs
        contents: null,
        file: null,

        /**
         * @param {classes.VMApplication} app the owner application
         */
        constructor: function(app) {
          $super.constructor.call(this, app);
          this.nodeHash = [];
          this.contents = ["LOGVERSION=2"];
        },

        /**
         * Clears the model
         */
        stop: function() {
          this.nodeHash.length = 0;
        },

        /**
         * Destroys the service
         */
        destroy: function() {
          this.nodeHash.length = 0;
          this.contents.length = 0;
          $super.destroy.call(this);
        },

        /**
         * Get a node object
         * @param {number|String} id - id of the Node to get
         * @returns {classes.NodeBase} Node Object
         */
        getNode: function(id) {
          if (Object.isNumber(id)) {
            return this.nodeHash[id];
          }
          if (Object.isString(id)) {
            return this.nodeHash[parseInt(id, 10)];
          }
          return null;
        },

        getNodesFrom: function(id, currentBag) {
          var result = currentBag || [];
          var localRoot = Object.isNumber(id) ? this.getNode(id || 0) : id;
          if (localRoot) {
            result.push(localRoot);
            for (var i = 0; i < localRoot.children.length; i++) {
              this.getNodesFrom(localRoot.children[i], result);
            }
          }
          if (!currentBag) {
            return result;
          } else {
            return null;
          }
        },

        /**
         * Add a node to the model
         * @param {number} id node idRef
         * @param {classes.NodeBase} node AUI tree node
         */
        addNode: function(id, node) {
          this.nodeHash[id] = node;
        },

        /**
         * Searches the nodes with the corresponding attribute and value
         * @param {string} attr attribute name
         * @param {string} value attribute value
         * @return {classes.NodeBase[]} the found node or null
         */
        getNodeByAttribute: function(attr, value) {
          return this.nodeHash.find(function(node) {
            return node ? node.attribute(attr) === value : false;
          });
        },

        /**
         * Searches the nodes with the corresponding tag
         * @param {string} tag node tag
         * @return {classes.NodeBase} the found nodes
         */
        getNodesByTag: function(tag) {
          return this.nodeHash.filter(function(node) {
            return node ? node.getTag() === tag : false;
          });
        },

        /**
         * Removes the node from the store
         * @param {number} id node idRef
         */
        removeNode: function(id) {
          this.nodeHash[id] = null;
        },

        /**
         * Creates and adds a node subtree to the store
         * @param {*} omCommand parsed VM command
         * @param {classes.TreeModificationTracker} treeModificationTrack tree modifications log
         * @return {classes.NodeBase} root of the created subtree
         */
        commandAdd: function(omCommand, treeModificationTrack) {
          var parentNode = (omCommand.node.id === 0) ? null : this.getNode(omCommand.parent);
          var partRootNode = null;
          if (this._application) {
            partRootNode = gbc.classes.NodeFactory.createRecursive(parentNode, omCommand.node, this._application,
              treeModificationTrack);
          }
          return partRootNode;
        },

        /**
         * Update nodes attributes
         * @param {*} omCommand parsed VM command
         * @param {classes.TreeModificationTracker} treeModificationTrack tree modifications log
         * @return {boolean} true if a relayout is required, false otherwise
         */
        commandUpdate: function(omCommand, treeModificationTrack) {
          var needRelayout = false,
            node = this.getNode(omCommand.id),
            attrsKeys = Object.keys(omCommand.attributes);
          if (omCommand.attributes && attrsKeys.length) {
            if (!treeModificationTrack.isNodeCreated(omCommand.id)) {
              var i = 0,
                len = attrsKeys.length;
              for (; i < len; i++) {
                var attr = attrsKeys[i];
                needRelayout = needRelayout || !!cls.LayoutTriggerAttributes[omCommand.type][attr];
                treeModificationTrack.attributeChanged(omCommand.id, attr);
              }
            }
          }
          node.updateAttributes(omCommand.attributes);
          return needRelayout;
        },

        /**
         * Handles VM node removal order
         * @param {number} omNode node idRef
         */
        remove: function(omNode) {
          var nodeToRemove = omNode || this._application && this._application.uiNode();
          if (nodeToRemove) {
            nodeToRemove.destroy();
          }
        },

        logFireEvent: function(eventContents) {

          // NOTE used to generate VM log (disabled temporally)

          var logItem = "" + this._application.applicationHash + ":FE:0:" + eventContents;

          /* if (context.$app._dvmLogger !== this) {
           context.$app._dvmLogger.contents.push(logItem);
           } else {
           this.contents.push(logItem);
           }*/
        },

        logDvm: function(dvmContents) {

          // NOTE used to generate VM log (disabled temporally)

          var logItem = "" + this._application.applicationHash + ":DVM:0:" + dvmContents;
          /* if (context.$app._dvmLogger !== this) {
           context.$app._dvmLogger.contents.push(logItem);
           } else {
           this.contents.push(logItem);
           }*/
        },

        linkDownload: function() {
          var data = new Blob([this.contents.join("\n")], {
            type: "text/plain"
          });

          if (this.file !== null) {
            window.URL.revokeObjectURL(this.file);
          }
          this.file = window.URL.createObjectURL(data);
          this._application.getSession().getWidget().getEndWidget().setAuiLogUrl(this._application.info().session, this.file);
        }
      };
    });
    cls.ApplicationServiceFactory.register("Model", cls.AuiApplicationService);
  });
;
"use strict";

modulum('DVMApplicationService', ['ApplicationServiceBase', 'ApplicationServiceFactory'],
  function(context, cls) {
    /**
     * Application Service to manage DVM interactions for an application
     *
     * @class DVMApplicationService
     * @memberOf classes
     * @extends classes.ApplicationServiceBase
     */
    cls.DVMApplicationService = context.oo.Class(cls.ApplicationServiceBase,
      function($super) {
        return /** @lends classes.DVMApplicationService.prototype */ {

          __name: "DVMApplicationService",
          /** Indicator to know if DVM is idle or not */
          idle: true,
          _managingOrders: false,
          processed: false,
          /**
           * @constructs
           * @param app
           */
          constructor: function(app) {
            $super.constructor.call(this, app);
          },

          destroy: function() {
            $super.destroy.call(this);
          },

          updateProcessingStatus: function() {
            var menu = this._getMenu("runtimeStatus");
            if (menu) {
              if (this.idle) {
                menu.setIdle();
                this._application.getUI().getWidget().removeClass("processing");
              } else {
                menu.setProcessing();
                this._application.getUI().getWidget().addClass("processing");
              }
            }
          },

          setIdle: function(isIdle) {
            this.idle = isIdle;
            if (!this.processed && this.idle) {
              this.processed = true;
            }
            this.updateProcessingStatus();
            this.emit(context.constants.baseEvents.idleChanged);

          },
          onOrdersManaged: function(hook, once) {
            return this.when(context.constants.baseEvents.ordersManaged, hook, once);
          },
          afterManagingCurrentOrders: function(hook) {
            if (this._managingOrders) {
              this.when(context.constants.baseEvents.ordersManaged, hook, true);
            } else {
              hook();
            }
          },
          onIdleChanged: function(hook) {
            return this.when(context.constants.baseEvents.idleChanged, hook);
          },

          manageAuiOrders: function(data, callback) {
            this._managingOrders = true;

            var treeModificationTrack = new cls.TreeModificationTracker(),
              nodesWithDom = [];
            var vmMessages = cls.AuiProtocolReader.translate(data);
            context.styler.bufferize();
            this._application.getUI().getWidget().bufferizeDom(true);
            var needLayout = false;
            var hasAddedRemovedNodes = false;
            var initialOrder = vmMessages.length && vmMessages[0] && vmMessages[0].id === 0 && vmMessages[0];
            // 1. readOrder : create nodes
            while (vmMessages.length) {
              if (this._application) {
                var order = vmMessages.shift();
                if (order.type !== "om") {
                  throw "Received auiTree bad format : " + order;
                }
                var result = this.manageAuiOrder(order, treeModificationTrack, nodesWithDom);
                needLayout = needLayout || result.needLayout;
                hasAddedRemovedNodes = hasAddedRemovedNodes || result.hasAddedRemovedNodes;
                if (vmMessages.length !== 0 && treeModificationTrack.isNodeAttributeChanged(0, 'runtimeStatus')) {
                  // We don't apply behaviors before reading all VM orders
                  // except for runtimeStatus which must be managed immediately
                  // to handle the transitive 'childstart' status
                  var runtimeStatusTracker = new cls.TreeModificationTracker();
                  runtimeStatusTracker.attributeChanged(0, 'runtimeStatus');
                  this._application.getNode(0).applyBehaviors(runtimeStatusTracker);
                }
              }
            }

            var callbackDone = false;
            var rootNode = this._application && this._application.getNode(0);

            if (!!rootNode) {
              treeModificationTrack.attributeChanged(0, "runtimeStatus");

              var runtimeStatus = rootNode.attribute('runtimeStatus');
              if (runtimeStatus === "childstart" || runtimeStatus === "processing") {
                callbackDone = true;
                if (!!callback) {
                  callback();
                }
              }

              if (initialOrder) {
                treeModificationTrack.attributeChanged(0, "focus");
              }

              var nodes = this._application.model.nodeHash;
              var node = null;
              for (var i = 0; i < nodes.length; ++i) {
                node = nodes[i];
                if (node) {
                  node.resetActivePseudoSelectors();
                }
              }

              // 2. update styles
              if (this._application.styleListsChanged || this._application.styleAttributesChanged.length || hasAddedRemovedNodes) {
                rootNode.updateApplicableStyles(true, this._application.styleListsChanged,
                  this._application.styleAttributesChanged, treeModificationTrack);
                this._application.usedStyleAttributes = {};
                var styleLists = rootNode.getChildren('StyleList');
                for (i = 0; i < styleLists.length; i++) {
                  var styles = styleLists[i].getChildren();
                  for (var j = 0; j < styles.length; ++j) {
                    var styleAttributes = styles[j].getChildren();
                    for (var k = 0; k < styleAttributes.length; ++k) {
                      this._application.usedStyleAttributes[styleAttributes[k].attribute('name')] = true;
                    }
                  }
                }
                for (i = 0; i < nodes.length; ++i) {
                  node = nodes[i];
                  if (node) {
                    node.resetPseudoSelectorsUsedInSubTree();
                  }
                }
                for (i = 0; i < nodes.length; ++i) {
                  node = nodes[i];
                  if (node) {
                    node.updatePseudoSelectorsUsedInSubTree();
                  }
                }
                treeModificationTrack.forEach(function(mods, idRef) {
                  if (mods.created && !mods.removed) {
                    var node = this._application.getNode(idRef);
                    if (node) {
                      node.setInitialStyleAttributes();
                    }
                  }
                }.bind(this));
              }

              // 3. create controllers + widgets
              this._createControllers(treeModificationTrack);
              this._notifyUpdatedAttributes(treeModificationTrack);

              if (this._application.styleListsChanged || this._application.styleAttributesChanged.length || hasAddedRemovedNodes) {
                for (i = 0; i < nodes.length; ++i) {
                  node = nodes[i];
                  if (node) {
                    var controller = node.getController();
                    if (controller) {
                      controller.setStyleBasedBehaviorsDirty(true, true);
                    }
                  }
                }
              }

              this._application.styleListsChanged = false;
              this._application.styleAttributesChanged = [];

              var stillDirty = true;
              // 4. Apply behaviors
              while (stillDirty) {
                stillDirty = rootNode.applyBehaviors(treeModificationTrack, true);
              }

              // 5. Add root widget to DOM
              for (i = 0; i < nodesWithDom.length; i++) {
                if (!nodesWithDom[i].getParentNode()) {
                  if (nodesWithDom[i].getController()) {
                    this._application.attachRootWidget(nodesWithDom[i].getController().getWidget());
                  }
                }
              }
            }
            this._application.getUI().getWidget().bufferizeDom(false);
            context.styler.flush();
            if (this._application) {
              this._application.layout.refreshLayout();
            }
            if (!callbackDone) {
              if (!!callback) {
                callback();
              }
            }
            if (this._application) {
              var isCurrentApp = context.SessionService.getCurrent().getCurrentApplication() === this._application;
              this._application.typeahead.validateLastCommand(isCurrentApp);
            }
            this._managingOrders = false;
            this.emit(context.constants.baseEvents.ordersManaged, data);
          },

          manageAuiOrder: function(order, treeModificationTrack, nodesWithDom) {
            var result = {
              needLayout: false,
              hasAddedRemovedNodes: false
            };
            var node;
            var i;
            for (var index = 0; index < order.operations.length; index++) {
              var cmd = order.operations[index];
              switch (cmd.type) {
                case "update":
                  result.needLayout = this._application.model.commandUpdate(cmd, treeModificationTrack) || result.needLayout;
                  this._application.getNode(0).auiSerial = order.id;
                  break;
                case "add":
                  node = this._application.model.commandAdd(cmd, treeModificationTrack);
                  if (node) {
                    nodesWithDom.push(node);
                    result.needLayout = result.needLayout || !!cls.LayoutTriggerAttributes[cmd.type][node._tag];
                    result.hasAddedRemovedNodes = true;
                  }
                  if (this._application) {
                    this._application.getNode(0).auiSerial = order.id;
                  }
                  break;
                case "remove":
                  node = null;
                  for (i = 0; i < nodesWithDom.length; ++i) {
                    if (nodesWithDom[i].getId() === cmd.id) {
                      nodesWithDom.splice(i, 1);
                      break;
                    }
                  }
                  treeModificationTrack.nodeRemoved(cmd.id);
                  var toDestroy = this._application.getNode(cmd.id);
                  if (toDestroy) {
                    // detach from DOM first and then destroy recursively
                    if (toDestroy.getController()) {
                      var widget = toDestroy.getController().getWidget();
                      if (widget) {
                        widget.detach();
                      }
                    }
                    toDestroy.destroy();
                  }
                  if (cmd.id === 0) {
                    this._application.setEnding();
                  } else {
                    this._application.getNode(0).auiSerial = order.id;
                  }
                  result.needLayout = result.needLayout || !!cls.LayoutTriggerAttributes[cmd.type][toDestroy._tag];
                  result.hasAddedRemovedNodes = true;
                  break;
                default:
                  node = null;
                  context.LogService.error("dvm.manageAuiOrder: Invalid command (" + cmd.type + ")");
              }
            }

            return result;
          },

          /**
           * Call update attributes callback for modified attributes
           * @param {classes.TreeModificationTracker} treeModificationTrack tree modifications log
           * @private
           */
          _notifyUpdatedAttributes: function(treeModificationTrack) {
            treeModificationTrack.forEach(function(mods, nodeId) {
              var node = this._application.getNode(nodeId);
              if (node) {
                var attrs = Object.keys(mods.updatedAttributes);
                for (var i = 0; i < attrs.length; ++i) {
                  var attr = attrs[i];
                  var eventName = cls.NodeBase.attributeChangedEventName(attr);
                  if (node.hasEventListeners(eventName)) {
                    var oldValue = node.previousAttribute(attr);
                    var newValue = node.attribute(attr);
                    node.emit(eventName, {
                      node: node,
                      attr: attr,
                      old: oldValue,
                      new: newValue,
                      changed: newValue !== oldValue
                    });
                  }
                }
              }
            }.bind(this));
          },

          /**
           * Create controllers for created nodes
           * @param {classes.TreeModificationTracker} treeModificationTrack tree modifications log
           * @private
           */
          _createControllers: function(treeModificationTrack) {
            treeModificationTrack.forEach(function(mods, nodeId) {
              if (mods.createdSubTreeRoot) {
                var node = this._application.getNode(nodeId);
                if (node && !node._destroyed) {
                  node.createController();
                  node.attachUI();
                }
              }
            }.bind(this));
          },

          _getMenu: function(name) {
            var sessionWidget = this._application.getSession().getWidget();
            var menu = null;
            if (!gbc.ThemeService.getValue("theme-legacy-topbar")) {
              var uiWidget = this._application.getUI().getWidget().getUserInterfaceWidget();
              if (uiWidget) {
                menu = uiWidget.getChromeBarWidget();
                return menu ? menu.getGbcMenuItem(name) : false;
              } else {
                return false;
              }
            } else {
              var applicationHostWidget = sessionWidget.getParentWidget();
              menu = applicationHostWidget._menu;
              return name ? menu["_" + name] : menu;
            }
          }
        };
      });
    cls.ApplicationServiceFactory.register("Dvm", cls.DVMApplicationService);
  });
;
"use strict";

modulum('FileTransferApplicationService', ['ApplicationServiceBase', 'ApplicationServiceFactory'],
  function(context, cls) {
    /**
     * Base class of application scoped services
     * @class FileTransferApplicationService
     * @memberOf classes
     * @extends classes.ApplicationServiceBase
     */
    cls.FileTransferApplicationService = context.oo.Class(cls.ApplicationServiceBase, function($super) {
      return /** @lends classes.FileTransferApplicationService.prototype */ {
        __name: "FileTransferApplicationService",
        /**
         * @type {Object<string, Array<FilePickerWidget>>}
         */
        _fileChoosers: null,
        /**
         * @inheritDoc
         */
        constructor: function(app) {
          $super.constructor.call(this, app);
          this._fileChoosers = {};
        },
        /**
         * Handler raised on file pick
         * @param callback
         * @param errorCallback
         * @param event
         * @param src
         * @param data
         * @private
         */
        _whenFileSelectionChanged: function(callback, errorCallback, event, src, data) {
          var hasData = false;
          var normalizedFileName = "";
          if (data) {
            if (Array.isArray(data)) {
              if (data.length) {
                hasData = true;
                for (var i = 0; i < data.length; i++) {
                  // normalize() converts 2 combined diacritical marks into 1 (ex:  encoded as e')
                  // For exemple under Safari a file with name 'Qualit.pdf' has a length of 12 while under
                  // chrome length will be 11 because of the special accent char : 
                  // for this reason we need to normalize our file name.
                  // ! IE11 doesn't support normalize.
                  var fileName = data[i];
                  normalizedFileName = fileName.normalize ? fileName.normalize() : fileName;
                  this._fileChoosers[normalizedFileName] = this._fileChoosers[normalizedFileName] || [];
                  this._fileChoosers[normalizedFileName].push(src);
                  src._processing = true;
                }
              } else {
                src.destroy();
              }
            } else {
              hasData = true;
              // cf previous comment of normalize()
              normalizedFileName = data.normalize ? data.normalize() : data;
              this._fileChoosers[normalizedFileName] = this._fileChoosers[normalizedFileName] || [];
              this._fileChoosers[normalizedFileName].push(src);
              src._processing = true;
            }
            if (hasData) {
              src.when(context.constants.widgetEvents.destroyed, this._onFilePickerDestroyed.bind(this, src), true);
            }
            callback(data);
          } else {
            src.destroy();
            callback("");
          }
        },
        /**
         * manage openFile frontcall
         * @param options
         * @param callback
         * @param errorCallback
         */
        openFile: function(options, callback, errorCallback) {
          var filePicker = cls.WidgetFactory.createWidget("FilePicker", {
            appHash: this._application.applicationHash
          });
          this._application.layout.afterLayout(function() {
            filePicker.resizeHandler();
          });
          this._application.getUI().getWidget().getElement().appendChild(filePicker.getElement());
          filePicker.setExtension(this._extractExtensions(options && options.wildcards || ""));
          filePicker.setCaption(options && options.caption || "");
          filePicker.show();
          filePicker.whenFileSelectionChanged(this._whenFileSelectionChanged.bind(this, callback, errorCallback));
        },
        /**
         * manage openFiles frontcall
         * @param options
         * @param callback
         * @param errorCallback
         */
        openFiles: function(options, callback, errorCallback) {
          var filePicker = cls.WidgetFactory.createWidget("FilePicker", {
            appHash: this._application.applicationHash
          });
          this._application.layout.afterLayout(function() {
            filePicker.resizeHandler();
          });
          this._application.getUI().getWidget().getElement().appendChild(filePicker.getElement());
          filePicker.setExtension(this._extractExtensions(options && options.wildcards || ""));
          filePicker.setCaption(options && options.caption || "");
          filePicker.allowMultipleFiles(true);
          filePicker.show();
          filePicker.whenFileSelectionChanged(this._whenFileSelectionChanged.bind(this, callback, errorCallback));
        },
        /**
         * getFile method executed on getfile frontcall call
         * @param options
         * @param callback
         * @param errorCallback
         */
        getFile: function(options, callback, errorCallback) {
          var filePicker;
          // cf previous comment of normalize() in _whenFileSelectionChanged function definition
          var normalizedFileName = options.filename.normalize ? options.filename.normalize() : options.filename;
          var onSuccess = function() {
              if (filePicker._processing) {
                this._application.getMenu("uploadStatus").setIdle();
              }
              callback();
              filePicker.freeFile(normalizedFileName, true);
              if (this._fileChoosers[normalizedFileName]) {
                this._fileChoosers[normalizedFileName].remove(filePicker);
              }
            }.bind(this),
            onError = function() {
              if (filePicker._processing) {
                this._application.getMenu("uploadStatus").setIdle();
              }
              errorCallback();
              filePicker.freeFile(normalizedFileName, true);
              if (this._fileChoosers[normalizedFileName]) {
                this._fileChoosers[normalizedFileName].remove(filePicker);
              }
            }.bind(this),
            onFile = function(file) {
              if (!file) {
                onError();
              } else {
                this._application.getMenu("uploadStatus").setProcessing();
                var url = options.fileTransferUrl;
                filePicker.send(file, url, onSuccess, onError);
              }
            }.bind(this);
          if (this._fileChoosers[normalizedFileName] && this._fileChoosers[normalizedFileName].length) {
            filePicker = this._fileChoosers[normalizedFileName].shift();
            onFile(normalizedFileName);
          } else {
            filePicker = cls.WidgetFactory.createWidget("FilePicker", {
              appHash: this._application.applicationHash
            });
            this._application.layout.afterLayout(function() {
              filePicker.resizeHandler();
            });
            this._application.getUI().getWidget().getElement().appendChild(filePicker.getElement());
            filePicker.setExtension("." + normalizedFileName.split('.').pop());
            filePicker.show();
            filePicker.whenFileSelectionChanged(this._whenFileSelectionChanged.bind(this, onFile, onError));
          }
        },
        /**
         * @inheritDoc
         */
        destroy: function() {
          var destroyable = [],
            keys = Object.keys(this._fileChoosers),
            len = keys.length,
            k = 0,
            i = 0;
          for (; k < len; k++) {
            while (this._fileChoosers[k] && this._fileChoosers[k][i]) {
              if (!destroyable.contains(this._fileChoosers[k][i])) {
                destroyable.push(this._fileChoosers[k][i]);
              }
              i++;
            }
          }
          len = destroyable.length;
          for (k = 0; k < len; k++) {
            destroyable[k].destroy();
          }
          $super.destroy.call(this);
        },

        /**
         * free resources when a file picker is destroyed
         * @param {classes.FilePickerWidget} picker
         * @private
         */
        _onFilePickerDestroyed: function(picker) {
          var files = picker && picker.getAvailableFiles();
          if (files) {
            for (var i = 0; i < files.length; i++) {
              if (this._fileChoosers[files[i]]) {
                this._fileChoosers[files[i]].remove(picker);
              }
            }
          }
        },

        /**
         * format extensions
         * @param {string} raw
         * @return {string}
         * @private
         */
        _extractExtensions: function(raw) {
          var regex = /[^\s]*(\.[^.\s]+)/g,
            m, res = [];
          while ((m = regex.exec(raw)) !== null) {
            var ext = m[1];
            if (ext === ".*") {
              res.length = 0;
              break;
            }
            res.push(ext);
          }
          return res.join(",") || "";
        }
      };
    });
    cls.ApplicationServiceFactory.register("FileTransfer", cls.FileTransferApplicationService);
  });
;
"use strict";

modulum('FocusApplicationService', ['ApplicationServiceBase', 'ApplicationServiceFactory'],
  function(context, cls) {
    /**
     * @class FocusApplicationService
     * @memberOf classes
     * @extends classes.ApplicationServiceBase
     */
    cls.FocusApplicationService = context.oo.Class(cls.ApplicationServiceBase, function($super) {
      return /** @lends classes.FocusApplicationService.prototype */ {
        __name: "FocusApplicationService",

        $static: /** @lends classes.FocusApplicationService */ {
          /**
           * Get next ordered field
           * TODO missing parameter types
           * @param form
           * @param node
           * @param offset
           * @param inputWrap
           * @returns {*}
           */
          getPrevOrNextContainer: function(form, node, offset, inputWrap) {
            var fields = [];
            cls.FocusApplicationService.orderFields(form, fields);
            var index = fields.indexOf(node) + offset;
            if (index < 0) {
              if (inputWrap) {
                return fields[fields.length - 1];
              } else {
                return null;
              }
            } else if (index >= fields.length) {
              if (inputWrap) {
                return fields[0];
              } else {
                return null;
              }
            } else {
              return fields[index];
            }
          },

          /**
           * Order fields and update fields parameter in consequence
           * TODO missing parameter types
           * @param node
           * @param fields
           * @param nodeTypes
           * @param attributesFilter
           */
          orderFields: function(node, fields, nodeTypes, attributesFilter) {
            var i = 0;
            if (!nodeTypes) {
              nodeTypes = ['FormField', 'Matrix', 'Table', 'Button'];
            }
            var ok = nodeTypes.contains(node.getTag()) && node.attribute('active') !== 0 && node.attribute('tabIndexRt') !== 0 &&
              node.attribute('hidden') === 0 && node.attribute('actionActive') !== 0;
            if (node.getTag() === 'Table') {
              var columns = cls.FocusApplicationService.getActiveTableColumns(node);
              ok = ok && columns.length > 0;
            }
            if (attributesFilter) {
              var attrs = Object.keys(attributesFilter);
              if (ok) {
                for (i = 0; ok && i < attrs.length; ++i) {
                  var key = attrs[i];
                  ok = ok && node.attribute(key) === attributesFilter[key];
                }
              }
            }
            if (ok) {
              if (fields.length === 0) {
                fields.push(node);
              } else {
                var nodeTabIndexRt = node.attribute('tabIndexRt');
                var inserted = false;
                for (i = 0; i < fields.length; ++i) {
                  var field = fields[i];

                  var fieldTabIndexRt = 0;
                  if (field.getTag() === "Table") {
                    fieldTabIndexRt = field.getFirstChild('TableColumn').attribute('tabIndexRt');
                  } else {
                    fieldTabIndexRt = field.attribute('tabIndexRt');
                  }
                  if (fieldTabIndexRt > nodeTabIndexRt) {
                    fields.splice(i, 0, node);
                    inserted = true;
                    break;
                  }
                }
                if (!inserted) {
                  fields.push(node);
                }
              }
            } else {
              var children = node.getChildren();
              for (i = 0; i < children.length; ++i) {
                cls.FocusApplicationService.orderFields(children[i], fields, nodeTypes, attributesFilter);
              }
            }
          },

          /**
           * Get list of active table columns
           * @param {classes.TableNode} tableNode
           * @returns {classes.TableColumnNode[]} list of active table columns
           */
          getActiveTableColumns: function(tableNode) {
            return tableNode.getChildren('TableColumn').filter(function(column) {
              return column.attribute('active') !== 0 && column.attribute('tabIndexRt') !== 0 &&
                column.attribute('hidden') === 0;
            });
          },

          /**
           * Get ordered table columns list
           * @param {classes.TableNode} tableNode
           * @returns {classes.TableColumnNode[]} list of ordered columns
           */
          getOrderedTableColumns: function(tableNode) {
            var columns = cls.FocusApplicationService.getActiveTableColumns(tableNode);
            columns.sort(function(col1, col2) {
              return col1.attribute('tabIndexRt') - col2.attribute('tabIndexRt');
            });
            return columns;
          }

        },

        /**
         * The currently visually focused node. Due to the typeahead mechanism,
         * this may be different from the VM focused node
         * @type {classes.NodeBase}
         */
        _focusedNode: null,

        /**
         * true if we are currently restoring the VM focus, false otherwise
         * @type {boolean}
         */
        _restoringVMFocus: false,

        /**
         * @inheritDoc
         */
        constructor: function(app) {
          $super.constructor.call(this, app);
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          $super.destroy.call(this);

          this._focusedNode = null;
        },

        /**
         * The currently visually focused node. Due to the typeahead mechanism,
         * this may be different from the VM focused node
         * @returns {classes.NodeBase}
         */
        getFocusedNode: function() {
          return this._focusedNode;
        },

        /**
         * @param {classes.NodeBase} focusedNode - the currently visually focused node
         */
        setFocusedNode: function(focusedNode) {
          this._focusedNode = focusedNode;
        },

        /**
         * Restores the focus according to the VM focus
         * @param {boolean=} [restoreDOMFocus] ensure to restore the DOM focus
         */
        restoreVMFocus: function(restoreDOMFocus) {
          var node = this._application.getFocusedVMNodeAndValue(true);
          if (node) {
            // set current focused node for typeahead
            context.LogService.focus.log("restoreVMFocus for node : ", node);
            this.setFocusedNode(node);
            var ctrl = node.getController();
            if (ctrl) {
              // ensure visible for folder pages
              var parentForm = node.getAncestor("Form");
              var visibleId = null;
              if (parentForm) {
                visibleId = parentForm.attribute("visibleId");
              }
              var uiWidget = null;
              var appWidget = this._application.getUI().getWidget();
              if (appWidget) {
                uiWidget = appWidget._uiWidget;
              }
              var focusedWidget = ctrl.getWidget() || ctrl.getCurrentInternalWidget();
              if (focusedWidget) {
                if (!uiWidget) {
                  uiWidget = focusedWidget.getUserInterfaceWidget();
                }
                if (uiWidget) { // set ui current focused widget
                  uiWidget.setVMFocusedWidget(focusedWidget);
                  uiWidget.setFocusedWidget(focusedWidget);
                }
              }
              this._restoringVMFocus = true;
              if (uiWidget && (restoreDOMFocus || uiWidget.hasVMFocusedWidgetChanged()) || uiWidget.hasFocusedWidgetChanged()) {
                // if no visibleId is set we make sure to display potential current page
                if (!visibleId || visibleId === -1) {
                  if (ctrl.ensureVisible()) {
                    this._application.layout.refreshLayout();
                  }
                }
                ctrl.setFocus(); // set ui focus on widget element

                // hide previously displayed dropdowns
                if (cls.DropDownWidget.hasAnyVisible() && !cls.DropDownWidget.isChildOrParentOfDropDown(focusedWidget
                    .getElement())) {
                  cls.DropDownWidget.hideAll();
                }

              }
              this.emit(context.constants.widgetEvents.focusRestored);
              this._restoringVMFocus = false;
            }
          }
        },

        /**
         * @returns {boolean} true if we are currently restoring the VM focus, false otherwise
         */
        isRestoringVMFocus: function() {
          return this._restoringVMFocus;
        },

        /**
         * Set the focusedDropdown widget
         * @param {classes.WidgetBase} activeWidget
         */
        setFocusedDropDownWidget: function(activeWidget) {
          this._dropDownWidget = activeWidget;
        },

        /**
         * Get the focusedDropdown widget
         * @return {classes.WidgetBase|*}
         */
        getFocusedDropDownWidget: function() {
          return this._dropDownWidget;
        },

        /**
         * Transfer focus to corresponding node
         * @param {string} actionName
         * @param {classes.NodeBase} node
         * @param {number} [currentRow]
         * @param {number} [currentColumn]
         * @returns {boolean}
         * @private
         */
        _transferFocusToNode: function(actionName, node, currentRow, currentColumn) {
          var valueList = null;
          var valueNode = null;
          var widget = null;
          var newFocusedNode = node;
          var cursors = null;
          var focusAsked = false;

          var dialogType = node.attribute('dialogType');
          var displayDialog = dialogType === "Display" || dialogType === "DisplayArray";

          context.LogService.focus.log("Transfer focus to node : ", node, actionName, currentRow, currentColumn);

          switch (node.getTag()) {
            case "FormField":
            case "Button":
              widget = node.getController().getWidget();
              cursors = {
                start: 0,
                end: 0
              };
              if (widget.hasCursors()) {
                widget.setCursors(0, -1);
                cursors = widget.getCursors();
              }
              this._application.typeahead.focus(node, cursors.start, cursors.end, actionName);
              focusAsked = true;
              break;
            case "Matrix":
              if (currentRow === undefined) {
                currentRow = node.attribute('currentRow') - node.attribute('offset');
              }

              if (!displayDialog) { // INPUT ARRAY
                valueList = node.getFirstChild('ValueList');
                valueNode = valueList.getChildren()[Math.max(currentRow, 0)];
                widget = valueNode.getController().getWidget();
                cursors = {
                  start: 0,
                  end: 0
                };
                if (widget.hasCursors()) {
                  widget.setCursors(0, -1);
                  cursors = widget.getCursors();
                }
                this._application.typeahead.focus(valueNode, cursors.start, cursors.end, actionName);
                newFocusedNode = valueNode;
              } else { // DISPLAY ARRAY
                // if typeahead is frozen, we don't update visual focus, focus will be restored by VM answer
                if (!this._application.typeahead.isFrozen()) {
                  context.LogService.focus.log("Update visual matrix currentRow: ", node, currentRow);
                  node.getController().updateCurrentRow(node, currentRow);
                }
                this._application.typeahead.currentRow(node, actionName);
              }
              focusAsked = true;
              break;
            case "Table":
              if (currentRow === undefined) {
                currentRow = node.attribute('currentRow') - node.attribute('offset');
              }
              var columnIndexToFocus = null;
              var tableWidget = node.getController().getWidget();

              if (!displayDialog) { // INPUT ARRAY
                if (currentColumn === undefined) {
                  // If no current column is provided, simply focus the first visible column
                  currentColumn = 0;
                }

                // search column which must be focused
                var allColumns = node.getChildren('TableColumn');
                var orderedFocusableColumns = cls.FocusApplicationService.getOrderedTableColumns(node);
                var columnToFocus = orderedFocusableColumns[currentColumn];
                if (!columnToFocus) {
                  return false; // if column cannot be found, don't focus anything
                }

                columnIndexToFocus = allColumns.indexOf(columnToFocus);
                valueList = columnToFocus.getFirstChild('ValueList');
                valueNode = valueList.getChildren()[Math.max(currentRow, 0)];
                widget = valueNode.getController().getWidget();

                cursors = {
                  start: 0,
                  end: 0
                };

                if (widget.hasCursors()) {
                  widget.setCursors(0, -1);
                  cursors = widget.getCursors();
                }
                this._application.typeahead.focus(valueNode, cursors.start, cursors.end, actionName);
                newFocusedNode = valueNode;
              } else { // DISPLAY ARRAY
                if (cls.ActionNode.isTableNavigationAction(actionName)) {
                  this._application.typeahead.currentRow(node, actionName);
                } else {
                  this._application.typeahead.focus(node);
                }
              }

              // if typeahead is frozen, we don't update visual focus, focus will be restored by VM answer
              if (!this._application.typeahead.isFrozen()) {
                context.LogService.focus.log("Update visual table currentRow,currentCol: ", node, currentRow, columnIndexToFocus);
                tableWidget.setCurrentRow(currentRow);
                if (columnIndexToFocus !== null) {
                  tableWidget.setCurrentColumn(columnIndexToFocus);
                }
              }

              focusAsked = true;
              break;
          }

          if (focusAsked) {
            // if typeahead is frozen, we don't update visual focus, focus will be restored by VM answer
            if (!this._application.typeahead.isFrozen()) {
              context.LogService.focus.log("Change focused widget: ", newFocusedNode);
              newFocusedNode.getController().ensureVisible();
              newFocusedNode.getController().setFocus();

              this.setFocusedNode(newFocusedNode);
            }
          }
          return focusAsked;
        },

      };
    });
    cls.ApplicationServiceFactory.register("Focus", cls.FocusApplicationService);
  });
;
"use strict";

modulum('KeyboardApplicationService', ['ApplicationServiceBase', 'ApplicationServiceFactory'],
  function(context, cls) {
    /**
     * @class KeyboardApplicationService
     * @memberOf classes
     * @extends classes.ApplicationServiceBase
     */
    cls.KeyboardApplicationService = context.oo.Class(cls.ApplicationServiceBase, function($super) {
      return /** @lends classes.KeyboardApplicationService.prototype */ {
        __name: "KeyboardApplicationService",
        $static: /** @lends classes.KeyboardApplicationService */ {
          keymap: {
            8: 'backspace',
            9: 'tab',
            13: 'enter',
            16: 'shift',
            17: 'ctrl',
            18: 'alt',
            19: 'pause',
            20: 'capslock',
            27: 'esc',
            32: 'space',
            33: 'pageup',
            34: 'pagedown',
            35: 'end',
            36: 'home',
            37: 'left',
            38: 'up',
            39: 'right',
            40: 'down',
            45: 'ins',
            46: 'del',
            91: 'meta',
            92: 'meta',
            93: 'contextmenu',
            112: 'f1',
            113: 'f2',
            114: 'f3',
            115: 'f4',
            116: 'f5',
            117: 'f6',
            118: 'f7',
            119: 'f8',
            120: 'f9',
            121: 'f10',
            122: 'f11',
            123: 'f12',
            144: 'numlock',
            145: 'scrolllock',
            224: 'meta',
          },

          navigationKeys: [
            'up',
            'down',
            'left',
            'right'
          ]
        },

        _bufferedKeys: null,

        /** @type {boolean} */
        _keyDownProcessed: false,

        /**
         * @inheritDoc
         */
        constructor: function(app) {
          $super.constructor.call(this, app);
          this._application.dvm.onOrdersManaged(this._bindKeyboardEvents.bind(this), true);
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._bufferedKeys = null;
          this._unbindKeyboardEvents();
          $super.destroy.call(this);
        },

        /**
         * Bind keydown & keyup events on the ui and listen to them to catch all keys
         * @private
         */
        _bindKeyboardEvents: function() {
          var uiWidget = this._application.getUI().getWidget();
          if (uiWidget) {
            var uiElement = uiWidget.getElement();
            uiElement.on("keydown.UserInterfaceWidget", this._onKeyDown.bind(this));
            uiElement.on("keyup.UserInterfaceWidget", this._onKeyUp.bind(this));
          }
        },

        /**
         * Unbind keydown & keyup events of the ui
         * @private
         */
        _unbindKeyboardEvents: function() {
          var uiWidget = this._application.getUI().getWidget();
          if (uiWidget) {
            var uiElement = uiWidget.getElement();
            uiElement.off("keydown.UserInterfaceWidget");
            uiElement.off("keyup.UserInterfaceWidget");
          }
        },

        /**
         * Keydown handler bound on UserInterface widget. Catch all keydown events and propagate it to the corresponding widget.
         * We detect the key combination and execute all actions bound to it. Otherwise we let widget manage the key
         * @param event
         * @private
         */
        _onKeyDown: function(event) {
          event.gbcKey = this.getNormalizedKey(event);
          var combi = this.translateKeys(event, event.gbcKey);
          // if user keep pressing same key without releasing it and typeahead is flagged as frozen, we don't push event
          this._keyDownProcessed = false;

          var repeatKey = this._bufferedKeys === combi;

          window.isCapslock(event);

          if (combi && combi !== "unidentified") {
            this._bufferedKeys = combi;
            context.LogService.keyboard.log("KEY USED onKeyDown saved as bufferedKeys : ", this._bufferedKeys, event.key);

            var focusedNode = this._application.focus.getFocusedNode();
            if (this._application.typeahead.isBufferizeKeysMode() && focusedNode.getFirstChild('WebComponent') === null) {
              event.stopPropagation();
              event.preventCancelableDefault();

              if (!repeatKey) { // don't delay repeated key, simply ignore it
                context.LogService.keyboard.log("Delayed key captured : ", this._bufferedKeys);
                this._application.typeahead.delayedKey(this._bufferedKeys, event);
              }
            } else {
              this._keyDownProcessed = this.processKey(this._bufferedKeys, event, repeatKey);
              if (this._keyDownProcessed) {
                context.LogService.keyboard.log("onKeyDown processed event.key : ", event.key);
              }
            }
          }
        },

        /**
         * Keyup handler bound on UserInterface widget. Catch all keyup events and propagate it to the corresponding widget.
         * Key combination previously detected in Keydown is passed as parameter
         * @param event
         * @private
         */
        _onKeyUp: function(event) {
          event.gbcKey = this.getNormalizedKey(event);
          this.executeKeyUp(this._bufferedKeys, event);
          this._bufferedKeys = null;
        },

        /**
         * @param {String} keyString string corresponding to the key
         * @param {Object} keyEvent keyDown js event
         */
        executeKeyUp: function(keyString, keyEvent) {
          var focusedNode = this._application.focus.getFocusedNode();
          var widget = focusedNode && focusedNode.getWidget();
          if (widget) {
            // we pass bufferedKeys as parameter in order to be able to be sure to manage previously typed combination.
            widget.manageKeyUp(keyString, keyEvent);
          }
        },

        /**
         * Check if key is a basic modifier (ctrl, shift, alt)
         * @param {string} key
         * @returns {boolean} returns true if key is a basic modifier
         */
        isBasicModifier: function(key) {
          var k = key.toLowerCase();
          return k === 'shift' || k === 'ctrl' || k === 'alt' || k === 'meta' || k === 'dead';
        },

        /**
         * Normalize DOM event key using VM modifier common names
         * @param event
         * @returns {*|string} returns normalized key
         */
        getNormalizedKey: function(event) {
          var key = cls.KeyboardApplicationService.keymap[event.which] || "";

          //Difference between Return and Enter
          if (key === "enter" && event.code !== "NumpadEnter") {
            key = "return";
          }

          if (!key) {
            key = event.key;
          }
          if (window.browserInfo.isEdge || window.browserInfo.isIE) {
            key = key.replace("Divide", "/").replace("Multiply", "*").replace("Subtract", "-").replace("Add", "+").replace(
              "Decimal", ".");
          }

          if (!key) {
            key = String.fromCharCode(event.which || event.code);
          }

          return key;
        },

        /**
         * Get the combination of keys (modifiers included) being typed
         * @param event
         * @param {string} normalizedKey
         * @returns {string} returns normalized keys combination
         */
        translateKeys: function(event, normalizedKey) {
          var ctrlKey = event.ctrlKey;
          var altKey = event.altKey;
          var shiftKey = event.shiftKey;
          var metaKey = event.metaKey;

          var keys = "";
          if (!this.isBasicModifier(normalizedKey)) {
            if (metaKey) {
              keys += "meta";
            }
            // use that order : ctrl+shift+alt
            if (ctrlKey) {
              if (keys.length !== 0) {
                keys += '+';
              }
              keys += "ctrl";
            }
            if (altKey) {
              if (keys.length !== 0) {
                keys += '+';
              }
              keys += "alt";
            }
            if (shiftKey) {
              if (keys.length !== 0) {
                keys += '+';
              }
              keys += "shift";
            }
            if (keys.length !== 0) {
              keys += '+';
            }
            keys += normalizedKey;
          }
          return keys.toLowerCase(); // return any combi in lowercase
        },

        /**
         *
         * @param {String} keyString - string of the key (including combination, ctrl+, shift+, ...)
         * @param {Object} event - dom key event
         * @param {boolean} repeat - true if key is being pressed
         * @returns {boolean} true if the key has been processed, false otherwise
         */
        processKey: function(keyString, event, repeat) {

          var processed = false;

          var app = this._application;

          var focusedNode = app.focus.getFocusedNode();
          var currentDropDownWidget = app.focus.getFocusedDropDownWidget();

          var widget = focusedNode && focusedNode.getWidget();
          // 1. Special case CTRL+C, if there is a text selection and the current VM focus has not DOM focus
          if (keyString === "ctrl+c" || keyString === "meta+c") {
            var selectionText = window.getSelection().toString();
            var domFocus = widget.hasDOMFocus();
            if (!domFocus && !!selectionText && selectionText !== "") {
              // return false, to let the browser manage CTRL+C
              return false;
            }
          }

          if (app.typeahead.isFrozen()) {
            // set the typeahead overlay visible if user press a key when typeahead is frozen
            context.OverlayService.setOpacity("typeahead", true);
          }

          // 2. Priority key managed by the widget before any action
          if (!processed) {
            if (currentDropDownWidget) {
              // TODO why are we doing this ?
              // TODO it seems that in most cases currentDropDownWidget & widget are the same, so it seems to be useless
              processed = currentDropDownWidget.managePriorityKeyDown(keyString, event, repeat);
            }
            if (!processed && widget && !widget.isHidden()) {
              processed = widget.managePriorityKeyDown(keyString, event, repeat);
            }

          }

          // 3. Try to process action for combination key
          if (!processed) {
            processed = this._processAction(keyString);
          }
          // 4. If there is no action on combination and shift key is pressed,
          // we try to process action on shifted key but only for key which can be displayed
          if (!processed && event.shiftKey === true && event.key && event.key.length === 1) {
            processed = this._processAction(event.key);
          }

          // 5. if key not processed, ask widget to manage it
          if (!processed) {
            if (currentDropDownWidget) {
              // TODO why are we doing this ?
              // TODO it seems that in most cases currentDropDownWidget & widget are the same, so it seems to be useless
              processed = currentDropDownWidget.manageKeyDown(keyString, event, repeat);
            }
            if (!processed && widget && !widget.isHidden()) {
              processed = widget.manageKeyDown(keyString, event, repeat);
            }

          }

          if (event) {
            if (processed) {
              event.stopPropagation();
              if (event.gbcDontPreventDefault !== true) {
                event.preventCancelableDefault();
              }
            } else {
              // check if existing modal menu
              var uiNode = app.uiNode();
              var currentWindow = uiNode && app.getNode(uiNode.attribute('currentWindow'));
              var modalMenu = currentWindow && currentWindow.getFirstChildWithAttribute('Menu', 'active', 1);
              if (modalMenu) {
                var modalType = modalMenu.attribute("style");
                if (modalType === "winmsg" || modalType === "dialog") {
                  // dialog detected, we need to prevent default to avoid focus being moved to another application
                  event.stopPropagation();
                  event.preventCancelableDefault();
                }
              }
            }
          }

          return processed;
        },

        /**
         * Check if key is a menu action shortcut
         * @param {classes.NodeBase} menuNode
         * @param {string} key
         * @returns {boolean} returns true if key is a shortcut of the passed menu node
         * @private
         */
        _isMenuActionShortcutKey: function(menuNode, key) {
          var menuActions = menuNode.getChildren('MenuAction');
          for (var i = 0; i < menuActions.length; ++i) {
            var menuAction = menuActions[i];
            if (menuAction.attribute('active')) {
              var text = menuAction.isAttributeSetByVM('text') ? menuAction.attribute('text') : menuAction.attribute('name');
              text = text.toString().toLocaleLowerCase();
              if (!!text && text.length !== 0 && text[0] === key) {
                return true;
              }
            }
          }
          return false;
        },

        /**
         * Find and execute VM action corresponding to key
         * @param {string} keyString - string of the key (including combination, ctrl+, shift+, ...)
         * @returns {boolean} true if the key has been processed, false otherwise
         */
        _processAction: function(keyString) {

          var processed = false;
          var actionName = null;
          var actionNode = null;
          var vmEvent = null;
          var vmKey = cls.KeyboardHelper.convertBrowserKeyToVMKey(keyString);

          var app = this._application;
          var typeahead = app.typeahead;

          var focusedNode = app.focus.getFocusedNode();

          // 1. Try to find corresponding action in active dialog actions list
          if (!processed) {
            actionNode = this._application.getActiveDialogAction(vmKey);
            if (actionNode) {
              actionName = actionNode.attribute('name');
              if (cls.ActionApplicationService.getLocalActionNames().contains(actionName)) {
                // pass the actionNode to processLocalAction because "in some cases" when the action is in the active dialog actions list
                // we must send an ActionEvent instead of a KeyEvent
                processed = this._processLocalAction(actionName, vmKey, actionNode);
              } else {
                vmEvent = new cls.VMActionEvent(actionNode.getId());
                context.LogService.keyboard.log("processKey found Action & send ActionEvent for key : ", keyString);
              }
            }
          }

          // 2. Try to find corresponding action in default action list
          if (!vmEvent && !processed) {
            actionNode = this._application.getDefaultAction(vmKey);
            if (actionNode) {
              actionName = actionNode.attribute('name');
              if (cls.ActionApplicationService.browserNativeActions.contains(actionName)) {
                context.LogService.keyboard.log("processKey found copy/cut/paste Action");
              } else if (cls.ActionApplicationService.getLocalActionNames().contains(actionName)) {
                processed = this._processLocalAction(actionName, vmKey);
              } else {
                vmEvent = new cls.VMKeyEvent(vmKey);
                context.LogService.keyboard.log("processKey found ActionDefault & send KeyEvent for key : ", vmKey);
              }
            }
          }

          // 3. Check if key must be send to VM (for specific nodes and specific keys we always send to VM)
          if (!vmEvent && !processed && focusedNode) {
            var createKeyEvent;
            switch (focusedNode.getTag()) {
              case "MenuAction":
                // first letter of actions and nav keys should be send to VM to navigate in the menu
                createKeyEvent = (this._isMenuActionShortcutKey(focusedNode.getParentNode(), vmKey) || cls.KeyboardApplicationService
                  .navigationKeys.indexOf(keyString) >= 0);
                break;
              case "Table":
                // letter should be send to VM for "search" feature
                createKeyEvent = (focusedNode.attribute("dialogType") === "DisplayArray" && vmKey.length === 1 && (cls.KeyboardHelper
                  .isLetter(vmKey) || cls.KeyboardHelper.isNumeric(vmKey)));
                break;
              default:
                createKeyEvent = false;
            }

            if (createKeyEvent) {
              vmEvent = new cls.VMKeyEvent(vmKey);
              context.LogService.keyboard.log("processKey send KeyEvent for key : ", vmKey);
            }
          }

          // 4. TODO explain this ...
          if (!vmEvent && !processed) {
            actionName = cls.ActionApplicationService.getLocalActionName(vmKey);
            if (!!actionName) {
              processed = this._processLocalAction(actionName, vmKey);
            }
          }

          if (vmEvent && !processed) { // a vmEvent is found, send current widget value and then send key to VM
            if (focusedNode) {
              var ctrl = focusedNode.getController();
              if (ctrl) {
                ctrl.sendWidgetCursors();
                ctrl.sendWidgetValue();
              }
            }
            typeahead.event(vmEvent);
            processed = true;
          }

          return processed;

        },

        /**
         * @param {string} actionName - abstract name of the action to process
         * @param {string} actionAccelerator - accelerator key corresponding to the action
         * @param {classes.ActionNode} [actionNode] - action node to be processed
         * @returns {boolean} true if the action has been processed, false otherwise
         * @private
         */
        _processLocalAction: function(actionName, actionAccelerator, actionNode) {

          var app = this._application;
          var typeahead = app.typeahead;
          var focusedNode = app.focus.getFocusedNode();
          var processed = false;

          var focusedNodeController = focusedNode.getController();
          var focusedNodeIsFormField = (focusedNode.getTag() === "FormField");
          var focusedNodeIsAction = (focusedNode.getTag() === "Action" || focusedNode.getTag() === "MenuAction");
          var focusedNodeIsButton = (focusedNode.getTag() === "Button");
          var focusedNodeIsMatrix = (focusedNode.getTag() === "Matrix");
          var focusedNodeIsTable = (focusedNode.getTag() === "Table");
          var focusedNodeIsValue = (focusedNode.getTag() === "Value");

          var focusedNodeIsInInputMode = (['Input', 'InputArray', 'Construct'].indexOf(focusedNode.attribute('dialogType')) !==
            -1);

          // if Table or Matrix in DISPLAY mode
          if ((focusedNodeIsTable || focusedNodeIsMatrix) && !focusedNodeIsInInputMode) {
            return this._processDisplayTableMatrixLocalAction(focusedNode, actionName, actionAccelerator, actionNode);
          }

          typeahead.startGroupCommand();
          if (focusedNodeController) {
            focusedNodeController.sendWidgetCursors(true);
            focusedNodeController.sendWidgetValue(true);
          }

          // FormField case
          if (focusedNodeIsFormField || focusedNodeIsAction || focusedNodeIsButton) {
            processed = this._processFormFieldLocalAction(focusedNode, actionName, actionAccelerator);
          } else {
            // Case of Matrix or Table (INPUT)
            var valueNode = null;
            if (focusedNodeIsValue) {
              valueNode = focusedNode;
            } else if (focusedNodeIsMatrix || focusedNodeIsTable) {
              valueNode = focusedNode.getCurrentValueNode();
            }

            if (valueNode !== null) {
              /** @type classes.MatrixNode|classes.TableColumnNode */
              var containerNode = !!valueNode.getParentNode() && valueNode.getParentNode().getParentNode();
              if (focusedNodeIsMatrix || (focusedNode && focusedNode.isInMatrix()) || focusedNodeIsTable || (
                  focusedNodeController && focusedNode.isInTable())) {
                processed = this._processInputTableMatrixLocalAction(containerNode, valueNode, actionName, actionAccelerator);
              }
            } else { //focused node is directly Table/Matrix (currentRow not in visible offset)
              typeahead.freeze();
              processed = this._sendKeyEvent(actionAccelerator);
            }
          }

          typeahead.finishGroupCommand();

          return processed;
        },

        /**
         * Sends a key event command
         * @param {string} keyName
         * @returns {boolean}
         * @private
         */
        _sendKeyEvent: function(keyName) {
          this._application.typeahead.event(new cls.VMKeyEvent(keyName));
          return true;
        },

        /**
         * @param {classes.FormFieldNode} formFieldNode
         * @param {string} actionName abstract name of the action to process
         * @param {string} actionAccelerator accelerator key corresponding to the action
         * @returns {boolean} true if the action has been processed, false otherwise
         * @private
         */
        _processFormFieldLocalAction: function(formFieldNode, actionName, actionAccelerator) {
          var isFieldNavigation = cls.ActionNode.isFieldNavigationAction(actionName);
          if (isFieldNavigation) {
            var uiNode = this._application.uiNode();
            var currentWindow = uiNode && this._application.getNode(uiNode.attribute('currentWindow'));
            var form = currentWindow && currentWindow.getLastChild('Form');
            if (!form) {
              return false;
            }
            var inputWrap = uiNode && uiNode.attribute('inputWrap');
            var newFocusedNode = cls.FocusApplicationService.getPrevOrNextContainer(form, formFieldNode, actionName ===
              'nextfield' ?
              1 : -1,
              inputWrap);
            if (newFocusedNode && !this._application.typeahead.isFrozen()) {
              return this._application.focus._transferFocusToNode(actionName, newFocusedNode);
            } else {
              return this._sendKeyEvent(actionAccelerator);
            }
          } else {
            var dialogType = formFieldNode.attribute("dialogType");
            var isArrayContainer = dialogType ? dialogType.indexOf("Array") !== -1 : false;
            if (isArrayContainer && cls.ActionNode.isTableNavigationAction(actionName)) {
              // FormField is a single line matrix
              return this._sendKeyEvent(actionAccelerator);
            }
          }
          return false;
        },

        /**
         * @param {classes.TableColumnNode|classes.MatrixNode} node
         * @param {classes.ValueNode} valueNode
         * @param {string} actionName abstract name of the action to process
         * @param {string} actionAccelerator accelerator key corresponding to the action
         * @returns {boolean} true if the action has been processed, false otherwise
         * @private
         */
        _processInputTableMatrixLocalAction: function(node, valueNode, actionName, actionAccelerator) {

          // if a action is table or field navigation consider that action is processed
          var processed = cls.ActionNode.isTableNavigationAction(actionName) || cls.ActionNode.isFieldNavigationAction(
            actionName);

          var isTable = (node.getTag() === "TableColumn");
          var arrayNode = isTable ? node.getParentNode() : node; // MatrixNode or TableNode

          var localRow = valueNode.getIndex();
          var newLocalRow = localRow;
          var newCurrentRow = null;
          var newColumn = null;
          var newNode = null;
          var pageSize = arrayNode.attribute('pageSize');
          var offset = arrayNode.attribute('offset');
          var size = arrayNode.attribute('size');

          if (isTable) { // TABLE
            var tableNode = arrayNode;
            newNode = tableNode; // no new node the focus is still on table node

            var columnList = cls.FocusApplicationService.getOrderedTableColumns(tableNode);
            var column = columnList.indexOf(node);

            // compute new row and new col
            newColumn = column;

            if (actionName === 'nextfield') {
              if (newColumn + 1 < columnList.length) {
                newColumn++;
              } else {
                newColumn = 0;
                newLocalRow++;
              }
            } else if (actionName === 'prevfield') {
              if (newColumn - 1 >= 0) {
                newColumn--;
              } else {
                newColumn = 0;
                newLocalRow--;
              }
            } else {
              newCurrentRow = cls.TypeAheadCurrentRow.computeNewRowFromAction(tableNode, actionName, localRow + offset, true);
              newLocalRow = newCurrentRow - offset;
            }

            // if row and col have not changed nothing to do
            if (localRow === newLocalRow && column === newColumn) {
              return processed;
            }
          } else { // MATRIX
            // compute new row an col
            var newMatrixNode = node;

            if (actionName === 'nextfield' || actionName === 'prevfield') {
              var uiNode = this._application.uiNode();
              var currentWindow = uiNode && this._application.getNode(uiNode.attribute('currentWindow'));
              var form = currentWindow && currentWindow.getLastChild('Form');
              if (!form) {
                return false;
              }
              var mats = [];
              cls.FocusApplicationService.orderFields(form, mats, ['Matrix'], {
                screenRecord: node.attribute('screenRecord')
              });
              var currentIndex = mats.indexOf(node);
              currentIndex += actionName === 'nextfield' ? 1 : -1;
              if (currentIndex < 0) {
                currentIndex = mats.length - 1;
                newLocalRow--;
              } else if (currentIndex >= mats.length) {
                currentIndex = 0;
                newLocalRow++;
              }
              newMatrixNode = mats[currentIndex];
            } else {
              newCurrentRow = cls.TypeAheadCurrentRow.computeNewRowFromAction(node, actionName, localRow + offset, true);
              newLocalRow = newCurrentRow - offset;
            }

            // if row and col have not changed nothing to do
            if (localRow === newLocalRow && node === newMatrixNode) {
              return processed;
            }

            newNode = newMatrixNode; // matrix node can change
          }

          // if we are outside of [0...pageSize] typeahead is no more possible
          // if we want to put the row on a index >= size of table
          // we don't know what to do --> freeze Typeahead
          if ((newLocalRow >= pageSize || newLocalRow < 0) || ((newLocalRow + offset) >= size)) {
            this._application.typeahead.freeze();
          }

          if (this._application.typeahead.isFrozen()) {
            // typeahead frozen --> send key event to VM
            this._sendKeyEvent(actionAccelerator);
            var scrollGridNode = node.getAncestor('ScrollGrid');
            if (scrollGridNode && scrollGridNode.getController().isPagedScrollGrid()) {
              var newOffset = Math.floor((newLocalRow + offset) / pageSize) * pageSize;
              var isLastPage = size - offset < pageSize;
              if (newOffset !== offset || isLastPage) {
                this._application.typeahead.scroll(node, newOffset);
              }
            }
            return true;
          } else {
            // else transfer focus to appropriate widget
            return this._application.focus._transferFocusToNode(actionName, newNode, newLocalRow, newColumn);
          }
        },

        /**
         * @param {classes.TableNode|classes.MatrixNode} node
         * @param {string} actionName abstract name of the action to process
         * @param {string} actionAccelerator accelerator key corresponding to the action
         * @param {classes.ActionNode} [actionNode] - action node to be processed
         * @returns {boolean} true if the action has been processed, false otherwise
         * @private
         */
        _processDisplayTableMatrixLocalAction: function(node, actionName, actionAccelerator, actionNode) {
          var ctrl = node.getController();
          var widget = ctrl.getWidget(); // matrix controller has no widget
          var offset = node.attribute('offset');
          var pageSize = node.attribute('pageSize');
          var size = node.attribute('size');
          var localRow = node.attribute("currentRow") - offset;
          var scrollGridController = null;
          if (widget) { // if there is a widget, it means you are in a table
            localRow = widget.getCurrentRow();
          } else { // if we are in a matrix, we check if a corresponding widget exists (PagedScrollGrid, StretchableScrollGrid, etc..)
            // TODO this could be simplified by using getAncestor('ScrollGrid') and checking types instead of searching for methods
            var matrixParent = node.getParentNode();
            var matrixParentWidget = matrixParent && matrixParent.getController() && matrixParent.getController().getWidget();
            while (matrixParent && matrixParentWidget && !matrixParentWidget.setCurrentRow) {
              matrixParent = matrixParent.getParentNode();
              matrixParentWidget = matrixParent && matrixParent.getController() && matrixParent.getController().getWidget();
            }
            if (matrixParentWidget && matrixParentWidget.getCurrentRow) { // we found a scrollgrid widget, we get its current row
              scrollGridController = matrixParent.getController();
              localRow = matrixParentWidget.getCurrentRow();
            } else if (ctrl.getCurrentRow) { // no widget exists, we get currentrow from matrix controller
              localRow = ctrl.getCurrentRow();
            }
          }

          // compute new row
          var newLocalRow = localRow;

          if (scrollGridController && scrollGridController.isPagedScrollGrid()) {
            // Tab / Shift-Tab should be handled as prevrow and nextrow in paged ScrollGrids
            if (actionName === 'prevfield') {
              actionName = 'prevrow';
            } else if (actionName === 'nextfield') {
              actionName = 'nextrow';
            }
          }
          var isTableNavigation = cls.ActionNode.isTableNavigationAction(actionName);
          if (isTableNavigation) {
            if (node.attribute('multiRowSelection') === 1) {
              return false; // in case of mrs, local actions will be managed by the widget
            }
            var newCurrentRow = cls.TypeAheadCurrentRow.computeNewRowFromAction(node, actionName, localRow + offset, false);
            newLocalRow = newCurrentRow - offset;
          } else {
            var vmEvent = !!actionNode ? new cls.VMActionEvent(actionNode.getId()) : new cls.VMKeyEvent(actionAccelerator);
            this._application.typeahead.event(vmEvent);
            return true;
          }

          // if row has not changed nothing to do
          if (localRow === newLocalRow) {
            return false;
          }

          // if we are outside of [0...pageSize] typeahead is no more possible
          // if we want to put the row on a index >= size of table
          // we don't know what to do --> freeze Typeahead
          if ((newLocalRow >= pageSize || newLocalRow < 0) || ((newLocalRow + offset) >= size)) {
            this._application.typeahead.freeze();
          }

          return this._application.focus._transferFocusToNode(actionName, node, newLocalRow);

        }
      };
    });
    cls.ApplicationServiceFactory.register("Keyboard", cls.KeyboardApplicationService);
  });
;
"use strict";

modulum('LayoutApplicationService', ['ApplicationServiceBase', 'ApplicationServiceFactory', 'LayoutInvalidationService'],
  function(context, cls) {
    /**
     * @class LayoutApplicationService
     * @memberOf classes
     * @extends classes.ApplicationServiceBase
     */
    cls.LayoutApplicationService = context.oo.Class(cls.ApplicationServiceBase, function($super) {
      return /** @lends classes.LayoutApplicationService.prototype */ {
        __name: "LayoutApplicationService",
        /**
         * Timeout identifier (for further feeing purpose)
         * @type {?number}
         */
        _throttle: null,
        /**
         * Mimimum throttle time
         * @type {number}
         */
        _throttleTimeout: 1,

        /**
         * flag to identify layout from resizing
         * @type {boolean}
         */
        _resizing: false,

        /**
         * flag to detect if document is visible (and not running layout computing if not)
         * @type {boolean}
         */
        _documentIsVisible: true,

        /**
         * invalidation number
         * index to compare to measure and allocated space invalidations
         * Used to filter and optimize layout traversal.
         * @type {number}
         */
        _lastInvalidated: 0,

        /**
         * Handle to watch document visibility changes.
         * @type {HandleRegistration}
         */
        _visibilityChangeHandler: null,

        /**
         * flag to know if layout is currently idle.
         * @type {boolean}
         */
        _idle: true,

        /**
         * flag to know if a bonus (adjustMeasure - adjustStretchability - prepareApplyLayout) is needed
         * @type {boolean}
         */
        _backLayout: false,

        /**
         * @inheritDoc
         */
        constructor: function(app) {
          $super.constructor.call(this, app);
          this._updateDocumentVisibility();
          this._visibilityChangeHandler = context.InitService.when(
            context.constants.widgetEvents.visibilityChange,
            this._updateDocumentVisibility.bind(this)
          );
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._throttle) {
            window.clearTimeout(this._throttle);
            this._throttle = null;
          }
          if (this._visibilityChangeHandler) {
            this._visibilityChangeHandler();
            this._visibilityChangeHandler = null;
          }
          $super.destroy.call(this);
        },

        /**
         * update document visibility info and run layout if needed
         * @private
         */
        _updateDocumentVisibility: function() {
          this._documentIsVisible = !document.hidden;
          if (this._documentIsVisible) {
            this.refreshLayout();
          }
        },

        /**
         * reset all layout and rerun it
         */
        reset: function() {
          this._application.getUI().getWidget().getLayoutEngine().reset(true);
          this._registerAnimationFrame(function() {
            this._updateDocumentVisibility();
          }.bind(this));
        },

        /**
         * request a layout refresh
         * @param {Object} [options] options to pass
         * @param {boolean} [options.resize] true if invoked by window resize
         */
        refreshLayout: function(options) {
          options = options || {};
          this._idle = false;
          if (this._throttle) {
            window.clearTimeout(this._throttle);
          }
          this._resizing = Boolean(options.resize);
          if (this._resizing && this._application && this._application.getUI()) {
            this._application.getUI().getWidget().getLayoutEngine().invalidateAllocatedSpace();
          }
          this._throttle = window.setTimeout(function() {
            this._throttle = null;
            if (this._application) {
              this._executeLayout();
            }
          }.bind(this), this._throttleTimeout);
        },

        /**
         * get a list of all children of the given widget that will be renderable
         * @param {classes.WidgetBase} widget the widget
         * @return {classes.WidgetBase[]} a list of renderable children
         */
        _internalChildrenSelector: function(widget) {
          var result = [];
          if (widget && !widget.isHidden()) {
            result = widget.getLayoutEngine() && widget.getLayoutEngine().getRenderableChildren() || [];
          }
          return result;
        },

        /**
         * run the whole layout algorithm
         * @private
         */
        _executeLayout: function() {
          var app = this._documentIsVisible && this._application, // we only get application if document is visible
            node = app && app.model && app.model.getNode(0),
            ctrl = node && node.getController(),
            widget = ctrl && ctrl.getWidget(),
            traversal = null;

          if (widget && document.body.contains(widget.getElement()) && this._application.getUI().isLayoutable()) {
            if (ctrl) {
              context.styler.bufferize();
              var measureInfo = {
                needMeasureSwitching: false,
                needMeasureWidgets: []
              };

              /// Here we declare the whole scenario to compute Genero layout on the whole application tree
              traversal = new window.Throu(widget);

              /// 1. set a default traversal function to run through the widget tree
              traversal.setChildrenSelector(this._internalChildrenSelector.bind(this));

              /// 2. beforeLayout can be defined on each layout engine
              ///    here is to adapt or initiate layout information
              traversal.pass(this.beforeLayout.bind(this));

              /// 3. walk the whole tree to update layouting information (hidden state, need measure switching)
              traversal.pass(this._refreshLayoutPassHidden.bind(this, measureInfo), false, this._hasChildrenFunction);

              /// 4. switch g_measured to g_measuring css class if needed
              traversal.unique(this._switchMeasuring.bind(this, true, measureInfo));

              /// 5. walk the whole tree (from children to parents) to prepare DOM/values to futures measures
              traversal.pass(this.prepareMeasure.bind(this), true);

              /// 6. walk the whole tree (from children to parents) to measure DOM / set values from DOM measures
              traversal.pass(this.measure.bind(this), true);

              /// 7. walk the whole tree (from children to parents) to adjust measures from children information
              traversal.pass(this.adjustMeasure.bind(this), true);

              /// 8. walk the whole tree (from children to parents) to adjust stretchability indices from children information
              traversal.pass(this.adjustStretchability.bind(this), true);

              /// 9. walk the whole tree (from children to parents) to re-adjust measures from children information
              ///    needed for example to manage auto overflow (change shrink rules if form must overflow in all cases)
              traversal.pass(this.reAdjustMeasure.bind(this), true);

              /// 10. walk the whole tree (from children to parents) to re-adjust stretchability indices from children information
              traversal.pass(this.adjustStretchability.bind(this), true);

              /// 11. walk the whole tree to compute space to loss/gain and distsribute it amongst the children
              traversal.pass(this.prepareApplyLayout.bind(this));

              // ### this pass is only done if stack layout has autoscaled image widgets
              ///    12. walk the whole tree (from children to parents) to adjust measures from children information
              traversal.passIf(this.isBackLayoutActivated.bind(this), this.adjustMeasure.bind(this), true);

              ///    13. walk the whole tree (from children to parents) to adjust stretchability indices from children information
              traversal.passIf(this.isBackLayoutActivated.bind(this), this.adjustStretchability.bind(this), true);

              ///    14. walk the whole tree to compute space to loss/gain and distsribute it amongst the children
              traversal.passIf(this.isBackLayoutActivated.bind(this), this.prepareApplyLayout.bind(this));
              // ###

              /// 15. walk the whole tree to apply computed sizes to elements
              traversal.pass(this.applyLayout.bind(this));

              /// 16. switch g_measuring to g_measured css class if needed
              traversal.unique(this._switchMeasuring.bind(this, false, measureInfo));

              /// 17. walk the whole tree to notify listeners of g_layoutApplied
              traversal.pass(this.notifyLayoutApplied.bind(this));

              /// 18. update invalidation indices
              traversal.unique(this._updateInvalidation.bind(this));

              // run the declared passes
              traversal.run();

              context.styler.flush();
              this.emit(context.constants.widgetEvents.layout, this._resizing);

              this._resizing = false;
            }

            this.emit(context.constants.widgetEvents.afterLayout);
            if (this._application) {
              this._registerAnimationFrame(function(traversal) {
                this.emit(context.constants.widgetEvents.afterLayoutFocusRestored);
                this._registerAnimationFrame(function(traversal) {
                  this.emit(context.constants.widgetEvents.afterLayoutComplete);
                  this._idle = true;
                  if (traversal) {
                    traversal.destroy();
                  }
                }.bind(this, traversal));
              }.bind(this, traversal));
            } else {
              this._idle = true;
            }
          }
        },

        /**
         * update invalidation indice
         * @private
         */
        _updateInvalidation: function() {
          this._lastInvalidated = context.LayoutInvalidationService.nextInvalidation();
        },

        /**
         * get list of children of given widget
         * @param {classes.WidgetBase|classes.WidgetGroupBase} widget the widget
         * @return {null|classes.WidgetBase[]}
         * @private
         */
        _hasChildrenFunction: function(widget) {
          return widget && widget.getChildren && widget.getChildren();
        },

        /**
         * toggle css classes to measure DOM elements
         * @param {boolean} measuring true if measuring
         * @param {{needMeasureSwitching: boolean}} measureInfo data bag
         * @private
         */
        _switchMeasuring: function(measuring, measureInfo) {
          if (measureInfo.needMeasureSwitching && !(
              !measureInfo.needMeasureWidgets.length ||
              (measureInfo.needMeasureWidgets.length === 1 && measureInfo.needMeasureWidgets[0].isInstanceOf(cls.FormWidget))
            )) {
            var rootElement = this._application.getUI().getWidget().getElement();
            if (measuring) {
              rootElement.addClass("g_measuring").removeClass("g_measured");
            } else {
              rootElement.addClass("g_measured").removeClass("g_measuring");
            }
          }
          this._backLayout = false;
        },

        /**
         * call beforeLayout of widget's layout engine
         * @param {classes.WidgetBase} widget the widget
         */
        beforeLayout: function(widget) {
          widget.getLayoutEngine().beforeLayout();
        },

        /**
         * update layouting information (hidden state, need measure switching)
         * @param {{needMeasureSwitching: boolean}} measureInfo data bag
         * @param {classes.WidgetBase} widget the widget
         * @param {classes.WidgetBase} parentWidget the parent widget
         * @private
         */
        _refreshLayoutPassHidden: function(measureInfo, widget, parentWidget, traversal) { //TODO if only form, no measureSwitching
          var itemLayoutInformation = widget && widget.getLayoutInformation(),
            itemLayoutEngine = widget && widget.getLayoutEngine(),
            parentLayoutInformation = parentWidget && parentWidget.getLayoutInformation();
          if (itemLayoutInformation && itemLayoutEngine && parentLayoutInformation) {
            itemLayoutInformation.__layoutPassHidden = parentLayoutInformation.__layoutPassHidden || !widget.isVisible();
            itemLayoutInformation.__ignoreMeasureInvalidation =
              (parentLayoutInformation.__ignoreMeasureInvalidation) || itemLayoutEngine.ignoreMeasureInvalidation();

            if (
              (!itemLayoutInformation.__ignoreMeasureInvalidation &&
                (itemLayoutEngine.isInvalidatedMeasure(this._lastInvalidated) && itemLayoutEngine.needMeasureSwitching()))
            ) {
              measureInfo.needMeasureWidgets.push(widget);
              measureInfo.needMeasureSwitching = true;
            }
          }
        },

        /**
         * call prepareMeasure of widget's layout engine
         * @param {classes.WidgetBase} widget the widget
         */
        prepareMeasure: function(widget) {
          var layoutEngine = widget.getLayoutEngine();
          if (layoutEngine && layoutEngine.isInvalidatedMeasure(this._lastInvalidated)) {
            layoutEngine.prepareMeasure();
          }
        },

        /**
         * call different measure steps of widget's layout engine
         * @param {classes.WidgetBase} widget the widget
         */
        measure: function(widget) {
          var layoutEngine = widget.getLayoutEngine();
          if (layoutEngine && layoutEngine.isInvalidatedMeasure(this._lastInvalidated) && widget.getElement().isInDOM()) {
            layoutEngine.resetSizes(this._lastInvalidated, this);

            if (!widget.ignoreLayout()) {
              layoutEngine.measureChar();
            }
            layoutEngine.DOMMeasure();
            layoutEngine.measureDecoration(this._lastInvalidated, this);
            layoutEngine.measure(this._lastInvalidated, this);
            layoutEngine.afterMeasure(this._lastInvalidated, this);
          }
          if (layoutEngine.isInvalidated(this._lastInvalidated)) {
            layoutEngine.prepareAdjustments();
          }
        },

        /**
         * call adjustMeasure of widget's layout engine
         * @param {classes.WidgetBase} widget
         */
        adjustMeasure: function(widget) {
          var layoutEngine = widget.getLayoutEngine();
          if (layoutEngine && layoutEngine.isInvalidated(this._lastInvalidated)) {
            layoutEngine.adjustMeasure(this._lastInvalidated);
            layoutEngine.afterAdjustMeasure(this._lastInvalidated);
          }
        },

        /**
         * call adjustStretchability of widget's layout engine
         * @param {classes.WidgetBase} widget the widget
         */
        adjustStretchability: function(widget) {
          var layoutEngine = widget.getLayoutEngine();
          if (layoutEngine && layoutEngine.isInvalidated(this._lastInvalidated)) {
            layoutEngine.adjustStretchability(this._lastInvalidated);
          }
        },

        /**
         * call adjustMeasure of widget's layout engine if auto overflow is activated
         * @param {classes.WidgetBase} widget the widget
         */
        reAdjustMeasure: function(widget) {
          var form = widget.getFormWidget(),
            formLayoutEngine = form && form.getLayoutEngine();
          if (!form || !formLayoutEngine ||
            (formLayoutEngine.isAutoOverflowActivated && formLayoutEngine.isAutoOverflowActivated())) {
            this.adjustMeasure(widget);
          }
        },

        /**
         * call prepareApplyLayout of widget's layout engine
         * @param {classes.WidgetBase} widget the widget
         */
        prepareApplyLayout: function(widget) {
          var layoutEngine = widget.getLayoutEngine();
          if (layoutEngine && layoutEngine.isInvalidated(this._lastInvalidated)) {
            layoutEngine.prepareApplyLayout(this);
          }
        },

        /**
         * call applyLayout of widget's layout engine
         * @param {classes.WidgetBase} widget the widget
         */
        applyLayout: function(widget) {
          var layoutEngine = widget.getLayoutEngine();
          if (layoutEngine && layoutEngine.isInvalidated(this._lastInvalidated)) {
            layoutEngine.applyLayout();
            layoutEngine.updateInvalidated(this._lastInvalidated);
          }
        },

        /**
         * call notifyLayoutApplied of widget's layout engine
         * @param {classes.WidgetBase} widget the widget
         */
        notifyLayoutApplied: function(widget) {
          var layoutEngine = widget.getLayoutEngine();
          if (layoutEngine) {
            layoutEngine.notifyLayoutApplied();
          }
        },

        /**
         * activate back layout
         */
        activateBackLayout: function() {
          this._backLayout = true;
        },

        /**
         * return true if back layout is activated
         * @return {boolean} true if back layout is activated
         */
        isBackLayoutActivated: function() {
          return this._backLayout;
        },

        /**
         * return true if layout is not running
         * @return {boolean} true if layout is not running
         */
        isIdle: function() {
          return this._idle;
        },

        /**
         * attach to afterLayout event
         * @param {Function} hook the hook
         * @param {boolean} [once] true to free handle after first call
         * @return {HandleRegistration} the event handle
         */
        afterLayout: function(hook, once) {
          return this.when(context.constants.widgetEvents.layout, hook, once);
        },

        /**
         * attach to afterLayoutComplete event
         * @param {Function} hook the hook
         * @param {boolean} [once] true to free handle after first call
         * @return {HandleRegistration} the event handle
         */
        afterLayoutComplete: function(hook, once) {
          return this.when(context.constants.widgetEvents.afterLayoutComplete, hook, once);
        }
      };
    });
    cls.ApplicationServiceFactory.register("Layout", cls.LayoutApplicationService);
  });
;
"use strict";

modulum('MessageApplicationService', ['ApplicationServiceBase', 'ApplicationServiceFactory'],
  function(context, cls) {

    /**
     * @class MessageApplicationService
     * @memberOf classes
     * @extends classes.ApplicationServiceBase
     */
    cls.MessageApplicationService = context.oo.Class(cls.ApplicationServiceBase, function($super) {
      return /** @lends classes.MessageApplicationService.prototype */ {
        __name: "MessageApplicationService",

        /**
         * @type classes.EventListener
         */
        _eventListener: null,

        _messageList: null,
        _maxMessageStack: 10,

        constructor: function() {
          this._messageList = {};
        },

        /**
         * Add a message to the stack
         * @param {string} id - count param
         * @param {classes.MessageWidget} widget - message to add
         */
        addMessage: function(id, widget) {
          this._messageList[id] = widget;
        },

        /**
         * Remove a message by its id
         * @param {string} id - count param
         */
        removeMessage: function(id) {
          if (this._messageList[id]) {
            delete(this._messageList[id]);
          }
          this.handlePositions();
        },

        /**
         * Allow messages and error defined at same position to stack
         * @private
         */
        handlePositions: function() {
          if (this._messageList) {
            var messageKeys = Object.keys(this._messageList).sort(function(a, b) {
              return a - b;
            });
            if (messageKeys.length <= 0) {
              return;
            }
            var bodyRect = document.body.getBoundingClientRect();

            var stack = context.ThemeService.getValue("theme-message-display-position") === context.ThemeService.getValue(
              "theme-error-display-position");

            for (var i = 0; i < messageKeys.length; i++) {
              var messageWidget = this._messageList[messageKeys[i]];
              if (messageWidget && messageWidget.getElement()) {
                var prevWidget = i >= 1 && messageKeys[i - 1] && this._messageList[messageKeys[i - 1]];
                var positionName = messageWidget.getPosition();
                var style = {};
                var margin = context.ThemeService.getValue("theme-margin-ratio") * 14; // TODO : Need to remove margins if screen is really small;
                var drift = {
                  top: 0,
                  bottom: 0,
                  left: 0,
                  right: 0
                };

                var uiWidget = messageWidget.getUserInterfaceWidget();
                if (uiWidget && !uiWidget._destroyed && uiWidget.getContainerElement()) {
                  var userInterfaceRect = uiWidget.getContainerElement().getBoundingClientRect();
                  var messageRect = messageWidget.getElement().getBoundingClientRect();

                  // Use body and ui RECT for position calculations
                  drift.bottom = bodyRect.height - userInterfaceRect.height - userInterfaceRect.top;
                  drift.top = userInterfaceRect.top;
                  drift.left = bodyRect.left + userInterfaceRect.left;
                  drift.center = drift.left + (userInterfaceRect.width / 2) - (messageRect.width / 2);

                  var overlap = prevWidget && this._checkOverlap(messageWidget, prevWidget);
                  var anyHidden = messageWidget.isHidden() || (prevWidget && prevWidget.isHidden());

                  // Handle stack if more than 1 message and none of the widgets is hidden
                  if ((i >= 1 && (stack || overlap)) && !anyHidden) {
                    drift.bottom += messageRect.height + (margin / 2);
                    drift.top += messageRect.height + (margin / 2);
                  }

                  if (positionName.indexOf("top") >= 0) {
                    style.top = (margin + drift.top).toFixed() + "px";
                    style.bottom = null;
                  }
                  if (positionName.indexOf("bottom") >= 0) {
                    style.top = null;
                    style.bottom = (margin + drift.bottom).toFixed() + "px";
                  }
                  if (positionName.indexOf("right") >= 0) {
                    style.left = null;
                    style["margin-left"] = margin.toFixed() + "px";
                    style.right = margin.toFixed() + "px";
                  }
                  if (positionName.indexOf("left") >= 0) {
                    style.left = (margin + drift.left).toFixed() + "px";
                    style.right = null;
                    style["margin-right"] = margin.toFixed() + "px";
                  }
                  if (positionName.indexOf("center") >= 0) {
                    style.left = (margin + drift.center).toFixed() + "px";
                    style.right = null;
                    style["margin-right"] = margin.toFixed() + "px";
                  }

                  if (!messageWidget.isHidden()) {
                    style.opacity = 1;
                    style["z-index"] = context.ThemeService.getValue("gbc-MessageWidget-z-index");
                  } else {
                    style.opacity = 0;
                    style["z-index"] = -1;
                  }
                  messageWidget.setStyle(style);
                }
              }
            }
          }
        },

        /**
         * Check if 2 widgets overlap in the view
         * @param w1 - first widget to compare
         * @param w2 - second widget to compare
         * @return {boolean} - true if overlap, false otherwise
         * @private
         */
        _checkOverlap: function(w1, w2) {
          if (w1.isHidden() || w2.isHidden()) {
            return false;
          }
          var rect1 = w1.getElement().getBoundingClientRect();
          var rect2 = w2.getElement().getBoundingClientRect();
          return !(rect1.right < rect2.left ||
            rect1.left > rect2.right ||
            rect1.bottom < rect2.top ||
            rect1.top > rect2.bottom);
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._messageList = null;
          $super.destroy.call(this);
        }
      };
    });
    cls.ApplicationServiceFactory.register("Message", cls.MessageApplicationService);
  });
;
"use strict";

modulum('BrowserBackSpecialAction', ['ActionApplicationService'],
  function(context, cls) {
    /**
     * @class BrowserBackSpecialAction
     * @memberOf classes
     */
    cls.BrowserBackSpecialAction = context.oo.Class(function() {
      return /** @lends classes.BrowserBackSpecialAction.prototype */ {
        __name: "BrowserBackSpecialAction",
        /** @type {classes.ActionApplicationService} */
        _actionService: null,
        _listener: null,
        constructor: function(actionService) {
          this._actionService = actionService;
          this._listener = this._onBrowserBack.bind(this);
          if (history.pushState) {
            history.replaceState("back", "");
            history.pushState("", "");
            history.pushState("forward", "");
            history.back();
          }
          window.addEventListener("popstate", this._listener);
        },

        destroy: function() {
          window.removeEventListener("popstate", this._listener);
          this._actionService = null;
        },
        _onBrowserBack: function(event) {
          if (this._actionService && this._actionService.hasAction("browser_back")) {
            if (event.state && event.state === "back") { //back or forward
              this._actionService.executeByName("browser_back");
              history.forward();
            }
          }
        }
      };
    });
    cls.ActionApplicationService.registerSpecialAction("browser_back", cls.BrowserBackSpecialAction);
  });
;
"use strict";

modulum('BrowserForwardSpecialAction', ['ActionApplicationService'],
  function(context, cls) {
    /**
     * @class BrowserForwardSpecialAction
     * @memberOf classes
     */
    cls.BrowserForwardSpecialAction = context.oo.Class(function() {
      return /** @lends classes.BrowserForwardSpecialAction.prototype */ {
        __name: "BrowserForwardSpecialAction",
        /** @type {classes.ActionApplicationService} */
        _actionService: null,
        _listener: null,
        constructor: function(actionService) {
          this._actionService = actionService;
          this._listener = this._onBrowserForward.bind(this);
          if (history.pushState) {
            history.replaceState("back", "");
            history.pushState("", "");
            history.pushState("forward", "");
            history.back();
          }
          window.addEventListener("popstate", this._listener);
        },

        destroy: function() {
          window.removeEventListener("popstate", this._listener);
          this._actionService = null;
        },
        _onBrowserForward: function(event) {
          if (this._actionService && this._actionService.hasAction("browser_forward")) {
            if (event.state && event.state === "forward") { //back or forward
              this._actionService.executeByName("browser_forward");
              history.back();
            }
          }
        }
      };
    });
    cls.ActionApplicationService.registerSpecialAction("browser_forward", cls.BrowserForwardSpecialAction);
  });
;
"use strict";

modulum('WindowResizedSpecialAction', ['ActionApplicationService'],
  function(context, cls) {
    /**
     * @class WindowResizedSpecialAction
     * @memberOf classes
     */
    cls.WindowResizedSpecialAction = context.oo.Class(function() {
      return /** @lends classes.WindowResizedSpecialAction.prototype */ {
        __name: "WindowResizedSpecialAction",
        /** @type {classes.ActionApplicationService} */
        _actionService: null,
        _listener: null,
        constructor: function(actionService) {
          this._actionService = actionService;
          this._listener = context.HostService.onScreenResize(this._onResized.debounce().bind(this));
        },

        destroy: function() {
          if (this._listener) {
            this._listener();
            this._listener = null;
          }
          this._actionService = null;
        },
        _onResized: function() {
          if (this._actionService && this._actionService.hasAction("windowresized")) {
            this._actionService.executeByName("windowresized");
          }
        }
      };
    });
    cls.ActionApplicationService.registerSpecialAction("windowresized", cls.WindowResizedSpecialAction);
  });
;
"use strict";

modulum('TreeModificationTracker', [],
  function(context, cls) {
    /**
     * Records AUI tree modifications
     * @class TreeModificationTracker
     * @memberOf classes
     */
    cls.TreeModificationTracker = context.oo.Class(function($super) {
      return /** @lends classes.TreeModificationTracker.prototype */ {
        __name: "TreeModificationTracker",

        /** @type Map<number,*>*/
        _modifications: null,

        constructor: function() {
          this._modifications = new Map();
        },

        /**
         * Returns the tree modifications for the given node. Creates a new entry if not found
         * @param {number} nodeId node idRef
         * @return {*} the modifications for the given node
         * @private
         */
        _fetch: function(nodeId) {
          var mods = this._modifications.get(nodeId);
          if (!mods) {
            mods = {
              createdSubTreeRoot: false,
              created: false,
              removed: false,
              updatedAttributes: {}
            };
            this._modifications.set(nodeId, mods);
          }
          return mods;
        },

        /**
         * @param {number} nodeId
         * @return {*} the node's modifications or undefined
         */
        get: function(nodeId) {
          return this._modifications.get(nodeId);
        },

        /**
         * Records a node creation
         * @param {number} nodeId node idRef
         * @param subTreeRoot true if this is a VM order sub tree root node
         */
        nodeCreated: function(nodeId, subTreeRoot) {
          var mods = this._fetch(nodeId);
          mods.created = true;
          mods.createdSubTreeRoot = !!subTreeRoot;
        },

        /**
         * @param {number} nodeId node idRef
         * @return {boolean} true if the node has been created
         */
        isNodeCreated: function(nodeId) {
          var mods = this._modifications.get(nodeId);
          return mods ? mods.created : false;
        },

        /**
         * @param {number} nodeId node idRef
         * @return {*} true if the node is a VM sub tree root node
         */
        isNodeCreatedAndSubTreeRoot: function(nodeId) {
          var mods = this._modifications.get(nodeId);
          return mods ? mods.createdSubTreeRoot : false;
        },

        /**
         * Records a removed node
         * @param {number} nodeId node idRef
         */
        nodeRemoved: function(nodeId) {
          this._fetch(nodeId).removed = true;
        },

        /**
         * @param {number} nodeId node idRef
         * @return {boolean} true if the node has been removed
         */
        isNodeRemoved: function(nodeId) {
          var mods = this._modifications.get(nodeId);
          return mods ? mods.removed : false;
        },

        /**
         * Records an attribute modification
         * @param {number} nodeId node idRef
         * @param {string} attributeName name of the attribute
         */
        attributeChanged: function(nodeId, attributeName) {
          this._fetch(nodeId).updatedAttributes[attributeName] = true;
        },

        /**
         * @param {number} nodeId node idRef
         * @return {{string:boolean}} the updated attributes
         */
        getChangedAttributes: function(nodeId) {
          var mods = this._modifications.get(nodeId);
          return mods ? mods.updatedAttributes : {};
        },

        /**
         * @param {number} nodeId node idRef
         * @param attributeName attribute name
         * @return {boolean} true if the attribute value has changed
         */
        isNodeAttributeChanged: function(nodeId, attributeName) {
          var mods = this._modifications.get(nodeId);
          return mods ? mods.updatedAttributes[attributeName] : false;
        },

        /**
         * Iterate over all modifications
         * @param {Function} handler callback with value, keys arguments
         */
        forEach: function(handler) {
          this._modifications.forEach(handler);
        }
      };
    });
  }
);
;
"use strict";
modulum('UIApplicationService', ['ApplicationServiceBase', 'ApplicationServiceFactory'],
  function(context, cls) {
    /**
     * @class UIApplicationService
     * @memberOf classes
     * @extends classes.ApplicationServiceBase
     */
    cls.UIApplicationService = context.oo.Class(cls.ApplicationServiceBase, function($super) {
      return /** @lends classes.UIApplicationService.prototype */ {
        __name: "UIApplicationService",
        /**
         * @type {classes.ApplicationWidget}
         */
        _applicationWidget: null,
        constructor: function(app) {
          $super.constructor.call(this, app);
          this._applicationWidget = cls.WidgetFactory.createWidget("Application", {
            appHash: this._application.applicationHash
          });
          this._applicationWidget.setApplicationHash(app.applicationHash);
          this._applicationWidget.onActivate(this._onActivate.bind(this));
          this._application.getSession().addApplicationWidget(app, this._applicationWidget);
          this._applicationWidget.onLayoutRequest(this._onLayoutRequest.bind(this));
        },
        _onActivate: function() {
          this._application.getSession().setCurrentApplication(this._application);
        },
        _onLayoutRequest: function() {
          this._application.layout.refreshLayout();
        },
        destroy: function() {
          if (!this._destroyed) {
            this._applicationWidget.destroy();
            this._applicationWidget = null;
            $super.destroy.call(this);
          }
        },
        /**
         *
         * @returns {classes.ApplicationWidget}
         */
        getWidget: function() {
          return this._applicationWidget;
        },
        setRunning: function(running) {
          if (running) {
            this.getWidget().hideWaiter();
          }
        },
        isLayoutable: function() {
          return this.getWidget() && this.getWidget().getElement() && !this.getWidget().getElement().hasClass("gbc_out_of_view");
        }
      };
    });
    cls.ApplicationServiceFactory.register("UI", cls.UIApplicationService);
  });
;
"use strict";
modulum('VMApplication', ['EventListener'],
  function(context, cls) {
    /**
     * Object that represents an application of a VM Session
     * @class VMApplication
     * @memberOf classes
     * @extends classes.EventListener
     * @publicdoc Base
     */
    cls.VMApplication = context.oo.Class(cls.EventListener, function($super) {
      return /** @lends classes.VMApplication.prototype */ {
        $static: /** @lends classes.VMApplication */ {
          styleListLoaded: "gStyleListLoaded"
        },
        __name: "VMApplication",
        /** General information for this application
         * @type classes.VMApplicationInfo
         */
        applicationInfo: null,
        /** Indicator to know if the application is running or not */
        running: false,
        /** Indicator to know if the application is ending */
        ending: false,
        ended: false,
        /** Indicator to know if the application has protocol error */
        hasError: false,
        /** protocolInterface
         * @type classes.ProtocolInterface
         */
        protocolInterface: null,
        /** dvm management
         * @type classes.DVMApplicationService
         */
        dvm: null,
        /** model (aui) management
         * @type classes.AuiApplicationService
         */
        model: null,
        /** layout management
         * @type classes.LayoutApplicationService
         */
        layout: null,
        /** actions
         * @type classes.ActionApplicationService
         */
        action: null,
        /** file transfer management
         * @type classes.FileTransferApplicationService
         */
        filetransfer: null,
        /** type ahead management
         * @type classes.TypeAheadApplicationService
         */
        typeahead: null,
        /** keyboard management
         * @type classes.KeyboardApplicationService
         */
        keyboard: null,
        /** Focus management
         * @type classes.FocusApplicationService
         */
        focus: null,
        /** application ui
         * @type classes.UIApplicationService
         * */
        _ui: null,
        /**
         * @type {classes.VMSession}
         */
        _session: null,

        /** @type {Array} */
        styleAttributesChanged: null,

        /** @type {boolean} */
        styleListsChanged: false,

        /** @type {Object} */
        usedStyleAttributes: {},

        _currentlyProcessing: false,
        _processingDelayer: 0,

        /**
         *
         * @param {classes.VMApplicationInfo} info - application info
         * @param {classes.VMSession} session

         */
        constructor: function(info, session) {
          $super.constructor.call(this);
          this._session = session;
          this.applicationInfo = info;
          this.applicationHash = session.getApplicationIdentifier();
          if (!info.inNewWindow) {
            this._ui = cls.ApplicationServiceFactory.create('UI', this);
            this.dvm = cls.ApplicationServiceFactory.create('Dvm', this);
            this.model = cls.ApplicationServiceFactory.create('Model', this);
            this.layout = cls.ApplicationServiceFactory.create('Layout', this);
            this.action = cls.ApplicationServiceFactory.create('Action', this);
            this.filetransfer = cls.ApplicationServiceFactory.create('FileTransfer', this);
            this.typeahead = cls.ApplicationServiceFactory.create('TypeAhead', this);
            this.keyboard = cls.ApplicationServiceFactory.create('Keyboard', this);
            this.focus = cls.ApplicationServiceFactory.create('Focus', this);
            this.message = cls.ApplicationServiceFactory.create('Message', this);
          }
          this.protocolInterface = cls.ApplicationServiceFactory.create(this._getProtocolInterface(info), this);

          this.styleAttributesChanged = [];
          context.WidgetService.registerVMApplication(this);
        },
        /**
         * Get the owning session
         * @returns {classes.VMSession} The owning session
         * @publicdoc
         */
        getSession: function() {
          return this._session;
        },

        waitForNewApp: function(onSuccess, onFailure) {
          this.protocolInterface.waitForNewApp(onSuccess, onFailure);
        },
        _getProtocolInterface: function(info) {
          var result = "NoProtocolInterface";
          switch (info.mode) {
            case "direct":
              result = "DirectProtocolInterface";
              break;
            case "ua":
              result = "UAProtocolInterface";
              break;
            default:
              break;
          }
          return result;
        },
        /**
         * @inheritDoc
         */
        destroy: function() {
          if (!this._destroyed) { // TODO whe should not call destroy on a destroyed object
            this._ui.destroy();
            this.filetransfer.destroy();
            this._session.remove(this);
            this.model.destroy();

            this.applicationInfo = null;

            this._session = null;
            this._ui = null;
            this.dvm = null;
            this.model = null;
            this.layout = null;
            this.action = null;
            this.filetransfer = null;
            this.typeahead = null;
            this.keyboard = null;
            this.focus = null;
            this.message = null;
            this.protocolInterface = null;

            $super.destroy.call(this);

            context.WidgetService.unregisterVMApplication(this);
          }
        },

        start: function() {
          this.protocolInterface.start(this.applicationInfo);
        },
        stop: function(message) {
          if (!this.stopping) {
            this.stopping = true;
            if (!this.ended) {
              if (message) {
                this.applicationInfo.ending = cls.ApplicationEnding.notok(message);
              }
              if (!this.applicationInfo.ending) {
                this.applicationInfo.ending = cls.ApplicationEnding.ok;
              }
              if (this.applicationInfo.urlParameters.logPlayer) {
                this.applicationInfo.ending = cls.ApplicationEnding.logPlayer;
              }

              context.styler.bufferize();
              // TODO reorder, why we don't call this in destroy ??
              this.typeahead.destroy();
              this.model.remove();
              this.setEnding();
              this.action.destroy();
              this.layout.destroy();
              this.model.stop();
              this.dvm.destroy();
              this.protocolInterface.destroy();
              this.keyboard.destroy();
              this.focus.destroy();
              this.filetransfer.destroy();
              this.message.destroy();

              this.destroy();
              context.styler.flush();
              this.ended = true;
            }
          }
        },
        /**
         * Set status of application
         * @param {boolean} running Status
         */
        setRunning: function(running) {
          this.running = running;
          this._ui.setRunning(running);
        },

        /**
         * Set the error status at application's protocol error
         */
        setError: function() {
          this.hasError = true;
        },

        /**
         * Set the ending status at application's end
         */
        setEnding: function() {
          if (!this.ending && !this.ended && !this._destroyed) {
            this.ending = true;
            this.setIdle();
          }
        },

        /**
         * Returns this application's info.
         * @returns {classes.VMApplicationInfo}
         */
        info: function() {
          return this.applicationInfo;
        },
        /**
         * Get application instantiated node by its Aui Id
         * @param {number} id the node id
         * @returns {classes.NodeBase} the node, if found
         * @publicdoc
         */
        getNode: function(id) {
          return this.model && this.model.getNode(id);
        },
        uiNode: function() {
          return this.getNode(0);
        },

        /**
         * Get the VM Focused Node instance
         * @returns {classes.NodeBase} The VM focused node
         * @publicdoc
         */
        getFocusedVMNode: function() {
          var uiNode = this.uiNode();
          if (uiNode) {
            var id = uiNode.attribute("focus");
            return this.getNode(id);
          }
          return null;
        },

        /**
         * Get the VM Focused Node instance
         * or if the focused node is a table or a matrix get the current value node
         * @param {boolean} [inputModeOnly] - return value node only if is node is in INPUT mode
         * @returns {*|classes.NodeBase}
         */
        getFocusedVMNodeAndValue: function(inputModeOnly) {
          var focusedNode = this.getFocusedVMNode();
          if (focusedNode && focusedNode.getCurrentValueNode) {
            var currentValueNode = focusedNode.getCurrentValueNode(inputModeOnly);
            if (currentValueNode) {
              focusedNode = currentValueNode;
            }
          }
          return focusedNode;
        },

        newTask: function() {
          var opener = this._session && this._session._browserMultiPageModeAsChild && window.opener,
            openerSession = opener && opener.gbc && window.opener.gbc.SessionService.getCurrent();
          if (openerSession) {
            openerSession.newTask();
          } else {
            this.protocolInterface.newTask();
          }
        },
        /**
         * Set the idle status to true
         */
        setIdle: function() {
          this._setProcessingStyle(false);
          this.dvm.setIdle(true);
          this.action.setInterruptablesActive(false);
        },
        /**
         * Set the processing status to true
         */
        setProcessing: function() {
          this._setProcessingStyle(true);
          this.dvm.setIdle(false);
          this.action.setInterruptablesActive(true);
          if (gbc.ThemeService.getValue("theme-legacy-topbar")) {
            this.getMenu("runtimeStatus").setProcessing();
          }
        },

        _setProcessingStyleImpl: function(processing) {
          this._processingDelayer = 0;
          if (this._ui && this._ui.getWidget()) {
            this._ui.getWidget().getSidebarWidget().setProcessing(processing);
            var windows = this.model.getNodesByTag("Window"),
              len = windows.length,
              i = 0;
            for (; i < len; i++) {
              if (windows[i] && windows[i]._setProcessingStyle) {
                windows[i]._setProcessingStyle(processing);
              }
            }
          }
        },

        _setProcessingStyle: function(processing) {
          if (!processing) {
            if (this._processingDelayer !== 0) {
              this._clearAnimationFrame(this._processingDelayer);
              this._processingDelayer = 0;
            }
            this._setProcessingStyleImpl(false);
          } else {
            if (this._processingDelayer === 0) {
              this._processingDelayer = this._registerAnimationFrame(this._setProcessingStyleImpl.bind(this, true));
            }
          }
        },
        /**
         * Check if the application is idle
         * @returns {boolean} true if idle, false otherwise
         */
        isIdle: function() {
          return this.dvm.idle;
        },

        /**
         * Check if the application is running
         * @returns {boolean} true if running, false otherwise
         */
        isProcessing: function() {
          return !this.dvm.idle;
        },
        /**
         * Send an Interrupt order
         */
        interrupt: function() {
          this.protocolInterface.interrupt();
        },
        close: function() {
          if (!this.ended && !this._destroyed) {
            if (this.ending) {
              this.destroy();
            } else {
              this.protocolInterface.close();
            }
          }
        },
        error: function() {
          this.setEnding();
        },
        /**
         * fail application gracefully,
         * @param ending ending message
         */
        fail: function(ending) {
          if (ending) {
            this.applicationInfo.ending = cls.ApplicationEnding.notok(ending);
          }
          this._registerTimeout(function() {
            this.stop(ending);
          }.bind(this));
        },
        /**
         * get active window
         * @returns {classes.WindowNode}
         */
        getVMWindow: function() {
          if (this.ending) {
            return null;
          }
          var uiNode = this.uiNode();
          if (uiNode && uiNode.isAttributeSetByVM("currentWindow")) {
            return this.model.getNode(uiNode.attribute("currentWindow"));
          } else {
            return null;
          }
        },

        getActionApplicationService: function() {
          return this.action;
        },

        getTitle: function() {
          if (this.uiNode()) {
            return this.uiNode().attributes.text || this.uiNode().attributes.name;
          } else {
            return "New application";
          }
        },

        /**
         *
         * @param {classes.WidgetBase} widget
         */
        attachRootWidget: function(widget) {
          this._ui.getWidget().addChildWidget(widget);
        },
        /**
         *
         * @returns {classes.UIApplicationService}
         */
        getUI: function() {
          return this._ui;
        },

        /**
         * Get items from the chromebar or from the applicationHostWidget if legacy mode enabled
         * @param {String} name
         * @return {*}
         */
        getMenu: function(name) {
          var sessionWidget = this.getSession().getWidget();
          var menu = null;
          if (!gbc.ThemeService.getValue("theme-legacy-topbar")) {
            menu = this.getUI().getWidget().getUserInterfaceWidget().getChromeBarWidget();
            return menu.getGbcMenuItem(name);
          } else {
            var applicationHostWidget = sessionWidget.getParentWidget();
            menu = applicationHostWidget._menu;
            return name ? menu["_" + name] : menu;
          }
        },

        /**
         * Get the Chromebar
         * @return {classes.ChromeBarWidget|null} the chromebar
         */
        getChromeBar: function() {
          return this.getUI().getWidget().getUserInterfaceWidget().getChromeBarWidget();
        },

        hasActiveKeyEventNode: function() {
          var uiNode = this.uiNode();
          if (uiNode) {
            var focusId = uiNode.attribute('focus');
            var focusedNode = this.getNode(focusId);
            if (['Table', 'Matrix', 'Menu', 'MenuAction', 'Dialog', 'Action'].indexOf(focusedNode.getTag()) !== -1) {
              var isActive = focusedNode.attribute('active') === 1;
              return isActive && (!focusedNode.isAttributePresent("dialogType") || focusedNode.attribute("dialogType").startsWith(
                "Display")); // if node is table and is in display or displayarray mode (only send keys to VM if not in edit mode)
            }
          }
          return false;
        },

        setBrowserMultiPageMode: function(activation) {
          var applicationCount = this._session && this._session.getApplications().length;
          if (applicationCount === 1) {
            if (activation) {
              this._session.activateBrowserMultiPageMode();
            }
          }
        },

        setTabbedContainerMode: function(activation, windowNode) {
          if (this._session && activation) {
            this._session.activateTabbedContainerMode(windowNode);
          }
        },

        /** Return the action node of active dialog according to vmKey param
         *
         * @param vmKey
         * @returns {*} vm event
         */
        getActiveDialogAction: function(vmKey) {

          var actionNode = null;
          var window = this.getVMWindow();
          var acceleratorName = null;
          var acceleratorName2 = null;
          var acceleratorName3 = null;
          var acceleratorName4 = null;

          if (window) { // search the action in the current dialog
            var dialog = window.getActiveDialog();
            if (dialog) {
              var actions = dialog.getChildren();
              for (var i = 0; i < actions.length; ++i) {
                var action = actions[i];
                var isActive = (action.attribute("active") !== 0);
                if (isActive) {
                  acceleratorName = action.attribute("acceleratorName");
                  acceleratorName2 = action.attribute("acceleratorName2");
                  acceleratorName3 = action.attribute("acceleratorName3");
                  acceleratorName4 = action.attribute("acceleratorName4");
                  if (acceleratorName && acceleratorName.toString().toLowerCase() === vmKey ||
                    acceleratorName2 && acceleratorName2.toString().toLowerCase() === vmKey ||
                    acceleratorName3 && acceleratorName3.toString().toLowerCase() === vmKey ||
                    acceleratorName4 && acceleratorName4.toString().toLowerCase() === vmKey) {
                    actionNode = action;
                  }
                }
              }
            }
          }
          return actionNode;
        },

        /** Return the action node of default action list according to vmKey param
         *
         * @param vmKey
         * @returns {*} vm event
         */
        getDefaultAction: function(vmKey) {
          var acceleratorName = null;
          var acceleratorName2 = null;
          var acceleratorName3 = null;
          var acceleratorName4 = null;

          // search the action in the action default list
          var actionDefaultList = this.uiNode() && this.uiNode().getFirstChild("ActionDefaultList");
          if (actionDefaultList) {
            var actionDefaults = actionDefaultList.getChildren();
            for (var i = 0; i < actionDefaults.length; ++i) {
              var actionDefault = actionDefaults[i];
              acceleratorName = actionDefault.attribute("acceleratorName");
              acceleratorName2 = actionDefault.attribute("acceleratorName2");
              acceleratorName3 = actionDefault.attribute("acceleratorName3");
              acceleratorName4 = actionDefault.attribute("acceleratorName4");
              if (acceleratorName && acceleratorName.toString().toLowerCase() === vmKey ||
                acceleratorName2 && acceleratorName2.toString().toLowerCase() === vmKey ||
                acceleratorName3 && acceleratorName3.toString().toLowerCase() === vmKey ||
                acceleratorName4 && acceleratorName4.toString().toLowerCase() === vmKey) {
                return actionDefault;
              }
            }
          }
          return null;
        },

        getDefaultActionForName: function(name) {
          var actionDefaultList = this.uiNode() && this.uiNode().getFirstChild("ActionDefaultList");
          if (actionDefaultList) {
            var actionDefaults = actionDefaultList.getChildren();
            for (var i = 0; i < actionDefaults.length; ++i) {
              var actionDefault = actionDefaults[i];
              if (name === actionDefault.attribute("name")) {
                return actionDefault;
              }
            }
          }
          return null;
        }
      };
    });
  });
;
"use strict";
modulum('VMApplicationInfo',
  function(context, cls) {
    /**
     * Stores application general information like VM dialog configuration and parameters.
     * @class VMApplicationInfo
     * @memberOf classes
     */
    cls.VMApplicationInfo = context.oo.Class(function() {
      return /** @lends classes.VMApplicationInfo.prototype */ {
        __name: "VMApplicationInfo",
        /**
         * Application VM dialog mode : 'ua' or 'direct'
         * @type {?string}
         */
        mode: null,
        /**
         * Application identifier
         * @type {?string}
         */
        appId: null,
        /**
         * First front-end identifier (VM dialog)
         * @type {?string}
         */
        frontEndId1: null,
        /**
         * Second front-end identifier (VM dialog)
         * @type {?string}
         */
        frontEndId2: null,
        /**
         * Default time to ping VM (ms)
         * @type {number}
         */
        pingTimeout: 1000,
        /**
         * VM connection info
         * @type {Object}
         */
        connectionInfo: null,
        /**
         * Session identifier in UA dialog
         * @type {?string}
         */
        session: null,
        /**
         * Page number in UA dialog
         * @type {number}
         */
        page: 1,
        /**
         * Aui dialog om order increment
         * @type {number}
         */
        auiOrder: 0,
        /**
         * Default relative path to Web components
         * @type {?string}
         */
        webComponent: null,
        /**
         * User defined relative path to Web components
         * @type {?string}
         */
        webComponentUsrPath: null,
        /**
         * If style browserMultiPage is activated, helps to know where to open the new application
         * @type {boolean}
         */
        inNewWindow: false,
        /**
         *
         * @param {classes.VMApplicationInfo|Object} info - info definition
         */
        constructor: function(info) {
          this.mode = "ua";
          var keys = Object.keys(info);
          for (var k = 0; k < keys.length; k++) {
            this[keys[k]] = info[keys[k]];
          }
          this.ending = null;
        }
      };
    });
  });
;
"use strict";
modulum('VMActionEvent', ['VMEventBase'],
  function(context, cls) {
    /**
     *
     * @class VMActionEvent
     * @memberOf classes
     * @extends classes.VMEventBase
     */
    cls.VMActionEvent = context.oo.Class({
      base: cls.VMEventBase
    }, function() {
      return /** @lends classes.VMActionEvent.prototype */ {
        __name: "VMActionEvent",
        type: "actionEvent",
        /**
         * @type {Object}
         */
        attributes: null,

        /**
         * to know that the action is not from a user interaction (ON IDLE)
         * @type {boolean}
         */
        noUserActivity: false,

        /**
         * @param {string} idRef reference of the node holding the action
         */
        constructor: function(idRef) {
          this.attributes = {
            idRef: idRef
          };
        }
      };
    });
  });
;
"use strict";
modulum('VMConfigureEvent', ['VMEventBase'],
  function(context, cls) {
    /**
     *
     * @class VMConfigureEvent
     * @memberOf classes
     * @extends classes.VMEventBase
     */
    cls.VMConfigureEvent = context.oo.Class({
      base: cls.VMEventBase
    }, function() {
      return /** @lends classes.VMConfigureEvent.prototype */ {
        __name: "VMConfigureEvent",
        type: "configureEvent",
        /**
         * @type {Object}
         */
        attributes: null,
        /**
         * @type {Function}
         */
        lazyResolve: null,
        /**
         * @param {string} idRef reference of the node to update
         * @param {object} attr dictionary of attributes to update
         * @param {function} lazyResolve
         */
        constructor: function(idRef, attr, lazyResolve) {
          this.attributes = {
            idRef: idRef
          };
          var keys = Object.keys(attr);
          for (var k = 0; k < keys.length; k++) {
            this.attributes[keys[k]] = attr[keys[k]];
          }
          this.lazyResolve = lazyResolve;
        }
      };
    });
  });
;
"use strict";
modulum('VMDragDropEvent', ['VMEventBase'],
  function(context, cls) {
    /**
     *
     * @class VMDragDropEvent
     * @memberOf classes
     * @extends classes.VMEventBase
     */
    cls.VMDragDropEvent = context.oo.Class({
      base: cls.VMEventBase
    }, function() {
      return /** @lends classes.VMDragDropEvent.prototype */ {
        __name: "VMDragDropEvent",
        type: "dragDropEvent",
        /**
         * @type {Object}
         */
        attributes: null,

        /**
         * @param {string} idRef
         * @param {object} attr
         */
        constructor: function(idRef, attr) {
          this.attributes = {
            idRef: idRef
          };
          var keys = Object.keys(attr);
          for (var k = 0; k < keys.length; k++) {
            this.attributes[keys[k]] = attr[keys[k]];
          }

        }
      };
    });
  });
;
"use strict";
modulum('VMEventBase',
  function(context, cls) {
    /**
     * Base class of vm events
     * @class VMEventBase
     * @memberOf classes
     */
    cls.VMEventBase = context.oo.Class(function() {
      return /** @lends classes.VMEventBase.prototype */ {
        __name: "VMEventBase"
      };
    });
  });
;
"use strict";
modulum('VMFunctionCallEvent', ['VMEventBase'],
  function(context, cls) {
    /**
     *
     * @class VMFunctionCallEvent
     * @memberOf classes
     * @extends classes.VMEventBase
     */
    cls.VMFunctionCallEvent = context.oo.Class({
      base: cls.VMEventBase
    }, function() {
      return /** @lends classes.VMFunctionCallEvent.prototype */ {
        $static: /** @lends classes.VMFunctionCallEvent */ {
          success: 0, // Success
          unknownFunction: -1, // The function is not defined in the specified package
          unknownModule: -2, // Unknown module or shared library could not be loaded
          stackError: -3, // Wrong number of parameters or return values. Stack problem.
          functionError: -4 // Function call failed - fatal error in front-end function
        },

        __name: "VMFunctionCallEvent",
        type: "functionCallEvent",
        status: null,
        message: null,
        values: null,

        /**
         * @param status
         * @param message
         * @param values
         */
        constructor: function(status, message, values) {
          this.status = status;
          this.message = message;
          this.values = values;
        }
      };
    });
  });
;
"use strict";
modulum('VMKeyEvent', ['VMEventBase'],
  function(context, cls) {
    /**
     *
     * @class VMKeyEvent
     * @memberOf classes
     * @extends classes.VMEventBase
     */
    cls.VMKeyEvent = context.oo.Class({
      base: cls.VMEventBase
    }, function() {
      return /** @lends classes.VMKeyEvent.prototype */ {
        __name: "VMKeyEvent",
        type: "keyEvent",
        /**
         * @type {Object}
         */
        attributes: null,
        /**
         * @param keyName {string} keyName name of the pressed key
         * @param idRef {string?} optional idRef (used for canvas)
         */
        constructor: function(keyName, idRef) {
          this.attributes = {
            keyName: keyName
          };
          if (idRef !== undefined) {
            this.attributes.idRef = idRef;
          }
        }
      };
    });
  });
;
"use strict";
modulum('VMRowSelectionEvent', ['VMEventBase'],
  function(context, cls) {
    /**
     *
     * @class VMRowSelectionEvent
     * @memberOf classes
     * @extends classes.VMEventBase
     */
    cls.VMRowSelectionEvent = context.oo.Class({
      base: cls.VMEventBase
    }, function() {
      return /** @lends classes.VMRowSelectionEvent.prototype */ {
        __name: "VMRowSelectionEvent",
        type: "rowSelectionEvent",
        /**
         * @type {Object}
         */
        attributes: null,
        /**
         * @param {string} idRef reference of the table
         * @param {object} attr row update information
         */
        constructor: function(idRef, attr) {
          this.attributes = {
            idRef: idRef
          };
          var keys = Object.keys(attr);
          for (var k = 0; k < keys.length; k++) {
            this.attributes[keys[k]] = attr[keys[k]];
          }
        }
      };
    });
  });
;
"use strict";

modulum('ProtocolFactory', ['ApplicationServiceFactory'],

  function(context, cls) {
    cls.ApplicationServiceFactory.register("NoProtocolInterface", cls.NoInterface);
    cls.ApplicationServiceFactory.register("UAProtocolInterface", cls.UAInterface);
    cls.ApplicationServiceFactory.register("DirectProtocolInterface", cls.DirectInterface);
  });
;
"use strict";

modulum("VMSession", ["EventListener"],
  function(context, cls) {
    /**
     * A VM driven Session
     * @class VMSession
     * @memberOf classes
     * @extends classes.EventListener
     * @publicdoc Base
     */
    cls.VMSession = context.oo.Class(cls.EventListener, function($super) {
      return /** @lends classes.VMSession.prototype */ {
        __name: "VMSession",
        /**
         * @type {?string}
         */
        _identifier: null,
        /**
         * @type {?string}
         */
        _sessionId: null,
        /**
         * @type {classes.VMApplication[]}
         */
        _applications: null,
        _baseInfos: null,
        _closeHandler: null,
        _restartHandler: null,
        /**
         * @type {classes.SessionWidget}
         */
        _widget: null,
        _sidebarWidget: null,
        _bookmarkWidget: null,
        _applicationIdentifier: 0,
        _applicationQueue: null,

        _browserMultiPageMode: false,
        _browserMultiPageModeAsChild: false,
        _childrenWindows: null,

        _waitingNewTasks: 0,
        _showEnding: false,
        _flushingApplications: false,
        _flushingApplicationsListener: false,
        _unloadListener: false,
        _flushableApplications: null,

        _tabbedContainerInfo: null,

        /** @type {?string} */
        _logPromptUrl: null,
        /** @type Window */
        _logPromptWindow: null,
        /** @type classes.SessionLogPromptWidget */
        _logPromptWidget: null,
        /** @type string[] */
        _serverFeatures: null,
        /** @type {?string} */
        _endUrl: null,

        /**
         * @inheritDoc
         * @constructs
         * @param {?string} identifier session identifier
         */
        constructor: function(identifier) {
          $super.constructor.call(this);
          this._widget = cls.WidgetFactory.createWidget("Session", {
            appHash: gbc.systemAppId
          });
          context.HostService.getApplicationHostWidget().addChildWidget(this._widget);
          this._sidebarWidget = cls.WidgetFactory.createWidget("SessionSidebar", {
            appHash: gbc.systemAppId
          });
          context.HostService.getApplicationHostWidget().getSideBar().addChildWidget(this._sidebarWidget);
          this._widget.setSidebarWidget(this._sidebarWidget);
          this._identifier = identifier;
          this._applications = [];
          this._applicationQueue = [];
          this._closeHandler = this._widget.getEndWidget().when(context.constants.widgetEvents.close, this.destroy.bind(this));
          this._restartHandler = this._widget.getEndWidget().when(context.constants.widgetEvents.restart, this._onRestart.bind(
            this));

          this._flushableApplications = [];
          context.HostService.getApplicationHostWidget().getSideBar().setTitleText(i18next.t("gwc.main.sidebar.title"));
          this._browserMultiPageModeAsChild = context.bootstrapInfo.subAppInfo;
          /*
          if (!this._browserMultiPageModeAsChild) {
            this._bookmarkWidget = cls.WidgetFactory.createWidget("ApplicationBookmarkHostMenu", {
              appHash: gbc.systemAppId
            });
            context.HostService.getApplicationHostWidget().getMenu().addChildWidget(this._bookmarkWidget);
            context.HostService.getApplicationHostWidget().getMenu().setBookmarkWidget(this._bookmarkWidget);
          }
          */
          this._childrenWindows = [];
          this._flushingApplicationsListener = context.InitService.when(gbc.constants.widgetEvents.onBeforeUnload, this
            ._flushWaitingApplications
            .bind(this));
          this._unloadListener = context.InitService.when(gbc.constants.widgetEvents.onUnload, this._destroyChildrenWindows.bind(
            this));
          this._tabbedContainerInfo = {
            app: null,
            windowNode: null,
            /**
             * @type {classes.TabbedContainerWidget}
             */
            tabbedContainerWidget: null,
            /**
             * @type {classes.WidgetBase[]}
             */
            tabbedApplications: [],
            currentTabbedWidget: null,
            currentTabbedRect: {
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              width: "auto",
              height: "auto"
            },
            nullRect: {
              top: null,
              left: null,
              right: null,
              bottom: null,
              width: "auto",
              height: "auto",
              "max-width": "100%",
              "max-height": "100%"
            }
          };
          this._serverFeatures = [];
        },
        _onRestart: function() {
          if (context.bootstrapInfo.reloadOnRestart === "true") {
            window.location.reload(true);
            return;
          }
          var info = this._baseInfos;
          this.destroy(true);
          context.SessionService.start(info.appId, info.urlParameters);
        },
        getWidget: function() {
          return this._widget;
        },
        getApplicationIdentifier: function() {
          return this._applicationIdentifier++;
        },

        destroy: function(restarting) {
          /*
          if (this._bookmarkWidget) {
            context.HostService.getApplicationHostWidget().getMenu().removeChildWidget(this._bookmarkWidget);
            this._bookmarkWidget.destroy();
            this._bookmarkWidget = null;
          }
          */
          context.SessionService.remove(this, true === restarting);
          this._closeHandler();
          this._restartHandler();

          this._sidebarWidget.destroy();
          this._sidebarWidget = null;
          this._widget.destroy();
          this._widget = null;
          this._applications.length = 0;
          this._flushingApplicationsListener();
          this._destroyChildrenWindows();
          $super.destroy.call(this);
        },
        getConnector: function() {
          return this._baseInfos.connector;
        },
        /**
         * Get the session ID
         * @return {string} the session ID
         * @publicdoc
         */
        getSessionId: function() {
          return this._sessionId;
        },

        setSessionId: function(id) {
          if (!this._sessionId) {
            this._sessionId = id;
            context.SessionService.updateSessionId(this, id);
          } else if (id !== this._sessionId) {
            this.error("Session Id Changed");
          }
        },
        getAppId: function() {
          return this._baseInfos.appId;
        },
        error: function(msg) {

        },
        /**
         *
         * @param {classes.VMApplication} application
         */
        add: function(application) {
          this._applications.push(application);
          application.__idleChangedSessionHook = application.dvm.onIdleChanged(this._onIdleChanged.bind(this, application));
          this.emit(context.constants.baseEvents.applicationAdded, application);
        },
        /**
         *
         * @param {classes.VMApplication} application
         */
        remove: function(application) {
          application.__idleChangedSessionHook();
          this._applications.remove(application);
          this._applicationQueue.remove(application);
          this._applicationEnding = application.info().ending;
          var pos = 0;
          while (pos < this._applicationQueue.length) {
            if (this._applicationQueue[pos] === this._applicationQueue[pos + 1]) {
              this._applicationQueue.splice(pos, 1);
            } else {
              pos++;
            }
          }
          this.emit(context.constants.baseEvents.applicationRemoved, application);
          var currentApp = this.getCurrentApplication();
          if (currentApp) {
            var currentWindow = currentApp.getVMWindow();
            if (currentWindow) {
              var appWidget = currentApp.getUI().getWidget(),
                winWidget = currentWindow.getController().getWidget();
              this._widget.setCurrentWidget(appWidget);
              context.HostService.setDisplayedWindow(winWidget);
              context.HostService.getApplicationHostWidget().getSideBar().setActiveWindow(winWidget);
            }
          }
          this._showEnding = true;
          this._updateDisplayEnd();
        },
        _updateDisplayEnd: function() {
          if (this._showEnding && !this._applications.length) {
            if (this._childrenWindows.length || (this._browserMultiPageMode && this._waitingNewTasks > 0)) {
              this.getWidget().showWaitingEnd();
              context.HostService.setDisplayedWindow(null);
            } else {
              if (this._waitingNewTasks === 0 && !this._destroyed) {
                context.HostService.setSidebarContent();
                if (this._tabbedContainerInfo.appIdleHook) {
                  this._tabbedContainerInfo.appIdleHook();
                }
                this.displayEnd();
              }
            }
          }
        },
        _autoclose: function() {
          this._registerTimeout(function() {
            var can = !this._flushableApplications || !this._flushableApplications.length;
            if (can) {
              cls.WindowHelper.closeWindow();
            } else {
              this._autoclose();
            }
          }.bind(this), 200);
        },

        /**
         * Terminate the session
         * (This is always called by window.onunload with forceServer=true)
         * @param {boolean} [forceServer] true to send a session close (/ua/close) to the server (if supported)
         * @publicdoc
         */
        closeSession: function(forceServer) {
          // if forceServer and is not child of an other tab (stantdalone or browserMultiPage activated),
          // send session /ua/close if has feature
          if (forceServer && !this._browserMultiPageModeAsChild && this.hasServerFeature("close-session")) {
            if (this._applications && this._applications[0]) {
              this._applications[0].protocolInterface.closeSession();
            }
            // if forceServer and is child of an other tab (browserMultiPage activated)
            // try to send app /ua/close (will free parent app processing if RUN was called)
          } else if (forceServer && this._browserMultiPageModeAsChild && this._applications[0]) {
            this._applications[0].close();
          } else {
            while (this._applications.length) {
              this._applications[0].stop();
            }
          }
        },

        setEndUrl: function(url) {
          this._endUrl = url;
        },

        displayEnd: function() {
          if (this._browserMultiPageModeAsChild) {
            this._autoclose();
            return;
          }
          this.emit(context.constants.baseEvents.displayEnd, this._baseInfos.session);
          if (this.getWidget()) {
            this.getWidget().getEndWidget().setHeader(i18next.t("gwc.app.ending.title"));
            // disable sidebar on session end
            context.HostService.setSidebarAvailable(false);
            if (this._baseInfos.session) {
              this.getWidget().getEndWidget().showSessionActions();
              this.getWidget().getEndWidget().setSessionLinks(this._baseInfos.customUA || this._baseInfos.connector || "",
                this._baseInfos.session);
              //cls.AuiApplicationService.linkDownload();
              this.getWidget().getEndWidget().setSessionID(this._baseInfos.session);
            }
            if (this._baseInfos.mode === "ua") {
              this.getWidget().getEndWidget().showUAActions();
            }
            if (!this._applicationEnding.normal) {

              switch (this._applicationEnding.flag) {
                case "notFound":
                  this.getWidget().getEndWidget().setHeader(i18next.t("gwc.app.notFound.title"));
                  this.getWidget().getEndWidget().setMessage(i18next.t("gwc.app.notFound.message", {
                    appId: "<strong>\"" + this._baseInfos.appId + "\"</strong>"
                  }));
                  break;
                case "notok":
                  this.getWidget().getEndWidget().setMessage(
                    "<p data-details='notok'>" + i18next.t("gwc.app.error.message") + ".</p><p>" + this._applicationEnding
                    .message +
                    "</p>");
                  break;
                case "forbidden":
                  this.getWidget().getEndWidget().setMessage(
                    "<p data-details='forbidden'>" + i18next.t("gwc.app.forbidden.message") + ".</p><p>" + this._applicationEnding
                    .message + "</p>");
                  break;
                case "autoLogout":
                  this.getWidget().getEndWidget().setMessage(
                    "<p data-details='autoLogout'>" + i18next.t("gwc.app.autologout.message") + ".</p>");
                  break;
                case "uaProxy":
                  this.getWidget().getEndWidget().setMessage(
                    "<p data-details='uaProxy'>" + i18next.t("gwc.app.uaProxy.message") + ".</p><p>" + this._applicationEnding
                    .message +
                    "</p>");
                  break;
              }
            }
            if (this._endUrl) {
              this.getWidget().showRedirectEnd();
              window.location.href = this._endUrl;
            } else if (this._applicationEnding.flag !== "hidden") {
              this.getWidget().showEnd();
            }
          }
          this.displayLogPrompt();
          context.HostService.setDisplayedWindow(null);
        },

        displayLogPrompt: function(promptUrl) {
          var latePromptHandling = !this._logPromptUrl && !!promptUrl;
          if (!latePromptHandling) {
            this._trackPromptEnding();
          }
          if (this._logPromptUrl !== promptUrl) {
            this._logPromptUrl = promptUrl;
            if (!this._logPromptUrl) {
              document.body.removeClass("logPrompting");
              if (this._logPromptWindow) {
                this._logPromptWindow.close();
                this._logPromptWindow = null;
              }
              if (this._logPromptWidgetHandle) {
                this._logPromptWidgetHandle();
              }
              if (this._logPromptWidget) {
                this._logPromptWidget.destroy();
                this._logPromptWidget = null;
              }
            } else {
              if (latePromptHandling) {
                this._trackPromptEnding();
              }
              if (!this._logPromptWidget) {
                this._logPromptWidget = cls.WidgetFactory.createWidget("SessionLogPrompt", {
                  appHash: gbc.systemAppId
                });
                this._logPromptWidgetHandle = this._logPromptWidget.when(context.constants.widgetEvents.click, function() {
                  if (!this._browserMultiPageModeAsChild) {
                    this._displayLogPopup();
                  } else {
                    var opener = window.opener,
                      openerSession = opener && opener.gbc && window.opener.gbc.SessionService.getCurrent();
                    if (openerSession) {
                      openerSession._displayLogPopup();
                    }
                  }
                }.bind(this));
                document.body.appendChild(this._logPromptWidget.getElement());
              }
              if (!this._browserMultiPageModeAsChild) {
                if (!this._logPromptWindow) {
                  document.body.addClass("logPrompting");
                } else {
                  this._logPromptWindow.location.href = this._logPromptUrl;
                }
              }
            }
          }
        },
        _displayLogPopup: function() {
          if (!this._logPromptWindow || this._logPromptWindow.closed) {
            this._logPromptWindow = window.open(this._logPromptUrl, "",
              "resizable,scrollbars,status,width=" + window.innerWidth + ",height=" + window.innerHeight +
              ",top=" + window.screenTop + ",left=" + window.screenLeft);
          } else if (this._logPromptWindow) {
            this._logPromptWindow.focus();
          }
        },

        _trackPromptEnding: function() {
          if (this._logPromptUrl) {
            var hasOnlyIdle = true,
              protocolInterface = this.getApplications()[0] && this.getApplications()[0].protocolInterface,
              protocolAlive = protocolInterface && protocolInterface.isAlive();
            this.getApplications().forEach(function(app) {
              hasOnlyIdle = hasOnlyIdle && app.isIdle();
            });
            if (hasOnlyIdle && protocolAlive) {
              protocolInterface.trackPrompt();
            }
          }
        },

        /**
         *
         * @param {string[]} features
         */
        addServerFeatures: function(features) {
          for (var i = 0; i < features.length; i++) {
            var feature = features[i].trim();
            if (this._serverFeatures.indexOf(feature) < 0) {
              this._serverFeatures.push(feature);
            }
          }
        },
        /**
         *
         * @param {string} feature
         * @return {boolean}
         */
        hasServerFeature: function(feature) {
          return !!this._serverFeatures && this._serverFeatures.indexOf(feature) >= 0;
        },
        /**
         *
         * @returns {boolean}
         */
        isEmpty: function() {
          return !this._applications.length;
        },

        start: function(appName, params) {
          var info = new cls.VMApplicationInfo({
            appId: appName,
            urlParameters: params || (
              context.bootstrapInfo.queryString ?
              new cls.QueryString(context.bootstrapInfo.queryString).copyContentsObject() :
              context.UrlService.currentUrl().getQueryStringObject()
            )
          });
          info.connector = info.urlParameters.connector || context.bootstrapInfo.connectorUri || "";
          info.customUA = info.urlParameters.customUA || null;
          info.mode = info.urlParameters.mode || "ua";
          info.inNewWindow = this._browserMultiPageModeAsChild;
          if (info.inNewWindow) {
            info.session = this._sessionId = context.bootstrapInfo.sessionId;
            context.HostService.getApplicationHostWidget().getSideBar().setTitleText(i18next.t("gwc.main.sidebar.multitab_title"));
          }
          this._baseInfos = info;
          /*
          if (this._bookmarkWidget) {
            this._bookmarkWidget.setActivated(context.BookmarkService.getBookmark(this.getAppId()));
          }
          */
          var application = new cls.VMApplication(info, this);
          var appWidget = application.getUI().getWidget();
          this.add(application);
          this._widget.setCurrentWidget(appWidget);
          application.start();
          this._registerNewTask(application.protocolInterface);
        },

        startTask: function(taskId, callback) {
          callback = callback || Function.noop;
          var info = {},
            keys;
          if (this._baseInfos) {
            keys = Object.keys(this._baseInfos);
            for (var k = 0; k < keys.length; k++) {
              info[keys[k]] = this._baseInfos[keys[k]];
            }
          }
          info.inNewWindow = this._browserMultiPageMode || (this._browserMultiPageModeAsChild &&
            (this._browserMultiPageModeAsChild !== taskId));

          if (info.inNewWindow) {
            info.urlParameters = context.bootstrapInfo.queryString ?
              new cls.QueryString(context.bootstrapInfo.queryString).copyContentsObject() :
              context.UrlService.currentUrl().getQueryStringObject();
            info.connector = info.urlParameters.connector || context.bootstrapInfo.connectorUri || "";
            info.customUA = info.urlParameters.customUA || null;
            info.mode = info.urlParameters.mode || "ua";
          }
          if (this._browserMultiPageModeAsChild) {
            context.HostService.getApplicationHostWidget().getSideBar().setTitleText(i18next.t("gwc.main.sidebar.multitab_title"));
            this._sessionId = context.bootstrapInfo.sessionId;
            info.session = this._sessionId;
          }

          info.task = true;
          info.page = 2;
          info.app = taskId;

          var application = new cls.VMApplication(new cls.VMApplicationInfo(info), this);
          if (!info.inNewWindow) {
            var appWidget = application.getUI().getWidget();
            this._widget.setCurrentWidget(appWidget);
            this.add(application);
            application.start();
            this.waitedForNewTask();
            callback();
          } else {
            application.waitForNewApp(function() {
              this.waitedForNewTask();
              callback();
            }.bind(this), function() {

            });
          }
        },

        /**
         *
         * @param {window.gbcWrapper} wrapper
         * @param {Object<string, *>} headers
         */
        startDirect: function(wrapper, headers) {
          context.HostService.setSidebarAvailable(true);
          var info = new cls.VMApplicationInfo({
            pingTimeout: 1000,
            page: 1,
            auiOrder: 0,
            mode: "direct"
          });
          if (headers) {
            var headersKeys = Object.keys(context.constants.network.startHeaders);
            for (var i = 0; i < headersKeys.length; i++) {
              var key = headersKeys[i];
              var value = context.constants.network.startHeaders[key];
              info[value.prop || key] = headers[context.constants.network.headers[key]];
            }
          }
          info.wrapper = wrapper;
          this._baseInfos = info;
          var application = new cls.VMApplication(info, this);
          application.setProcessing();
          var appWidget = application.getUI().getWidget();
          this._widget.setCurrentWidget(appWidget);
          this.add(application);
          application.start();
        },
        onApplicationAdded: function(hook) {
          return this.when(context.constants.baseEvents.applicationAdded, hook);
        },
        onApplicationRemoved: function(hook) {
          return this.when(context.constants.baseEvents.applicationRemoved, hook);
        },

        info: function() {
          return this._baseInfos;
        },

        /**
         * Get all running applications
         * @returns {classes.VMApplication[]} an array of applications or null
         * @publicdoc
         */
        getApplications: function() {
          return this._applications;
        },

        /**
         * Get the current application
         * @returns {classes.VMApplication}
         */
        getCurrentApplication: function() {
          if (this._applications.length && this._applications[this._applications.length - 1]) {
            return this._applications[this._applications.length - 1];
          }
          return null;
        },

        /**
         *
         * @returns {classes.VMApplication}
         */
        getApplicationByHash: function(hash) {
          return this._applications && this._applications.filter(function(item) {
            return item.applicationHash === hash;
          })[0];
        },
        setCurrentApplication: function(application) {
          var index = this._applications.indexOf(application);
          if (index !== -1) {
            this._applications.splice(index, 1);
            this._applications.push(application);
          }
        },
        _onIdleChanged: function(application) {
          this.emit(context.constants.baseEvents.idleChanged, application);
        },
        whenIdleChanged: function(hook) {
          return this.when(context.constants.baseEvents.idleChanged, hook);
        },
        isCurrentIdle: function() {
          var app = this.getCurrentApplication();
          return !app || app.dvm.processed && app.dvm.idle && app.layout.isIdle() && app.typeahead.hasFinished();
        },
        activateBrowserMultiPageMode: function() {
          this._browserMultiPageMode = true;
          context.HostService.getApplicationHostWidget().getSideBar().setTitleText(i18next.t("gwc.main.sidebar.multitab_title"));
        },
        _addWaitingApplication: function(application) {
          this._flushableApplications.push(application);
        },
        _removeWaitingApplication: function(application) {
          this._flushableApplications.remove(application);
        },
        _flushWaitingApplications: function() {
          this._flushingApplications = true;
          while (this._flushableApplications && this._flushableApplications.length) {
            cls.WindowHelper.openWindow(cls.UANetwork.newApp(this._flushableApplications.shift()), true);
          }
        },
        _registerNewTask: function(protocolInterface) {
          this._storedProtocol = protocolInterface;
        },
        newTask: function() {
          if (this._storedProtocol) {
            this._storedProtocol.newTask();
          }
        },
        _registerChildWindow: function(win) {
          if (win) {
            this._childrenWindows.push(win);
            win.addEventListener("unload", function() {
              if (win.location.href !== "about:blank") { // thank you firefox
                this._childrenWindows.remove(win);
                this._updateDisplayEnd();
              }
            }.bind(this));
          }
        },
        _destroyChildrenWindows: function() {
          while (this._childrenWindows.length) {
            var w = this._childrenWindows.pop();
            w.__desactivateEndingPopup = true;
            w.close();
          }
        },
        waitingForNewTask: function() {
          this._waitingNewTasks++;
        },

        waitedForNewTask: function() {
          if (this._waitingNewTasks > 0) {
            this._waitingNewTasks--;
          }
          this._updateDisplayEnd();
        },

        isInTabbedContainerMode: function() {
          return !!this._tabbedContainerInfo.windowNode;
        },

        getTabbedContainerModeHostApplication: function() {
          return this._tabbedContainerInfo.app;
        },

        getTabbedContainerWidget: function() {
          return this._tabbedContainerInfo.tabbedContainerWidget;
        },

        /**
         *
         * @param {classes.WindowNode} windowNode
         */
        activateTabbedContainerMode: function(windowNode) {
          var info = this._tabbedContainerInfo;
          var opt = {};

          if (!info.windowNode && windowNode) {
            var session = context.SessionService.getCurrent(),
              apps = session.getApplications(),
              appslen = apps.length;
            session.getWidget().setCurrentWidget(windowNode.getApplication().getUI().getWidget());
            info.app = windowNode.getApplication();
            info.windowNode = windowNode;
            info.tabbedContainerWidget = cls.WidgetFactory.createWidget("TabbedContainer", {
              appHash: gbc.systemAppId
            });
            this.getWidget().setTabbedContainer(info.tabbedContainerWidget);
            var widget = windowNode.getController() && windowNode.getController().getWidget();
            if (widget) {
              this.getWidget().setTabbedContainerHost(windowNode.getApplication().getUI().getWidget());
              // 1. prepare the window
              widget.getContainerElement().empty();
              widget.when(gbc.constants.widgetEvents.unfrozen, function() {
                if (this._currentTabbedWidget && this._currentTabbedWidget._tabbedPage) {
                  this._currentTabbedWidget._tabbedPage._tabbedApp.layout.refreshLayout({
                    resize: true
                  });
                }
              }.bind(this));
              widget.when(context.constants.widgetEvents.destroyed, function() {
                var apps, appFinder = function(app) {
                  return !app._tabbedClosing;
                };
                while ((apps = this.getApplications().filter(appFinder)).length) {
                  if (apps[0] !== info.app) {
                    apps[0].close();
                  }
                  apps[0]._tabbedClosing = true;
                }
              }.bind(this));
              widget.addTabbedContainer(info.tabbedContainerWidget);
              info.tabbedContainerWidget.when(context.constants.widgetEvents.change, function(event, src, page) {
                if (this._currentTabbedWidget && this._currentTabbedWidget.getElement()) {
                  this._currentTabbedWidget.getElement().addClass("gbc_out_of_view");
                  this._currentTabbedWidget.setStyle(this._tabbedContainerInfo.nullRect);
                  this._currentTabbedWidget = null;
                }
                if (page && page._tabbedAppWidget) {
                  this._currentTabbedWidget = page._tabbedAppWidget;
                  this._currentTabbedWidget.getElement().removeClass("gbc_out_of_view");
                  this._currentTabbedWidget.setStyle(this._tabbedContainerInfo.currentTabbedRect);
                  this.setCurrentApplication(page._tabbedApp);
                  if (page._tabbedApp.layout) {
                    page._tabbedApp.layout.refreshLayout({
                      resize: true
                    });
                  }
                  var displayedWindow = page._tabbedApp.getVMWindow(),
                    displayedWindowWidget = displayedWindow && displayedWindow.getController() && displayedWindow
                    .getController()
                    .getWidget();
                  if (displayedWindowWidget) {
                    context.HostService.setDisplayedWindow(displayedWindowWidget);
                  }
                }
              }.bind(this));

              windowNode.getApplication().layout.afterLayout(function() {
                var rectPages = info.tabbedContainerWidget.getContainerElement().getBoundingClientRect(),
                  rect = this._widget.getElement().getBoundingClientRect();
                info.currentTabbedRect = {
                  top: "" + (rectPages.top - rect.top) + "px !important",
                  left: "" + (rectPages.left - rect.left) + "px !important",
                  right: "" + (rect.right - rectPages.right) + "px !important",
                  bottom: "" + (rect.bottom - rectPages.bottom) + "px !important",
                  width: "auto",
                  height: "auto"
                };
                for (var i = 0; i < info.tabbedApplications.length; i++) {
                  var app = info.tabbedApplications[i],
                    appWidget = app.getUI().getWidget();
                  if (appWidget._tabbedPage === info.tabbedContainerWidget.getCurrentPage()) {
                    appWidget.setStyle(info.currentTabbedRect);
                  } else {
                    appWidget.setStyle(this._tabbedContainerInfo.nullRect);
                  }
                  if (!appWidget.getElement().hasClass("gbc_out_of_view") &&
                    appWidget._tabbedPage.getElement().parent("gbc_ApplicationWidget") && app.layout) {
                    app.layout.refreshLayout({
                      resize: true
                    });
                  }
                }
                this._registerAnimationFrame(function() {
                  if (info.tabbedContainerWidget && info.tabbedContainerWidget.updateScrollersVisibility) {
                    info.tabbedContainerWidget.updateScrollersVisibility();
                  }
                });
              }.bind(this));

              // 2. manage sidebar
              this.manageStartMenu();

              context.HostService.setTabbedHost(widget);

              info.app.uiNode().getDescendants("Window").map(function(w) {
                if (w && w.getController() && w.getController().getWidget()) {
                  // Since registerClosableWindow can take an optional argument, use it to pass chromeBar to it
                  opt = {
                    chromeBar: w.getParentNode().getWidget().getChromeBarWidget()
                  };
                  context.HostService.registerClosableWindow(w.getController().getWidget(), opt);
                }
              });
              // 3. manage existing apps
              for (var i = 0; i < appslen; i++) {
                var app = apps[i];
                if (!app.getUI().getWidget()._tabbedPage && app !== info.app) {
                  this.addApplicationWidget(app, app.getUI().getWidget());

                  // jshint ignore:start
                  app.uiNode().getDescendants("Window").map(function(w) {
                    if (w && w.getController() && w.getController().getWidget()) {
                      opt = {
                        chromeBar: w.getParentNode().getWidget().getChromeBarWidget()
                      };
                      context.HostService.registerClosableWindow(w.getController().getWidget(), opt);
                    }
                  });
                  // jshint ignore:end

                }
              }

              context.HostService.setDisplayedWindow(widget);
            }
          }
        },

        /**
         * '
         * @param {classes.VMApplication} app
         * @param {classes.ApplicationWidget} appWidget
         */
        addApplicationWidget: function(app, appWidget) {
          if (this._tabbedContainerInfo.windowNode) {
            this._tabbedContainerInfo.tabbedApplications.push(app);
            appWidget.getElement().addClass("gbc_out_of_view");
            appWidget.setStyle(this._tabbedContainerInfo.nullRect);
            var tabbedContainerPage = cls.WidgetFactory.createWidget("Page", {
              appHash: gbc.systemAppId
            });

            var win = app.getVMWindow() && app.getVMWindow().getController().getWidget();
            tabbedContainerPage.setText(win ? (win.getText() || win.getUserInterfaceWidget().getText()) : "");
            tabbedContainerPage.setImage(win ? (win.getImage() || win.getUserInterfaceWidget().getImage()) : "");
            appWidget._tabbedPage = tabbedContainerPage;
            tabbedContainerPage._tabbedApp = app;
            tabbedContainerPage._tabbedAppWidget = appWidget;

            this.getWidget().addChildWidget(appWidget, {
              noDOMInsert: false
            });
            appWidget.when(context.constants.widgetEvents.destroyed, function() {
              this._tabbedContainerInfo.tabbedApplications.remove(app);
              this._tabbedContainerInfo.tabbedContainerWidget.removeChildWidget(appWidget._tabbedPage);
              appWidget._tabbedPage = null;
              tabbedContainerPage._tabbedApp = null;
              tabbedContainerPage._tabbedAppWidget = null;
              this._registerAnimationFrame(function() {
                if (this._tabbedContainerInfo.tabbedContainerWidget && this._tabbedContainerInfo.tabbedContainerWidget
                  .updateScrollersVisibility) {
                  this._tabbedContainerInfo.tabbedContainerWidget.updateScrollersVisibility();
                }
              }.bind(this));
            }.bind(this));
            this._tabbedContainerInfo.tabbedContainerWidget.addChildWidget(tabbedContainerPage);
            this._registerAnimationFrame(function() {
              if (this._tabbedContainerInfo.tabbedContainerWidget && this._tabbedContainerInfo.tabbedContainerWidget
                .updateScrollersVisibility) {
                this._tabbedContainerInfo.tabbedContainerWidget.updateScrollersVisibility();
              }
            }.bind(this));
          } else {
            this.getWidget().addChildWidget(appWidget);
          }
        },

        manageStartMenu: function(startMenuNode, widget) {
          if (this._tabbedContainerInfo.windowNode && (!startMenuNode ||
              this._tabbedContainerInfo.windowNode.getAncestor("UserInterface") === startMenuNode.getAncestor("UserInterface"))) {
            switch (this._tabbedContainerInfo.windowNode.getStyleAttribute("startMenuPosition")) {
              case "menu":
                context.HostService.setSidebarAvailable(false);
                break;
              case "tree":
                context.HostService.setSidebarAvailable(true);
                var startMenuWidget = widget || this._tabbedContainerInfo.windowNode.getParentNode() &&
                  this._tabbedContainerInfo.windowNode.getParentNode().getController() &&
                  this._tabbedContainerInfo.windowNode.getParentNode().getController().getWidget().getStartMenuWidget();
                if (this._tabbedContainerInfo.app) {
                  this._tabbedContainerInfo.appIdleHook = this._tabbedContainerInfo.app.dvm.onIdleChanged(function() {
                    startMenuWidget.setProcessing(this._tabbedContainerInfo.app && !this._tabbedContainerInfo.app.isIdle());
                  }.bind(this));
                }
                context.HostService.setSidebarContent(startMenuWidget);
                break;
              default:
                context.HostService.setSidebarAvailable(false);
                break;
            }
          } else {
            startMenuNode.getAncestor("UserInterface").getController().getWidget().addStartMenu(widget);
          }
        }
      };
    });
  });
;
"use strict";

modulum('FrontCallService.modules.mybackofficemodule', ['FrontCallService'],
  function(context, cls) {
    context.FrontCallService.modules.mybackofficemodule = {

      myCustomSyncFunction: function (name) {
        if (name === undefined) {
          this.parametersError();
          return;
        }
        if (name.length === 0) {
          this.runtimeError("name shouldn't be empty");
          return;
        }

        return ["Hello " + name + " !"];
      },
      replace_html: function (id, value) {
        document.getElementById(id).innerHTML=value;
        return ["0"];
      },
      forgotpassword_page: function () {
        document.getElementById('slftxaction_viewmainpanel').style.display="none";
        document.getElementById('slftxaction_viewbrands').style.display="none";
        document.getElementById('slftxaction_addbrand').style.display="none";
        document.getElementById('slftxaction_viewcampaigns').style.display="none";
        document.getElementById('slftxaction_addcampaign').style.display="none";
        document.getElementById('slftxaction_viewinfluencers').style.display="none";
        document.getElementById('slftxaction_addinfluencer').style.display="none";
        document.getElementById('slftxaction_viewbousers').style.display="none";
        document.getElementById('slftxaction_addbouser').style.display="none";
        document.getElementById('slftxaction_signin').style.display="inherit";
        document.getElementById('dropdownlogin').style.display="none";
        return ["0"];
      },
      credentials_page: function () {
        document.getElementById('slftxaction_viewmainpanel').style.display="none";
        document.getElementById('slftxaction_viewbrands').style.display="none";
        document.getElementById('slftxaction_addbrand').style.display="none";
        document.getElementById('slftxaction_viewcampaigns').style.display="none";
        document.getElementById('slftxaction_addcampaign').style.display="none";
        document.getElementById('slftxaction_viewinfluencers').style.display="none";
        document.getElementById('slftxaction_addinfluencer').style.display="none";
        document.getElementById('slftxaction_viewbousers').style.display="none";
        document.getElementById('slftxaction_addbouser').style.display="none";
        document.getElementById('slftxaction_signin').style.display="none";
        document.getElementById('dropdownlogin').style.display="none";
        return ["0"];
      },
      mainpanel_page: function (value) {
        document.getElementById('slftxaction_viewmainpanel').style.display="inherit";
        document.getElementById('slftxaction_viewbrands').style.display="inherit";
        document.getElementById('slftxaction_addbrand').style.display="none";
        document.getElementById('slftxaction_viewcampaigns').style.display="inherit";
        document.getElementById('slftxaction_addcampaign').style.display="none";
        document.getElementById('slftxaction_viewinfluencers').style.display="inherit";
        document.getElementById('slftxaction_addinfluencer').style.display="none";
        document.getElementById('slftxaction_viewbousers').style.display="inherit";
        document.getElementById('slftxaction_addbouser').style.display="none";
        document.getElementById('slftxaction_signin').style.display="none";
        document.getElementById('dropdownlogin').style.display="inherit";
        document.getElementById('dropbtnloginname').innerHTML="Hi, "+value;
        return ["0"];
      },
      addbouser_page: function (value) {
        document.getElementById('slftxaction_viewmainpanel').style.display="inherit";
        document.getElementById('slftxaction_viewbrands').style.display="inherit";
        document.getElementById('slftxaction_addbrand').style.display="none";
        document.getElementById('slftxaction_viewcampaigns').style.display="inherit";
        document.getElementById('slftxaction_addcampaign').style.display="none";
        document.getElementById('slftxaction_viewinfluencers').style.display="inherit";
        document.getElementById('slftxaction_addinfluencer').style.display="none";
        document.getElementById('slftxaction_viewbousers').style.display="inherit";
        document.getElementById('slftxaction_addbouser').style.display="none";
        document.getElementById('slftxaction_signin').style.display="none";
        document.getElementById('dropdownlogin').style.display="inherit";
        document.getElementById('dropbtnloginname').innerHTML="Hi, "+value;
        return ["0"];
      },
      updatebouser_page: function (value) {
        document.getElementById('slftxaction_viewmainpanel').style.display="inherit";
        document.getElementById('slftxaction_viewbrands').style.display="inherit";
        document.getElementById('slftxaction_addbrand').style.display="none";
        document.getElementById('slftxaction_viewcampaigns').style.display="inherit";
        document.getElementById('slftxaction_addcampaign').style.display="none";
        document.getElementById('slftxaction_viewinfluencers').style.display="inherit";
        document.getElementById('slftxaction_addinfluencer').style.display="none";
        document.getElementById('slftxaction_viewbousers').style.display="inherit";
        document.getElementById('slftxaction_addbouser').style.display="none";
        document.getElementById('slftxaction_signin').style.display="none";
        document.getElementById('dropdownlogin').style.display="inherit";
        document.getElementById('dropbtnloginname').innerHTML="Hi, "+value;
        return ["0"];
      },
      bouserlist_page: function (value) {
        document.getElementById('slftxaction_viewmainpanel').style.display="inherit";
        document.getElementById('slftxaction_viewbrands').style.display="inherit";
        document.getElementById('slftxaction_addbrand').style.display="none";
        document.getElementById('slftxaction_viewcampaigns').style.display="inherit";
        document.getElementById('slftxaction_addcampaign').style.display="none";
        document.getElementById('slftxaction_viewinfluencers').style.display="inherit";
        document.getElementById('slftxaction_addinfluencer').style.display="none";
        document.getElementById('slftxaction_viewbousers').style.display="inherit";
        document.getElementById('slftxaction_addbouser').style.display="flex";
        document.getElementById('slftxaction_signin').style.display="none";
        document.getElementById('dropdownlogin').style.display="inherit";
        document.getElementById('dropbtnloginname').innerHTML="Hi, "+value;
        return ["0"];
      },
      addbrand_page: function (value) {
        document.getElementById('slftxaction_viewmainpanel').style.display="inherit";
        document.getElementById('slftxaction_viewbrands').style.display="inherit";
        document.getElementById('slftxaction_addbrand').style.display="none";
        document.getElementById('slftxaction_viewcampaigns').style.display="inherit";
        document.getElementById('slftxaction_addcampaign').style.display="none";
        document.getElementById('slftxaction_viewinfluencers').style.display="inherit";
        document.getElementById('slftxaction_addinfluencer').style.display="none";
        document.getElementById('slftxaction_viewbousers').style.display="inherit";
        document.getElementById('slftxaction_addbouser').style.display="none";
        document.getElementById('slftxaction_signin').style.display="none";
        document.getElementById('dropdownlogin').style.display="inherit";
        document.getElementById('dropbtnloginname').innerHTML="Hi, "+value;
        return ["0"];
      },
      updatebrand_page: function (value) {
        document.getElementById('slftxaction_viewmainpanel').style.display="inherit";
        document.getElementById('slftxaction_viewbrands').style.display="inherit";
        document.getElementById('slftxaction_addbrand').style.display="none";
        document.getElementById('slftxaction_viewcampaigns').style.display="inherit";
        document.getElementById('slftxaction_addcampaign').style.display="none";
        document.getElementById('slftxaction_viewinfluencers').style.display="inherit";
        document.getElementById('slftxaction_addinfluencer').style.display="none";
        document.getElementById('slftxaction_viewbousers').style.display="inherit";
        document.getElementById('slftxaction_addbouser').style.display="none";
        document.getElementById('slftxaction_signin').style.display="none";
        document.getElementById('dropdownlogin').style.display="inherit";
        document.getElementById('dropbtnloginname').innerHTML="Hi, "+value;
        return ["0"];
      },
      brandlist_page: function (value) {
        document.getElementById('slftxaction_viewmainpanel').style.display="inherit";
        document.getElementById('slftxaction_viewbrands').style.display="inherit";
        document.getElementById('slftxaction_addbrand').style.display="flex";
        document.getElementById('slftxaction_viewcampaigns').style.display="inherit";
        document.getElementById('slftxaction_addcampaign').style.display="none";
        document.getElementById('slftxaction_viewinfluencers').style.display="inherit";
        document.getElementById('slftxaction_addinfluencer').style.display="none";
        document.getElementById('slftxaction_viewbousers').style.display="inherit";
        document.getElementById('slftxaction_addbouser').style.display="none";
        document.getElementById('slftxaction_signin').style.display="none";
        document.getElementById('dropdownlogin').style.display="inherit";
        document.getElementById('dropbtnloginname').innerHTML="Hi, "+value;
        return ["0"];
      },
      addinfluencer_page: function (value) {
        document.getElementById('slftxaction_viewmainpanel').style.display="inherit";
        document.getElementById('slftxaction_viewbrands').style.display="inherit";
        document.getElementById('slftxaction_addbrand').style.display="none";
        document.getElementById('slftxaction_viewcampaigns').style.display="inherit";
        document.getElementById('slftxaction_addcampaign').style.display="none";
        document.getElementById('slftxaction_viewinfluencers').style.display="inherit";
        document.getElementById('slftxaction_addinfluencer').style.display="none";
        document.getElementById('slftxaction_viewbousers').style.display="inherit";
        document.getElementById('slftxaction_addbouser').style.display="none";
        document.getElementById('slftxaction_signin').style.display="none";
        document.getElementById('dropdownlogin').style.display="inherit";
        document.getElementById('dropbtnloginname').innerHTML="Hi, "+value;
        return ["0"];
      },
      updateinfluencer_page: function (value) {
        document.getElementById('slftxaction_viewmainpanel').style.display="inherit";
        document.getElementById('slftxaction_viewbrands').style.display="inherit";
        document.getElementById('slftxaction_addbrand').style.display="none";
        document.getElementById('slftxaction_viewcampaigns').style.display="inherit";
        document.getElementById('slftxaction_addcampaign').style.display="none";
        document.getElementById('slftxaction_viewinfluencers').style.display="inherit";
        document.getElementById('slftxaction_addinfluencer').style.display="none";
        document.getElementById('slftxaction_viewbousers').style.display="inherit";
        document.getElementById('slftxaction_addbouser').style.display="none";
        document.getElementById('slftxaction_signin').style.display="none";
        document.getElementById('dropdownlogin').style.display="inherit";
        document.getElementById('dropbtnloginname').innerHTML="Hi, "+value;
        return ["0"];
      },
      influencerlist_page: function (value) {
        document.getElementById('slftxaction_viewmainpanel').style.display="inherit";
        document.getElementById('slftxaction_viewbrands').style.display="inherit";
        document.getElementById('slftxaction_addbrand').style.display="none";
        document.getElementById('slftxaction_viewcampaigns').style.display="inherit";
        document.getElementById('slftxaction_addcampaign').style.display="none";
        document.getElementById('slftxaction_viewinfluencers').style.display="inherit";
        document.getElementById('slftxaction_addinfluencer').style.display="flex";
        document.getElementById('slftxaction_viewbousers').style.display="inherit";
        document.getElementById('slftxaction_addbouser').style.display="none";
        document.getElementById('slftxaction_signin').style.display="none";
        document.getElementById('dropdownlogin').style.display="inherit";
        document.getElementById('dropbtnloginname').innerHTML="Hi, "+value;
        return ["0"];
      },
      campaignlist_page: function (value) {
        document.getElementById('slftxaction_viewmainpanel').style.display="inherit";
        document.getElementById('slftxaction_viewbrands').style.display="inherit";
        document.getElementById('slftxaction_addbrand').style.display="none";
        document.getElementById('slftxaction_viewcampaigns').style.display="inherit";
        document.getElementById('slftxaction_addcampaign').style.display="flex";
        document.getElementById('slftxaction_viewinfluencers').style.display="inherit";
        document.getElementById('slftxaction_addinfluencer').style.display="none";
        document.getElementById('slftxaction_viewbousers').style.display="inherit";
        document.getElementById('slftxaction_addbouser').style.display="none";
        document.getElementById('slftxaction_signin').style.display="none";
        document.getElementById('dropdownlogin').style.display="inherit";
        document.getElementById('dropbtnloginname').innerHTML="Hi, "+value;
        return ["0"];
      },
      campaignmenu_page: function (value) {
        document.getElementById('slftxaction_viewmainpanel').style.display="inherit";
        document.getElementById('slftxaction_viewbrands').style.display="inherit";
        document.getElementById('slftxaction_addbrand').style.display="none";
        document.getElementById('slftxaction_viewcampaigns').style.display="inherit";
        document.getElementById('slftxaction_addcampaign').style.display="none";
        document.getElementById('slftxaction_viewinfluencers').style.display="inherit";
        document.getElementById('slftxaction_addinfluencer').style.display="none";
        document.getElementById('slftxaction_viewbousers').style.display="inherit";
        document.getElementById('slftxaction_addbouser').style.display="none";
        document.getElementById('slftxaction_signin').style.display="none";
        document.getElementById('dropdownlogin').style.display="inherit";
        document.getElementById('dropbtnloginname').innerHTML="Hi, "+value;
        return ["0"];
      },
      campaigngrid_page: function (value) {
        document.getElementById('slftxaction_viewmainpanel').style.display="inherit";
        document.getElementById('slftxaction_viewbrands').style.display="inherit";
        document.getElementById('slftxaction_addbrand').style.display="none";
        document.getElementById('slftxaction_viewcampaigns').style.display="inherit";
        document.getElementById('slftxaction_addcampaign').style.display="none";
        document.getElementById('slftxaction_viewinfluencers').style.display="inherit";
        document.getElementById('slftxaction_addinfluencer').style.display="none";
        document.getElementById('slftxaction_viewbousers').style.display="inherit";
        document.getElementById('slftxaction_addbouser').style.display="none";
        document.getElementById('slftxaction_signin').style.display="none";
        document.getElementById('dropdownlogin').style.display="inherit";
        document.getElementById('dropbtnloginname').innerHTML="Hi, "+value;
        return ["0"];
      },
      getclickedaction: function () {
        var x = document.getElementById('clickedfrom').innerHTML;
        return [document.getElementById('clickedfrom').innerHTML];
      },

      myCustomAsyncFunction: function (name) {
        if (name === undefined) {
          this.parametersError();
          return;
        }
        if (name.length === 0) {
          this.runtimeError("name shouldn't be empty");
          return;
        }

        window.setTimeout(function () {
          this.setReturnValues(["After 5s, Hello " + name + " !"]);
        }.bind(this), 5000);
      }
    };
  }
);
;
"use strict";

modulum('MyBackOfficeMenu', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class MyBackOfficeMenu
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.MyBackOfficeMenu = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.MyBackOfficeMenu.prototype */ {
        __name: "MyBackOfficeMenu",
        _model: null,
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          this._model = new cls.ModelHelper(this);
          //this._element.on("click", this._onClick.bind(this));
          this._element.getElementsByClassName("slftxaction_viewmainpanel")[0].on("click", this._onClick.bind(this));
          this._element.getElementsByClassName("slftxaction_viewbrands")[0].on("click", this._onClick.bind(this));
          this._element.getElementsByClassName("slftxaction_addbrand")[0].on("click", this._onClick.bind(this));
          this._element.getElementsByClassName("slftxaction_viewcampaigns")[0].on("click", this._onClick.bind(this));
          this._element.getElementsByClassName("slftxaction_addcampaign")[0].on("click", this._onClick.bind(this));
          this._element.getElementsByClassName("slftxaction_viewinfluencers")[0].on("click", this._onClick.bind(this));
          this._element.getElementsByClassName("slftxaction_addinfluencer")[0].on("click", this._onClick.bind(this));
          this._element.getElementsByClassName("slftxaction_viewbousers")[0].on("click", this._onClick.bind(this));
          this._element.getElementsByClassName("slftxaction_addbouser")[0].on("click", this._onClick.bind(this));
          this._element.getElementsByClassName("slftxaction_signin")[0].on("click", this._onClick.bind(this));
          this._element.getElementsByClassName("slftxaction_editprofile")[0].on("click", this._onClick.bind(this));
          this._element.getElementsByClassName("slftxaction_logout")[0].on("click", this._onClick.bind(this));

          this._element.getElementsByClassName("img_salfatixlogo")[0].src = gbc.ThemeService.getResource("img/logo.png");
          this._element.getElementsByClassName("img_viewmainpanel")[0].src = gbc.ThemeService.getResource("img/home.png");
          this._element.getElementsByClassName("img_dropbtn")[0].src = gbc.ThemeService.getResource("img/caret-down.png");
          this._element.getElementsByClassName("img_editprofile")[0].src = gbc.ThemeService.getResource("img/user.png");
          this._element.getElementsByClassName("img_logout")[0].src = gbc.ThemeService.getResource("img/signout.png");
        },
        _onClick: function( event ) {
          document.getElementById('clickedfrom').innerHTML=event.currentTarget.id;
          this._model.executeActionByName("customaction");
        }
      };
    });
  }
);
;
"use strict";

modulum('FrontCallService.modules.mybrandmodule', ['FrontCallService'],
  function(context, cls) {
    context.FrontCallService.modules.mybrandmodule = {

      myCustomSyncFunction: function (name) {
        if (name === undefined) {
          this.parametersError();
          return;
        }
        if (name.length === 0) {
          this.runtimeError("name shouldn't be empty");
          return;
        }

        return ["Hello " + name + " !"];
      },
      replace_html: function (id, value) {
        document.getElementById(id).innerHTML=value;
        return ["0"];
      },
      forgotpassword_page: function () {
        document.getElementById('slftxaction_viewcampaigns').style.display="none";
        document.getElementById('slftxaction_addcampaign').style.display="none";
        document.getElementById('slftxaction_signin').style.display="inherit";
        document.getElementById('dropdownlogin').style.display="none";
        return ["0"];
      },
      credentials_page: function () {
        document.getElementById('slftxaction_viewcampaigns').style.display="none";
        document.getElementById('slftxaction_addcampaign').style.display="none";
        document.getElementById('slftxaction_signin').style.display="none";
        document.getElementById('dropdownlogin').style.display="none";
        return ["0"];
      },
      addbrand_page: function (value) {
        document.getElementById('slftxaction_viewcampaigns').style.display="none";
        document.getElementById('slftxaction_addcampaign').style.display="none";
        document.getElementById('slftxaction_signin').style.display="inherit";
        document.getElementById('dropdownlogin').style.display="none";
        return ["0"];
      },
      updatebrand_page: function (value) {
        document.getElementById('slftxaction_viewcampaigns').style.display="inherit";
        document.getElementById('slftxaction_addcampaign').style.display="none";
        document.getElementById('slftxaction_signin').style.display="none";
        document.getElementById('dropdownlogin').style.display="inherit";
        document.getElementById('dropbtnloginname').innerHTML="Hi, "+value;
        return ["0"];
      },
      campaignlist_page: function (value) {
        document.getElementById('slftxaction_viewcampaigns').style.display="inherit";
        document.getElementById('slftxaction_addcampaign').style.display="flex";
        document.getElementById('slftxaction_signin').style.display="none";
        document.getElementById('dropdownlogin').style.display="inherit";
        document.getElementById('dropbtnloginname').innerHTML="Hi, "+value;
        return ["0"];
      },
      campaignmenu_page: function (value) {
        document.getElementById('slftxaction_viewcampaigns').style.display="inherit";
        document.getElementById('slftxaction_addcampaign').style.display="none";
        document.getElementById('slftxaction_signin').style.display="none";
        document.getElementById('dropdownlogin').style.display="inherit";
        document.getElementById('dropbtnloginname').innerHTML="Hi, "+value;
        return ["0"];
      },
      campaigngrid_page: function (value) {
        document.getElementById('slftxaction_viewcampaigns').style.display="inherit";
        document.getElementById('slftxaction_addcampaign').style.display="none";
        document.getElementById('slftxaction_signin').style.display="none";
        document.getElementById('dropdownlogin').style.display="inherit";
        document.getElementById('dropbtnloginname').innerHTML="Hi, "+value;
        return ["0"];
      },
      getclickedaction: function () {
        var x = document.getElementById('clickedfrom').innerHTML;
        return [document.getElementById('clickedfrom').innerHTML];
      },

      myCustomAsyncFunction: function (name) {
        if (name === undefined) {
          this.parametersError();
          return;
        }
        if (name.length === 0) {
          this.runtimeError("name shouldn't be empty");
          return;
        }

        window.setTimeout(function () {
          this.setReturnValues(["After 5s, Hello " + name + " !"]);
        }.bind(this), 5000);
      }
    };
  }
);;
"use strict";

modulum('MyBrandMenu', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class MyBrandMenu
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.MyBrandMenu = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.MyBrandMenu.prototype */ {
        __name: "MyBrandMenu",
        _model: null,
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          this._model = new cls.ModelHelper(this);
          //this._element.on("click", this._onClick.bind(this));
          this._element.getElementsByClassName("salfatixlogo")[0].on("click", this._onClick.bind(this));
          this._element.getElementsByClassName("slftxaction_viewcampaigns")[0].on("click", this._onClick.bind(this));
          this._element.getElementsByClassName("slftxaction_addcampaign")[0].on("click", this._onClick.bind(this));
          this._element.getElementsByClassName("slftxaction_signin")[0].on("click", this._onClick.bind(this));
          this._element.getElementsByClassName("slftxaction_editprofile")[0].on("click", this._onClick.bind(this));
          this._element.getElementsByClassName("slftxaction_logout")[0].on("click", this._onClick.bind(this));

          this._element.getElementsByClassName("img_salfatixlogo")[0].src = gbc.ThemeService.getResource("img/logo.png");
          this._element.getElementsByClassName("img_dropbtn")[0].src = gbc.ThemeService.getResource("img/caret-down.png");
          this._element.getElementsByClassName("img_editprofile")[0].src = gbc.ThemeService.getResource("img/user.png");
          this._element.getElementsByClassName("img_logout")[0].src = gbc.ThemeService.getResource("img/signout.png");

        },
        _onClick: function( event ) {
          var x = event.currentTarget.id;
          var y = true;
          if (x === 'salfatixlogo') {
            if (document.getElementById('slftxaction_viewcampaigns').style.display !== 'none') {
              x = "slftxaction_viewcampaigns";
            } else {
                y = false;
            }
          }
          if (y === true) {
            document.getElementById('clickedfrom').innerHTML=x;
            this._model.executeActionByName("customaction");
          }
        }
      };
    });
  }
);
;
"use strict";

modulum('MyMainContainerWidget', ['MainContainerWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class MyMainContainerWidget
     * @memberOf classes
     * @extends classes.MainContainerWidget
     */
    cls.MyMainContainerWidget = context.oo.Class(cls.MainContainerWidget, function($super) {
      return /** @lends classes.MyMainContainerWidget.prototype */ {
        __name: "MyMainContainerWidget",

        constructor: function(opts) {
          $super.constructor.call(this, opts);

          var x;
          if (gbc.bootstrapInfo.appName.startsWith("salfatixmedia4brands") || gbc.bootstrapInfo.appName.startsWith("brands")) {
            x = new cls.MyBrandMenu(opts);
          }
          if (gbc.bootstrapInfo.appName.startsWith("salfatixmedia4backoffice") || gbc.bootstrapInfo.appName.startsWith("backoffice")) {
            x = new cls.MyBackOfficeMenu(opts);
          }
          if (gbc.bootstrapInfo.appName.startsWith("validation") || gbc.bootstrapInfo.appName.startsWith("resetpassword")) {
            this.getElement().querySelector("foobar").innerHTML = '<div class="topnav" id="myTopnav"><div class="salfatixlogo"><a href="https://www.salfatixmedia.com/" target="_self"><img src="https://static.wixstatic.com/media/3201d9_57980f35b11f4fc595e7afa32186d250~mv2.png/v1/fill/w_51,h_51,al_c,usm_0.66_1.00_0.01/3201d9_57980f35b11f4fc595e7afa32186d250~mv2.png"/></a></div><div class="navbrand">Salfatix Media</div></div>'; 
          }
          if ( x ) { /* not : null,undefined,NaN,"",0,false */
            x.setParentWidget(this);
            this.getElement().querySelector("foobar").appendChild(x.getElement());              
          }
        }
      };
    });

    /*
     *  This is a sample widget that would replace the default one in GBC
     *  To activate it, please uncomment the line below. This will override
     *  the original widget registration to this one.
     */

    cls.WidgetFactory.registerBuilder('MainContainer', cls.MyMainContainerWidget);
  });
;
"use strict";

modulum('MySessionEndWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class MySessionEndWidget
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.MySessionEndWidget = context.oo.Class(cls.SessionEndWidget, function($super) {
      return /** @lends classes.MySessionEndWidget.prototype */ {
        __name: "MySessionEndWidget",

        setHeader: function(message) {
          //this._element.getElementsByClassName("myHeaderText")[0].innerHTML = message;
        },

        setSessionLinks: function(base, session) {
          //$super.setSessionLinks.call(this, base, session);

          // update redirection link url of the template
          //var redirectionLink = this._element.getElementsByClassName("redirectionLink")[0];
          //redirectionLink.title = i18next.t("mycusto.session.redirectionText");
          var url = "https://www.salfatixmedia.com/";
          //redirectionLink.href = url;

          var modelHelper = new cls.ModelHelper(this);

          // launch the redirection after a delay of 10 seconds
          // to remove the delay, remove the setTimeout
          //setTimeout(function () {
            // check if an application is running in the current session before reloading
            if(!modelHelper.getCurrentApplication()) {
              window.location = url;
            }
          //}.bind(this), 10000); // 10000ms
        }
      };
    });

     cls.WidgetFactory.registerBuilder('SessionEnd', cls.MySessionEndWidget);
  });
;
"use strict";

/*
 starter for gbc environment
 script has to be the last to load to run the environment
 */

(function(context) {
  context.gbcWrapper.__prepare();
  context.gbcWrapper.on(context.gbcWrapper.events.READY, function() {
    context.gbc.run(function() {
      context.gbcWrapper.__gbcReady();
    });
  });
})(window);
